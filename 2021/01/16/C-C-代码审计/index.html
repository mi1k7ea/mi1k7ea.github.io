
<!DOCTYPE html>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="C/C++,代码审计,">
  

  
    <meta name="description" content="d2VsY29tZSB0byBteSBibG9n">
  
  
  
  <link rel="icon" type="image/x-icon" href="/1.jpg">
  
  <title>C&amp;C++代码审计 [ Mi1k7ea ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Mi1k7ea</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        C&amp;C++代码审计
      </h1>
      <span>
        
        <time class="time" datetime="2021-01-16T06:45:49.000Z">
        2021-01-16
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/">C/C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码审计/">代码审计</a></li></ul>
      </span>
    </span>
      <!--<span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>-->
    </header>

    <div class="post-content">
      <h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>本篇只小结代码层面的C/C++安全问题，具体漏洞利用不在范围内。</p>
<p>基本思路：全局找出调用的危险函数或危险操作，往上回溯确定相关参数是否外部可控</p>
<h2 id="0x01-栈溢出"><a href="#0x01-栈溢出" class="headerlink" title="0x01 栈溢出"></a>0x01 栈溢出</h2><h3 id="审计点"><a href="#审计点" class="headerlink" title="审计点"></a>审计点</h3><p>常见的危险函数：</p>
<ul>
<li>输入<ul>
<li>gets，直接读取一行，忽略’\x00’</li>
<li>scanf</li>
<li>vscanf</li>
</ul>
</li>
<li>输出<ul>
<li>sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li>strcpy，字符串复制，遇到’\x00’停止</li>
<li>strcat，字符串拼接，遇到’\x00’停止</li>
<li>bcopy</li>
</ul>
</li>
</ul>
<p>对应的安全函数：</p>
<ul>
<li>gets——fgets、StringCchGets、gets_s</li>
<li>字符串处理函数：strcpy、strcat、strncpy、strncat、strlen，输出函数sprintf和snprintf，内存拷贝函数memcpy——对于使用Microsoft编译器的用户，考虑使用StrSate库中的函数：StringCchCopy，StringCchCopyN，StringCchCopyEx，StringCchCopyNEx，StringCbCopy，StringCbCopyN，StringCbCopyEx，StringCbCopyNEx，strnlen_s，StringCchPrintf，StringCchVPrintf，StringCchPrintfEx，StringCchVPrintfEx，StringCbPrintf，StringVCbPrintf，StringCbPrintEx，StringCbVPrintEx；对于使用Gcc编译器的用户，考虑使用libssp库，例如<code>__strcpy_chk.c</code>和<code>__strncpy_chk.c</code>；另外可以使用支持C/C++标准的新版本编译器，并使用新的安全的标准库函数，例如C11标准附录K中的函数<code>strcpy_s</code>，<code>strncpy_s</code>，<code>sprintf_s</code>，<code>_snprintf_s</code>，<code>_snwprintf_s</code>，<code>_vstprintf_s</code>，<code>_vsntprintf_s</code>。</li>
<li>scanf——sscanf_s</li>
<li></li>
</ul>
<h3 id="随机数值用作长度参数"><a href="#随机数值用作长度参数" class="headerlink" title="随机数值用作长度参数"></a>随机数值用作长度参数</h3><p>将随机数值作为strncpy()等函数的长度参数，会导致不可预知的行为发生。</p>
<p>由于rand()等函数返回的整型数值是随机的，其长度可能超过缓冲区的最大长度，甚至可能为负值。该情况会造成缓冲区越界。</p>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">len = rand();</span><br><span class="line"><span class="built_in">strncpy</span>(dest, src, len);</span><br></pre></td></tr></table></figure>
<p>用例中，长度参数len经过了长度验证，但验证的行为并不充分：该验证并未考虑到返回负值的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> URAND31() (((unsigned)rand()&lt;&lt;30) ^ ((unsigned)rand()&lt;&lt;15) ^ rand())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAND32() ((int)(rand() &amp; 1 ? URAND31() : -URAND31() - 1))</span></span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">100</span>];</span><br><span class="line">len = RAND32();</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">100</span>)</span><br><span class="line">    <span class="built_in">strncpy</span>(dest, src, len);</span><br></pre></td></tr></table></figure>
<h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><p>不要将随机数用作strncpy()等库函数的长度参数。</p>
<p>如果需要随机数作为strncpy()等库函数的长度参数，需要对其长度进行有效的限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> URAND31() (((unsigned)rand()&lt;&lt;30) ^ ((unsigned)rand()&lt;&lt;15) ^ rand())</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAND32() ((int)(rand() &amp; 1 ? URAND31() : -URAND31() - 1))</span></span><br><span class="line"><span class="keyword">char</span> dest[<span class="number">100</span>];</span><br><span class="line">len = RAND32();</span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; len &lt; <span class="number">100</span>)</span><br><span class="line">    <span class="built_in">strncpy</span>(dest, src, len);</span><br></pre></td></tr></table></figure>
<h2 id="0x02-堆溢出"><a href="#0x02-堆溢出" class="headerlink" title="0x02 堆溢出"></a>0x02 堆溢出</h2><h3 id="审计点-1"><a href="#审计点-1" class="headerlink" title="审计点"></a>审计点</h3><p>堆分配函数：</p>
<ul>
<li>malloc</li>
<li>calloc</li>
<li>realloc</li>
</ul>
<p>常见的危险函数：</p>
<ul>
<li>输入<ul>
<li>gets，直接读取一行，忽略 <code>&#39;\x00&#39;</code></li>
<li>scanf</li>
<li>vscanf</li>
</ul>
</li>
<li>输出<ul>
<li>sprintf</li>
</ul>
</li>
<li>字符串<ul>
<li>strcpy，字符串复制，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>strcat，字符串拼接，遇到 <code>&#39;\x00&#39;</code> 停止</li>
<li>bcopy</li>
</ul>
</li>
</ul>
<p>对应的安全函数：</p>
<p>alloca——SafeAllocA</p>
<h2 id="0x03-UAF"><a href="#0x03-UAF" class="headerlink" title="0x03 UAF"></a>0x03 UAF</h2><p>如果内存在释放后继续使用，可能会造成无法预测的结果。</p>
<p>释放后使用会导致严重的问题。使用已经释放的内存将会导致合法数据损坏，或者执行任意代码，具体取决于当时的运行状态。</p>
<p>当内存被释放，又没有重新分配指针之前，它的内容依然可以访问。这些被释放内存上的数据看似合法，但是会发生非预期的改变，最终可能导致出现意料之外的代码行为。</p>
<h3 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo"></a>Demo</h3><p>例1，代码中<code>int *x = malloc(4)</code>分配的指针x在free(x)释放之后在返回语句进行解引用，这就发生了对已经释放的内存指针进行解引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="keyword">return</span> *x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，代码中可能因为t的值不为0而导致x被释放，之后返回了被释放的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">foo</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> *x = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">        x = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) &#123;</span><br><span class="line">        <span class="built_in">free</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修复-1"><a href="#修复-1" class="headerlink" title="修复"></a>修复</h3><p>要避免释放后再使用问题，可以采取以下几种措施：</p>
<ol>
<li>在指针被释放后将其设为空值。</li>
<li>确保全局变量仅被释放一次。</li>
<li>在循环或条件语句中释放内存或重新分配内存时，尤其要多加小心。</li>
</ol>
<p>上述代码中在free之前将x所指向的int值赋值给局部变量a，再返回a的值，从而避免了释放后再使用的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *x = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    *x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> a = *x;</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x04-Double-Free"><a href="#0x04-Double-Free" class="headerlink" title="0x04 Double Free"></a>0x04 Double Free</h2><p>如果内存在释放后再次进行重复释放，可能会造成无法预测的结果。</p>
<p>当程序重复释放内存时，内存管理数据结构将被破坏，引起程序崩溃或者返回与上一次相同的指针。在这种情况下，攻击者能够成功的控制数据写入到多重分配的内存，这将导致缓冲区溢出的漏洞攻击。</p>
<p>在C++代码中，下述浅拷贝的情况可能会导致内存重复释放：</p>
<p>如调用一次赋值运算符或拷贝构造函数将会导致两个对象的数据成员指向相同的动态内存。缺少一种合适的引用计数设备，当第一个对象超出作用域时，析构函数将会释放这两个对象共享的内存。第二个对象中对应的数据成员将会指向已经释放的内存地址。当第二个对象超出作用域时，它的析构函数试图再次释放这块内存。这会导致应用程序崩溃或堆内存损坏。</p>
<h3 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo"></a>Demo</h3><p>例1，代码中 release(a) 已经对a进行了释放， 稍后的两个free语句再次对a进行了重复释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">x</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> * field;</span><br><span class="line">&#125; tx;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(tx * a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;field);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    tx *a = (tx *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(tx));</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    a-&gt;field = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    release(a);</span><br><span class="line">    <span class="built_in">free</span>(a-&gt;field);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，示例中类C为C::data动态分配内存，但是没有定义赋值运算符。结果，当函数main()执行时，c1.data和c2.data具有相同的值，当析构时都调用delete[]操作符，相同的指针被释放两次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">    C(<span class="keyword">const</span> C &amp;) &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C() &#123; data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; &#125;</span><br><span class="line">        ~C() &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling delete for "</span> &lt;&lt; (<span class="keyword">void</span> *)data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c1;</span><br><span class="line">    C c2;</span><br><span class="line">    c1 = c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例3，示例中，因为没有定义拷贝构造函数，编译器生成一个从一个实例拷贝所有值到另一个实例的拷贝构造函数。结果，c1.data和c2.data具有相同的值，当析构函数被调用时释放了两次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">    C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C() &#123; data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; &#125;</span><br><span class="line">        ~C() &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"Calling delete for "</span> &lt;&lt; (<span class="keyword">void</span> *)data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] data;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    C c1;</span><br><span class="line">    C c2 = c1;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例4，示例中，在赋值运算符中对成员指针d执行浅拷贝。在析构函数<code>~C()</code>中释放相应的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C();</span><br><span class="line">        ~C() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">        C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;rhs) &#123;</span><br><span class="line">            d = rhs.d; <span class="comment">// shallow copy</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C(<span class="keyword">const</span> C &amp;rhs);</span><br><span class="line">        D *d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例5，示例中，在拷贝构造函数中对成员指针d执行浅拷贝。在析构函数<code>~C()</code>中释放相应的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C();</span><br><span class="line">        ~C() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">        C(<span class="keyword">const</span> C &amp;rhs) &#123;</span><br><span class="line">            d = rhs.d; <span class="comment">// shallow copy</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;rhs);</span><br><span class="line">        D *d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="修复-2"><a href="#修复-2" class="headerlink" title="修复"></a>修复</h3><p>例1：为了解决这个问题，应该定义赋值运算符。依据具体的情况，可以使用不同的赋值运算符实现。</p>
<p>（1）如果需要申请新内存，赋值运算符的实现应该检测是否是自赋值，释放原来内存，申请新内存，并且拷贝数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;src == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(data, src.data, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（2）先前的实现执行了不必要的堆内存操作。由于释放的数据和申请的数据具有相同大小的结构，在这种情况下原来的内存是可以被重用的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;src) &#123;</span><br><span class="line">        <span class="keyword">if</span> (&amp;src == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(data, src.data, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（3）如果不想要拷贝类实例，赋值运算符应该被声明为私有的。在这种情况下，如果试图拷贝一个对象，编译器就会产生一个错误:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;) &#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例2：为了解决这个问题，依据具体的情况，可以使用两种不同的实现方式中的一个。</p>
<p>（1）通常，定义一个深拷贝构造函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    C(<span class="keyword">const</span> C &amp;src) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(data, src.data, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（2）如果不想要拷贝类实例，拷贝构造函数应该被声明为私有的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C(<span class="keyword">const</span> C &amp;src) &#123; <span class="comment">/* do not create copies */</span> &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例3：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">    <span class="comment">/* omitted for brevity */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C();</span><br><span class="line">        ~C() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">        C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;rhs) &#123;</span><br><span class="line">            d = <span class="keyword">new</span> D(*rhs.d);</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C(<span class="keyword">const</span> C &amp;rhs);</span><br><span class="line">        D *d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在示例中，在赋值运算符中执行深拷贝。因此，当这两个对象的析构函数被调用时不会发生两次释放内存。</p>
<p>例4：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line">    <span class="comment">/* omitted for brevity */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C();</span><br><span class="line">        ~C() &#123; <span class="keyword">delete</span> d; &#125;</span><br><span class="line">        C(<span class="keyword">const</span> C &amp;rhs) &#123;</span><br><span class="line">            d = <span class="keyword">new</span> D((*rhs.d);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;rhs);</span><br><span class="line">        D *d;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在示例中，在拷贝构造函数中执行深拷贝。因此，当这两个对象的析构函数被调用时不会发生两次释放内存。</p>
<h2 id="0x05-整数溢出"><a href="#0x05-整数溢出" class="headerlink" title="0x05 整数溢出"></a>0x05 整数溢出</h2><p>整数溢出分为上界溢出和下界溢出。</p>
<p>一般出现整数溢出的场景：</p>
<ul>
<li>未限制范围</li>
<li>错误的类型转换（范围大的变量赋值给范围小的变量、只做了单边限制）</li>
</ul>
<h3 id="Demo-3"><a href="#Demo-3" class="headerlink" title="Demo"></a>Demo</h3><p>size类型为unsigned int，最大取值为65535，当超过这个值时，截断导致越过size检查，然后，在memcpy()函数函数中造成栈溢出，程序crash，可能导致代码执行。堆上的整数溢出同理，只是溢出对象是堆数据，导致覆盖的时候后面的堆结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的整数溢出</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">char</span> overflow[<span class="number">65550</span>];</span><br><span class="line">    <span class="built_in">memset</span>(overflow,<span class="number">65</span>,<span class="keyword">sizeof</span>(overflow));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"please input size:\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;i);</span><br><span class="line">    size =i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size:%d"</span>,size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i:%d"</span>,i);</span><br><span class="line">    <span class="keyword">if</span>(size &gt; <span class="number">8</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//stack overflow</span></span><br><span class="line">    <span class="built_in">memcpy</span>(buf,overflow,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x06-格式化字符串漏洞"><a href="#0x06-格式化字符串漏洞" class="headerlink" title="0x06 格式化字符串漏洞"></a>0x06 格式化字符串漏洞</h2><h3 id="审计点-2"><a href="#审计点-2" class="headerlink" title="审计点"></a>审计点</h3><p>格式化字符串函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>基本介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>printf</td>
<td>输出到 stdout</td>
</tr>
<tr>
<td>fprintf</td>
<td>输出到指定 FILE 流</td>
</tr>
<tr>
<td>vprintf</td>
<td>根据参数列表格式化输出到 stdout</td>
</tr>
<tr>
<td>vfprintf</td>
<td>根据参数列表格式化输出到指定 FILE 流</td>
</tr>
<tr>
<td>sprintf</td>
<td>输出到字符串</td>
</tr>
<tr>
<td>snprintf</td>
<td>输出指定字节数到字符串</td>
</tr>
<tr>
<td>vsprintf</td>
<td>根据参数列表格式化输出到字符串</td>
</tr>
<tr>
<td>vsnprintf</td>
<td>根据参数列表格式化输出指定字节到字符串</td>
</tr>
<tr>
<td>setproctitle</td>
<td>设置 argv</td>
</tr>
<tr>
<td>syslog</td>
<td>输出日志</td>
</tr>
<tr>
<td>err, verr, warn, vwarn 等</td>
<td>。。。</td>
</tr>
</tbody>
</table>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p><a href="https://github.com/L4ys/LazyIDA" target="_blank" rel="noopener">LazyIDA</a></p>
<h2 id="0x07-命令注入"><a href="#0x07-命令注入" class="headerlink" title="0x07 命令注入"></a>0x07 命令注入</h2><h3 id="审计点-3"><a href="#审计点-3" class="headerlink" title="审计点"></a>审计点</h3><p>执行命令的几个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">system</span><br><span class="line">fopen</span><br><span class="line">popen</span><br></pre></td></tr></table></figure>
<h2 id="0x08-SQL注入"><a href="#0x08-SQL注入" class="headerlink" title="0x08 SQL注入"></a>0x08 SQL注入</h2><p>关键还是在于直接拼接SQL语句。</p>
<p>后续会推出SQL注入检查扫描插件。</p>
<h3 id="Demo-4"><a href="#Demo-4" class="headerlink" title="Demo"></a>Demo</h3><p>示例中，mysql_real_query执行了外部读取的SQL语句，因stmt_str内容不可控，这将造成恶意用户可以执行任意SQL命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_mysql_real_query</span><span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *stmt_str, <span class="keyword">unsigned</span> <span class="keyword">long</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, stmt_str);</span><br><span class="line">    mysql_real_query(mysql, stmt_str, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修复-3"><a href="#修复-3" class="headerlink" title="修复"></a>修复</h3><p>为避免SQL注入缺陷，可以：</p>
<ol>
<li>创建SQL语句时仅使用常量字符串；</li>
<li>创建安全库，将用作输入数据的参数化的SQL语句进行安全验证；</li>
<li>如果构造SQL指令时需要动态输入，应当针对动态输入的数据进行有效的验证。</li>
</ol>
<h2 id="0x09-条件竞争"><a href="#0x09-条件竞争" class="headerlink" title="0x09 条件竞争"></a>0x09 条件竞争</h2><h3 id="TOCTOU条件竞争"><a href="#TOCTOU条件竞争" class="headerlink" title="TOCTOU条件竞争"></a>TOCTOU条件竞争</h3><p>TOCTOU(Time-of-check Time-of-use) 指的是程序在使用资源（变量，内存，文件）前会对进行检查，但是在程序使用对应的资源前，该资源却被修改了。</p>
<p>下面是最易出现TOCTOU条件竞争的几个场景。</p>
<h4 id="CWE-365-Race-Condition-in-Switch"><a href="#CWE-365-Race-Condition-in-Switch" class="headerlink" title="CWE-365: Race Condition in Switch"></a>CWE-365: Race Condition in Switch</h4><p>当程序正在执行 switch 语句时，如果 switch 变量的值被改变，那么就可能造成不可预知的行为。尤其在 case 语句后不写 break 语句的代码，一旦 switch 变量发生改变，很有可能会改变程序原有的逻辑。</p>
<h4 id="CWE-363-Race-Condition-Enabling-Link-Following"><a href="#CWE-363-Race-Condition-Enabling-Link-Following" class="headerlink" title="CWE-363: Race Condition Enabling Link Following"></a>CWE-363: Race Condition Enabling Link Following</h4><p>…</p>
<p>函数都会使用文件名作为参数：access(), open(), creat(), mkdir(), unlink(), rmdir(), chown(), symlink(), link(), rename(), chroot(),…</p>
<p>…</p>
<h3 id="Signal-Handler条件竞争"><a href="#Signal-Handler条件竞争" class="headerlink" title="Signal Handler条件竞争"></a>Signal Handler条件竞争</h3><p>条件竞争经常会发生在信号处理程序中，这是因为信号处理程序支持异步操作。尤其是当信号处理程序是不可重入的或者状态敏感的时候，攻击者可能通过利用信号处理程序中的条件竞争，可能可以达到拒绝服务攻击和代码执行的效果。</p>
<p>malloc、free， setjmp、longjmp。</p>
<h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3><h4 id="静态检测"><a href="#静态检测" class="headerlink" title="静态检测"></a>静态检测</h4><p>目前已知的静态检测工具有</p>
<ul>
<li><a href="http://www.dwheeler.com/flawfinder/" target="_blank" rel="noopener">Flawfinder</a><ul>
<li>目标：C/C++ 源码</li>
<li>步骤<ul>
<li>建立漏洞数据库</li>
<li>进行简单的文本模式匹配，没有任何的数据流或控制流分析</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://github.com/google/sanitizers" target="_blank" rel="noopener">ThreadSanitizer</a><ul>
<li>目标：C++ 和 GO</li>
<li>实现：LLVM</li>
</ul>
</li>
</ul>
<h5 id="动态检测"><a href="#动态检测" class="headerlink" title="动态检测"></a>动态检测</h5><ul>
<li><a href="https://en.wikipedia.org/wiki/Intel_Inspector" target="_blank" rel="noopener">Intel Inspector</a></li>
<li><a href="https://en.wikipedia.org/wiki/Valgrind" target="_blank" rel="noopener">Valgrind</a></li>
</ul>
<h2 id="0x0A-数组越界"><a href="#0x0A-数组越界" class="headerlink" title="0x0A 数组越界"></a>0x0A 数组越界</h2><h3 id="越界访问"><a href="#越界访问" class="headerlink" title="越界访问"></a>越界访问</h3><p>当程序访问一个数组中的元素时，如果索引值超出数组的长度，就会访问数组之外的内存。C和C++没有提供内置的防护措施来防止在任意内存中访问数据，也没有自动检测写入数组（这种语言内置的缓冲区类型）的数据是否在数组的边界以内。</p>
<p>一旦这种情况发生，将会造成程序内存结构破坏，导致安全隐患产生，攻击者可以利用这个缺陷执行任意代码片段。</p>
<h4 id="Demo-5"><a href="#Demo-5" class="headerlink" title="Demo"></a>Demo</h4><p>例1，循环变量的上界是以数组a为char类型（1字节）数组时计算出来的数组大小，但是在循环内部数组a作为一个整型（4字节）数组被访问。因此，由于1字节的字符和4字节的整数在内存中的大小不同，导致大小为2的“整型”数组a可能使用下标<code>2..7</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">8</span>];      <span class="comment">// holds two 4-byte ints</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a); i++) &#123;</span><br><span class="line">        ((<span class="keyword">int</span> *)a)[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，函数foobar()获取一个值作为访问数组local_array的下标，而main函数使用实参15来调用函数foobar()，超过数组local_array的下标合法值<code>0..7</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local_array[<span class="number">7</span>];</span><br><span class="line">    local_array[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foobar(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-4"><a href="#修复-4" class="headerlink" title="修复"></a>修复</h4><p>例1，循环的上界变为数组a作为一个整型数组时所包含的元素个数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">8</span>]; <span class="comment">// holds two 4-byte ints</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>); i++) &#123;</span><br><span class="line">        ((<span class="keyword">int</span> *)a)[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，使用参数x作为局部数组local_array的下标时，在第5行验证x的值是否合法。在其他情况下，最好的修复方式就是在主调函数中验证值是否合法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foobar</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local_array[<span class="number">7</span>];</span><br><span class="line">    <span class="comment">// verify the parameter is in range</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">7</span>) &#123;</span><br><span class="line">        local_array[x] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foobar(<span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串操作造成目的缓冲区缺少-0"><a href="#字符串操作造成目的缓冲区缺少-0" class="headerlink" title="字符串操作造成目的缓冲区缺少\0"></a>字符串操作造成目的缓冲区缺少<code>\0</code></h3><p>在执行字符串拷贝的时候，如果源字符串大于目标字符串的大小，可能会导致目标字符串中存入的数据结尾不是<code>\0</code>。如果字符串不是以<code>\0</code>结尾，在后续访问该字符串时，会导致越界访问非法内存。</p>
<h4 id="Demo-6"><a href="#Demo-6" class="headerlink" title="Demo"></a>Demo</h4><p>例1，foo的大小为10，而”1234567890”的大小也为10，所以执行strncpy之后foo的最后一个字符不是<code>\0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> foo[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">strncpy</span>(foo, <span class="string">"1234567890"</span>, <span class="keyword">sizeof</span>(foo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，由于字符序列c_str中不带有null终结符，而作为参数传给函数printf()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c_str[<span class="number">3</span>] = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, c_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例3，作为参数传给wcslen()函数的宽字节字符序列cur_msg可能并不具有null终结符。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">wchar_t</span> *cur_msg = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> cur_msg_size = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">size_t</span> cur_msg_len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lessen_memory_usage</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">wchar_t</span> *temp;</span><br><span class="line">    <span class="keyword">size_t</span> temp_size;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">if</span> (cur_msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp_size = cur_msg_size / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        temp = <span class="built_in">realloc</span>(cur_msg, temp_size * <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>));</span><br><span class="line">        <span class="comment">/* temp &amp;and cur_msg may no longer be null-terminated */</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Handle error */</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur_msg = temp;</span><br><span class="line">        cur_msg_size = temp_size;</span><br><span class="line">        cur_msg_len = wcslen(cur_msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-5"><a href="#修复-5" class="headerlink" title="修复"></a>修复</h4><p>审查代码逻辑，避免缓冲区存入数据超过容纳限制，或者增大缓冲区大小。</p>
<p>例1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">good</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> foo[<span class="number">11</span>];</span><br><span class="line">    <span class="built_in">strncpy</span>(foo, <span class="string">"1234567890"</span>, <span class="keyword">sizeof</span>(foo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，如果该边界被省略，编译器会为字符串以及字符串中的null终结符分配足够的内存空间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c_str[] = <span class="string">"abc"</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, c_str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例3，在调用函数wcslen()时，cur_msg会带有null终结符：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">wchar_t</span> *cur_msg = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">size_t</span> cur_msg_size = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">size_t</span> cur_msg_len = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lessen_memory_usage</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">wchar_t</span> *temp;</span><br><span class="line">    <span class="keyword">size_t</span> temp_size;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">if</span> (cur_msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp_size = cur_msg_size / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        temp = <span class="built_in">realloc</span>(cur_msg, temp_size * <span class="keyword">sizeof</span>(<span class="keyword">wchar_t</span>));</span><br><span class="line">        <span class="comment">/* temp and cur_msg may no longer be null-terminated */</span></span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Handle error */</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur_msg = temp;</span><br><span class="line">        <span class="comment">/* Properly null-terminate cur_msg */</span></span><br><span class="line">        cur_msg[temp_size - <span class="number">1</span>] = L'\<span class="number">0'</span>;</span><br><span class="line">        cur_msg_size = temp_size;</span><br><span class="line">        cur_msg_len = wcslen(cur_msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x0B-迭代器相关问题"><a href="#0x0B-迭代器相关问题" class="headerlink" title="0x0B 迭代器相关问题"></a>0x0B 迭代器相关问题</h2><h3 id="迭代器使用不匹配"><a href="#迭代器使用不匹配" class="headerlink" title="迭代器使用不匹配"></a>迭代器使用不匹配</h3><p>将一个容器的迭代器用于另一个容器使用将会导致未定义行为。</p>
<h4 id="Demo-7"><a href="#Demo-7" class="headerlink" title="Demo"></a>Demo</h4><p>在这个示例中，cont2.erase(i) 使用了指向cont1的迭代器，这将导致未定义行为发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont1, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i = cont1.find(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (i != cont1.end())</span><br><span class="line">        cont2.erase(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，代码cont3.erase(i,j)执行的erase操作，其中i迭代器指向容器cont1，j迭代器指向容器cont2，而调用该方法的容器为cont3，这将导致未定义行为发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont1, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont2, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont3)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i = cont1.find(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator j = cont2.find(<span class="number">200</span>);</span><br><span class="line">    cont3.assign(i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-6"><a href="#修复-6" class="headerlink" title="修复"></a>修复</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont1, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i = cont1.find(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (i != cont1.end()) &#123;</span><br><span class="line">        i = cont2.find(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != cont2.end())</span><br><span class="line">            cont2.erase(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>当迭代器失效后，再次使用迭代器进行数据修改将会导致未定义行为。</p>
<h4 id="Demo-8"><a href="#Demo-8" class="headerlink" title="Demo"></a>Demo</h4><p>示例代码中，函数试图从cont中删除所有的与“x”相等的元素，但是在调用cont.erase(i)后将会导致迭代器i失效，因此在i++时将会产生未定义行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;cont, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span> (i = cont.begin(); i != cont.end(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*i == x)</span><br><span class="line">            cont.erase(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-7"><a href="#修复-7" class="headerlink" title="修复"></a>修复</h4><p>这个修复用例将cont.erase(i)的返回值赋值给i，避免了迭代器i的失效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; &amp;cont, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span> (i = cont.begin(); i != cont.end();) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*i == x)</span><br><span class="line">            i = cont.erase(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对迭代器尾部进行解引用"><a href="#对迭代器尾部进行解引用" class="headerlink" title="对迭代器尾部进行解引用"></a>对迭代器尾部进行解引用</h3><p>对容器的迭代器进行解引用时，当迭代器指向容器的end()或者rend()，都将产生未定义行为。</p>
<h4 id="Demo-9"><a href="#Demo-9" class="headerlink" title="Demo"></a>Demo</h4><p>例1，如果break语句没有得到执行，i将会等于cont.end()。这样对i进行解引用将会产生未定义行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span> (i = cont.begin(); i != cont.end(); i++) &#123;</span><br><span class="line">        x += *i;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x += *i;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，如果<code>“cont”</code>容器为空,i将会等于cont.end()。这样对i进行解引用将会产生未定义行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i = cont.begin();</span><br><span class="line">    <span class="keyword">if</span> (*i &lt; <span class="number">100</span>)</span><br><span class="line">        <span class="keyword">return</span> *i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-8"><a href="#修复-8" class="headerlink" title="修复"></a>修复</h4><p>迭代器解引用前进行有效性验证，避免迭代器对尾部进行解引用。</p>
<p>例1，在这个解决方案中对i值进行判断，判断是否等于cont.end()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i;</span><br><span class="line">    <span class="keyword">for</span> (i = cont.begin(); i != cont.end(); i++) &#123;</span><br><span class="line">        x += *i;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">100</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i != cont.end())</span><br><span class="line">        x += *i;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，在这个解决方案中对i在解引用前进行检测判断其值是否等于cont.end()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;cont)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator i = cont.begin();</span><br><span class="line">    <span class="keyword">if</span> ((i != cont.end()) &amp;&amp; (*i &lt; <span class="number">100</span>))</span><br><span class="line">        <span class="keyword">return</span> *i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x0C-IO相关问题"><a href="#0x0C-IO相关问题" class="headerlink" title="0x0C IO相关问题"></a>0x0C IO相关问题</h2><h3 id="使用无效句柄"><a href="#使用无效句柄" class="headerlink" title="使用无效句柄"></a>使用无效句柄</h3><p>当申请一个资源失败后，仍然继续使用该资源，就会导致程序崩溃。</p>
<h4 id="Demo-10"><a href="#Demo-10" class="headerlink" title="Demo"></a>Demo</h4><p>示例中，如果socket()调用失败，再调用close()使用该句柄就会导致程序崩溃。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">my_addr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-9"><a href="#修复-9" class="headerlink" title="修复"></a>修复</h4><p>在资源申请时应当考虑异常情况的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">good</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">my_addr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误的资源关闭"><a href="#错误的资源关闭" class="headerlink" title="错误的资源关闭"></a>错误的资源关闭</h3><p>程序员手动创建或申请的资源，通常应当进行相应的释放或关闭操作。选用的释放或关闭方法应当和创建或申请的方法相对应，否则，会造成程序运行未定义行为，甚至造成程序运行崩溃。</p>
<h4 id="Demo-11"><a href="#Demo-11" class="headerlink" title="Demo"></a>Demo</h4><p>代码中通过库函数fopen()打开文件指针fp，然后试图通过调用Windows API对其进行关闭，该行为会造成程序运行未定义行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"some_file.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    CloseHandle((HANDLE)fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-10"><a href="#修复-10" class="headerlink" title="修复"></a>修复</h4><p>调用和创建或申请资源相对应的释放或关闭方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">"some_file.txt"</span>, <span class="string">"r"</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x0D-加解锁相关问题"><a href="#0x0D-加解锁相关问题" class="headerlink" title="0x0D 加解锁相关问题"></a>0x0D 加解锁相关问题</h2><h3 id="加锁未解锁"><a href="#加锁未解锁" class="headerlink" title="加锁未解锁"></a>加锁未解锁</h3><p>所有的针对互斥量的加锁解锁操作，都必须针对同一模块，并且在同一抽象层面进行。否则，将会可能导致某些加锁/解锁操作不会依照多线程设计而被执行，甚至依照锁的类型，最终导致死锁、资源竞争等其他漏洞的爆发。</p>
<p>缺少对锁的有效释放，会导致死锁。如果锁被占用并未被有效释放，后续对该加锁资源的操作将无法被执行，直到该锁得到有效释放。</p>
<p>为避免锁竞争，应当：</p>
<ol>
<li>尽可能的缩小保存锁的代码；</li>
<li>不要对有可能产生并行问题（例如数据竞争）的模块进行加锁；</li>
<li>避免环路等待条件；</li>
<li>如果使用了多个锁，尤其是在一个递增的守护模式<code>（guard pattern）</code>，一定要确保在各种情况下增量的等同。</li>
</ol>
<h4 id="Demo-12"><a href="#Demo-12" class="headerlink" title="Demo"></a>Demo</h4><p>示例中，函数foo()在最开始位置进行了加锁操作，但如果switch的case为0，该锁将无法被有效释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(mutex);</span><br><span class="line">    <span class="keyword">switch</span> (z()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-11"><a href="#修复-11" class="headerlink" title="修复"></a>修复</h4><p>检查代码逻辑，详细排查每条代码可能的执行路径，避免加锁未释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">z</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(mutex);</span><br><span class="line">    <span class="keyword">switch</span> (z()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        pthread_mutex_unlock(mutex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不当的锁初始化"><a href="#不当的锁初始化" class="headerlink" title="不当的锁初始化"></a>不当的锁初始化</h3><p>所有的针对互斥量的加锁解锁操作，都必须针对同一模块，并且在同一抽象层面进行。否则，将会可能导致某些加锁/解锁操作不会依照多线程设计而被执行，甚至依照锁的类型，最终导致死锁、资源竞争等其他漏洞的爆发。</p>
<p>在对资源进行加锁/解锁操作前，很多的库都需要对锁进行初始化操作，并在完成对锁资源进行加锁/解锁操作后，对锁进行清理。对锁资源不当的初始化，会造成程序运行逻辑错误等。</p>
<h4 id="Demo-13"><a href="#Demo-13" class="headerlink" title="Demo"></a>Demo</h4><p>示例中，对已经初始化了的锁资源进行了冗余的初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_init(mutex);</span><br><span class="line">    pthread_mutex_init(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-12"><a href="#修复-12" class="headerlink" title="修复"></a>修复</h4><p>删除冗余的锁资源初始化代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_init(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x0E-不安全的内存拷贝函数"><a href="#0x0E-不安全的内存拷贝函数" class="headerlink" title="0x0E 不安全的内存拷贝函数"></a>0x0E 不安全的内存拷贝函数</h2><p>有一些C/C++函数没有考虑安全性，例如内存拷贝函数memcpy。禁止使用这些不安全的函数是一种移除代码缺陷的非常好的方式。</p>
<h3 id="Demo-14"><a href="#Demo-14" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(dest, src, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修复-13"><a href="#修复-13" class="headerlink" title="修复"></a>修复</h3><p>不要使用不安全的内存拷贝函数memcpy，应该使用一些安全的函数来代替这些被禁止使用的函数。</p>
<h2 id="0x0F-其他污点数据问题"><a href="#0x0F-其他污点数据问题" class="headerlink" title="0x0F 其他污点数据问题"></a>0x0F 其他污点数据问题</h2><p>无论输入的数据是由用户直接输入，还是从环境中读取，都应当对该值的类型、长度、格式以及范围等进行验证。未经验证的值都应被视为污染数据。</p>
<p>如果输入的数据没有经过有效的验证，攻击者就可能会将该数据篡改为程序不期望的数据形式。接受了与预期不符的数据类型，会造成程序控制逻辑泄漏、资源泄漏甚至被植入可执行代码。</p>
<p>该种情况下，攻击者可以：</p>
<ol>
<li>提供不合规的值造成程序运行崩溃；</li>
<li>造成过多的资源消耗；</li>
<li>读取机密数据；</li>
<li>通过恶意输入篡改数据或改变控制流；</li>
<li>执行有风险的命令。</li>
</ol>
<h3 id="污点数据作为循环边界"><a href="#污点数据作为循环边界" class="headerlink" title="污点数据作为循环边界"></a>污点数据作为循环边界</h3><h4 id="Demo-15"><a href="#Demo-15" class="headerlink" title="Demo"></a>Demo</h4><p>函数中，循环次数由用户直接输入，而未进行验证。该行为可被攻击者控制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iterateFoo_bad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> num;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%u"</span>, &amp;num);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-14"><a href="#修复-14" class="headerlink" title="修复"></a>修复</h4><p>为避免污染输入错误，应当：</p>
<ol>
<li>了解每个不可信源可能输入到程序的位置，包括：函数参数、cookies、网络数据读取、环境变量、逆向DNS、查询结果、文件名、数据库以及任何外部系统；</li>
<li>为输入数据提供一个白名单，或者“已知合理的”输入情况，而非仅仅依赖黑名单以及“输入不当”的输入情况；</li>
<li>确保输入数据的所有属性都合适，包括长度、类型、范围、输入丢失或额外输入、语法以及连贯性等；</li>
<li>如果应用的客户端存在安全验证，确保该验证在服务端同样存在；</li>
<li>如果输入数据由多处输入拼合而成，在完成拼合后，对该数据进行验证。</li>
</ol>
<p>Demo中，添加了对污点数据的前置判断，避免了过多次数的循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iterateFoo_good</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> num;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%u"</span>, &amp;num);</span><br><span class="line">    <span class="keyword">if</span> (num &gt; <span class="number">20</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="污染配置"><a href="#污染配置" class="headerlink" title="污染配置"></a>污染配置</h3><p>直接将污点数据作为参数传递给对系统进行配置的库函数、API，会为恶意攻击者提供篡改操作系统的可能性，进而对操作系统造成破坏。</p>
<h4 id="Demo-16"><a href="#Demo-16" class="headerlink" title="Demo"></a>Demo</h4><p>示例中，函数SetFileAttributes()对文件进行属性设置，其属性值是污点数据，该行为会导致文件的属性可被攻击者任意设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(LPCTSTR lpFileName, DWORD dwFileAttributes)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;dwFileAttributes);</span><br><span class="line">    SetFileAttributes(lpFileName, dwFileAttributes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-15"><a href="#修复-15" class="headerlink" title="修复"></a>修复</h4><p>示例中，通过if语句，对CASE情况进行判断，进而决定对文件属性值进行具体的设置，即用预先获知的可能的固定情况，代替了污点数据，保证了文件属性的安全性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(LPCTSTR lpFileName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( CASE1 )　&#123;</span><br><span class="line">        SetFileAttributes(lpFileName, dwFileAttributes_value_1 );</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( CASE2 ) ｛</span><br><span class="line">        SetFileAttributes(lpFileName, dwFileAttributes_value_2 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h3><p>如题，不多说。</p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>直接将污点数据作为动态库加载路径，会为攻击者提供加载恶意库的机会，攻击者可以将篡改后的，带有恶意功能的库进行加载，使程序在运行过程中执行危险动作，甚至被攻击者控制。</p>
<h4 id="Demo-17"><a href="#Demo-17" class="headerlink" title="Demo"></a>Demo</h4><p>示例中，函数LoadLibrary()加载库的参数为污点数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(LPCTSTR lpFileName)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, lpFileName);</span><br><span class="line">    LoadLibrary(lpFileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-16"><a href="#修复-16" class="headerlink" title="修复"></a>修复</h4><p>用明确的固定的数据来进行动态库加载，如果加载动态库的参数，确实需要从外界获取，在这种情况下，应该设计并实现完备的验证机制。</p>
<p>示例中，函数LoadLibrary()加载库的参数经过了校验函数CheckArgStr()的验证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(LPCTSTR lpFileName)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, lpFileName);</span><br><span class="line">    lpFileName = CheckArgStr(lpFileName);</span><br><span class="line">    LoadLibrary(lpFileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="资源注入"><a href="#资源注入" class="headerlink" title="资源注入"></a>资源注入</h3><p>在调用库函数、API进行资源操作的时候，如果相关的参数是污点数据，传入的资源可能会被污染，甚至篡改。</p>
<h4 id="Demo-18"><a href="#Demo-18" class="headerlink" title="Demo"></a>Demo</h4><p>示例中，函数CreateEvent()创建事件对象的名称为污点数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset,</span></span></span><br><span class="line"><span class="function"><span class="params">       BOOL bInitialState, LPTSTR lpName)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, lpName);</span><br><span class="line">    CreateEvent(lpEventAttributes, bManualReset, bInitialState, lpName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-17"><a href="#修复-17" class="headerlink" title="修复"></a>修复</h4><p>示例中，函数CreateEvent()创建事件对象的名称经过了校验函数CheckArgStr()的验证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset,</span></span></span><br><span class="line"><span class="function"><span class="params">       BOOL bInitialState, LPTSTR lpName)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, lpName);</span><br><span class="line">    lpName = CheckArgStr(lpName);</span><br><span class="line">    CreateEvent(lpEventAttributes, bManualReset, bInitialState, lpName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="日志伪造"><a href="#日志伪造" class="headerlink" title="日志伪造"></a>日志伪造</h3><p>将被污染的数据写入系统日志中，会导致系统日志记录的数据混乱。</p>
<h4 id="Demo-19"><a href="#Demo-19" class="headerlink" title="Demo"></a>Demo</h4><p>示例中，syslog()将被污染的数据str记录到了系统日志中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span> *format, <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">    syslog(priority, format, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="修复-18"><a href="#修复-18" class="headerlink" title="修复"></a>修复</h4><p>确保写入日志的数据的正确性，如果确定要将用户输入的某些污点数据写入到日志文件中，应当确保该数据和其他数据加以区分并处理，以免用户输入的污点数据对日志记录造成影响。</p>
<h2 id="0x10-错误的内存释放对象"><a href="#0x10-错误的内存释放对象" class="headerlink" title="0x10 错误的内存释放对象"></a>0x10 错误的内存释放对象</h2><p>释放的对象并非动态分配的内存，这种错误的释放操作会导致严重的错误。不要对不是由标准内存分配函数malloc(), calloc(), realloc(), 或 aligned_alloc()所返回的指针调用free()。</p>
<p>向realloc()提供一个指向非动态分配的指针也会产生类似的情况，realloc()函数用于改变一块动态内存的大小。如果向realloc()提供一个指向并非由标准内存分配函数分配的指针，程序行为未定义。结果导致程序异常终止。</p>
<h3 id="Demo-20"><a href="#Demo-20" class="headerlink" title="Demo"></a>Demo</h3><p>例1，这个不规范的代码样例，根据argc的值，设置c_str引用动态申请内存或非静态的string字符串。无论哪种情况，c_str都被当作参数传递给了free()。如果任何的其他不同于动态分配内存被c_str引用，在调用free(c_str)的时候都将出现错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">enum</span> &#123; MAX_ALLOCATION = <span class="number">1000</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *c_str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; MAX_ALLOCATION) &#123;</span><br><span class="line">            <span class="comment">/* Handle error */</span></span><br><span class="line">        &#125;</span><br><span class="line">        c_str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len);</span><br><span class="line">        <span class="keyword">if</span> (c_str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Handle error */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(c_str, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c_str = <span class="string">"usage: $&gt;a.exe [string]"</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, c_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(c_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，realloc()代码样例中，指向realloc()函数返回值的指针buf，没有引用动态分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">enum</span> &#123; BUFSIZE = <span class="number">256</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZE];</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(buf, <span class="number">2</span> * BUFSIZE);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Handle error */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修复-19"><a href="#修复-19" class="headerlink" title="修复"></a>修复</h3><p>例1：代码样例消除了在调用free()函数之前，c_str引用非动态分配内存的可能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">enum</span> &#123; MAX_ALLOCATION = <span class="number">1000</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *c_str = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">        len = <span class="built_in">strlen</span>(argv[<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; MAX_ALLOCATION) &#123;</span><br><span class="line">            <span class="comment">/* Handle error */</span></span><br><span class="line">        &#125;</span><br><span class="line">        c_str = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len);</span><br><span class="line">        <span class="keyword">if</span> (c_str == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Handle error */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(c_str, argv[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="string">"usage: $&gt;a.exe [string]"</span>);</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(c_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2（realloc()）：在这个规范的代码样例中，buf引用了动态分配内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">enum</span> &#123; BUFSIZE = <span class="number">256</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *buf = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(BUFSIZE * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *)<span class="built_in">realloc</span>(buf, <span class="number">2</span> * BUFSIZE);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Handle error */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，realloc()即使在malloc()失败的情况下，依然会表现出正确的行为。因为realloc()在给予null指针的情况下与malloc()行为相同。</p>
<h2 id="0x11-内存泄漏"><a href="#0x11-内存泄漏" class="headerlink" title="0x11  内存泄漏"></a>0x11  内存泄漏</h2><p>函数内部分配内存且返回后没有在外部做任何变量赋值保存，这种情况会造成指向分配内存的指针丢失。</p>
<p>当一个类在构造函数中申请动态内存但是没有在析构函数中释放内存时，会导致内存泄漏。在赋值运算符中也会存在潜在的内存泄漏问题。当一个类在构造函数中执行动态内存分配并且在赋值运算符中重写相应的指针时，没有提前释放内存或者减少自身的引用计数，这会导致内存泄漏。</p>
<h3 id="Demo-21"><a href="#Demo-21" class="headerlink" title="Demo"></a>Demo</h3><p>例1，alloc_data() 分配的内存没有变量保存返回的内存指针，导致内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">alloc_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    alloc_data();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，类C在构造函数中申请内存，但是缺少析构函数。即使有除了析构函数之外的方法释放分配的内存，也有可能在使用这样的类时造成内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C() &#123; data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即使是一个没有使用过的对象的简单声明也会导致内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例3，ip指向的内存在被重写之前没有被释放。由于在构造函数中已经为这个指针分配了内存，这个赋值操作会导致可能的内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C() &#123; ip = <span class="keyword">new</span> <span class="keyword">int</span>; &#125;</span><br><span class="line">        ~C() &#123; <span class="keyword">delete</span> ip; &#125;</span><br><span class="line">        C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;rhs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            ip = <span class="keyword">new</span> <span class="keyword">int</span>;      <span class="comment">// memory pointed by ip is leaked</span></span><br><span class="line">            *ip = *rhs.ip;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C(<span class="keyword">const</span> C &amp;);</span><br><span class="line">        <span class="keyword">int</span> *ip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例4，在内存重写之前，cp所指向的内存的引用计数没有减少会导致内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">counted</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        counted() &#123; counter = <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addRef</span><span class="params">()</span> </span>&#123; counter++; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">decRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            counter--;</span><br><span class="line">            <span class="keyword">if</span> (counter == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> counter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C2() &#123; cp = <span class="keyword">new</span> counted(); &#125;</span><br><span class="line">        ~C2() &#123; cp-&gt;decRef(); &#125;</span><br><span class="line">        C2 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C2 &amp;rhs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            cp = rhs.cp;</span><br><span class="line">            cp-&gt;addRef();</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C2(<span class="keyword">const</span> C2 &amp;);</span><br><span class="line">        counted *cp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="修复-20"><a href="#修复-20" class="headerlink" title="修复"></a>修复</h3><p>例1：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">alloc_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = alloc_data();</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例2，在析构函数中释放分配的内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *data;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C() &#123; data = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>]; &#125;</span><br><span class="line">        ~C() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例3，ip指向的动态分配的内存在赋值之前已经被释放了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C() &#123; ip = <span class="keyword">new</span> <span class="keyword">int</span>; &#125;</span><br><span class="line">        ~C() &#123; <span class="keyword">delete</span> ip; &#125;</span><br><span class="line">        C &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C &amp;rhs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">delete</span> ip;</span><br><span class="line">            ip = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">// memory pointed by ip is leaked</span></span><br><span class="line">            *ip = *rhs.ip;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C(<span class="keyword">const</span> C &amp;);</span><br><span class="line">        <span class="keyword">int</span> *ip;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例4，增加了引用计数减少操作，保证了引用计数的正确计算，从而保证不会发生内存泄漏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">counted</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        counted() &#123; counter = <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addRef</span><span class="params">()</span> </span>&#123; counter++; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">decRef</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            counter--;</span><br><span class="line">            <span class="keyword">if</span> (counter == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> counter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        C2() &#123; cp = <span class="keyword">new</span> counted(); &#125;</span><br><span class="line">        ~C2() &#123; cp-&gt;decRef(); &#125;</span><br><span class="line">        C2 &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> C2 &amp;rhs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">            cp-&gt;decRef();</span><br><span class="line">            cp = rhs.cp;</span><br><span class="line">            cp-&gt;addRef();</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        C2(<span class="keyword">const</span> C2 &amp;);</span><br><span class="line">        counted *cp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="0x12-对指针进行sizeof操作"><a href="#0x12-对指针进行sizeof操作" class="headerlink" title="0x12 对指针进行sizeof操作"></a>0x12 对指针进行sizeof操作</h2><p>使用sizeof对指针进行取值，很有可能出现对取值结果的错误理解。因为对指针进行sizeof操作将会返回指针的大小而非指针指向对象的大小。</p>
<p>如果要对指针进行取值，应当使用指针类型作为参数，如下代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>（<span class="keyword">int</span> *）</span><br></pre></td></tr></table></figure>
<p>因为用户显式的指明了指针类型，可以确保sizeof的意图是明确的。</p>
<p>有时也会出现对指针解引用的sizeof操作，如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = a;</span><br><span class="line"><span class="keyword">sizeof</span>(*p);</span><br></pre></td></tr></table></figure>
<p>上述代码中使用了对指针的解引用操作，可以表明编码者理解sizeof操作的结果输出，明确是对指针所指向对象进行sizeof操作。</p>
<h3 id="Demo-22"><a href="#Demo-22" class="headerlink" title="Demo"></a>Demo</h3><p>代码中，sizeof(ps)操作，对指针进行操作，获取的结果并非指针指向的内存区域的长度，而是指针的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_S</span><span class="params">(struct S *ps)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ps, <span class="number">0</span>, <span class="keyword">sizeof</span>(ps));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修复-21"><a href="#修复-21" class="headerlink" title="修复"></a>修复</h3><p>使用<code>sizeof(*ps)</code>或者<code>sizeof(struct S)</code>都可以将示例修复。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_S</span><span class="params">(struct S *ps)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(ps, <span class="number">0</span>, <span class="keyword">sizeof</span>(*ps));</span><br><span class="line">    <span class="built_in">memset</span>(ps, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct S));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x13-整数回绕造成的逻辑问题"><a href="#0x13-整数回绕造成的逻辑问题" class="headerlink" title="0x13 整数回绕造成的逻辑问题"></a>0x13 整数回绕造成的逻辑问题</h2><p>因常量值超出变量取值范围造成的二元逻辑判断恒真或恒假，将导致程序逻辑判断失去意义。这种类型的问题可以通过改变变量的范围区间，使其包含常量值，从而避免二元逻辑判断恒真或恒假。</p>
<h3 id="Demo-23"><a href="#Demo-23" class="headerlink" title="Demo"></a>Demo</h3><p>代码中，i定义为unsigned char，其取值范围在0～255之间，这将导致i&lt;256恒成立，循环无法终止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        a[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修复-22"><a href="#修复-22" class="headerlink" title="修复"></a>修复</h3><p>通过修改i变量类型为int，扩大其取值区间，保证循环可以顺利终止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        a[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="0x14-参考"><a href="#0x14-参考" class="headerlink" title="0x14 参考"></a>0x14 参考</h2><p><a href="https://codeleading.com/article/17772626925/" target="_blank" rel="noopener">代码审计–40–新篇章之C/C++代码审计（一）</a></p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-前言"><span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-栈溢出"><span class="toc-text">0x01 栈溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#审计点"><span class="toc-text">审计点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#随机数值用作长度参数"><span class="toc-text">随机数值用作长度参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复"><span class="toc-text">修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-堆溢出"><span class="toc-text">0x02 堆溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#审计点-1"><span class="toc-text">审计点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-UAF"><span class="toc-text">0x03 UAF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-1"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修复-1"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-Double-Free"><span class="toc-text">0x04 Double Free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-2"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修复-2"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-整数溢出"><span class="toc-text">0x05 整数溢出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-3"><span class="toc-text">Demo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x06-格式化字符串漏洞"><span class="toc-text">0x06 格式化字符串漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#审计点-2"><span class="toc-text">审计点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工具"><span class="toc-text">工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x07-命令注入"><span class="toc-text">0x07 命令注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#审计点-3"><span class="toc-text">审计点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x08-SQL注入"><span class="toc-text">0x08 SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-4"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修复-3"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x09-条件竞争"><span class="toc-text">0x09 条件竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TOCTOU条件竞争"><span class="toc-text">TOCTOU条件竞争</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CWE-365-Race-Condition-in-Switch"><span class="toc-text">CWE-365: Race Condition in Switch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CWE-363-Race-Condition-Enabling-Link-Following"><span class="toc-text">CWE-363: Race Condition Enabling Link Following</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Signal-Handler条件竞争"><span class="toc-text">Signal Handler条件竞争</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工具-1"><span class="toc-text">工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态检测"><span class="toc-text">静态检测</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#动态检测"><span class="toc-text">动态检测</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x0A-数组越界"><span class="toc-text">0x0A 数组越界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#越界访问"><span class="toc-text">越界访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-5"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-4"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串操作造成目的缓冲区缺少-0"><span class="toc-text">字符串操作造成目的缓冲区缺少\0</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-6"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-5"><span class="toc-text">修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x0B-迭代器相关问题"><span class="toc-text">0x0B 迭代器相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器使用不匹配"><span class="toc-text">迭代器使用不匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-7"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-6"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器失效"><span class="toc-text">迭代器失效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-8"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-7"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对迭代器尾部进行解引用"><span class="toc-text">对迭代器尾部进行解引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-9"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-8"><span class="toc-text">修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x0C-IO相关问题"><span class="toc-text">0x0C IO相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用无效句柄"><span class="toc-text">使用无效句柄</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-10"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-9"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误的资源关闭"><span class="toc-text">错误的资源关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-11"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-10"><span class="toc-text">修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x0D-加解锁相关问题"><span class="toc-text">0x0D 加解锁相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加锁未解锁"><span class="toc-text">加锁未解锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-12"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-11"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不当的锁初始化"><span class="toc-text">不当的锁初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-13"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-12"><span class="toc-text">修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x0E-不安全的内存拷贝函数"><span class="toc-text">0x0E 不安全的内存拷贝函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-14"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修复-13"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x0F-其他污点数据问题"><span class="toc-text">0x0F 其他污点数据问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#污点数据作为循环边界"><span class="toc-text">污点数据作为循环边界</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-15"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-14"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#污染配置"><span class="toc-text">污染配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-16"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-15"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录穿越"><span class="toc-text">目录穿越</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#进程控制"><span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-17"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-16"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#资源注入"><span class="toc-text">资源注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-18"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-17"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#日志伪造"><span class="toc-text">日志伪造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo-19"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修复-18"><span class="toc-text">修复</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x10-错误的内存释放对象"><span class="toc-text">0x10 错误的内存释放对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-20"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修复-19"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x11-内存泄漏"><span class="toc-text">0x11  内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-21"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修复-20"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x12-对指针进行sizeof操作"><span class="toc-text">0x12 对指针进行sizeof操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-22"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修复-21"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x13-整数回绕造成的逻辑问题"><span class="toc-text">0x13 整数回绕造成的逻辑问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Demo-23"><span class="toc-text">Demo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修复-22"><span class="toc-text">修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x14-参考"><span class="toc-text">0x14 参考</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2021/01/16/隐藏通信隧道技术之网络层-传输层/" rel="next" title="隐藏通信隧道技术之网络层&amp;传输层">
          隐藏通信隧道技术之网络层&amp;传输层
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2021/01/16/浅析界面操作劫持攻击/" rel="prev" title="浅析界面操作劫持攻击">
            浅析界面操作劫持攻击
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    
    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <span>Copyright &copy; Mi1k7ea</span>  |  
        <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span></span> | 
        <span id="busuanzi_container_site_uv">访客 <span id="busuanzi_value_site_uv"></span></span>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>
