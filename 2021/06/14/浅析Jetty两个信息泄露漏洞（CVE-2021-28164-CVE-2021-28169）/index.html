
<!DOCTYPE html>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#202020">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
  
  
    <meta name="keywords" content="Web安全,Java,Jetty,">
  

  
    <meta name="description" content="d2VsY29tZSB0byBteSBibG9n">
  
  
  
  <link rel="icon" type="image/x-icon" href="/1.jpg">
  
  <title>浅析Jetty两个URI路径限制绕过漏洞（CVE-2021-28164/CVE-2021-28169） [ Mi1k7ea ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css">
    
      <link rel="stylesheet" href="/css/xoxo.css">
    
  
</head>


<body>
  <div class="nav-container">
    <nav class="home-menu pure-menu pure-menu-horizontal">
  <a class="pure-menu-heading" href="/">
    
    <span class="title" style="text-transform:none">Mi1k7ea</span>
  </a>

  <ul class="pure-menu-list clearfix">
      
          
            
              <li class="pure-menu-item"><a href="/archives" class="pure-menu-link">归档</a></li>
            
          
      
          
            
              <li class="pure-menu-item"><a href="/about" class="pure-menu-link">关于</a></li>
            
          
      
  </ul>
   
</nav>

  </div>

  <div class="container" id="content-outer">
    <div class="inner" id="content-inner">
      <div class="post-container">
  <article class="post" id="post">
    <header class="post-header text-center">
      <h1 class="title">
        浅析Jetty两个URI路径限制绕过漏洞（CVE-2021-28164/CVE-2021-28169）
      </h1>
      <span>
        
        <time class="time" datetime="2021-06-14T13:14:38.000Z">
        2021-06-14
      </time>
        
      </span>
      <span class="slash">/</span>
      <span class="post-meta">
      <span class="post-tags">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Jetty/">Jetty</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Web安全/">Web安全</a></li></ul>
      </span>
    </span>
      <!--<span class="slash">/</span>
      <span class="read">
      <span id="busuanzi_value_page_pv"></span> 点击
    </span>
      <span class="slash">/</span>-->
    </header>

    <div class="post-content">
      <h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前段时间Jetty爆出了两个CVE，Vulhub也更新了该漏洞靶场，就简单地看下吧。</p>
<h2 id="0x01-Jetty-URI路径限制绕过漏洞（CVE-2021-28164）"><a href="#0x01-Jetty-URI路径限制绕过漏洞（CVE-2021-28164）" class="headerlink" title="0x01 Jetty URI路径限制绕过漏洞（CVE-2021-28164）"></a>0x01 Jetty URI路径限制绕过漏洞（CVE-2021-28164）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><blockquote>
<p>Jetty 9.4.37引入对RFC3986的新实现，而URL编码的<code>.</code>字符被排除在URI规范之外，这个行为在RFC中是正确的，但在servlet的实现中导致攻击者可以通过<code>%2e</code>来绕过限制，下载WEB-INF目录下的任意文件，导致敏感信息泄露。该漏洞在9.4.39中修复。</p>
</blockquote>
<p>实际测试中发现，是能同时绕过限制来下载WEB-INF和META-INF两个目录下的任意文件的（前提是存在该目录）。</p>
<h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>9.4.37.v20210219</li>
<li>9.4.38.v20210224</li>
</ul>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28164" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28164</a></p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>正常访问页面如下：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/1.png" alt=""></p>
<p>尝试访问<code>/WEB-INF/web.xml</code>，返回404：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/2.png" alt=""></p>
<p>在Web路径前面添加URL编码的<code>./</code>即可权限绕过查看到web.xml的敏感信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/%2e/WEB-INF/web.xml</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/3.png" alt=""></p>
<p><code>../</code>也是可以的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/noexist/%2e%2e/WEB-INF/web.xml</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/17.png" alt=""></p>
<h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>在运行Jetty的命令中添加IDEA中远程调试的参数然后IDEA连接即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=5005 -jar start.jar</span><br></pre></td></tr></table></figure>
<p>下面看下一些关键点即可。</p>
<h4 id="场景一：访问-WEB-INF-web-xml"><a href="#场景一：访问-WEB-INF-web-xml" class="headerlink" title="场景一：访问/WEB-INF/web.xml"></a>场景一：访问<code>/WEB-INF/web.xml</code></h4><p>在该漏洞版本中，可以看到Jetty Server在初始化HttpConnection类时，会将HTTP解析器遵从的是RFC7230_LEGACY：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/4.png" alt=""></p>
<p>往下调试，HttpURI类的parse()函数在处理URL路径时，在识别到<code>;?#/</code>等字符时会有一个检测URI的函数checkSegment()来对URI中是否存在<code>..;</code>、<code>%2e</code>、<code>%2e%2e</code>等特殊字符进行检测：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/10.png" alt=""></p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/5.png" alt=""></p>
<p>接着在Request类的setMetaData()函数是设置请求相关的方法类型、URI和请求路径信息等，其中会判断该URI是否存在上述的特殊字符，这里没有就跳过其中的代码逻辑：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/6.png" alt=""></p>
<p>设置完请求各项内容之后，往下就会调用到HTTPChannel中的action——Dispatch分发请求：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/7.png" alt=""></p>
<p>往下会看到会调用isProtectedTarget()函数检测URL路径是否为保护路径，是的话则直接将响应设置为404：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/8.png" alt=""></p>
<p>跟进isProtectedTarget()函数，这里保护目标含有<code>/web-inf</code>且忽略大小写和URL路径进行比较，我们访问的路径刚好匹配因此返回true：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/9.png" alt=""></p>
<p>再往后，就是返回404响应然后结束整个请求响应处理的过程了。</p>
<h4 id="场景二：访问-2e-WEB-INF-web-xml"><a href="#场景二：访问-2e-WEB-INF-web-xml" class="headerlink" title="场景二：访问/%2e/WEB-INF/web.xml"></a>场景二：访问<code>/%2e/WEB-INF/web.xml</code></h4><p>直接调试到checkSegment()函数中，识别到<code>%2e</code>并标记了出来：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/11.png" alt=""></p>
<p>往下，在Request类的setMetaData()函数中进入了hasAmbiguousSegment()判断为真的逻辑中，其中compliance就是RFC7230_LEGACY、其中的sections并不包含NO_AMBIGUOUS_PATH_SEGMENTS这一项，因此直接放行往下执行进行path的URL解码然后设置到PathInfo中：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/12.png" alt=""></p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/13.png" alt=""></p>
<p>由于path以<code>/./</code>开头，绕过了isProtectedTarget()函数的检测，从而导致继续往下正常处理请求返回内容：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/14.png" alt=""></p>
<p>往下就是chain.doFilter()调用拦截器，然后就是doGet()发送请求获取响应内容回来：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/15.png" alt=""></p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/16.png" alt=""></p>
<p>OK，至此我们已经发现漏洞产生的根源所在就是Jetty遵循的RFC7230_LEGACY没有包含NO_AMBIGUOUS_PATH_SEGMENTS即RFC3986、从而并没有对识别到的<code>%2e</code>进行处理。</p>
<p>我们看到NO_AMBIGUOUS_PATH_SEGMENTS中链接的RFC3986的URL，其中就说到了会把URI路径中的<code>.</code>和<code>..</code>删除掉的操作：<a href="https://datatracker.ietf.org/doc/html/rfc3986#section-3.3" target="_blank" rel="noopener">https://datatracker.ietf.org/doc/html/rfc3986#section-3.3</a></p>
<blockquote>
<p>The path segments “.” and “..”, also known as dot-segments, aredefined for relative reference within the path name hierarchy.  Theyare intended for use at the beginning of a relative-path reference(Section 4.2) to indicate relative position within the hierarchicaltree of names.  This is similar to their role within some operatingsystems’ file directory structures to indicate the current directoryand parent directory, respectively.  However, unlike in a filesystem, these dot-segments are only interpreted within the URI pathhierarchy and are removed as part of the resolution process (Section5.2).</p>
</blockquote>
<h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>这里简单看下9.4.40版本的代码修复情况。</p>
<p>在RFC7230_LEGACY的sections中，添加了NO_AMBIGUOUS_PATH_PARAMETERS：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/21.png" alt=""></p>
<p>接着在判断存在歧义字符的为true之后的那段代码逻辑中，由于URI没有歧义参数因此没法直接进入第三个判断条件逻辑直接报错，而是继续往下执行：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/22.png" alt=""></p>
<p>接着就判断URI存在歧义字符的话就直接调用URIUtil.canonicalPath()函数进行URI规范化处理，其是专门处理<code>.</code>和<code>..</code>字符的，从而杜绝了该漏洞：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/23.png" alt=""></p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/24.png" alt=""></p>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul>
<li><p>升级到9.4.39及以上版本；</p>
</li>
<li><p>或者更新<code>start.d/http.ini</code>包含以下内容来启用HttpCompliance模式RFC7230_NO_AMBIGUOUS_URIS：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jetty.http.compliance=RFC7230_NO_AMBIGUOUS_URIS</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="0x02-Jetty-Servlets-URI路径限制绕过漏洞（CVE-2021-28169）"><a href="#0x02-Jetty-Servlets-URI路径限制绕过漏洞（CVE-2021-28169）" class="headerlink" title="0x02 Jetty Servlets URI路径限制绕过漏洞（CVE-2021-28169）"></a>0x02 Jetty Servlets URI路径限制绕过漏洞（CVE-2021-28169）</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Jetty Servlets中的ConcatServlet、WelcomeFilter类存在多重解码问题，当应用到这两个类之一时，攻击者就可以利用双重URL编码绕过限制来访问WEB-INF目录下的敏感文件，造成敏感信息泄露。</p>
<h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><ul>
<li>9.x系列 &lt;= 9.4.40</li>
<li>10.x系列 &lt;= 10.0.2</li>
<li>11.x系列 &lt;= 11.0.2</li>
</ul>
<h3 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28169" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28169</a></p>
<h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>正常访问是个Example页面：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/18.png" alt=""></p>
<p>查看页面源码，其中link标签的href属性值是使用到了ConcatServlet类来优化静态文件的加载：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/static?/css/base.css&amp;/css/app.css"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基于这种访问方式尝试直接访问WEB-INF下的文件是会返回404的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/static?/WEB-INF/web.xml</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/19.png" alt=""></p>
<p>对W进行双重URL编码则成功绕过限制访问得到敏感文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/static?/%2557EB-INF/web.xml</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/20.png" alt=""></p>
<p>这里看到确实设置了ConcatServlet类来优化静态文件加载。</p>
<p>针对WelcomeFilter类的测试可以参考官网GitHub的代码：<a href="https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182#diff-70d52a090f69fbcbb6fb9d0899c514474c25c4ea79263f81cbf0e87e3c103bd5" target="_blank" rel="noopener">https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182#diff-70d52a090f69fbcbb6fb9d0899c514474c25c4ea79263f81cbf0e87e3c103bd5</a></p>
<h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>在运行Jetty的命令中添加IDEA中远程调试的参数然后IDEA连接即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=5005 -jar start.jar</span><br></pre></td></tr></table></figure>
<p>之前在关于CVE-2021-28164的文章中已经简单调试过Jetty的主要路由处理过程了，后面就只看本次漏洞的关键点。</p>
<p>直接在ConcatServlet类的doGet()函数中下断点。</p>
<p><strong>访问<code>/static?/WEB-INF/web.xml</code></strong></p>
<p>在断点中看到，先获取请求查询内容即URI中?号之后<code>/WEB-INF/web.xml</code>，接着根据<code>&amp;</code>即做参数切分，再逐个参数进行操作（URL解码和<code>.</code>、<code>..</code>等字符处理），最后判断处理后的path值是否以<code>/WEB-INF/</code>或<code>/META-INF/</code>开头，是的话直接返回404：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/25.png" alt=""></p>
<p>可以看到，还想用<code>/./</code>和<code>/../</code>等方式已经行不通了，但是URL解码那块代码逻辑还需要继续跟进分析。</p>
<p><strong>访问<code>/static?/%2557EB-INF/web.xml</code></strong></p>
<p>调试到调用URIUtil.decodePath()函数进行解码的地方：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/26.png" alt=""></p>
<p>调试发现只进行了一次URL解码操作：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/27.png" alt=""></p>
<p>看下关键的处理逻辑，就是逐个获取请求参数的字符，当遇到<code>%</code>时会对其后面两位字符进行URL解码并替换结果，但是可以看到仅仅替换了一次，这就是漏洞根源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Utf8StringBuilder builder = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> end = offset + length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c = path.charAt(i);</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">            <span class="keyword">if</span> (builder == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                builder = <span class="keyword">new</span> Utf8StringBuilder(path.length());</span><br><span class="line">                builder.append(path, offset, i - offset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">2</span>) &lt; end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> u = path.charAt(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (u == <span class="string">'u'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// TODO remove %u support in jetty-10</span></span><br><span class="line">                    <span class="comment">// this is wrong. This is a codepoint not a char</span></span><br><span class="line">                    builder.append((<span class="keyword">char</span>)(<span class="number">0xffff</span> &amp; TypeUtil.parseInt(path, i + <span class="number">2</span>, <span class="number">4</span>, <span class="number">16</span>)));</span><br><span class="line">                    i += <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    builder.append((<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (TypeUtil.convertHexDigit(u) * <span class="number">16</span> + TypeUtil.convertHexDigit(path.charAt(i + <span class="number">2</span>)))));</span><br><span class="line">                    i += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bad URI % encoding"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">';'</span>:</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (builder != <span class="keyword">null</span>)</span><br><span class="line">                builder.append(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="补丁分析-1"><a href="#补丁分析-1" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>参考官方在9.4.41版本的修复commit：<a href="https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182" target="_blank" rel="noopener">https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182</a></p>
<p>ConcatServlet类的修复方法就是将path替换为part，即使用原始路径字符串作为分发器就会再次进行URL解码：</p>
<p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/28.png" alt=""></p>
<h3 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h3><p>升级到9.4.41, 10.0.3, 11.0.3及以上版本。</p>
<h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://github.com/eclipse/jetty.project/security/advisories/GHSA-v7ff-8wcx-gmc5" target="_blank" rel="noopener">https://github.com/eclipse/jetty.project/security/advisories/GHSA-v7ff-8wcx-gmc5</a></p>
<p><a href="https://github.com/eclipse/jetty.project/security/advisories/GHSA-gwcr-j4wh-j3cq" target="_blank" rel="noopener">https://github.com/eclipse/jetty.project/security/advisories/GHSA-gwcr-j4wh-j3cq</a></p>

    </div>

  </article>
  <div class="toc-container">
    
  <div id="toc" class="toc-article">
    <strong class="toc-title">目录</strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x00-前言"><span class="toc-text">0x00 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-Jetty-URI路径限制绕过漏洞（CVE-2021-28164）"><span class="toc-text">0x01 Jetty URI路径限制绕过漏洞（CVE-2021-28164）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞原理"><span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#影响版本"><span class="toc-text">影响版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环境搭建"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞复现"><span class="toc-text">漏洞复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试分析"><span class="toc-text">调试分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#场景一：访问-WEB-INF-web-xml"><span class="toc-text">场景一：访问/WEB-INF/web.xml</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#场景二：访问-2e-WEB-INF-web-xml"><span class="toc-text">场景二：访问/%2e/WEB-INF/web.xml</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补丁分析"><span class="toc-text">补丁分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#防御方法"><span class="toc-text">防御方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-Jetty-Servlets-URI路径限制绕过漏洞（CVE-2021-28169）"><span class="toc-text">0x02 Jetty Servlets URI路径限制绕过漏洞（CVE-2021-28169）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞原理-1"><span class="toc-text">漏洞原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#影响版本-1"><span class="toc-text">影响版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#环境搭建-1"><span class="toc-text">环境搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#漏洞复现-1"><span class="toc-text">漏洞复现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#调试分析-1"><span class="toc-text">调试分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#补丁分析-1"><span class="toc-text">补丁分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#防御方法-1"><span class="toc-text">防御方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-参考"><span class="toc-text">0x03 参考</span></a></li></ol>
  </div>


  </div>
</div>
<div class="copyright">
    <span>本作品采用</span>
    <a href="https://creativecommons.org/licenses/by/4.0/">知识共享署名 4.0 国际许可协议</a>
    <span>进行许可。 转载时请注明原文链接。</span>
</div>


  
    <div class="post-nav">
      <div class="post-nav-item post-nav-next">
        
          <span>〈 </span>
          <a href="/2021/05/16/浅谈SDL与DevSecOps/" rel="next" title="浅谈SDL与DevSecOps">
          浅谈SDL与DevSecOps
          </a>
        
      </div>
  
      <div class="post-nav-item post-nav-prev">
          
          <a href="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/" rel="prev" title="浅析Dubbo Kryo/FST反序列化漏洞（CVE-2021-25641）">
            浅析Dubbo Kryo/FST反序列化漏洞（CVE-2021-25641）
          </a>
          <span>〉</span>
        
      </div>
    </div>
  


    </div>

    
    

  </div>
  <footer class="footer text-center">
    <div id="bottom-inner">
        <span>Copyright &copy; Mi1k7ea</span>  |  
        <span id="busuanzi_container_site_pv">总访问量 <span id="busuanzi_value_site_pv"></span></span> | 
        <span id="busuanzi_container_site_uv">访客 <span id="busuanzi_value_site_uv"></span></span>
    </div>
</footer>

  

<script>
  (function(window, document, undefined) {

    var timer = null;

    function returnTop() {
      cancelAnimationFrame(timer);
      timer = requestAnimationFrame(function fn() {
        var oTop = document.body.scrollTop || document.documentElement.scrollTop;
        if (oTop > 0) {
          document.body.scrollTop = document.documentElement.scrollTop = oTop - 50;
          timer = requestAnimationFrame(fn);
        } else {
          cancelAnimationFrame(timer);
        }
      });
    }

    var hearts = [];
    window.requestAnimationFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback) {
          setTimeout(callback, 1000 / 60);
        }
    })();
    init();

    function init() {
      css(".heart{z-index:9999;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}");
      attachEvent();
      gameloop();
      addMenuEvent();
    }

    function gameloop() {
      for (var i = 0; i < hearts.length; i++) {
        if (hearts[i].alpha <= 0) {
          document.body.removeChild(hearts[i].el);
          hearts.splice(i, 1);
          continue;
        }
        hearts[i].y--;
        hearts[i].scale += 0.004;
        hearts[i].alpha -= 0.013;
        hearts[i].el.style.cssText = "left:" + hearts[i].x + "px;top:" + hearts[i].y + "px;opacity:" + hearts[i].alpha + ";transform:scale(" + hearts[i].scale + "," + hearts[i].scale + ") rotate(45deg);background:" + hearts[i].color;
      }
      requestAnimationFrame(gameloop);
    }

    /**
     * 给logo设置点击事件
     * 
     * - 回到顶部
     * - 出现爱心
     */
    function attachEvent() {
      var old = typeof window.onclick === "function" && window.onclick;
      var logo = document.getElementById("logo");
      if (logo) {
        logo.onclick = function(event) {
          returnTop();
          old && old();
          createHeart(event);
        }
      }
      
    }

    function createHeart(event) {
      var d = document.createElement("div");
      d.className = "heart";
      hearts.push({
        el: d,
        x: event.clientX - 5,
        y: event.clientY - 5,
        scale: 1,
        alpha: 1,
        color: randomColor()
      });
      document.body.appendChild(d);
    }

    function css(css) {
      var style = document.createElement("style");
      style.type = "text/css";
      try {
        style.appendChild(document.createTextNode(css));
      } catch (ex) {
        style.styleSheet.cssText = css;
      }
      document.getElementsByTagName('head')[0].appendChild(style);
    }

    function randomColor() {
      // return "rgb(" + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + "," + (~~(Math.random() * 255)) + ")";
      return "#F44336";
    }

    function addMenuEvent() {
      var menu = document.getElementById('menu-main-post');
      if (menu) {
        var toc = document.getElementById('toc');
        if (toc) {
          menu.onclick = function() {
            if (toc) {
              if (toc.style.display == 'block') {
                toc.style.display = 'none';
              } else {
                toc.style.display = 'block';
              }
            }
          };
        } else {
          menu.style.display = 'none';
        }
      }
    }

  })(window, document);
</script>

  



  
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
</script>


</body>
</html>
